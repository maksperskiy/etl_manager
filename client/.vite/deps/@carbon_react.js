import {
  Add,
  AddFilled,
  AiLabel,
  ArrowRight,
  ArrowUp,
  ArrowsVertical,
  Calendar,
  CaretDown,
  CaretLeft,
  CaretRight,
  Checkbox,
  CheckboxCheckedFilled,
  Checkmark,
  CheckmarkFilled,
  CheckmarkOutline,
  ChevronDown,
  ChevronLeft,
  ChevronRight,
  CircleDash,
  Close,
  Copy,
  Error as Error2,
  ErrorFilled,
  InProgress,
  Incomplete,
  InformationFilled,
  InformationSquareFilled,
  Menu,
  OverflowMenuHorizontal,
  OverflowMenuVertical,
  PendingFilled,
  RadioButton,
  RadioButtonChecked,
  Search,
  Settings,
  Subtract,
  UndefinedFilled,
  Undo,
  UnknownFilled,
  View,
  ViewOff,
  Warning,
  WarningAltFilled,
  WarningAltInvertedFilled,
  WarningFilled,
  WarningSquareFilled,
  require_prop_types,
  require_react
} from "./chunk-RUNR7HNO.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// ../node_modules/.pnpm/classnames@2.5.1/node_modules/classnames/index.js
var require_classnames = __commonJS({
  "../node_modules/.pnpm/classnames@2.5.1/node_modules/classnames/index.js"(exports, module) {
    (function() {
      "use strict";
      var hasOwn = {}.hasOwnProperty;
      function classNames() {
        var classes = "";
        for (var i = 0; i < arguments.length; i++) {
          var arg = arguments[i];
          if (arg) {
            classes = appendClass(classes, parseValue(arg));
          }
        }
        return classes;
      }
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes = "";
        for (var key in arg) {
          if (hasOwn.call(arg, key) && arg[key]) {
            classes = appendClass(classes, key);
          }
        }
        return classes;
      }
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      if (typeof module !== "undefined" && module.exports) {
        classNames.default = classNames;
        module.exports = classNames;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames;
        });
      } else {
        window.classNames = classNames;
      }
    })();
  }
});

// ../node_modules/.pnpm/react-dom@19.0.0_react@19.0.0/node_modules/react-dom/cjs/react-dom.development.js
var require_react_dom_development = __commonJS({
  "../node_modules/.pnpm/react-dom@19.0.0_react@19.0.0/node_modules/react-dom/cjs/react-dom.development.js"(exports) {
    "use strict";
    (function() {
      function noop3() {
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function createPortal$1(children, containerInfo, implementation) {
        var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        try {
          testStringCoercion(key);
          var JSCompiler_inline_result = false;
        } catch (e2) {
          JSCompiler_inline_result = true;
        }
        JSCompiler_inline_result && (console.error(
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          "function" === typeof Symbol && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || "Object"
        ), testStringCoercion(key));
        return {
          $$typeof: REACT_PORTAL_TYPE,
          key: null == key ? null : "" + key,
          children,
          containerInfo,
          implementation
        };
      }
      function getCrossOriginStringAs(as, input) {
        if ("font" === as) return "";
        if ("string" === typeof input)
          return "use-credentials" === input ? input : "";
      }
      function getValueDescriptorExpectingObjectForWarning(thing) {
        return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : 'something with type "' + typeof thing + '"';
      }
      function getValueDescriptorExpectingEnumForWarning(thing) {
        return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : "string" === typeof thing ? JSON.stringify(thing) : "number" === typeof thing ? "`" + thing + "`" : 'something with type "' + typeof thing + '"';
      }
      function resolveDispatcher() {
        var dispatcher = ReactSharedInternals.H;
        null === dispatcher && console.error(
          "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
        );
        return dispatcher;
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React5 = require_react(), Internals = {
        d: {
          f: noop3,
          r: function() {
            throw Error(
              "Invalid form element. requestFormReset must be passed a form that was rendered by React."
            );
          },
          D: noop3,
          C: noop3,
          L: noop3,
          m: noop3,
          X: noop3,
          S: noop3,
          M: noop3
        },
        p: 0,
        findDOMNode: null
      }, REACT_PORTAL_TYPE = Symbol.for("react.portal"), ReactSharedInternals = React5.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
      "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error(
        "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"
      );
      exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
      exports.createPortal = function(children, container) {
        var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
          throw Error("Target container is not a DOM element.");
        return createPortal$1(children, container, null, key);
      };
      exports.flushSync = function(fn) {
        var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
        try {
          if (ReactSharedInternals.T = null, Internals.p = 2, fn)
            return fn();
        } finally {
          ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f() && console.error(
            "flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."
          );
        }
      };
      exports.preconnect = function(href, options) {
        "string" === typeof href && href ? null != options && "object" !== typeof options ? console.error(
          "ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.",
          getValueDescriptorExpectingEnumForWarning(options)
        ) : null != options && "string" !== typeof options.crossOrigin && console.error(
          "ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.",
          getValueDescriptorExpectingObjectForWarning(options.crossOrigin)
        ) : console.error(
          "ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
          getValueDescriptorExpectingObjectForWarning(href)
        );
        "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
      };
      exports.prefetchDNS = function(href) {
        if ("string" !== typeof href || !href)
          console.error(
            "ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href)
          );
        else if (1 < arguments.length) {
          var options = arguments[1];
          "object" === typeof options && options.hasOwnProperty("crossOrigin") ? console.error(
            "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
            getValueDescriptorExpectingEnumForWarning(options)
          ) : console.error(
            "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
            getValueDescriptorExpectingEnumForWarning(options)
          );
        }
        "string" === typeof href && Internals.d.D(href);
      };
      exports.preinit = function(href, options) {
        "string" === typeof href && href ? null == options || "object" !== typeof options ? console.error(
          "ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.",
          getValueDescriptorExpectingEnumForWarning(options)
        ) : "style" !== options.as && "script" !== options.as && console.error(
          'ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".',
          getValueDescriptorExpectingEnumForWarning(options.as)
        ) : console.error(
          "ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
          getValueDescriptorExpectingObjectForWarning(href)
        );
        if ("string" === typeof href && options && "string" === typeof options.as) {
          var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
          "style" === as ? Internals.d.S(
            href,
            "string" === typeof options.precedence ? options.precedence : void 0,
            {
              crossOrigin,
              integrity,
              fetchPriority
            }
          ) : "script" === as && Internals.d.X(href, {
            crossOrigin,
            integrity,
            fetchPriority,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0
          });
        }
      };
      exports.preinitModule = function(href, options) {
        var encountered = "";
        "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
        void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "script" !== options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingEnumForWarning(options.as) + ".");
        if (encountered)
          console.error(
            "ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s",
            encountered
          );
        else
          switch (encountered = options && "string" === typeof options.as ? options.as : "script", encountered) {
            case "script":
              break;
            default:
              encountered = getValueDescriptorExpectingEnumForWarning(encountered), console.error(
                'ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)',
                encountered,
                href
              );
          }
        if ("string" === typeof href)
          if ("object" === typeof options && null !== options) {
            if (null == options.as || "script" === options.as)
              encountered = getCrossOriginStringAs(
                options.as,
                options.crossOrigin
              ), Internals.d.M(href, {
                crossOrigin: encountered,
                integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                nonce: "string" === typeof options.nonce ? options.nonce : void 0
              });
          } else null == options && Internals.d.M(href);
      };
      exports.preload = function(href, options) {
        var encountered = "";
        "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
        null == options || "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : "string" === typeof options.as && options.as || (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
        encountered && console.error(
          'ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s',
          encountered
        );
        if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
          encountered = options.as;
          var crossOrigin = getCrossOriginStringAs(
            encountered,
            options.crossOrigin
          );
          Internals.d.L(href, encountered, {
            crossOrigin,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0,
            type: "string" === typeof options.type ? options.type : void 0,
            fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
            referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
            imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
            imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
            media: "string" === typeof options.media ? options.media : void 0
          });
        }
      };
      exports.preloadModule = function(href, options) {
        var encountered = "";
        "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
        void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "string" !== typeof options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
        encountered && console.error(
          'ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s',
          encountered
        );
        "string" === typeof href && (options ? (encountered = getCrossOriginStringAs(
          options.as,
          options.crossOrigin
        ), Internals.d.m(href, {
          as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
          crossOrigin: encountered,
          integrity: "string" === typeof options.integrity ? options.integrity : void 0
        })) : Internals.d.m(href));
      };
      exports.requestFormReset = function(form) {
        Internals.d.r(form);
      };
      exports.unstable_batchedUpdates = function(fn, a) {
        return fn(a);
      };
      exports.useFormState = function(action, initialState, permalink) {
        return resolveDispatcher().useFormState(action, initialState, permalink);
      };
      exports.useFormStatus = function() {
        return resolveDispatcher().useHostTransitionStatus();
      };
      exports.version = "19.0.0";
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// ../node_modules/.pnpm/react-dom@19.0.0_react@19.0.0/node_modules/react-dom/index.js
var require_react_dom = __commonJS({
  "../node_modules/.pnpm/react-dom@19.0.0_react@19.0.0/node_modules/react-dom/index.js"(exports, module) {
    "use strict";
    if (false) {
      checkDCE();
      module.exports = null;
    } else {
      module.exports = require_react_dom_development();
    }
  }
});

// ../node_modules/.pnpm/resize-observer-polyfill@1.5.1/node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js
var ResizeObserver_es_exports = {};
__export(ResizeObserver_es_exports, {
  default: () => ResizeObserver_es_default
});
function throttle(callback, delay3) {
  var leadingCall = false, trailingCall = false, lastCallTime = 0;
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy();
    }
  }
  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  function proxy() {
    var timeStamp = Date.now();
    if (leadingCall) {
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay3);
    }
    lastCallTime = timeStamp;
  }
  return proxy;
}
function toFloat(value) {
  return parseFloat(value) || 0;
}
function getBordersSize(styles) {
  var positions = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }
  return positions.reduce(function(size6, position) {
    var value = styles["border-" + position + "-width"];
    return size6 + toFloat(value);
  }, 0);
}
function getPaddings(styles) {
  var positions = ["top", "right", "bottom", "left"];
  var paddings = {};
  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position = positions_1[_i];
    var value = styles["padding-" + position];
    paddings[position] = toFloat(value);
  }
  return paddings;
}
function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
function getHTMLElementContentRect(target) {
  var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  var width = toFloat(styles.width), height = toFloat(styles.height);
  if (styles.boxSizing === "border-box") {
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles, "left", "right") + horizPad;
    }
    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles, "top", "bottom") + vertPad;
    }
  }
  if (!isDocumentElement(target)) {
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width, height);
}
function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
function getContentRect(target) {
  if (!isBrowser) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }
  return getHTMLElementContentRect(target);
}
function createReadOnlyRect(_a) {
  var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
  var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype);
  defineConfigurable(rect, {
    x,
    y,
    width,
    height,
    top: y,
    right: x + width,
    bottom: height + y,
    left: x
  });
  return rect;
}
function createRectInit(x, y, width, height) {
  return { x, y, width, height };
}
var MapShim, isBrowser, global$1, requestAnimationFrame$1, trailingTimeout, REFRESH_DELAY, transitionKeys, mutationObserverSupported, ResizeObserverController, defineConfigurable, getWindowOf, emptyRect, isSVGGraphicsElement, ResizeObservation, ResizeObserverEntry, ResizeObserverSPI, observers, ResizeObserver2, index3, ResizeObserver_es_default;
var init_ResizeObserver_es = __esm({
  "../node_modules/.pnpm/resize-observer-polyfill@1.5.1/node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js"() {
    MapShim = function() {
      if (typeof Map !== "undefined") {
        return Map;
      }
      function getIndex(arr, key) {
        var result = -1;
        arr.some(function(entry, index4) {
          if (entry[0] === key) {
            result = index4;
            return true;
          }
          return false;
        });
        return result;
      }
      return (
        /** @class */
        function() {
          function class_1() {
            this.__entries__ = [];
          }
          Object.defineProperty(class_1.prototype, "size", {
            /**
             * @returns {boolean}
             */
            get: function() {
              return this.__entries__.length;
            },
            enumerable: true,
            configurable: true
          });
          class_1.prototype.get = function(key) {
            var index4 = getIndex(this.__entries__, key);
            var entry = this.__entries__[index4];
            return entry && entry[1];
          };
          class_1.prototype.set = function(key, value) {
            var index4 = getIndex(this.__entries__, key);
            if (~index4) {
              this.__entries__[index4][1] = value;
            } else {
              this.__entries__.push([key, value]);
            }
          };
          class_1.prototype.delete = function(key) {
            var entries = this.__entries__;
            var index4 = getIndex(entries, key);
            if (~index4) {
              entries.splice(index4, 1);
            }
          };
          class_1.prototype.has = function(key) {
            return !!~getIndex(this.__entries__, key);
          };
          class_1.prototype.clear = function() {
            this.__entries__.splice(0);
          };
          class_1.prototype.forEach = function(callback, ctx) {
            if (ctx === void 0) {
              ctx = null;
            }
            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
              var entry = _a[_i];
              callback.call(ctx, entry[1], entry[0]);
            }
          };
          return class_1;
        }()
      );
    }();
    isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
    global$1 = function() {
      if (typeof global !== "undefined" && global.Math === Math) {
        return global;
      }
      if (typeof self !== "undefined" && self.Math === Math) {
        return self;
      }
      if (typeof window !== "undefined" && window.Math === Math) {
        return window;
      }
      return Function("return this")();
    }();
    requestAnimationFrame$1 = function() {
      if (typeof requestAnimationFrame === "function") {
        return requestAnimationFrame.bind(global$1);
      }
      return function(callback) {
        return setTimeout(function() {
          return callback(Date.now());
        }, 1e3 / 60);
      };
    }();
    trailingTimeout = 2;
    REFRESH_DELAY = 20;
    transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
    mutationObserverSupported = typeof MutationObserver !== "undefined";
    ResizeObserverController = /** @class */
    function() {
      function ResizeObserverController2() {
        this.connected_ = false;
        this.mutationEventsAdded_ = false;
        this.mutationsObserver_ = null;
        this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
      }
      ResizeObserverController2.prototype.addObserver = function(observer) {
        if (!~this.observers_.indexOf(observer)) {
          this.observers_.push(observer);
        }
        if (!this.connected_) {
          this.connect_();
        }
      };
      ResizeObserverController2.prototype.removeObserver = function(observer) {
        var observers2 = this.observers_;
        var index4 = observers2.indexOf(observer);
        if (~index4) {
          observers2.splice(index4, 1);
        }
        if (!observers2.length && this.connected_) {
          this.disconnect_();
        }
      };
      ResizeObserverController2.prototype.refresh = function() {
        var changesDetected = this.updateObservers_();
        if (changesDetected) {
          this.refresh();
        }
      };
      ResizeObserverController2.prototype.updateObservers_ = function() {
        var activeObservers = this.observers_.filter(function(observer) {
          return observer.gatherActive(), observer.hasActive();
        });
        activeObservers.forEach(function(observer) {
          return observer.broadcastActive();
        });
        return activeObservers.length > 0;
      };
      ResizeObserverController2.prototype.connect_ = function() {
        if (!isBrowser || this.connected_) {
          return;
        }
        document.addEventListener("transitionend", this.onTransitionEnd_);
        window.addEventListener("resize", this.refresh);
        if (mutationObserverSupported) {
          this.mutationsObserver_ = new MutationObserver(this.refresh);
          this.mutationsObserver_.observe(document, {
            attributes: true,
            childList: true,
            characterData: true,
            subtree: true
          });
        } else {
          document.addEventListener("DOMSubtreeModified", this.refresh);
          this.mutationEventsAdded_ = true;
        }
        this.connected_ = true;
      };
      ResizeObserverController2.prototype.disconnect_ = function() {
        if (!isBrowser || !this.connected_) {
          return;
        }
        document.removeEventListener("transitionend", this.onTransitionEnd_);
        window.removeEventListener("resize", this.refresh);
        if (this.mutationsObserver_) {
          this.mutationsObserver_.disconnect();
        }
        if (this.mutationEventsAdded_) {
          document.removeEventListener("DOMSubtreeModified", this.refresh);
        }
        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
      };
      ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
        var _b = _a.propertyName, propertyName = _b === void 0 ? "" : _b;
        var isReflowProperty = transitionKeys.some(function(key) {
          return !!~propertyName.indexOf(key);
        });
        if (isReflowProperty) {
          this.refresh();
        }
      };
      ResizeObserverController2.getInstance = function() {
        if (!this.instance_) {
          this.instance_ = new ResizeObserverController2();
        }
        return this.instance_;
      };
      ResizeObserverController2.instance_ = null;
      return ResizeObserverController2;
    }();
    defineConfigurable = function(target, props) {
      for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
        var key = _a[_i];
        Object.defineProperty(target, key, {
          value: props[key],
          enumerable: false,
          writable: false,
          configurable: true
        });
      }
      return target;
    };
    getWindowOf = function(target) {
      var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
      return ownerGlobal || global$1;
    };
    emptyRect = createRectInit(0, 0, 0, 0);
    isSVGGraphicsElement = function() {
      if (typeof SVGGraphicsElement !== "undefined") {
        return function(target) {
          return target instanceof getWindowOf(target).SVGGraphicsElement;
        };
      }
      return function(target) {
        return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
      };
    }();
    ResizeObservation = /** @class */
    function() {
      function ResizeObservation2(target) {
        this.broadcastWidth = 0;
        this.broadcastHeight = 0;
        this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
      }
      ResizeObservation2.prototype.isActive = function() {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
      };
      ResizeObservation2.prototype.broadcastRect = function() {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
      };
      return ResizeObservation2;
    }();
    ResizeObserverEntry = /** @class */
    /* @__PURE__ */ function() {
      function ResizeObserverEntry2(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit);
        defineConfigurable(this, { target, contentRect });
      }
      return ResizeObserverEntry2;
    }();
    ResizeObserverSPI = /** @class */
    function() {
      function ResizeObserverSPI2(callback, controller, callbackCtx) {
        this.activeObservations_ = [];
        this.observations_ = new MapShim();
        if (typeof callback !== "function") {
          throw new TypeError("The callback provided as parameter 1 is not a function.");
        }
        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
      }
      ResizeObserverSPI2.prototype.observe = function(target) {
        if (!arguments.length) {
          throw new TypeError("1 argument required, but only 0 present.");
        }
        if (typeof Element === "undefined" || !(Element instanceof Object)) {
          return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
          throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        if (observations.has(target)) {
          return;
        }
        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this);
        this.controller_.refresh();
      };
      ResizeObserverSPI2.prototype.unobserve = function(target) {
        if (!arguments.length) {
          throw new TypeError("1 argument required, but only 0 present.");
        }
        if (typeof Element === "undefined" || !(Element instanceof Object)) {
          return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
          throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        if (!observations.has(target)) {
          return;
        }
        observations.delete(target);
        if (!observations.size) {
          this.controller_.removeObserver(this);
        }
      };
      ResizeObserverSPI2.prototype.disconnect = function() {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
      };
      ResizeObserverSPI2.prototype.gatherActive = function() {
        var _this = this;
        this.clearActive();
        this.observations_.forEach(function(observation) {
          if (observation.isActive()) {
            _this.activeObservations_.push(observation);
          }
        });
      };
      ResizeObserverSPI2.prototype.broadcastActive = function() {
        if (!this.hasActive()) {
          return;
        }
        var ctx = this.callbackCtx_;
        var entries = this.activeObservations_.map(function(observation) {
          return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
      };
      ResizeObserverSPI2.prototype.clearActive = function() {
        this.activeObservations_.splice(0);
      };
      ResizeObserverSPI2.prototype.hasActive = function() {
        return this.activeObservations_.length > 0;
      };
      return ResizeObserverSPI2;
    }();
    observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
    ResizeObserver2 = /** @class */
    /* @__PURE__ */ function() {
      function ResizeObserver3(callback) {
        if (!(this instanceof ResizeObserver3)) {
          throw new TypeError("Cannot call a class as a function.");
        }
        if (!arguments.length) {
          throw new TypeError("1 argument required, but only 0 present.");
        }
        var controller = ResizeObserverController.getInstance();
        var observer = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer);
      }
      return ResizeObserver3;
    }();
    [
      "observe",
      "unobserve",
      "disconnect"
    ].forEach(function(method2) {
      ResizeObserver2.prototype[method2] = function() {
        var _a;
        return (_a = observers.get(this))[method2].apply(_a, arguments);
      };
    });
    index3 = function() {
      if (typeof global$1.ResizeObserver !== "undefined") {
        return global$1.ResizeObserver;
      }
      return ResizeObserver2;
    }();
    ResizeObserver_es_default = index3;
  }
});

// ../node_modules/.pnpm/use-resize-observer@6.1.0_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/use-resize-observer/polyfilled.js
var require_polyfilled = __commonJS({
  "../node_modules/.pnpm/use-resize-observer@6.1.0_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/use-resize-observer/polyfilled.js"(exports, module) {
    "use strict";
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var ResizeObserver3 = _interopDefault((init_ResizeObserver_es(), __toCommonJS(ResizeObserver_es_exports)));
    var react = require_react();
    function useResizeObserver2(opts) {
      if (opts === void 0) {
        opts = {};
      }
      var defaultRef = react.useRef(null);
      var onResize = opts.onResize;
      var onResizeRef = react.useRef(void 0);
      onResizeRef.current = onResize;
      var resizeObserverRef = react.useRef();
      var ref = opts.ref || defaultRef;
      var _useState = react.useState({
        width: void 0,
        height: void 0
      }), size6 = _useState[0], setSize = _useState[1];
      var previous = react.useRef({
        width: void 0,
        height: void 0
      });
      react.useEffect(function() {
        if (resizeObserverRef.current) {
          return;
        }
        resizeObserverRef.current = new ResizeObserver3(function(entries) {
          if (!Array.isArray(entries)) {
            return;
          }
          if (!entries.length) {
            return;
          }
          var entry = entries[0];
          var newWidth = Math.round(entry.contentRect.width);
          var newHeight = Math.round(entry.contentRect.height);
          if (previous.current.width !== newWidth || previous.current.height !== newHeight) {
            var newSize = {
              width: newWidth,
              height: newHeight
            };
            if (onResizeRef.current) {
              onResizeRef.current(newSize);
            } else {
              previous.current.width = newWidth;
              previous.current.height = newHeight;
              setSize(newSize);
            }
          }
        });
      }, []);
      react.useEffect(function() {
        if (typeof ref !== "object" || ref === null || !(ref.current instanceof Element)) {
          return;
        }
        var element = ref.current;
        resizeObserverRef.current.observe(element);
        return function() {
          return resizeObserverRef.current.unobserve(element);
        };
      }, [ref]);
      return react.useMemo(function() {
        return {
          ref,
          width: size6.width,
          height: size6.height
        };
      }, [ref, size6 ? size6.width : null, size6 ? size6.height : null]);
    }
    module.exports = useResizeObserver2;
  }
});

// ../node_modules/.pnpm/toggle-selection@1.0.6/node_modules/toggle-selection/index.js
var require_toggle_selection = __commonJS({
  "../node_modules/.pnpm/toggle-selection@1.0.6/node_modules/toggle-selection/index.js"(exports, module) {
    module.exports = function() {
      var selection = document.getSelection();
      if (!selection.rangeCount) {
        return function() {
        };
      }
      var active = document.activeElement;
      var ranges = [];
      for (var i = 0; i < selection.rangeCount; i++) {
        ranges.push(selection.getRangeAt(i));
      }
      switch (active.tagName.toUpperCase()) {
        // .toUpperCase handles XHTML
        case "INPUT":
        case "TEXTAREA":
          active.blur();
          break;
        default:
          active = null;
          break;
      }
      selection.removeAllRanges();
      return function() {
        selection.type === "Caret" && selection.removeAllRanges();
        if (!selection.rangeCount) {
          ranges.forEach(function(range3) {
            selection.addRange(range3);
          });
        }
        active && active.focus();
      };
    };
  }
});

// ../node_modules/.pnpm/copy-to-clipboard@3.3.3/node_modules/copy-to-clipboard/index.js
var require_copy_to_clipboard = __commonJS({
  "../node_modules/.pnpm/copy-to-clipboard@3.3.3/node_modules/copy-to-clipboard/index.js"(exports, module) {
    "use strict";
    var deselectCurrent = require_toggle_selection();
    var clipboardToIE11Formatting = {
      "text/plain": "Text",
      "text/html": "Url",
      "default": "Text"
    };
    var defaultMessage = "Copy to clipboard: #{key}, Enter";
    function format(message) {
      var copyKey = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
      return message.replace(/#{\s*key\s*}/g, copyKey);
    }
    function copy2(text, options) {
      var debug, message, reselectPrevious, range3, selection, mark, success = false;
      if (!options) {
        options = {};
      }
      debug = options.debug || false;
      try {
        reselectPrevious = deselectCurrent();
        range3 = document.createRange();
        selection = document.getSelection();
        mark = document.createElement("span");
        mark.textContent = text;
        mark.ariaHidden = "true";
        mark.style.all = "unset";
        mark.style.position = "fixed";
        mark.style.top = 0;
        mark.style.clip = "rect(0, 0, 0, 0)";
        mark.style.whiteSpace = "pre";
        mark.style.webkitUserSelect = "text";
        mark.style.MozUserSelect = "text";
        mark.style.msUserSelect = "text";
        mark.style.userSelect = "text";
        mark.addEventListener("copy", function(e2) {
          e2.stopPropagation();
          if (options.format) {
            e2.preventDefault();
            if (typeof e2.clipboardData === "undefined") {
              debug && console.warn("unable to use e.clipboardData");
              debug && console.warn("trying IE specific stuff");
              window.clipboardData.clearData();
              var format2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
              window.clipboardData.setData(format2, text);
            } else {
              e2.clipboardData.clearData();
              e2.clipboardData.setData(options.format, text);
            }
          }
          if (options.onCopy) {
            e2.preventDefault();
            options.onCopy(e2.clipboardData);
          }
        });
        document.body.appendChild(mark);
        range3.selectNodeContents(mark);
        selection.addRange(range3);
        var successful = document.execCommand("copy");
        if (!successful) {
          throw new Error("copy command was unsuccessful");
        }
        success = true;
      } catch (err) {
        debug && console.error("unable to copy using execCommand: ", err);
        debug && console.warn("trying IE specific stuff");
        try {
          window.clipboardData.setData(options.format || "text", text);
          options.onCopy && options.onCopy(window.clipboardData);
          success = true;
        } catch (err2) {
          debug && console.error("unable to copy using clipboardData: ", err2);
          debug && console.error("falling back to prompt");
          message = format("message" in options ? options.message : defaultMessage);
          window.prompt(message, text);
        }
      } finally {
        if (selection) {
          if (typeof selection.removeRange == "function") {
            selection.removeRange(range3);
          } else {
            selection.removeAllRanges();
          }
        }
        if (mark) {
          document.body.removeChild(mark);
        }
        reselectPrevious();
      }
      return success;
    }
    module.exports = copy2;
  }
});

// ../node_modules/.pnpm/react-is@18.2.0/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "../node_modules/.pnpm/react-is@18.2.0/node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                  case REACT_SUSPENSE_LIST_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_SERVER_CONTEXT_TYPE:
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment2 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        var hasWarnedAboutDeprecatedIsConcurrentMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isConcurrentMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
              hasWarnedAboutDeprecatedIsConcurrentMode = true;
              console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement5(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef2(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        function isSuspenseList(object) {
          return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
        }
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element2;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment2;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.SuspenseList = SuspenseList;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement5;
        exports.isForwardRef = isForwardRef2;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isSuspenseList = isSuspenseList;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// ../node_modules/.pnpm/react-is@18.2.0/node_modules/react-is/index.js
var require_react_is = __commonJS({
  "../node_modules/.pnpm/react-is@18.2.0/node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// ../node_modules/.pnpm/react-fast-compare@3.2.2/node_modules/react-fast-compare/index.js
var require_react_fast_compare = __commonJS({
  "../node_modules/.pnpm/react-fast-compare@3.2.2/node_modules/react-fast-compare/index.js"(exports, module) {
    var hasElementType = typeof Element !== "undefined";
    var hasMap = typeof Map === "function";
    var hasSet = typeof Set === "function";
    var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
    function equal(a, b) {
      if (a === b) return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys2;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length) return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i])) return false;
          return true;
        }
        var it;
        if (hasMap && a instanceof Map && b instanceof Map) {
          if (a.size !== b.size) return false;
          it = a.entries();
          while (!(i = it.next()).done)
            if (!b.has(i.value[0])) return false;
          it = a.entries();
          while (!(i = it.next()).done)
            if (!equal(i.value[1], b.get(i.value[0]))) return false;
          return true;
        }
        if (hasSet && a instanceof Set && b instanceof Set) {
          if (a.size !== b.size) return false;
          it = a.entries();
          while (!(i = it.next()).done)
            if (!b.has(i.value[0])) return false;
          return true;
        }
        if (hasArrayBuffer && ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
          length = a.length;
          if (length != b.length) return false;
          for (i = length; i-- !== 0; )
            if (a[i] !== b[i]) return false;
          return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf && typeof a.valueOf === "function" && typeof b.valueOf === "function") return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString && typeof a.toString === "function" && typeof b.toString === "function") return a.toString() === b.toString();
        keys2 = Object.keys(a);
        length = keys2.length;
        if (length !== Object.keys(b).length) return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys2[i])) return false;
        if (hasElementType && a instanceof Element) return false;
        for (i = length; i-- !== 0; ) {
          if ((keys2[i] === "_owner" || keys2[i] === "__v" || keys2[i] === "__o") && a.$$typeof) {
            continue;
          }
          if (!equal(a[keys2[i]], b[keys2[i]])) return false;
        }
        return true;
      }
      return a !== a && b !== b;
    }
    module.exports = function isEqual8(a, b) {
      try {
        return equal(a, b);
      } catch (error2) {
        if ((error2.message || "").match(/stack|recursion/i)) {
          console.warn("react-fast-compare cannot handle circular refs");
          return false;
        }
        throw error2;
      }
    };
  }
});

// ../node_modules/.pnpm/react-is@18.3.1/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development2 = __commonJS({
  "../node_modules/.pnpm/react-is@18.3.1/node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                  case REACT_SUSPENSE_LIST_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_SERVER_CONTEXT_TYPE:
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment2 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        var hasWarnedAboutDeprecatedIsConcurrentMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isConcurrentMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
              hasWarnedAboutDeprecatedIsConcurrentMode = true;
              console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement5(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef2(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        function isSuspenseList(object) {
          return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
        }
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element2;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment2;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.SuspenseList = SuspenseList;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement5;
        exports.isForwardRef = isForwardRef2;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isSuspenseList = isSuspenseList;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// ../node_modules/.pnpm/react-is@18.3.1/node_modules/react-is/index.js
var require_react_is2 = __commonJS({
  "../node_modules/.pnpm/react-is@18.3.1/node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development2();
    }
  }
});

// ../node_modules/.pnpm/window-or-global@1.0.1/node_modules/window-or-global/lib/index.js
var require_lib = __commonJS({
  "../node_modules/.pnpm/window-or-global@1.0.1/node_modules/window-or-global/lib/index.js"(exports, module) {
    "use strict";
    module.exports = typeof self === "object" && self.self === self && self || typeof global === "object" && global.global === global && global || exports;
  }
});

// ../node_modules/.pnpm/invariant@2.2.4/node_modules/invariant/browser.js
var require_browser = __commonJS({
  "../node_modules/.pnpm/invariant@2.2.4/node_modules/invariant/browser.js"(exports, module) {
    "use strict";
    var invariant4 = function(condition, format, a, b, c, d, e2, f) {
      if (true) {
        if (format === void 0) {
          throw new Error("invariant requires an error message argument");
        }
      }
      if (!condition) {
        var error2;
        if (format === void 0) {
          error2 = new Error(
            "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
          );
        } else {
          var args = [a, b, c, d, e2, f];
          var argIndex = 0;
          error2 = new Error(
            format.replace(/%s/g, function() {
              return args[argIndex++];
            })
          );
          error2.name = "Invariant Violation";
        }
        error2.framesToPop = 1;
        throw error2;
      }
    };
    module.exports = invariant4;
  }
});

// ../node_modules/.pnpm/flatpickr@4.6.13/node_modules/flatpickr/dist/l10n/index.js
var require_l10n = __commonJS({
  "../node_modules/.pnpm/flatpickr@4.6.13/node_modules/flatpickr/dist/l10n/index.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.index = {}));
    })(exports, function(exports2) {
      "use strict";
      var __assign3 = function() {
        __assign3 = Object.assign || function __assign4(t2) {
          for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t2[p] = s[p];
          }
          return t2;
        };
        return __assign3.apply(this, arguments);
      };
      var fp = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Arabic = {
        weekdays: {
          shorthand: ["أحد", "اثنين", "ثلاثاء", "أربعاء", "خميس", "جمعة", "سبت"],
          longhand: [
            "الأحد",
            "الاثنين",
            "الثلاثاء",
            "الأربعاء",
            "الخميس",
            "الجمعة",
            "السبت"
          ]
        },
        months: {
          shorthand: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
          longhand: [
            "يناير",
            "فبراير",
            "مارس",
            "أبريل",
            "مايو",
            "يونيو",
            "يوليو",
            "أغسطس",
            "سبتمبر",
            "أكتوبر",
            "نوفمبر",
            "ديسمبر"
          ]
        },
        firstDayOfWeek: 6,
        rangeSeparator: " إلى ",
        weekAbbreviation: "Wk",
        scrollTitle: "قم بالتمرير للزيادة",
        toggleTitle: "اضغط للتبديل",
        amPM: ["ص", "م"],
        yearAriaLabel: "سنة",
        monthAriaLabel: "شهر",
        hourAriaLabel: "ساعة",
        minuteAriaLabel: "دقيقة",
        time_24hr: false
      };
      fp.l10ns.ar = Arabic;
      fp.l10ns;
      var fp$1 = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Austria = {
        weekdays: {
          shorthand: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
          longhand: [
            "Sonntag",
            "Montag",
            "Dienstag",
            "Mittwoch",
            "Donnerstag",
            "Freitag",
            "Samstag"
          ]
        },
        months: {
          shorthand: [
            "Jän",
            "Feb",
            "Mär",
            "Apr",
            "Mai",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Okt",
            "Nov",
            "Dez"
          ],
          longhand: [
            "Jänner",
            "Februar",
            "März",
            "April",
            "Mai",
            "Juni",
            "Juli",
            "August",
            "September",
            "Oktober",
            "November",
            "Dezember"
          ]
        },
        firstDayOfWeek: 1,
        weekAbbreviation: "KW",
        rangeSeparator: " bis ",
        scrollTitle: "Zum Ändern scrollen",
        toggleTitle: "Zum Umschalten klicken",
        time_24hr: true
      };
      fp$1.l10ns.at = Austria;
      fp$1.l10ns;
      var fp$2 = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Azerbaijan = {
        weekdays: {
          shorthand: ["B.", "B.e.", "Ç.a.", "Ç.", "C.a.", "C.", "Ş."],
          longhand: [
            "Bazar",
            "Bazar ertəsi",
            "Çərşənbə axşamı",
            "Çərşənbə",
            "Cümə axşamı",
            "Cümə",
            "Şənbə"
          ]
        },
        months: {
          shorthand: [
            "Yan",
            "Fev",
            "Mar",
            "Apr",
            "May",
            "İyn",
            "İyl",
            "Avq",
            "Sen",
            "Okt",
            "Noy",
            "Dek"
          ],
          longhand: [
            "Yanvar",
            "Fevral",
            "Mart",
            "Aprel",
            "May",
            "İyun",
            "İyul",
            "Avqust",
            "Sentyabr",
            "Oktyabr",
            "Noyabr",
            "Dekabr"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return ".";
        },
        rangeSeparator: " - ",
        weekAbbreviation: "Hf",
        scrollTitle: "Artırmaq üçün sürüşdürün",
        toggleTitle: "Aç / Bağla",
        amPM: ["GƏ", "GS"],
        time_24hr: true
      };
      fp$2.l10ns.az = Azerbaijan;
      fp$2.l10ns;
      var fp$3 = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Belarusian = {
        weekdays: {
          shorthand: ["Нд", "Пн", "Аў", "Ср", "Чц", "Пт", "Сб"],
          longhand: [
            "Нядзеля",
            "Панядзелак",
            "Аўторак",
            "Серада",
            "Чацвер",
            "Пятніца",
            "Субота"
          ]
        },
        months: {
          shorthand: [
            "Сту",
            "Лют",
            "Сак",
            "Кра",
            "Тра",
            "Чэр",
            "Ліп",
            "Жні",
            "Вер",
            "Кас",
            "Ліс",
            "Сне"
          ],
          longhand: [
            "Студзень",
            "Люты",
            "Сакавік",
            "Красавік",
            "Травень",
            "Чэрвень",
            "Ліпень",
            "Жнівень",
            "Верасень",
            "Кастрычнік",
            "Лістапад",
            "Снежань"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "";
        },
        rangeSeparator: " — ",
        weekAbbreviation: "Тыд.",
        scrollTitle: "Пракруціце для павелічэння",
        toggleTitle: "Націсніце для пераключэння",
        amPM: ["ДП", "ПП"],
        yearAriaLabel: "Год",
        time_24hr: true
      };
      fp$3.l10ns.be = Belarusian;
      fp$3.l10ns;
      var fp$4 = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Bosnian = {
        firstDayOfWeek: 1,
        weekdays: {
          shorthand: ["Ned", "Pon", "Uto", "Sri", "Čet", "Pet", "Sub"],
          longhand: [
            "Nedjelja",
            "Ponedjeljak",
            "Utorak",
            "Srijeda",
            "Četvrtak",
            "Petak",
            "Subota"
          ]
        },
        months: {
          shorthand: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "Maj",
            "Jun",
            "Jul",
            "Avg",
            "Sep",
            "Okt",
            "Nov",
            "Dec"
          ],
          longhand: [
            "Januar",
            "Februar",
            "Mart",
            "April",
            "Maj",
            "Juni",
            "Juli",
            "Avgust",
            "Septembar",
            "Oktobar",
            "Novembar",
            "Decembar"
          ]
        },
        time_24hr: true
      };
      fp$4.l10ns.bs = Bosnian;
      fp$4.l10ns;
      var fp$5 = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Bulgarian = {
        weekdays: {
          shorthand: ["Нд", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"],
          longhand: [
            "Неделя",
            "Понеделник",
            "Вторник",
            "Сряда",
            "Четвъртък",
            "Петък",
            "Събота"
          ]
        },
        months: {
          shorthand: [
            "Яну",
            "Фев",
            "Март",
            "Апр",
            "Май",
            "Юни",
            "Юли",
            "Авг",
            "Сеп",
            "Окт",
            "Ное",
            "Дек"
          ],
          longhand: [
            "Януари",
            "Февруари",
            "Март",
            "Април",
            "Май",
            "Юни",
            "Юли",
            "Август",
            "Септември",
            "Октомври",
            "Ноември",
            "Декември"
          ]
        },
        time_24hr: true,
        firstDayOfWeek: 1
      };
      fp$5.l10ns.bg = Bulgarian;
      fp$5.l10ns;
      var fp$6 = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Bangla = {
        weekdays: {
          shorthand: ["রবি", "সোম", "মঙ্গল", "বুধ", "বৃহস্পতি", "শুক্র", "শনি"],
          longhand: [
            "রবিবার",
            "সোমবার",
            "মঙ্গলবার",
            "বুধবার",
            "বৃহস্পতিবার",
            "শুক্রবার",
            "শনিবার"
          ]
        },
        months: {
          shorthand: [
            "জানু",
            "ফেব্রু",
            "মার্চ",
            "এপ্রিল",
            "মে",
            "জুন",
            "জুলাই",
            "আগ",
            "সেপ্টে",
            "অক্টো",
            "নভে",
            "ডিসে"
          ],
          longhand: [
            "জানুয়ারী",
            "ফেব্রুয়ারী",
            "মার্চ",
            "এপ্রিল",
            "মে",
            "জুন",
            "জুলাই",
            "আগস্ট",
            "সেপ্টেম্বর",
            "অক্টোবর",
            "নভেম্বর",
            "ডিসেম্বর"
          ]
        }
      };
      fp$6.l10ns.bn = Bangla;
      fp$6.l10ns;
      var fp$7 = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Catalan = {
        weekdays: {
          shorthand: ["Dg", "Dl", "Dt", "Dc", "Dj", "Dv", "Ds"],
          longhand: [
            "Diumenge",
            "Dilluns",
            "Dimarts",
            "Dimecres",
            "Dijous",
            "Divendres",
            "Dissabte"
          ]
        },
        months: {
          shorthand: [
            "Gen",
            "Febr",
            "Març",
            "Abr",
            "Maig",
            "Juny",
            "Jul",
            "Ag",
            "Set",
            "Oct",
            "Nov",
            "Des"
          ],
          longhand: [
            "Gener",
            "Febrer",
            "Març",
            "Abril",
            "Maig",
            "Juny",
            "Juliol",
            "Agost",
            "Setembre",
            "Octubre",
            "Novembre",
            "Desembre"
          ]
        },
        ordinal: function(nth2) {
          var s = nth2 % 100;
          if (s > 3 && s < 21)
            return "è";
          switch (s % 10) {
            case 1:
              return "r";
            case 2:
              return "n";
            case 3:
              return "r";
            case 4:
              return "t";
            default:
              return "è";
          }
        },
        firstDayOfWeek: 1,
        rangeSeparator: " a ",
        time_24hr: true
      };
      fp$7.l10ns.cat = fp$7.l10ns.ca = Catalan;
      fp$7.l10ns;
      var fp$8 = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Kurdish = {
        weekdays: {
          shorthand: [
            "یەکشەممە",
            "دووشەممە",
            "سێشەممە",
            "چوارشەممە",
            "پێنجشەممە",
            "هەینی",
            "شەممە"
          ],
          longhand: [
            "یەکشەممە",
            "دووشەممە",
            "سێشەممە",
            "چوارشەممە",
            "پێنجشەممە",
            "هەینی",
            "شەممە"
          ]
        },
        months: {
          shorthand: [
            "ڕێبەندان",
            "ڕەشەمە",
            "نەورۆز",
            "گوڵان",
            "جۆزەردان",
            "پووشپەڕ",
            "گەلاوێژ",
            "خەرمانان",
            "ڕەزبەر",
            "گەڵاڕێزان",
            "سەرماوەز",
            "بەفرانبار"
          ],
          longhand: [
            "ڕێبەندان",
            "ڕەشەمە",
            "نەورۆز",
            "گوڵان",
            "جۆزەردان",
            "پووشپەڕ",
            "گەلاوێژ",
            "خەرمانان",
            "ڕەزبەر",
            "گەڵاڕێزان",
            "سەرماوەز",
            "بەفرانبار"
          ]
        },
        firstDayOfWeek: 6,
        ordinal: function() {
          return "";
        }
      };
      fp$8.l10ns.ckb = Kurdish;
      fp$8.l10ns;
      var fp$9 = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Czech = {
        weekdays: {
          shorthand: ["Ne", "Po", "Út", "St", "Čt", "Pá", "So"],
          longhand: [
            "Neděle",
            "Pondělí",
            "Úterý",
            "Středa",
            "Čtvrtek",
            "Pátek",
            "Sobota"
          ]
        },
        months: {
          shorthand: [
            "Led",
            "Ún",
            "Bře",
            "Dub",
            "Kvě",
            "Čer",
            "Čvc",
            "Srp",
            "Zář",
            "Říj",
            "Lis",
            "Pro"
          ],
          longhand: [
            "Leden",
            "Únor",
            "Březen",
            "Duben",
            "Květen",
            "Červen",
            "Červenec",
            "Srpen",
            "Září",
            "Říjen",
            "Listopad",
            "Prosinec"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return ".";
        },
        rangeSeparator: " do ",
        weekAbbreviation: "Týd.",
        scrollTitle: "Rolujte pro změnu",
        toggleTitle: "Přepnout dopoledne/odpoledne",
        amPM: ["dop.", "odp."],
        yearAriaLabel: "Rok",
        time_24hr: true
      };
      fp$9.l10ns.cs = Czech;
      fp$9.l10ns;
      var fp$a = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Welsh = {
        weekdays: {
          shorthand: ["Sul", "Llun", "Maw", "Mer", "Iau", "Gwe", "Sad"],
          longhand: [
            "Dydd Sul",
            "Dydd Llun",
            "Dydd Mawrth",
            "Dydd Mercher",
            "Dydd Iau",
            "Dydd Gwener",
            "Dydd Sadwrn"
          ]
        },
        months: {
          shorthand: [
            "Ion",
            "Chwef",
            "Maw",
            "Ebr",
            "Mai",
            "Meh",
            "Gorff",
            "Awst",
            "Medi",
            "Hyd",
            "Tach",
            "Rhag"
          ],
          longhand: [
            "Ionawr",
            "Chwefror",
            "Mawrth",
            "Ebrill",
            "Mai",
            "Mehefin",
            "Gorffennaf",
            "Awst",
            "Medi",
            "Hydref",
            "Tachwedd",
            "Rhagfyr"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function(nth2) {
          if (nth2 === 1)
            return "af";
          if (nth2 === 2)
            return "ail";
          if (nth2 === 3 || nth2 === 4)
            return "ydd";
          if (nth2 === 5 || nth2 === 6)
            return "ed";
          if (nth2 >= 7 && nth2 <= 10 || nth2 == 12 || nth2 == 15 || nth2 == 18 || nth2 == 20)
            return "fed";
          if (nth2 == 11 || nth2 == 13 || nth2 == 14 || nth2 == 16 || nth2 == 17 || nth2 == 19)
            return "eg";
          if (nth2 >= 21 && nth2 <= 39)
            return "ain";
          return "";
        },
        time_24hr: true
      };
      fp$a.l10ns.cy = Welsh;
      fp$a.l10ns;
      var fp$b = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Danish = {
        weekdays: {
          shorthand: ["søn", "man", "tir", "ons", "tors", "fre", "lør"],
          longhand: [
            "søndag",
            "mandag",
            "tirsdag",
            "onsdag",
            "torsdag",
            "fredag",
            "lørdag"
          ]
        },
        months: {
          shorthand: [
            "jan",
            "feb",
            "mar",
            "apr",
            "maj",
            "jun",
            "jul",
            "aug",
            "sep",
            "okt",
            "nov",
            "dec"
          ],
          longhand: [
            "januar",
            "februar",
            "marts",
            "april",
            "maj",
            "juni",
            "juli",
            "august",
            "september",
            "oktober",
            "november",
            "december"
          ]
        },
        ordinal: function() {
          return ".";
        },
        firstDayOfWeek: 1,
        rangeSeparator: " til ",
        weekAbbreviation: "uge",
        time_24hr: true
      };
      fp$b.l10ns.da = Danish;
      fp$b.l10ns;
      var fp$c = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var German = {
        weekdays: {
          shorthand: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
          longhand: [
            "Sonntag",
            "Montag",
            "Dienstag",
            "Mittwoch",
            "Donnerstag",
            "Freitag",
            "Samstag"
          ]
        },
        months: {
          shorthand: [
            "Jan",
            "Feb",
            "Mär",
            "Apr",
            "Mai",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Okt",
            "Nov",
            "Dez"
          ],
          longhand: [
            "Januar",
            "Februar",
            "März",
            "April",
            "Mai",
            "Juni",
            "Juli",
            "August",
            "September",
            "Oktober",
            "November",
            "Dezember"
          ]
        },
        firstDayOfWeek: 1,
        weekAbbreviation: "KW",
        rangeSeparator: " bis ",
        scrollTitle: "Zum Ändern scrollen",
        toggleTitle: "Zum Umschalten klicken",
        time_24hr: true
      };
      fp$c.l10ns.de = German;
      fp$c.l10ns;
      var english2 = {
        weekdays: {
          shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
          longhand: [
            "Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday"
          ]
        },
        months: {
          shorthand: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
          ],
          longhand: [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December"
          ]
        },
        daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        firstDayOfWeek: 0,
        ordinal: function(nth2) {
          var s = nth2 % 100;
          if (s > 3 && s < 21)
            return "th";
          switch (s % 10) {
            case 1:
              return "st";
            case 2:
              return "nd";
            case 3:
              return "rd";
            default:
              return "th";
          }
        },
        rangeSeparator: " to ",
        weekAbbreviation: "Wk",
        scrollTitle: "Scroll to increment",
        toggleTitle: "Click to toggle",
        amPM: ["AM", "PM"],
        yearAriaLabel: "Year",
        monthAriaLabel: "Month",
        hourAriaLabel: "Hour",
        minuteAriaLabel: "Minute",
        time_24hr: false
      };
      var fp$d = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Esperanto = {
        firstDayOfWeek: 1,
        rangeSeparator: " ĝis ",
        weekAbbreviation: "Sem",
        scrollTitle: "Rulumu por pligrandigi la valoron",
        toggleTitle: "Klaku por ŝalti",
        weekdays: {
          shorthand: ["Dim", "Lun", "Mar", "Mer", "Ĵaŭ", "Ven", "Sab"],
          longhand: [
            "dimanĉo",
            "lundo",
            "mardo",
            "merkredo",
            "ĵaŭdo",
            "vendredo",
            "sabato"
          ]
        },
        months: {
          shorthand: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "Maj",
            "Jun",
            "Jul",
            "Aŭg",
            "Sep",
            "Okt",
            "Nov",
            "Dec"
          ],
          longhand: [
            "januaro",
            "februaro",
            "marto",
            "aprilo",
            "majo",
            "junio",
            "julio",
            "aŭgusto",
            "septembro",
            "oktobro",
            "novembro",
            "decembro"
          ]
        },
        ordinal: function() {
          return "-a";
        },
        time_24hr: true
      };
      fp$d.l10ns.eo = Esperanto;
      fp$d.l10ns;
      var fp$e = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Spanish = {
        weekdays: {
          shorthand: ["Dom", "Lun", "Mar", "Mié", "Jue", "Vie", "Sáb"],
          longhand: [
            "Domingo",
            "Lunes",
            "Martes",
            "Miércoles",
            "Jueves",
            "Viernes",
            "Sábado"
          ]
        },
        months: {
          shorthand: [
            "Ene",
            "Feb",
            "Mar",
            "Abr",
            "May",
            "Jun",
            "Jul",
            "Ago",
            "Sep",
            "Oct",
            "Nov",
            "Dic"
          ],
          longhand: [
            "Enero",
            "Febrero",
            "Marzo",
            "Abril",
            "Mayo",
            "Junio",
            "Julio",
            "Agosto",
            "Septiembre",
            "Octubre",
            "Noviembre",
            "Diciembre"
          ]
        },
        ordinal: function() {
          return "º";
        },
        firstDayOfWeek: 1,
        rangeSeparator: " a ",
        time_24hr: true
      };
      fp$e.l10ns.es = Spanish;
      fp$e.l10ns;
      var fp$f = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Estonian = {
        weekdays: {
          shorthand: ["P", "E", "T", "K", "N", "R", "L"],
          longhand: [
            "Pühapäev",
            "Esmaspäev",
            "Teisipäev",
            "Kolmapäev",
            "Neljapäev",
            "Reede",
            "Laupäev"
          ]
        },
        months: {
          shorthand: [
            "Jaan",
            "Veebr",
            "Märts",
            "Apr",
            "Mai",
            "Juuni",
            "Juuli",
            "Aug",
            "Sept",
            "Okt",
            "Nov",
            "Dets"
          ],
          longhand: [
            "Jaanuar",
            "Veebruar",
            "Märts",
            "Aprill",
            "Mai",
            "Juuni",
            "Juuli",
            "August",
            "September",
            "Oktoober",
            "November",
            "Detsember"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return ".";
        },
        weekAbbreviation: "Näd",
        rangeSeparator: " kuni ",
        scrollTitle: "Keri, et suurendada",
        toggleTitle: "Klõpsa, et vahetada",
        time_24hr: true
      };
      fp$f.l10ns.et = Estonian;
      fp$f.l10ns;
      var fp$g = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Persian = {
        weekdays: {
          shorthand: ["یک", "دو", "سه", "چهار", "پنج", "جمعه", "شنبه"],
          longhand: [
            "یک‌شنبه",
            "دوشنبه",
            "سه‌شنبه",
            "چهارشنبه",
            "پنچ‌شنبه",
            "جمعه",
            "شنبه"
          ]
        },
        months: {
          shorthand: [
            "ژانویه",
            "فوریه",
            "مارس",
            "آوریل",
            "مه",
            "ژوئن",
            "ژوئیه",
            "اوت",
            "سپتامبر",
            "اکتبر",
            "نوامبر",
            "دسامبر"
          ],
          longhand: [
            "ژانویه",
            "فوریه",
            "مارس",
            "آوریل",
            "مه",
            "ژوئن",
            "ژوئیه",
            "اوت",
            "سپتامبر",
            "اکتبر",
            "نوامبر",
            "دسامبر"
          ]
        },
        firstDayOfWeek: 6,
        ordinal: function() {
          return "";
        }
      };
      fp$g.l10ns.fa = Persian;
      fp$g.l10ns;
      var fp$h = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Finnish = {
        firstDayOfWeek: 1,
        weekdays: {
          shorthand: ["su", "ma", "ti", "ke", "to", "pe", "la"],
          longhand: [
            "sunnuntai",
            "maanantai",
            "tiistai",
            "keskiviikko",
            "torstai",
            "perjantai",
            "lauantai"
          ]
        },
        months: {
          shorthand: [
            "tammi",
            "helmi",
            "maalis",
            "huhti",
            "touko",
            "kesä",
            "heinä",
            "elo",
            "syys",
            "loka",
            "marras",
            "joulu"
          ],
          longhand: [
            "tammikuu",
            "helmikuu",
            "maaliskuu",
            "huhtikuu",
            "toukokuu",
            "kesäkuu",
            "heinäkuu",
            "elokuu",
            "syyskuu",
            "lokakuu",
            "marraskuu",
            "joulukuu"
          ]
        },
        ordinal: function() {
          return ".";
        },
        time_24hr: true
      };
      fp$h.l10ns.fi = Finnish;
      fp$h.l10ns;
      var fp$i = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Faroese = {
        weekdays: {
          shorthand: ["Sun", "Mán", "Týs", "Mik", "Hós", "Frí", "Ley"],
          longhand: [
            "Sunnudagur",
            "Mánadagur",
            "Týsdagur",
            "Mikudagur",
            "Hósdagur",
            "Fríggjadagur",
            "Leygardagur"
          ]
        },
        months: {
          shorthand: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "Mai",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Okt",
            "Nov",
            "Des"
          ],
          longhand: [
            "Januar",
            "Februar",
            "Mars",
            "Apríl",
            "Mai",
            "Juni",
            "Juli",
            "August",
            "Septembur",
            "Oktobur",
            "Novembur",
            "Desembur"
          ]
        },
        ordinal: function() {
          return ".";
        },
        firstDayOfWeek: 1,
        rangeSeparator: " til ",
        weekAbbreviation: "vika",
        scrollTitle: "Rulla fyri at broyta",
        toggleTitle: "Trýst fyri at skifta",
        yearAriaLabel: "Ár",
        time_24hr: true
      };
      fp$i.l10ns.fo = Faroese;
      fp$i.l10ns;
      var fp$j = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var French = {
        firstDayOfWeek: 1,
        weekdays: {
          shorthand: ["dim", "lun", "mar", "mer", "jeu", "ven", "sam"],
          longhand: [
            "dimanche",
            "lundi",
            "mardi",
            "mercredi",
            "jeudi",
            "vendredi",
            "samedi"
          ]
        },
        months: {
          shorthand: [
            "janv",
            "févr",
            "mars",
            "avr",
            "mai",
            "juin",
            "juil",
            "août",
            "sept",
            "oct",
            "nov",
            "déc"
          ],
          longhand: [
            "janvier",
            "février",
            "mars",
            "avril",
            "mai",
            "juin",
            "juillet",
            "août",
            "septembre",
            "octobre",
            "novembre",
            "décembre"
          ]
        },
        ordinal: function(nth2) {
          if (nth2 > 1)
            return "";
          return "er";
        },
        rangeSeparator: " au ",
        weekAbbreviation: "Sem",
        scrollTitle: "Défiler pour augmenter la valeur",
        toggleTitle: "Cliquer pour basculer",
        time_24hr: true
      };
      fp$j.l10ns.fr = French;
      fp$j.l10ns;
      var fp$k = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Greek = {
        weekdays: {
          shorthand: ["Κυ", "Δε", "Τρ", "Τε", "Πέ", "Πα", "Σά"],
          longhand: [
            "Κυριακή",
            "Δευτέρα",
            "Τρίτη",
            "Τετάρτη",
            "Πέμπτη",
            "Παρασκευή",
            "Σάββατο"
          ]
        },
        months: {
          shorthand: [
            "Ιαν",
            "Φεβ",
            "Μάρ",
            "Απρ",
            "Μάι",
            "Ιούν",
            "Ιούλ",
            "Αύγ",
            "Σεπ",
            "Οκτ",
            "Νοέ",
            "Δεκ"
          ],
          longhand: [
            "Ιανουάριος",
            "Φεβρουάριος",
            "Μάρτιος",
            "Απρίλιος",
            "Μάιος",
            "Ιούνιος",
            "Ιούλιος",
            "Αύγουστος",
            "Σεπτέμβριος",
            "Οκτώβριος",
            "Νοέμβριος",
            "Δεκέμβριος"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "";
        },
        weekAbbreviation: "Εβδ",
        rangeSeparator: " έως ",
        scrollTitle: "Μετακυλήστε για προσαύξηση",
        toggleTitle: "Κάντε κλικ για αλλαγή",
        amPM: ["ΠΜ", "ΜΜ"],
        yearAriaLabel: "χρόνος",
        monthAriaLabel: "μήνας",
        hourAriaLabel: "ώρα",
        minuteAriaLabel: "λεπτό"
      };
      fp$k.l10ns.gr = Greek;
      fp$k.l10ns;
      var fp$l = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Hebrew = {
        weekdays: {
          shorthand: ["א", "ב", "ג", "ד", "ה", "ו", "ש"],
          longhand: ["ראשון", "שני", "שלישי", "רביעי", "חמישי", "שישי", "שבת"]
        },
        months: {
          shorthand: [
            "ינו׳",
            "פבר׳",
            "מרץ",
            "אפר׳",
            "מאי",
            "יוני",
            "יולי",
            "אוג׳",
            "ספט׳",
            "אוק׳",
            "נוב׳",
            "דצמ׳"
          ],
          longhand: [
            "ינואר",
            "פברואר",
            "מרץ",
            "אפריל",
            "מאי",
            "יוני",
            "יולי",
            "אוגוסט",
            "ספטמבר",
            "אוקטובר",
            "נובמבר",
            "דצמבר"
          ]
        },
        rangeSeparator: " אל ",
        time_24hr: true
      };
      fp$l.l10ns.he = Hebrew;
      fp$l.l10ns;
      var fp$m = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Hindi = {
        weekdays: {
          shorthand: ["रवि", "सोम", "मंगल", "बुध", "गुरु", "शुक्र", "शनि"],
          longhand: [
            "रविवार",
            "सोमवार",
            "मंगलवार",
            "बुधवार",
            "गुरुवार",
            "शुक्रवार",
            "शनिवार"
          ]
        },
        months: {
          shorthand: [
            "जन",
            "फर",
            "मार्च",
            "अप्रेल",
            "मई",
            "जून",
            "जूलाई",
            "अग",
            "सित",
            "अक्ट",
            "नव",
            "दि"
          ],
          longhand: [
            "जनवरी ",
            "फरवरी",
            "मार्च",
            "अप्रेल",
            "मई",
            "जून",
            "जूलाई",
            "अगस्त ",
            "सितम्बर",
            "अक्टूबर",
            "नवम्बर",
            "दिसम्बर"
          ]
        }
      };
      fp$m.l10ns.hi = Hindi;
      fp$m.l10ns;
      var fp$n = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Croatian = {
        firstDayOfWeek: 1,
        weekdays: {
          shorthand: ["Ned", "Pon", "Uto", "Sri", "Čet", "Pet", "Sub"],
          longhand: [
            "Nedjelja",
            "Ponedjeljak",
            "Utorak",
            "Srijeda",
            "Četvrtak",
            "Petak",
            "Subota"
          ]
        },
        months: {
          shorthand: [
            "Sij",
            "Velj",
            "Ožu",
            "Tra",
            "Svi",
            "Lip",
            "Srp",
            "Kol",
            "Ruj",
            "Lis",
            "Stu",
            "Pro"
          ],
          longhand: [
            "Siječanj",
            "Veljača",
            "Ožujak",
            "Travanj",
            "Svibanj",
            "Lipanj",
            "Srpanj",
            "Kolovoz",
            "Rujan",
            "Listopad",
            "Studeni",
            "Prosinac"
          ]
        },
        time_24hr: true
      };
      fp$n.l10ns.hr = Croatian;
      fp$n.l10ns;
      var fp$o = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Hungarian = {
        firstDayOfWeek: 1,
        weekdays: {
          shorthand: ["V", "H", "K", "Sz", "Cs", "P", "Szo"],
          longhand: [
            "Vasárnap",
            "Hétfő",
            "Kedd",
            "Szerda",
            "Csütörtök",
            "Péntek",
            "Szombat"
          ]
        },
        months: {
          shorthand: [
            "Jan",
            "Feb",
            "Már",
            "Ápr",
            "Máj",
            "Jún",
            "Júl",
            "Aug",
            "Szep",
            "Okt",
            "Nov",
            "Dec"
          ],
          longhand: [
            "Január",
            "Február",
            "Március",
            "Április",
            "Május",
            "Június",
            "Július",
            "Augusztus",
            "Szeptember",
            "Október",
            "November",
            "December"
          ]
        },
        ordinal: function() {
          return ".";
        },
        weekAbbreviation: "Hét",
        scrollTitle: "Görgessen",
        toggleTitle: "Kattintson a váltáshoz",
        rangeSeparator: " - ",
        time_24hr: true
      };
      fp$o.l10ns.hu = Hungarian;
      fp$o.l10ns;
      var fp$p = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Armenian = {
        weekdays: {
          shorthand: ["Կիր", "Երկ", "Երք", "Չրք", "Հնգ", "Ուրբ", "Շբթ"],
          longhand: [
            "Կիրակի",
            "Եկուշաբթի",
            "Երեքշաբթի",
            "Չորեքշաբթի",
            "Հինգշաբթի",
            "Ուրբաթ",
            "Շաբաթ"
          ]
        },
        months: {
          shorthand: [
            "Հնվ",
            "Փտր",
            "Մար",
            "Ապր",
            "Մայ",
            "Հնս",
            "Հլս",
            "Օգս",
            "Սեպ",
            "Հոկ",
            "Նմբ",
            "Դեկ"
          ],
          longhand: [
            "Հունվար",
            "Փետրվար",
            "Մարտ",
            "Ապրիլ",
            "Մայիս",
            "Հունիս",
            "Հուլիս",
            "Օգոստոս",
            "Սեպտեմբեր",
            "Հոկտեմբեր",
            "Նոյեմբեր",
            "Դեկտեմբեր"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "";
        },
        rangeSeparator: " — ",
        weekAbbreviation: "ՇԲՏ",
        scrollTitle: "Ոլորեք՝ մեծացնելու համար",
        toggleTitle: "Սեղմեք՝ փոխելու համար",
        amPM: ["ՄԿ", "ԿՀ"],
        yearAriaLabel: "Տարի",
        monthAriaLabel: "Ամիս",
        hourAriaLabel: "Ժամ",
        minuteAriaLabel: "Րոպե",
        time_24hr: true
      };
      fp$p.l10ns.hy = Armenian;
      fp$p.l10ns;
      var fp$q = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Indonesian = {
        weekdays: {
          shorthand: ["Min", "Sen", "Sel", "Rab", "Kam", "Jum", "Sab"],
          longhand: ["Minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu"]
        },
        months: {
          shorthand: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "Mei",
            "Jun",
            "Jul",
            "Agu",
            "Sep",
            "Okt",
            "Nov",
            "Des"
          ],
          longhand: [
            "Januari",
            "Februari",
            "Maret",
            "April",
            "Mei",
            "Juni",
            "Juli",
            "Agustus",
            "September",
            "Oktober",
            "November",
            "Desember"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "";
        },
        time_24hr: true,
        rangeSeparator: " - "
      };
      fp$q.l10ns.id = Indonesian;
      fp$q.l10ns;
      var fp$r = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Icelandic = {
        weekdays: {
          shorthand: ["Sun", "Mán", "Þri", "Mið", "Fim", "Fös", "Lau"],
          longhand: [
            "Sunnudagur",
            "Mánudagur",
            "Þriðjudagur",
            "Miðvikudagur",
            "Fimmtudagur",
            "Föstudagur",
            "Laugardagur"
          ]
        },
        months: {
          shorthand: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "Maí",
            "Jún",
            "Júl",
            "Ágú",
            "Sep",
            "Okt",
            "Nóv",
            "Des"
          ],
          longhand: [
            "Janúar",
            "Febrúar",
            "Mars",
            "Apríl",
            "Maí",
            "Júní",
            "Júlí",
            "Ágúst",
            "September",
            "Október",
            "Nóvember",
            "Desember"
          ]
        },
        ordinal: function() {
          return ".";
        },
        firstDayOfWeek: 1,
        rangeSeparator: " til ",
        weekAbbreviation: "vika",
        yearAriaLabel: "Ár",
        time_24hr: true
      };
      fp$r.l10ns.is = Icelandic;
      fp$r.l10ns;
      var fp$s = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Italian = {
        weekdays: {
          shorthand: ["Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"],
          longhand: [
            "Domenica",
            "Lunedì",
            "Martedì",
            "Mercoledì",
            "Giovedì",
            "Venerdì",
            "Sabato"
          ]
        },
        months: {
          shorthand: [
            "Gen",
            "Feb",
            "Mar",
            "Apr",
            "Mag",
            "Giu",
            "Lug",
            "Ago",
            "Set",
            "Ott",
            "Nov",
            "Dic"
          ],
          longhand: [
            "Gennaio",
            "Febbraio",
            "Marzo",
            "Aprile",
            "Maggio",
            "Giugno",
            "Luglio",
            "Agosto",
            "Settembre",
            "Ottobre",
            "Novembre",
            "Dicembre"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "°";
        },
        rangeSeparator: " al ",
        weekAbbreviation: "Se",
        scrollTitle: "Scrolla per aumentare",
        toggleTitle: "Clicca per cambiare",
        time_24hr: true
      };
      fp$s.l10ns.it = Italian;
      fp$s.l10ns;
      var fp$t = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Japanese = {
        weekdays: {
          shorthand: ["日", "月", "火", "水", "木", "金", "土"],
          longhand: [
            "日曜日",
            "月曜日",
            "火曜日",
            "水曜日",
            "木曜日",
            "金曜日",
            "土曜日"
          ]
        },
        months: {
          shorthand: [
            "1月",
            "2月",
            "3月",
            "4月",
            "5月",
            "6月",
            "7月",
            "8月",
            "9月",
            "10月",
            "11月",
            "12月"
          ],
          longhand: [
            "1月",
            "2月",
            "3月",
            "4月",
            "5月",
            "6月",
            "7月",
            "8月",
            "9月",
            "10月",
            "11月",
            "12月"
          ]
        },
        time_24hr: true,
        rangeSeparator: " から ",
        monthAriaLabel: "月",
        amPM: ["午前", "午後"],
        yearAriaLabel: "年",
        hourAriaLabel: "時間",
        minuteAriaLabel: "分"
      };
      fp$t.l10ns.ja = Japanese;
      fp$t.l10ns;
      var fp$u = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Georgian = {
        weekdays: {
          shorthand: ["კვ", "ორ", "სა", "ოთ", "ხუ", "პა", "შა"],
          longhand: [
            "კვირა",
            "ორშაბათი",
            "სამშაბათი",
            "ოთხშაბათი",
            "ხუთშაბათი",
            "პარასკევი",
            "შაბათი"
          ]
        },
        months: {
          shorthand: [
            "იან",
            "თებ",
            "მარ",
            "აპრ",
            "მაი",
            "ივნ",
            "ივლ",
            "აგვ",
            "სექ",
            "ოქტ",
            "ნოე",
            "დეკ"
          ],
          longhand: [
            "იანვარი",
            "თებერვალი",
            "მარტი",
            "აპრილი",
            "მაისი",
            "ივნისი",
            "ივლისი",
            "აგვისტო",
            "სექტემბერი",
            "ოქტომბერი",
            "ნოემბერი",
            "დეკემბერი"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "";
        },
        rangeSeparator: " — ",
        weekAbbreviation: "კვ.",
        scrollTitle: "დასქროლეთ გასადიდებლად",
        toggleTitle: "დააკლიკეთ გადართვისთვის",
        amPM: ["AM", "PM"],
        yearAriaLabel: "წელი",
        time_24hr: true
      };
      fp$u.l10ns.ka = Georgian;
      fp$u.l10ns;
      var fp$v = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Korean = {
        weekdays: {
          shorthand: ["일", "월", "화", "수", "목", "금", "토"],
          longhand: [
            "일요일",
            "월요일",
            "화요일",
            "수요일",
            "목요일",
            "금요일",
            "토요일"
          ]
        },
        months: {
          shorthand: [
            "1월",
            "2월",
            "3월",
            "4월",
            "5월",
            "6월",
            "7월",
            "8월",
            "9월",
            "10월",
            "11월",
            "12월"
          ],
          longhand: [
            "1월",
            "2월",
            "3월",
            "4월",
            "5월",
            "6월",
            "7월",
            "8월",
            "9월",
            "10월",
            "11월",
            "12월"
          ]
        },
        ordinal: function() {
          return "일";
        },
        rangeSeparator: " ~ ",
        amPM: ["오전", "오후"]
      };
      fp$v.l10ns.ko = Korean;
      fp$v.l10ns;
      var fp$w = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Khmer = {
        weekdays: {
          shorthand: ["អាទិត្យ", "ចន្ទ", "អង្គារ", "ពុធ", "ព្រហស.", "សុក្រ", "សៅរ៍"],
          longhand: [
            "អាទិត្យ",
            "ចន្ទ",
            "អង្គារ",
            "ពុធ",
            "ព្រហស្បតិ៍",
            "សុក្រ",
            "សៅរ៍"
          ]
        },
        months: {
          shorthand: [
            "មករា",
            "កុម្ភះ",
            "មីនា",
            "មេសា",
            "ឧសភា",
            "មិថុនា",
            "កក្កដា",
            "សីហា",
            "កញ្ញា",
            "តុលា",
            "វិច្ឆិកា",
            "ធ្នូ"
          ],
          longhand: [
            "មករា",
            "កុម្ភះ",
            "មីនា",
            "មេសា",
            "ឧសភា",
            "មិថុនា",
            "កក្កដា",
            "សីហា",
            "កញ្ញា",
            "តុលា",
            "វិច្ឆិកា",
            "ធ្នូ"
          ]
        },
        ordinal: function() {
          return "";
        },
        firstDayOfWeek: 1,
        rangeSeparator: " ដល់ ",
        weekAbbreviation: "សប្តាហ៍",
        scrollTitle: "រំកិលដើម្បីបង្កើន",
        toggleTitle: "ចុចដើម្បីផ្លាស់ប្ដូរ",
        yearAriaLabel: "ឆ្នាំ",
        time_24hr: true
      };
      fp$w.l10ns.km = Khmer;
      fp$w.l10ns;
      var fp$x = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Kazakh = {
        weekdays: {
          shorthand: ["Жс", "Дс", "Сc", "Ср", "Бс", "Жм", "Сб"],
          longhand: [
            "Жексенбi",
            "Дүйсенбi",
            "Сейсенбi",
            "Сәрсенбi",
            "Бейсенбi",
            "Жұма",
            "Сенбi"
          ]
        },
        months: {
          shorthand: [
            "Қаң",
            "Ақп",
            "Нау",
            "Сәу",
            "Мам",
            "Мау",
            "Шiл",
            "Там",
            "Қыр",
            "Қаз",
            "Қар",
            "Жел"
          ],
          longhand: [
            "Қаңтар",
            "Ақпан",
            "Наурыз",
            "Сәуiр",
            "Мамыр",
            "Маусым",
            "Шiлде",
            "Тамыз",
            "Қыркүйек",
            "Қазан",
            "Қараша",
            "Желтоқсан"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "";
        },
        rangeSeparator: " — ",
        weekAbbreviation: "Апта",
        scrollTitle: "Үлкейту үшін айналдырыңыз",
        toggleTitle: "Ауыстыру үшін басыңыз",
        amPM: ["ТД", "ТК"],
        yearAriaLabel: "Жыл"
      };
      fp$x.l10ns.kz = Kazakh;
      fp$x.l10ns;
      var fp$y = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Lithuanian = {
        weekdays: {
          shorthand: ["S", "Pr", "A", "T", "K", "Pn", "Š"],
          longhand: [
            "Sekmadienis",
            "Pirmadienis",
            "Antradienis",
            "Trečiadienis",
            "Ketvirtadienis",
            "Penktadienis",
            "Šeštadienis"
          ]
        },
        months: {
          shorthand: [
            "Sau",
            "Vas",
            "Kov",
            "Bal",
            "Geg",
            "Bir",
            "Lie",
            "Rgp",
            "Rgs",
            "Spl",
            "Lap",
            "Grd"
          ],
          longhand: [
            "Sausis",
            "Vasaris",
            "Kovas",
            "Balandis",
            "Gegužė",
            "Birželis",
            "Liepa",
            "Rugpjūtis",
            "Rugsėjis",
            "Spalis",
            "Lapkritis",
            "Gruodis"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "-a";
        },
        rangeSeparator: " iki ",
        weekAbbreviation: "Sav",
        scrollTitle: "Keisti laiką pelės rateliu",
        toggleTitle: "Perjungti laiko formatą",
        time_24hr: true
      };
      fp$y.l10ns.lt = Lithuanian;
      fp$y.l10ns;
      var fp$z = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Latvian = {
        firstDayOfWeek: 1,
        weekdays: {
          shorthand: ["Sv", "Pr", "Ot", "Tr", "Ce", "Pk", "Se"],
          longhand: [
            "Svētdiena",
            "Pirmdiena",
            "Otrdiena",
            "Trešdiena",
            "Ceturtdiena",
            "Piektdiena",
            "Sestdiena"
          ]
        },
        months: {
          shorthand: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "Mai",
            "Jūn",
            "Jūl",
            "Aug",
            "Sep",
            "Okt",
            "Nov",
            "Dec"
          ],
          longhand: [
            "Janvāris",
            "Februāris",
            "Marts",
            "Aprīlis",
            "Maijs",
            "Jūnijs",
            "Jūlijs",
            "Augusts",
            "Septembris",
            "Oktobris",
            "Novembris",
            "Decembris"
          ]
        },
        rangeSeparator: " līdz ",
        time_24hr: true
      };
      fp$z.l10ns.lv = Latvian;
      fp$z.l10ns;
      var fp$A = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Macedonian = {
        weekdays: {
          shorthand: ["Не", "По", "Вт", "Ср", "Че", "Пе", "Са"],
          longhand: [
            "Недела",
            "Понеделник",
            "Вторник",
            "Среда",
            "Четврток",
            "Петок",
            "Сабота"
          ]
        },
        months: {
          shorthand: [
            "Јан",
            "Фев",
            "Мар",
            "Апр",
            "Мај",
            "Јун",
            "Јул",
            "Авг",
            "Сеп",
            "Окт",
            "Ное",
            "Дек"
          ],
          longhand: [
            "Јануари",
            "Февруари",
            "Март",
            "Април",
            "Мај",
            "Јуни",
            "Јули",
            "Август",
            "Септември",
            "Октомври",
            "Ноември",
            "Декември"
          ]
        },
        firstDayOfWeek: 1,
        weekAbbreviation: "Нед.",
        rangeSeparator: " до ",
        time_24hr: true
      };
      fp$A.l10ns.mk = Macedonian;
      fp$A.l10ns;
      var fp$B = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Mongolian = {
        firstDayOfWeek: 1,
        weekdays: {
          shorthand: ["Да", "Мя", "Лх", "Пү", "Ба", "Бя", "Ня"],
          longhand: ["Даваа", "Мягмар", "Лхагва", "Пүрэв", "Баасан", "Бямба", "Ням"]
        },
        months: {
          shorthand: [
            "1-р сар",
            "2-р сар",
            "3-р сар",
            "4-р сар",
            "5-р сар",
            "6-р сар",
            "7-р сар",
            "8-р сар",
            "9-р сар",
            "10-р сар",
            "11-р сар",
            "12-р сар"
          ],
          longhand: [
            "Нэгдүгээр сар",
            "Хоёрдугаар сар",
            "Гуравдугаар сар",
            "Дөрөвдүгээр сар",
            "Тавдугаар сар",
            "Зургаадугаар сар",
            "Долдугаар сар",
            "Наймдугаар сар",
            "Есдүгээр сар",
            "Аравдугаар сар",
            "Арваннэгдүгээр сар",
            "Арванхоёрдугаар сар"
          ]
        },
        rangeSeparator: "-с ",
        time_24hr: true
      };
      fp$B.l10ns.mn = Mongolian;
      fp$B.l10ns;
      var fp$C = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Malaysian = {
        weekdays: {
          shorthand: ["Aha", "Isn", "Sel", "Rab", "Kha", "Jum", "Sab"],
          longhand: ["Ahad", "Isnin", "Selasa", "Rabu", "Khamis", "Jumaat", "Sabtu"]
        },
        months: {
          shorthand: [
            "Jan",
            "Feb",
            "Mac",
            "Apr",
            "Mei",
            "Jun",
            "Jul",
            "Ogo",
            "Sep",
            "Okt",
            "Nov",
            "Dis"
          ],
          longhand: [
            "Januari",
            "Februari",
            "Mac",
            "April",
            "Mei",
            "Jun",
            "Julai",
            "Ogos",
            "September",
            "Oktober",
            "November",
            "Disember"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "";
        }
      };
      fp$C.l10ns;
      var fp$D = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Burmese = {
        weekdays: {
          shorthand: ["နွေ", "လာ", "ဂါ", "ဟူး", "ကြာ", "သော", "နေ"],
          longhand: [
            "တနင်္ဂနွေ",
            "တနင်္လာ",
            "အင်္ဂါ",
            "ဗုဒ္ဓဟူး",
            "ကြာသပတေး",
            "သောကြာ",
            "စနေ"
          ]
        },
        months: {
          shorthand: [
            "ဇန်",
            "ဖေ",
            "မတ်",
            "ပြီ",
            "မေ",
            "ဇွန်",
            "လိုင်",
            "သြ",
            "စက်",
            "အောက်",
            "နို",
            "ဒီ"
          ],
          longhand: [
            "ဇန်နဝါရီ",
            "ဖေဖော်ဝါရီ",
            "မတ်",
            "ဧပြီ",
            "မေ",
            "ဇွန်",
            "ဇူလိုင်",
            "သြဂုတ်",
            "စက်တင်ဘာ",
            "အောက်တိုဘာ",
            "နိုဝင်ဘာ",
            "ဒီဇင်ဘာ"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "";
        },
        time_24hr: true
      };
      fp$D.l10ns.my = Burmese;
      fp$D.l10ns;
      var fp$E = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Dutch = {
        weekdays: {
          shorthand: ["zo", "ma", "di", "wo", "do", "vr", "za"],
          longhand: [
            "zondag",
            "maandag",
            "dinsdag",
            "woensdag",
            "donderdag",
            "vrijdag",
            "zaterdag"
          ]
        },
        months: {
          shorthand: [
            "jan",
            "feb",
            "mrt",
            "apr",
            "mei",
            "jun",
            "jul",
            "aug",
            "sept",
            "okt",
            "nov",
            "dec"
          ],
          longhand: [
            "januari",
            "februari",
            "maart",
            "april",
            "mei",
            "juni",
            "juli",
            "augustus",
            "september",
            "oktober",
            "november",
            "december"
          ]
        },
        firstDayOfWeek: 1,
        weekAbbreviation: "wk",
        rangeSeparator: " t/m ",
        scrollTitle: "Scroll voor volgende / vorige",
        toggleTitle: "Klik om te wisselen",
        time_24hr: true,
        ordinal: function(nth2) {
          if (nth2 === 1 || nth2 === 8 || nth2 >= 20)
            return "ste";
          return "de";
        }
      };
      fp$E.l10ns.nl = Dutch;
      fp$E.l10ns;
      var fp$F = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var NorwegianNynorsk = {
        weekdays: {
          shorthand: ["Sø.", "Må.", "Ty.", "On.", "To.", "Fr.", "La."],
          longhand: [
            "Søndag",
            "Måndag",
            "Tysdag",
            "Onsdag",
            "Torsdag",
            "Fredag",
            "Laurdag"
          ]
        },
        months: {
          shorthand: [
            "Jan",
            "Feb",
            "Mars",
            "Apr",
            "Mai",
            "Juni",
            "Juli",
            "Aug",
            "Sep",
            "Okt",
            "Nov",
            "Des"
          ],
          longhand: [
            "Januar",
            "Februar",
            "Mars",
            "April",
            "Mai",
            "Juni",
            "Juli",
            "August",
            "September",
            "Oktober",
            "November",
            "Desember"
          ]
        },
        firstDayOfWeek: 1,
        rangeSeparator: " til ",
        weekAbbreviation: "Veke",
        scrollTitle: "Scroll for å endre",
        toggleTitle: "Klikk for å veksle",
        time_24hr: true,
        ordinal: function() {
          return ".";
        }
      };
      fp$F.l10ns.nn = NorwegianNynorsk;
      fp$F.l10ns;
      var fp$G = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Norwegian = {
        weekdays: {
          shorthand: ["Søn", "Man", "Tir", "Ons", "Tor", "Fre", "Lør"],
          longhand: [
            "Søndag",
            "Mandag",
            "Tirsdag",
            "Onsdag",
            "Torsdag",
            "Fredag",
            "Lørdag"
          ]
        },
        months: {
          shorthand: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "Mai",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Okt",
            "Nov",
            "Des"
          ],
          longhand: [
            "Januar",
            "Februar",
            "Mars",
            "April",
            "Mai",
            "Juni",
            "Juli",
            "August",
            "September",
            "Oktober",
            "November",
            "Desember"
          ]
        },
        firstDayOfWeek: 1,
        rangeSeparator: " til ",
        weekAbbreviation: "Uke",
        scrollTitle: "Scroll for å endre",
        toggleTitle: "Klikk for å veksle",
        time_24hr: true,
        ordinal: function() {
          return ".";
        }
      };
      fp$G.l10ns.no = Norwegian;
      fp$G.l10ns;
      var fp$H = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Punjabi = {
        weekdays: {
          shorthand: ["ਐਤ", "ਸੋਮ", "ਮੰਗਲ", "ਬੁੱਧ", "ਵੀਰ", "ਸ਼ੁੱਕਰ", "ਸ਼ਨਿੱਚਰ"],
          longhand: [
            "ਐਤਵਾਰ",
            "ਸੋਮਵਾਰ",
            "ਮੰਗਲਵਾਰ",
            "ਬੁੱਧਵਾਰ",
            "ਵੀਰਵਾਰ",
            "ਸ਼ੁੱਕਰਵਾਰ",
            "ਸ਼ਨਿੱਚਰਵਾਰ"
          ]
        },
        months: {
          shorthand: [
            "ਜਨ",
            "ਫ਼ਰ",
            "ਮਾਰ",
            "ਅਪ੍ਰੈ",
            "ਮਈ",
            "ਜੂਨ",
            "ਜੁਲਾ",
            "ਅਗ",
            "ਸਤੰ",
            "ਅਕ",
            "ਨਵੰ",
            "ਦਸੰ"
          ],
          longhand: [
            "ਜਨਵਰੀ",
            "ਫ਼ਰਵਰੀ",
            "ਮਾਰਚ",
            "ਅਪ੍ਰੈਲ",
            "ਮਈ",
            "ਜੂਨ",
            "ਜੁਲਾਈ",
            "ਅਗਸਤ",
            "ਸਤੰਬਰ",
            "ਅਕਤੂਬਰ",
            "ਨਵੰਬਰ",
            "ਦਸੰਬਰ"
          ]
        },
        time_24hr: true
      };
      fp$H.l10ns.pa = Punjabi;
      fp$H.l10ns;
      var fp$I = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Polish = {
        weekdays: {
          shorthand: ["Nd", "Pn", "Wt", "Śr", "Cz", "Pt", "So"],
          longhand: [
            "Niedziela",
            "Poniedziałek",
            "Wtorek",
            "Środa",
            "Czwartek",
            "Piątek",
            "Sobota"
          ]
        },
        months: {
          shorthand: [
            "Sty",
            "Lut",
            "Mar",
            "Kwi",
            "Maj",
            "Cze",
            "Lip",
            "Sie",
            "Wrz",
            "Paź",
            "Lis",
            "Gru"
          ],
          longhand: [
            "Styczeń",
            "Luty",
            "Marzec",
            "Kwiecień",
            "Maj",
            "Czerwiec",
            "Lipiec",
            "Sierpień",
            "Wrzesień",
            "Październik",
            "Listopad",
            "Grudzień"
          ]
        },
        rangeSeparator: " do ",
        weekAbbreviation: "tydz.",
        scrollTitle: "Przewiń, aby zwiększyć",
        toggleTitle: "Kliknij, aby przełączyć",
        firstDayOfWeek: 1,
        time_24hr: true,
        ordinal: function() {
          return ".";
        }
      };
      fp$I.l10ns.pl = Polish;
      fp$I.l10ns;
      var fp$J = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Portuguese = {
        weekdays: {
          shorthand: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"],
          longhand: [
            "Domingo",
            "Segunda-feira",
            "Terça-feira",
            "Quarta-feira",
            "Quinta-feira",
            "Sexta-feira",
            "Sábado"
          ]
        },
        months: {
          shorthand: [
            "Jan",
            "Fev",
            "Mar",
            "Abr",
            "Mai",
            "Jun",
            "Jul",
            "Ago",
            "Set",
            "Out",
            "Nov",
            "Dez"
          ],
          longhand: [
            "Janeiro",
            "Fevereiro",
            "Março",
            "Abril",
            "Maio",
            "Junho",
            "Julho",
            "Agosto",
            "Setembro",
            "Outubro",
            "Novembro",
            "Dezembro"
          ]
        },
        rangeSeparator: " até ",
        time_24hr: true
      };
      fp$J.l10ns.pt = Portuguese;
      fp$J.l10ns;
      var fp$K = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Romanian = {
        weekdays: {
          shorthand: ["Dum", "Lun", "Mar", "Mie", "Joi", "Vin", "Sâm"],
          longhand: [
            "Duminică",
            "Luni",
            "Marți",
            "Miercuri",
            "Joi",
            "Vineri",
            "Sâmbătă"
          ]
        },
        months: {
          shorthand: [
            "Ian",
            "Feb",
            "Mar",
            "Apr",
            "Mai",
            "Iun",
            "Iul",
            "Aug",
            "Sep",
            "Oct",
            "Noi",
            "Dec"
          ],
          longhand: [
            "Ianuarie",
            "Februarie",
            "Martie",
            "Aprilie",
            "Mai",
            "Iunie",
            "Iulie",
            "August",
            "Septembrie",
            "Octombrie",
            "Noiembrie",
            "Decembrie"
          ]
        },
        firstDayOfWeek: 1,
        time_24hr: true,
        ordinal: function() {
          return "";
        }
      };
      fp$K.l10ns.ro = Romanian;
      fp$K.l10ns;
      var fp$L = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Russian = {
        weekdays: {
          shorthand: ["Вс", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"],
          longhand: [
            "Воскресенье",
            "Понедельник",
            "Вторник",
            "Среда",
            "Четверг",
            "Пятница",
            "Суббота"
          ]
        },
        months: {
          shorthand: [
            "Янв",
            "Фев",
            "Март",
            "Апр",
            "Май",
            "Июнь",
            "Июль",
            "Авг",
            "Сен",
            "Окт",
            "Ноя",
            "Дек"
          ],
          longhand: [
            "Январь",
            "Февраль",
            "Март",
            "Апрель",
            "Май",
            "Июнь",
            "Июль",
            "Август",
            "Сентябрь",
            "Октябрь",
            "Ноябрь",
            "Декабрь"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "";
        },
        rangeSeparator: " — ",
        weekAbbreviation: "Нед.",
        scrollTitle: "Прокрутите для увеличения",
        toggleTitle: "Нажмите для переключения",
        amPM: ["ДП", "ПП"],
        yearAriaLabel: "Год",
        time_24hr: true
      };
      fp$L.l10ns.ru = Russian;
      fp$L.l10ns;
      var fp$M = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Sinhala = {
        weekdays: {
          shorthand: ["ඉ", "ස", "අ", "බ", "බ්‍ර", "සි", "සෙ"],
          longhand: [
            "ඉරිදා",
            "සඳුදා",
            "අඟහරුවාදා",
            "බදාදා",
            "බ්‍රහස්පතින්දා",
            "සිකුරාදා",
            "සෙනසුරාදා"
          ]
        },
        months: {
          shorthand: [
            "ජන",
            "පෙබ",
            "මාර්",
            "අප්‍රේ",
            "මැයි",
            "ජුනි",
            "ජූලි",
            "අගෝ",
            "සැප්",
            "ඔක්",
            "නොවැ",
            "දෙසැ"
          ],
          longhand: [
            "ජනවාරි",
            "පෙබරවාරි",
            "මාර්තු",
            "අප්‍රේල්",
            "මැයි",
            "ජුනි",
            "ජූලි",
            "අගෝස්තු",
            "සැප්තැම්බර්",
            "ඔක්තෝබර්",
            "නොවැම්බර්",
            "දෙසැම්බර්"
          ]
        },
        time_24hr: true
      };
      fp$M.l10ns.si = Sinhala;
      fp$M.l10ns;
      var fp$N = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Slovak = {
        weekdays: {
          shorthand: ["Ned", "Pon", "Ut", "Str", "Štv", "Pia", "Sob"],
          longhand: [
            "Nedeľa",
            "Pondelok",
            "Utorok",
            "Streda",
            "Štvrtok",
            "Piatok",
            "Sobota"
          ]
        },
        months: {
          shorthand: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "Máj",
            "Jún",
            "Júl",
            "Aug",
            "Sep",
            "Okt",
            "Nov",
            "Dec"
          ],
          longhand: [
            "Január",
            "Február",
            "Marec",
            "Apríl",
            "Máj",
            "Jún",
            "Júl",
            "August",
            "September",
            "Október",
            "November",
            "December"
          ]
        },
        firstDayOfWeek: 1,
        rangeSeparator: " do ",
        time_24hr: true,
        ordinal: function() {
          return ".";
        }
      };
      fp$N.l10ns.sk = Slovak;
      fp$N.l10ns;
      var fp$O = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Slovenian = {
        weekdays: {
          shorthand: ["Ned", "Pon", "Tor", "Sre", "Čet", "Pet", "Sob"],
          longhand: [
            "Nedelja",
            "Ponedeljek",
            "Torek",
            "Sreda",
            "Četrtek",
            "Petek",
            "Sobota"
          ]
        },
        months: {
          shorthand: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "Maj",
            "Jun",
            "Jul",
            "Avg",
            "Sep",
            "Okt",
            "Nov",
            "Dec"
          ],
          longhand: [
            "Januar",
            "Februar",
            "Marec",
            "April",
            "Maj",
            "Junij",
            "Julij",
            "Avgust",
            "September",
            "Oktober",
            "November",
            "December"
          ]
        },
        firstDayOfWeek: 1,
        rangeSeparator: " do ",
        time_24hr: true,
        ordinal: function() {
          return ".";
        }
      };
      fp$O.l10ns.sl = Slovenian;
      fp$O.l10ns;
      var fp$P = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Albanian = {
        weekdays: {
          shorthand: ["Di", "Hë", "Ma", "Më", "En", "Pr", "Sh"],
          longhand: [
            "E Diel",
            "E Hënë",
            "E Martë",
            "E Mërkurë",
            "E Enjte",
            "E Premte",
            "E Shtunë"
          ]
        },
        months: {
          shorthand: [
            "Jan",
            "Shk",
            "Mar",
            "Pri",
            "Maj",
            "Qer",
            "Kor",
            "Gus",
            "Sht",
            "Tet",
            "Nën",
            "Dhj"
          ],
          longhand: [
            "Janar",
            "Shkurt",
            "Mars",
            "Prill",
            "Maj",
            "Qershor",
            "Korrik",
            "Gusht",
            "Shtator",
            "Tetor",
            "Nëntor",
            "Dhjetor"
          ]
        },
        firstDayOfWeek: 1,
        rangeSeparator: " deri ",
        weekAbbreviation: "Java",
        yearAriaLabel: "Viti",
        monthAriaLabel: "Muaji",
        hourAriaLabel: "Ora",
        minuteAriaLabel: "Minuta",
        time_24hr: true
      };
      fp$P.l10ns.sq = Albanian;
      fp$P.l10ns;
      var fp$Q = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Serbian = {
        weekdays: {
          shorthand: ["Ned", "Pon", "Uto", "Sre", "Čet", "Pet", "Sub"],
          longhand: [
            "Nedelja",
            "Ponedeljak",
            "Utorak",
            "Sreda",
            "Četvrtak",
            "Petak",
            "Subota"
          ]
        },
        months: {
          shorthand: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "Maj",
            "Jun",
            "Jul",
            "Avg",
            "Sep",
            "Okt",
            "Nov",
            "Dec"
          ],
          longhand: [
            "Januar",
            "Februar",
            "Mart",
            "April",
            "Maj",
            "Jun",
            "Jul",
            "Avgust",
            "Septembar",
            "Oktobar",
            "Novembar",
            "Decembar"
          ]
        },
        firstDayOfWeek: 1,
        weekAbbreviation: "Ned.",
        rangeSeparator: " do ",
        time_24hr: true
      };
      fp$Q.l10ns.sr = Serbian;
      fp$Q.l10ns;
      var fp$R = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Swedish = {
        firstDayOfWeek: 1,
        weekAbbreviation: "v",
        weekdays: {
          shorthand: ["sön", "mån", "tis", "ons", "tor", "fre", "lör"],
          longhand: [
            "söndag",
            "måndag",
            "tisdag",
            "onsdag",
            "torsdag",
            "fredag",
            "lördag"
          ]
        },
        months: {
          shorthand: [
            "jan",
            "feb",
            "mar",
            "apr",
            "maj",
            "jun",
            "jul",
            "aug",
            "sep",
            "okt",
            "nov",
            "dec"
          ],
          longhand: [
            "januari",
            "februari",
            "mars",
            "april",
            "maj",
            "juni",
            "juli",
            "augusti",
            "september",
            "oktober",
            "november",
            "december"
          ]
        },
        rangeSeparator: " till ",
        time_24hr: true,
        ordinal: function() {
          return ".";
        }
      };
      fp$R.l10ns.sv = Swedish;
      fp$R.l10ns;
      var fp$S = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Thai = {
        weekdays: {
          shorthand: ["อา", "จ", "อ", "พ", "พฤ", "ศ", "ส"],
          longhand: [
            "อาทิตย์",
            "จันทร์",
            "อังคาร",
            "พุธ",
            "พฤหัสบดี",
            "ศุกร์",
            "เสาร์"
          ]
        },
        months: {
          shorthand: [
            "ม.ค.",
            "ก.พ.",
            "มี.ค.",
            "เม.ย.",
            "พ.ค.",
            "มิ.ย.",
            "ก.ค.",
            "ส.ค.",
            "ก.ย.",
            "ต.ค.",
            "พ.ย.",
            "ธ.ค."
          ],
          longhand: [
            "มกราคม",
            "กุมภาพันธ์",
            "มีนาคม",
            "เมษายน",
            "พฤษภาคม",
            "มิถุนายน",
            "กรกฎาคม",
            "สิงหาคม",
            "กันยายน",
            "ตุลาคม",
            "พฤศจิกายน",
            "ธันวาคม"
          ]
        },
        firstDayOfWeek: 1,
        rangeSeparator: " ถึง ",
        scrollTitle: "เลื่อนเพื่อเพิ่มหรือลด",
        toggleTitle: "คลิกเพื่อเปลี่ยน",
        time_24hr: true,
        ordinal: function() {
          return "";
        }
      };
      fp$S.l10ns.th = Thai;
      fp$S.l10ns;
      var fp$T = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Turkish = {
        weekdays: {
          shorthand: ["Paz", "Pzt", "Sal", "Çar", "Per", "Cum", "Cmt"],
          longhand: [
            "Pazar",
            "Pazartesi",
            "Salı",
            "Çarşamba",
            "Perşembe",
            "Cuma",
            "Cumartesi"
          ]
        },
        months: {
          shorthand: [
            "Oca",
            "Şub",
            "Mar",
            "Nis",
            "May",
            "Haz",
            "Tem",
            "Ağu",
            "Eyl",
            "Eki",
            "Kas",
            "Ara"
          ],
          longhand: [
            "Ocak",
            "Şubat",
            "Mart",
            "Nisan",
            "Mayıs",
            "Haziran",
            "Temmuz",
            "Ağustos",
            "Eylül",
            "Ekim",
            "Kasım",
            "Aralık"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return ".";
        },
        rangeSeparator: " - ",
        weekAbbreviation: "Hf",
        scrollTitle: "Artırmak için kaydırın",
        toggleTitle: "Aç/Kapa",
        amPM: ["ÖÖ", "ÖS"],
        time_24hr: true
      };
      fp$T.l10ns.tr = Turkish;
      fp$T.l10ns;
      var fp$U = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Ukrainian = {
        firstDayOfWeek: 1,
        weekdays: {
          shorthand: ["Нд", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"],
          longhand: [
            "Неділя",
            "Понеділок",
            "Вівторок",
            "Середа",
            "Четвер",
            "П'ятниця",
            "Субота"
          ]
        },
        months: {
          shorthand: [
            "Січ",
            "Лют",
            "Бер",
            "Кві",
            "Тра",
            "Чер",
            "Лип",
            "Сер",
            "Вер",
            "Жов",
            "Лис",
            "Гру"
          ],
          longhand: [
            "Січень",
            "Лютий",
            "Березень",
            "Квітень",
            "Травень",
            "Червень",
            "Липень",
            "Серпень",
            "Вересень",
            "Жовтень",
            "Листопад",
            "Грудень"
          ]
        },
        time_24hr: true
      };
      fp$U.l10ns.uk = Ukrainian;
      fp$U.l10ns;
      var fp$V = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Uzbek = {
        weekdays: {
          shorthand: ["Якш", "Душ", "Сеш", "Чор", "Пай", "Жум", "Шан"],
          longhand: [
            "Якшанба",
            "Душанба",
            "Сешанба",
            "Чоршанба",
            "Пайшанба",
            "Жума",
            "Шанба"
          ]
        },
        months: {
          shorthand: [
            "Янв",
            "Фев",
            "Мар",
            "Апр",
            "Май",
            "Июн",
            "Июл",
            "Авг",
            "Сен",
            "Окт",
            "Ноя",
            "Дек"
          ],
          longhand: [
            "Январ",
            "Феврал",
            "Март",
            "Апрел",
            "Май",
            "Июн",
            "Июл",
            "Август",
            "Сентябр",
            "Октябр",
            "Ноябр",
            "Декабр"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "";
        },
        rangeSeparator: " — ",
        weekAbbreviation: "Ҳафта",
        scrollTitle: "Катталаштириш учун айлантиринг",
        toggleTitle: "Ўтиш учун босинг",
        amPM: ["AM", "PM"],
        yearAriaLabel: "Йил",
        time_24hr: true
      };
      fp$V.l10ns.uz = Uzbek;
      fp$V.l10ns;
      var fp$W = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var UzbekLatin = {
        weekdays: {
          shorthand: ["Ya", "Du", "Se", "Cho", "Pa", "Ju", "Sha"],
          longhand: [
            "Yakshanba",
            "Dushanba",
            "Seshanba",
            "Chorshanba",
            "Payshanba",
            "Juma",
            "Shanba"
          ]
        },
        months: {
          shorthand: [
            "Yan",
            "Fev",
            "Mar",
            "Apr",
            "May",
            "Iyun",
            "Iyul",
            "Avg",
            "Sen",
            "Okt",
            "Noy",
            "Dek"
          ],
          longhand: [
            "Yanvar",
            "Fevral",
            "Mart",
            "Aprel",
            "May",
            "Iyun",
            "Iyul",
            "Avgust",
            "Sentabr",
            "Oktabr",
            "Noyabr",
            "Dekabr"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "";
        },
        rangeSeparator: " — ",
        weekAbbreviation: "Hafta",
        scrollTitle: "Kattalashtirish uchun aylantiring",
        toggleTitle: "O‘tish uchun bosing",
        amPM: ["AM", "PM"],
        yearAriaLabel: "Yil",
        time_24hr: true
      };
      fp$W.l10ns["uz_latn"] = UzbekLatin;
      fp$W.l10ns;
      var fp$X = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Vietnamese = {
        weekdays: {
          shorthand: ["CN", "T2", "T3", "T4", "T5", "T6", "T7"],
          longhand: [
            "Chủ nhật",
            "Thứ hai",
            "Thứ ba",
            "Thứ tư",
            "Thứ năm",
            "Thứ sáu",
            "Thứ bảy"
          ]
        },
        months: {
          shorthand: [
            "Th1",
            "Th2",
            "Th3",
            "Th4",
            "Th5",
            "Th6",
            "Th7",
            "Th8",
            "Th9",
            "Th10",
            "Th11",
            "Th12"
          ],
          longhand: [
            "Tháng một",
            "Tháng hai",
            "Tháng ba",
            "Tháng tư",
            "Tháng năm",
            "Tháng sáu",
            "Tháng bảy",
            "Tháng tám",
            "Tháng chín",
            "Tháng mười",
            "Tháng mười một",
            "Tháng mười hai"
          ]
        },
        firstDayOfWeek: 1,
        rangeSeparator: " đến "
      };
      fp$X.l10ns.vn = Vietnamese;
      fp$X.l10ns;
      var fp$Y = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Mandarin = {
        weekdays: {
          shorthand: ["周日", "周一", "周二", "周三", "周四", "周五", "周六"],
          longhand: [
            "星期日",
            "星期一",
            "星期二",
            "星期三",
            "星期四",
            "星期五",
            "星期六"
          ]
        },
        months: {
          shorthand: [
            "一月",
            "二月",
            "三月",
            "四月",
            "五月",
            "六月",
            "七月",
            "八月",
            "九月",
            "十月",
            "十一月",
            "十二月"
          ],
          longhand: [
            "一月",
            "二月",
            "三月",
            "四月",
            "五月",
            "六月",
            "七月",
            "八月",
            "九月",
            "十月",
            "十一月",
            "十二月"
          ]
        },
        rangeSeparator: " 至 ",
        weekAbbreviation: "周",
        scrollTitle: "滚动切换",
        toggleTitle: "点击切换 12/24 小时时制"
      };
      fp$Y.l10ns.zh = Mandarin;
      fp$Y.l10ns;
      var fp$Z = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var MandarinTraditional = {
        weekdays: {
          shorthand: ["週日", "週一", "週二", "週三", "週四", "週五", "週六"],
          longhand: [
            "星期日",
            "星期一",
            "星期二",
            "星期三",
            "星期四",
            "星期五",
            "星期六"
          ]
        },
        months: {
          shorthand: [
            "一月",
            "二月",
            "三月",
            "四月",
            "五月",
            "六月",
            "七月",
            "八月",
            "九月",
            "十月",
            "十一月",
            "十二月"
          ],
          longhand: [
            "一月",
            "二月",
            "三月",
            "四月",
            "五月",
            "六月",
            "七月",
            "八月",
            "九月",
            "十月",
            "十一月",
            "十二月"
          ]
        },
        rangeSeparator: " 至 ",
        weekAbbreviation: "週",
        scrollTitle: "滾動切換",
        toggleTitle: "點擊切換 12/24 小時時制"
      };
      fp$Z.l10ns.zh_tw = MandarinTraditional;
      fp$Z.l10ns;
      var l10n2 = {
        ar: Arabic,
        at: Austria,
        az: Azerbaijan,
        be: Belarusian,
        bg: Bulgarian,
        bn: Bangla,
        bs: Bosnian,
        ca: Catalan,
        ckb: Kurdish,
        cat: Catalan,
        cs: Czech,
        cy: Welsh,
        da: Danish,
        de: German,
        default: __assign3({}, english2),
        en: english2,
        eo: Esperanto,
        es: Spanish,
        et: Estonian,
        fa: Persian,
        fi: Finnish,
        fo: Faroese,
        fr: French,
        gr: Greek,
        he: Hebrew,
        hi: Hindi,
        hr: Croatian,
        hu: Hungarian,
        hy: Armenian,
        id: Indonesian,
        is: Icelandic,
        it: Italian,
        ja: Japanese,
        ka: Georgian,
        ko: Korean,
        km: Khmer,
        kz: Kazakh,
        lt: Lithuanian,
        lv: Latvian,
        mk: Macedonian,
        mn: Mongolian,
        ms: Malaysian,
        my: Burmese,
        nl: Dutch,
        nn: NorwegianNynorsk,
        no: Norwegian,
        pa: Punjabi,
        pl: Polish,
        pt: Portuguese,
        ro: Romanian,
        ru: Russian,
        si: Sinhala,
        sk: Slovak,
        sl: Slovenian,
        sq: Albanian,
        sr: Serbian,
        sv: Swedish,
        th: Thai,
        tr: Turkish,
        uk: Ukrainian,
        vn: Vietnamese,
        zh: Mandarin,
        zh_tw: MandarinTraditional,
        uz: Uzbek,
        uz_latn: UzbekLatin
      };
      exports2.default = l10n2;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// ../node_modules/.pnpm/flatpickr@4.6.13/node_modules/flatpickr/dist/plugins/rangePlugin.js
var require_rangePlugin = __commonJS({
  "../node_modules/.pnpm/flatpickr@4.6.13/node_modules/flatpickr/dist/plugins/rangePlugin.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.rangePlugin = factory());
    })(exports, function() {
      "use strict";
      function __spreadArrays2() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r2 = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r2[k] = a[j];
        return r2;
      }
      function rangePlugin2(config) {
        if (config === void 0) {
          config = {};
        }
        return function(fp) {
          var dateFormat = "", secondInput, _secondInputFocused, _prevDates;
          var createSecondInput = function() {
            if (config.input) {
              secondInput = config.input instanceof Element ? config.input : window.document.querySelector(config.input);
              if (!secondInput) {
                fp.config.errorHandler(new Error("Invalid input element specified"));
                return;
              }
              if (fp.config.wrap) {
                secondInput = secondInput.querySelector("[data-input]");
              }
            } else {
              secondInput = fp._input.cloneNode();
              secondInput.removeAttribute("id");
              secondInput._flatpickr = void 0;
            }
            if (secondInput.value) {
              var parsedDate = fp.parseDate(secondInput.value);
              if (parsedDate)
                fp.selectedDates.push(parsedDate);
            }
            secondInput.setAttribute("data-fp-omit", "");
            if (fp.config.clickOpens) {
              fp._bind(secondInput, ["focus", "click"], function() {
                if (fp.selectedDates[1]) {
                  fp.latestSelectedDateObj = fp.selectedDates[1];
                  fp._setHoursFromDate(fp.selectedDates[1]);
                  fp.jumpToDate(fp.selectedDates[1]);
                }
                _secondInputFocused = true;
                fp.isOpen = false;
                fp.open(void 0, config.position === "left" ? fp._input : secondInput);
              });
              fp._bind(fp._input, ["focus", "click"], function(e2) {
                e2.preventDefault();
                fp.isOpen = false;
                fp.open();
              });
            }
            if (fp.config.allowInput)
              fp._bind(secondInput, "keydown", function(e2) {
                if (e2.key === "Enter") {
                  fp.setDate([fp.selectedDates[0], secondInput.value], true, dateFormat);
                  secondInput.click();
                }
              });
            if (!config.input)
              fp._input.parentNode && fp._input.parentNode.insertBefore(secondInput, fp._input.nextSibling);
          };
          var plugin = {
            onParseConfig: function() {
              fp.config.mode = "range";
              dateFormat = fp.config.altInput ? fp.config.altFormat : fp.config.dateFormat;
            },
            onReady: function() {
              createSecondInput();
              fp.config.ignoredFocusElements.push(secondInput);
              if (fp.config.allowInput) {
                fp._input.removeAttribute("readonly");
                secondInput.removeAttribute("readonly");
              } else {
                secondInput.setAttribute("readonly", "readonly");
              }
              fp._bind(fp._input, "focus", function() {
                fp.latestSelectedDateObj = fp.selectedDates[0];
                fp._setHoursFromDate(fp.selectedDates[0]);
                _secondInputFocused = false;
                fp.jumpToDate(fp.selectedDates[0]);
              });
              if (fp.config.allowInput)
                fp._bind(fp._input, "keydown", function(e2) {
                  if (e2.key === "Enter")
                    fp.setDate([fp._input.value, fp.selectedDates[1]], true, dateFormat);
                });
              fp.setDate(fp.selectedDates, false);
              plugin.onValueUpdate(fp.selectedDates);
              fp.loadedPlugins.push("range");
            },
            onPreCalendarPosition: function() {
              if (_secondInputFocused) {
                fp._positionElement = secondInput;
                setTimeout(function() {
                  fp._positionElement = fp._input;
                }, 0);
              }
            },
            onChange: function() {
              if (!fp.selectedDates.length) {
                setTimeout(function() {
                  if (fp.selectedDates.length)
                    return;
                  secondInput.value = "";
                  _prevDates = [];
                }, 10);
              }
              if (_secondInputFocused) {
                setTimeout(function() {
                  secondInput.focus();
                }, 0);
              }
            },
            onDestroy: function() {
              if (!config.input)
                secondInput.parentNode && secondInput.parentNode.removeChild(secondInput);
            },
            onValueUpdate: function(selDates) {
              var _a, _b, _c;
              if (!secondInput)
                return;
              _prevDates = !_prevDates || selDates.length >= _prevDates.length ? __spreadArrays2(selDates) : _prevDates;
              if (_prevDates.length > selDates.length) {
                var newSelectedDate = selDates[0];
                var newDates = _secondInputFocused ? [_prevDates[0], newSelectedDate] : [newSelectedDate, _prevDates[1]];
                if (newDates[0].getTime() > newDates[1].getTime()) {
                  if (_secondInputFocused) {
                    newDates[0] = newDates[1];
                  } else {
                    newDates[1] = newDates[0];
                  }
                }
                fp.setDate(newDates, false);
                _prevDates = __spreadArrays2(newDates);
              }
              _a = fp.selectedDates.map(function(d) {
                return fp.formatDate(d, dateFormat);
              }), _b = _a[0], fp._input.value = _b === void 0 ? "" : _b, _c = _a[1], secondInput.value = _c === void 0 ? "" : _c;
            }
          };
          return plugin;
        };
      }
      return rangePlugin2;
    });
  }
});

// ../node_modules/.pnpm/@carbon+feature-flags@0.24.0/node_modules/@carbon/feature-flags/es/index.js
var enabled$1 = {};
try {
  if (process.env.CARBON_ENABLE_CSS_CUSTOM_PROPERTIES) {
    if (process.env.CARBON_ENABLE_CSS_CUSTOM_PROPERTIES === "true") {
      enabled$1.enableCssCustomProperties = true;
    } else {
      enabled$1.enableCssCustomProperties = false;
    }
  } else {
    enabled$1.enableCssCustomProperties = false;
  }
  if (process.env.CARBON_ENABLE_CSS_GRID) {
    if (process.env.CARBON_ENABLE_CSS_GRID === "true") {
      enabled$1.enableCssGrid = true;
    } else {
      enabled$1.enableCssGrid = false;
    }
  } else {
    enabled$1.enableCssGrid = false;
  }
  if (process.env.CARBON_ENABLE_V11_RELEASE) {
    if (process.env.CARBON_ENABLE_V11_RELEASE === "true") {
      enabled$1.enableV11Release = true;
    } else {
      enabled$1.enableV11Release = false;
    }
  } else {
    enabled$1.enableV11Release = true;
  }
  if (process.env.CARBON_ENABLE_EXPERIMENTAL_TILE_CONTRAST) {
    if (process.env.CARBON_ENABLE_EXPERIMENTAL_TILE_CONTRAST === "true") {
      enabled$1.enableExperimentalTileContrast = true;
    } else {
      enabled$1.enableExperimentalTileContrast = false;
    }
  } else {
    enabled$1.enableExperimentalTileContrast = false;
  }
  if (process.env.CARBON_ENABLE_V12_TILE_DEFAULT_ICONS) {
    if (process.env.CARBON_ENABLE_V12_TILE_DEFAULT_ICONS === "true") {
      enabled$1.enableV12TileDefaultIcons = true;
    } else {
      enabled$1.enableV12TileDefaultIcons = false;
    }
  } else {
    enabled$1.enableV12TileDefaultIcons = false;
  }
  if (process.env.CARBON_ENABLE_V12_TILE_RADIO_ICONS) {
    if (process.env.CARBON_ENABLE_V12_TILE_RADIO_ICONS === "true") {
      enabled$1.enableV12TileRadioIcons = true;
    } else {
      enabled$1.enableV12TileRadioIcons = false;
    }
  } else {
    enabled$1.enableV12TileRadioIcons = false;
  }
  if (process.env.CARBON_ENABLE_V12_OVERFLOWMENU) {
    if (process.env.CARBON_ENABLE_V12_OVERFLOWMENU === "true") {
      enabled$1.enableV12Overflowmenu = true;
    } else {
      enabled$1.enableV12Overflowmenu = false;
    }
  } else {
    enabled$1.enableV12Overflowmenu = false;
  }
  if (process.env.CARBON_ENABLE_TREEVIEW_CONTROLLABLE) {
    if (process.env.CARBON_ENABLE_TREEVIEW_CONTROLLABLE === "true") {
      enabled$1.enableTreeviewControllable = true;
    } else {
      enabled$1.enableTreeviewControllable = false;
    }
  } else {
    enabled$1.enableTreeviewControllable = false;
  }
  if (process.env.CARBON_ENABLE_V12_STRUCTURED_LIST_VISIBLE_ICONS) {
    if (process.env.CARBON_ENABLE_V12_STRUCTURED_LIST_VISIBLE_ICONS === "true") {
      enabled$1.enableV12StructuredListVisibleIcons = true;
    } else {
      enabled$1.enableV12StructuredListVisibleIcons = false;
    }
  } else {
    enabled$1.enableV12StructuredListVisibleIcons = false;
  }
  if (process.env.CARBON_ENABLE_EXPERIMENTAL_FOCUS_WRAP_WITHOUT_SENTINELS) {
    if (process.env.CARBON_ENABLE_EXPERIMENTAL_FOCUS_WRAP_WITHOUT_SENTINELS === "true") {
      enabled$1.enableExperimentalFocusWrapWithoutSentinels = true;
    } else {
      enabled$1.enableExperimentalFocusWrapWithoutSentinels = false;
    }
  } else {
    enabled$1.enableExperimentalFocusWrapWithoutSentinels = false;
  }
  if (process.env.CARBON_ENABLE_V12_DYNAMIC_FLOATING_STYLES) {
    if (process.env.CARBON_ENABLE_V12_DYNAMIC_FLOATING_STYLES === "true") {
      enabled$1.enableV12DynamicFloatingStyles = true;
    } else {
      enabled$1.enableV12DynamicFloatingStyles = false;
    }
  } else {
    enabled$1.enableV12DynamicFloatingStyles = false;
  }
} catch (error2) {
  enabled$1.enableCssCustomProperties = false;
  enabled$1.enableCssGrid = false;
  enabled$1.enableV11Release = true;
  enabled$1.enableExperimentalTileContrast = false;
  enabled$1.enableV12TileDefaultIcons = false;
  enabled$1.enableV12TileRadioIcons = false;
  enabled$1.enableV12Overflowmenu = false;
  enabled$1.enableTreeviewControllable = false;
  enabled$1.enableV12StructuredListVisibleIcons = false;
  enabled$1.enableExperimentalFocusWrapWithoutSentinels = false;
  enabled$1.enableV12DynamicFloatingStyles = false;
}
var featureFlagInfo = [{
  name: "enable-css-custom-properties",
  description: "Describe what the flag does",
  enabled: enabled$1.enableCssCustomProperties
}, {
  name: "enable-css-grid",
  description: "Enable CSS Grid Layout in the Grid and Column React components\n",
  enabled: enabled$1.enableCssGrid
}, {
  name: "enable-v11-release",
  description: "Enable the features and functionality for the v11 Release\n",
  enabled: enabled$1.enableV11Release
}, {
  name: "enable-experimental-tile-contrast",
  description: "Enable the experimental tile improved contrast styles\n",
  enabled: enabled$1.enableExperimentalTileContrast
}, {
  name: "enable-v12-tile-default-icons",
  description: "Enable rendering of default icons in the tile components\n",
  enabled: enabled$1.enableV12TileDefaultIcons
}, {
  name: "enable-v12-tile-radio-icons",
  description: "Enable rendering of radio icons in the RadioTile component\n",
  enabled: enabled$1.enableV12TileRadioIcons
}, {
  name: "enable-v12-overflowmenu",
  description: "Enable the use of the v12 OverflowMenu leveraging the Menu subcomponents\n",
  enabled: enabled$1.enableV12Overflowmenu
}, {
  name: "enable-treeview-controllable",
  description: "Enable the new TreeView controllable API\n",
  enabled: enabled$1.enableTreeviewControllable
}, {
  name: "enable-v12-structured-list-visible-icons",
  description: "Enable rendering of radio icons in the StructuredList component\n",
  enabled: enabled$1.enableV12StructuredListVisibleIcons
}, {
  name: "enable-experimental-focus-wrap-without-sentinels",
  description: "Enable the new focus wrap behavior that doesn't use sentinel nodes\n",
  enabled: enabled$1.enableExperimentalFocusWrapWithoutSentinels
}, {
  name: "enable-v12-dynamic-floating-styles",
  description: "Enable dynamic setting of floating styles for components like Popover, Tooltip, etc.\n",
  enabled: enabled$1.enableV12DynamicFloatingStyles
}];
function _arrayLikeToArray(r2, a) {
  (null == a || a > r2.length) && (a = r2.length);
  for (var e2 = 0, n2 = Array(a); e2 < a; e2++) n2[e2] = r2[e2];
  return n2;
}
function _arrayWithHoles(r2) {
  if (Array.isArray(r2)) return r2;
}
function _classCallCheck(a, n2) {
  if (!(a instanceof n2)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e2, r2) {
  for (var t2 = 0; t2 < r2.length; t2++) {
    var o2 = r2[t2];
    o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, _toPropertyKey(o2.key), o2);
  }
}
function _createClass(e2, r2, t2) {
  return r2 && _defineProperties(e2.prototype, r2), t2 && _defineProperties(e2, t2), Object.defineProperty(e2, "prototype", {
    writable: false
  }), e2;
}
function _createForOfIteratorHelper(r2, e2) {
  var t2 = "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (!t2) {
    if (Array.isArray(r2) || (t2 = _unsupportedIterableToArray(r2)) || e2 && r2 && "number" == typeof r2.length) {
      t2 && (r2 = t2);
      var n2 = 0, F = function() {
      };
      return {
        s: F,
        n: function() {
          return n2 >= r2.length ? {
            done: true
          } : {
            done: false,
            value: r2[n2++]
          };
        },
        e: function(r3) {
          throw r3;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o2, a = true, u = false;
  return {
    s: function() {
      t2 = t2.call(r2);
    },
    n: function() {
      var r3 = t2.next();
      return a = r3.done, r3;
    },
    e: function(r3) {
      u = true, o2 = r3;
    },
    f: function() {
      try {
        a || null == t2.return || t2.return();
      } finally {
        if (u) throw o2;
      }
    }
  };
}
function _iterableToArrayLimit(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e2, n2, i, u, a = [], f = true, o2 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f = false;
      } else for (; !(f = (e2 = i.call(t2)).done) && (a.push(e2.value), a.length !== l2); f = true) ;
    } catch (r3) {
      o2 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u)) return;
      } finally {
        if (o2) throw n2;
      }
    }
    return a;
  }
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray(r2, e2) {
  return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray(r2, e2) || _nonIterableRest();
}
function _toPrimitive(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2 || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _toPropertyKey(t2) {
  var i = _toPrimitive(t2, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _unsupportedIterableToArray(r2, a) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray(r2, a);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r2, a) : void 0;
  }
}
var FeatureFlagScope = function() {
  function FeatureFlagScope2(flags) {
    var _this = this;
    _classCallCheck(this, FeatureFlagScope2);
    this.flags = /* @__PURE__ */ new Map();
    if (flags) {
      Object.keys(flags).forEach(function(key) {
        _this.flags.set(key, flags[key]);
      });
    }
  }
  return _createClass(FeatureFlagScope2, [{
    key: "checkForFlag",
    value: function checkForFlag(name) {
      if (!this.flags.has(name)) {
        throw new Error("Unable to find a feature flag with the name: `".concat(name, "`"));
      }
    }
    /**
     * Add a feature flag
     * @param {string} name
     * @param {boolean} enabled
     */
  }, {
    key: "add",
    value: function add2(name, enabled2) {
      if (this.flags.has(name)) {
        throw new Error("The feature flag: ".concat(name, " already exists"));
      }
      this.flags.set(name, enabled2);
    }
    /**
     * Enable a feature flag
     * @param {string} name
     */
  }, {
    key: "enable",
    value: function enable(name) {
      this.checkForFlag(name);
      this.flags.set(name, true);
    }
    /**
     * Disable a feature flag
     * @param {string} name
     */
  }, {
    key: "disable",
    value: function disable(name) {
      this.checkForFlag(name);
      this.flags.set(name, false);
    }
    /**
     * Merge the given feature flags with the current set of feature flags.
     * Duplicate keys will be set to the value in the given feature flags.
     * @param {object} flags
     */
  }, {
    key: "merge",
    value: function merge4(flags) {
      var _this2 = this;
      Object.keys(flags).forEach(function(key) {
        _this2.flags.set(key, flags[key]);
      });
    }
    /**
     * @param {FeatureFlagScope} scope
     */
  }, {
    key: "mergeWithScope",
    value: function mergeWithScope(scope) {
      var _iterator = _createForOfIteratorHelper(scope.flags), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var _step$value = _slicedToArray(_step.value, 2), key = _step$value[0], value = _step$value[1];
          if (this.flags.has(key)) {
            continue;
          }
          this.flags.set(key, value);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * Check if a feature flag is enabled
     * @param {string} name
     * @returns {boolean}
     */
  }, {
    key: "enabled",
    value: function enabled2(name) {
      this.checkForFlag(name);
      return this.flags.get(name);
    }
  }]);
}();
var FeatureFlags = createScope();
for (i = 0; i < featureFlagInfo.length; i++) {
  featureFlag = featureFlagInfo[i];
  FeatureFlags.add(featureFlag.name, featureFlag.enabled);
}
var featureFlag;
var i;
function createScope(flags) {
  return new FeatureFlagScope(flags);
}
function enabled() {
  return FeatureFlags.enabled.apply(FeatureFlags, arguments);
}
function merge() {
  return FeatureFlags.merge.apply(FeatureFlags, arguments);
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/feature-flags.js
merge({
  "enable-css-custom-properties": true,
  "enable-css-grid": true,
  "enable-v11-release": true,
  "enable-experimental-tile-contrast": false,
  "enable-v12-tile-radio-icons": false,
  "enable-v12-structured-list-visible-icons": false,
  "enable-v12-dynamic-floating-styles": false
});

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/_virtual/_rollupPluginBabelHelpers.js
function _defineProperty(e2, r2, t2) {
  return (r2 = _toPropertyKey2(r2)) in e2 ? Object.defineProperty(e2, r2, {
    value: t2,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e2[r2] = t2, e2;
}
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends.apply(null, arguments);
}
function _toPrimitive2(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2 || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _toPropertyKey2(t2) {
  var i = _toPrimitive2(t2, "string");
  return "symbol" == typeof i ? i : i + "";
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Accordion/Accordion.js
var import_classnames = __toESM(require_classnames());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/internal/usePrefix.js
var import_react = __toESM(require_react());
var PrefixContext = import_react.default.createContext("cds");
function usePrefix() {
  return import_react.default.useContext(PrefixContext);
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Accordion/Accordion.js
var import_prop_types = __toESM(require_prop_types());
var import_react3 = __toESM(require_react());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Accordion/AccordionProvider.js
var import_react2 = __toESM(require_react());
var AccordionContext = (0, import_react2.createContext)({
  disabled: false
});
var AccordionProvider = (_ref) => {
  let {
    disabled,
    children
  } = _ref;
  return import_react2.default.createElement(AccordionContext.Provider, {
    value: {
      disabled
    }
  }, children);
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Accordion/Accordion.js
function Accordion(_ref) {
  let {
    align = "end",
    children,
    className: customClassName,
    disabled = false,
    isFlush = false,
    ordered = false,
    size: size6,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const className = (0, import_classnames.default)(`${prefix}--accordion`, customClassName, {
    [`${prefix}--accordion--${align}`]: align,
    [`${prefix}--accordion--${size6}`]: size6,
    // TODO: V12 - Remove this class
    [`${prefix}--layout--size-${size6}`]: size6,
    [`${prefix}--accordion--flush`]: isFlush && align !== "start"
  });
  const ListTag = ordered ? "ol" : "ul";
  return import_react3.default.createElement(AccordionProvider, {
    disabled
  }, import_react3.default.createElement(ListTag, _extends({
    className
  }, rest3), children));
}
Accordion.propTypes = {
  /**
   * Specify the alignment of the accordion heading title and chevron.
   */
  align: import_prop_types.default.oneOf(["start", "end"]),
  /**
   * Pass in the children that will be rendered within the Accordion
   */
  children: import_prop_types.default.node,
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types.default.string,
  /**
   * Specify whether an individual AccordionItem should be disabled
   */
  disabled: import_prop_types.default.bool,
  /**
   * Specify whether Accordion text should be flush, default is false, does not work with align="start"
   */
  isFlush: import_prop_types.default.bool,
  /**
   * Specify if the Accordion should be an ordered list,
   * default is `false`
   */
  ordered: import_prop_types.default.bool,
  /**
   * Specify the size of the Accordion. Currently supports the following:
   */
  size: import_prop_types.default.oneOf(["sm", "md", "lg"])
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Accordion/AccordionItem.js
var import_classnames2 = __toESM(require_classnames());
var import_prop_types4 = __toESM(require_prop_types());
var import_react10 = __toESM(require_react());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Text/TextDirection.js
var import_prop_types2 = __toESM(require_prop_types());
var import_react5 = __toESM(require_react());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Text/TextDirectionContext.js
var import_react4 = __toESM(require_react());
var TextDirectionContext = (0, import_react4.createContext)(null);

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Text/TextDirection.js
function TextDirection(_ref) {
  let {
    children,
    dir = "auto",
    getTextDirection
  } = _ref;
  const savedCallback = (0, import_react5.useRef)(getTextDirection);
  const value = (0, import_react5.useMemo)(() => {
    return {
      direction: dir,
      getTextDirection: savedCallback
    };
  }, [dir]);
  (0, import_react5.useEffect)(() => {
    savedCallback.current = getTextDirection;
  });
  return import_react5.default.createElement(TextDirectionContext.Provider, {
    value
  }, children);
}
TextDirection.propTypes = {
  /**
   * Provide children to be rendered inside of this component
   */
  children: import_prop_types2.default.node,
  /**
   * Specify the text direction for rendered children
   */
  dir: import_prop_types2.default.oneOf(["ltr", "rtl", "auto"]),
  /**
   * Optionally provide a custom function to get the text direction for a piece
   * of text. Whatever is returned will become the value of the `dir` attribute
   * on a node of text. Should return one of: 'ltr', 'rtl', or 'auto'
   */
  getTextDirection: import_prop_types2.default.func
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Text/Text.js
var import_prop_types3 = __toESM(require_prop_types());
var import_react6 = __toESM(require_react());
var Text = import_react6.default.forwardRef((_ref, ref) => {
  let {
    as,
    children,
    dir = "auto",
    ...rest3
  } = _ref;
  const context = (0, import_react6.useContext)(TextDirectionContext);
  const textProps = {};
  const BaseComponent = as ?? "span";
  const value = {
    ...context
  };
  if (!context) {
    textProps.dir = dir;
    value.direction = dir;
  } else {
    const {
      direction: parentDirection,
      getTextDirection
    } = context;
    if (getTextDirection && getTextDirection.current) {
      const text = getTextFromChildren(children);
      const override = getTextDirection.current(text);
      if (parentDirection !== override) {
        textProps.dir = override;
        value.direction = override;
      } else if (parentDirection === "auto") {
        textProps.dir = override;
      }
    } else if (parentDirection !== dir) {
      textProps.dir = dir;
      value.direction = dir;
    } else if (parentDirection === "auto") {
      textProps.dir = dir;
    }
  }
  return import_react6.default.createElement(TextDirectionContext.Provider, {
    value
  }, import_react6.default.createElement(BaseComponent, _extends({
    ref
  }, rest3, textProps), children));
});
Text.propTypes = {
  /**
   * Provide a custom element type used to render the outermost node
   */
  as: import_prop_types3.default.oneOfType([import_prop_types3.default.func, import_prop_types3.default.string, import_prop_types3.default.elementType]),
  /**
   * Provide child elements or text to be rendered inside of this component
   */
  children: import_prop_types3.default.node.isRequired,
  /**
   * Specify the text direction to be used for this component and any of its
   * children
   */
  dir: import_prop_types3.default.oneOf(["ltr", "rtl", "auto"])
};
function getTextFromChildren(children) {
  var _a;
  if (typeof children === "string") {
    return children;
  }
  const text = (_a = import_react6.default.Children.map(children, (child) => {
    if (typeof child === "string") {
      return child;
    }
    return null;
  })) == null ? void 0 : _a.filter((text2) => {
    return text2 !== null;
  });
  if ((text == null ? void 0 : text.length) === 1) {
    return text[0];
  }
  return text;
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Text/createTextComponent.js
var import_react7 = __toESM(require_react());
function createTextComponent(element, displayName) {
  function TextWrapper(props) {
    return import_react7.default.createElement(Text, _extends({
      as: element
    }, props));
  }
  if (true) {
    TextWrapper.displayName = displayName;
  }
  return TextWrapper;
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Text/index.js
createTextComponent("label", "Label");
var Legend = createTextComponent("legend", "Legend");

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/internal/useId.js
var import_react9 = __toESM(require_react());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/tools/setupGetInstanceId.js
function setupGetInstanceId() {
  let instanceId2 = 0;
  return function getInstanceId3() {
    return ++instanceId2;
  };
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/internal/environment.js
var canUseDOM = !!(typeof window !== "undefined" && // eslint-disable-next-line ssr-friendly/no-dom-globals-in-module-scope
window.document && // eslint-disable-next-line ssr-friendly/no-dom-globals-in-module-scope
window.document.createElement);

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/internal/useIdPrefix.js
var import_react8 = __toESM(require_react());
var IdPrefixContext = import_react8.default.createContext(null);
function useIdPrefix() {
  return import_react8.default.useContext(IdPrefixContext);
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/internal/useId.js
var _React = {
  ...import_react9.default
};
var instanceId = setupGetInstanceId();
var useIsomorphicLayoutEffect = canUseDOM ? import_react9.useLayoutEffect : import_react9.useEffect;
var serverHandoffCompleted = false;
var defaultId = "id";
function useCompatibleId() {
  let prefix = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultId;
  const contextPrefix = useIdPrefix();
  const [id, setId] = (0, import_react9.useState)(() => {
    if (serverHandoffCompleted) {
      return `${contextPrefix ? `${contextPrefix}-` : ``}${prefix}-${instanceId()}`;
    }
    return null;
  });
  useIsomorphicLayoutEffect(() => {
    if (id === null) {
      setId(`${contextPrefix ? `${contextPrefix}-` : ``}${prefix}-${instanceId()}`);
    }
  }, [instanceId]);
  (0, import_react9.useEffect)(() => {
    if (serverHandoffCompleted === false) {
      serverHandoffCompleted = true;
    }
  }, []);
  return id;
}
function useReactId() {
  let prefix = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultId;
  const contextPrefix = useIdPrefix();
  return `${contextPrefix ? `${contextPrefix}-` : ``}${prefix}-${_React.useId()}`;
}
var useId = _React.useId ? useReactId : useCompatibleId;
function useFallbackId(id) {
  const fallback = useId();
  return id ?? fallback;
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/internal/warning.js
var warning = true ? function warning2(condition, format) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  if (format === void 0) {
    throw new Error("`warning(condition, format, ...args)` requires a warning format argument");
  }
  if (!condition) {
    let index4 = 0;
    const message = format.replace(/%s/g, () => {
      return args[index4++];
    });
    console.warn("Warning: " + message);
  }
} : emptyFunction;

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/prop-types/deprecate.js
var didWarnAboutDeprecation = {};
function deprecate(propType, message) {
  function checker(props, propName, componentName) {
    if (props[propName] === void 0) {
      return;
    }
    if (!didWarnAboutDeprecation[componentName] || !didWarnAboutDeprecation[componentName][propName]) {
      didWarnAboutDeprecation[componentName] = {
        ...didWarnAboutDeprecation[componentName],
        [propName]: true
      };
      true ? warning(false, message || `The prop \`${propName}\` has been deprecated for the ${componentName} component. It will be removed in the next major release`) : void 0;
    }
    for (var _len = arguments.length, rest3 = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      rest3[_key - 3] = arguments[_key];
    }
    return propType(props, propName, componentName, ...rest3);
  }
  return checker;
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/internal/keyboard/match.js
function matches(event, keysToMatch) {
  for (let i = 0; i < keysToMatch.length; i++) {
    if (match(event, keysToMatch[i])) {
      return true;
    }
  }
  return false;
}
function match(eventOrCode) {
  let {
    key,
    which,
    keyCode,
    code
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (typeof eventOrCode === "string") {
    return eventOrCode === key;
  }
  if (typeof eventOrCode === "number") {
    return eventOrCode === which || eventOrCode === keyCode;
  }
  if (eventOrCode.key && Array.isArray(key)) {
    return key.indexOf(eventOrCode.key) !== -1;
  }
  return eventOrCode.key === key || eventOrCode.which === which || eventOrCode.keyCode === keyCode || eventOrCode.code === code;
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/internal/keyboard/keys.js
var Tab = {
  key: "Tab",
  which: 9,
  keyCode: 9,
  code: "Tab"
};
var Enter = {
  key: "Enter",
  which: 13,
  keyCode: 13,
  code: "Enter"
};
var Escape = {
  key: [
    "Escape",
    // IE11 Escape
    "Esc"
  ],
  which: 27,
  keyCode: 27,
  code: "Esc"
};
var Space = {
  key: " ",
  which: 32,
  keyCode: 32,
  code: "Space"
};
var End = {
  key: "End",
  which: 35,
  keyCode: 35,
  code: "Numpad1"
};
var Home = {
  key: "Home",
  which: 36,
  keyCode: 36,
  code: "Numpad7"
};
var ArrowLeft = {
  key: "ArrowLeft",
  which: 37,
  keyCode: 37,
  code: "ArrowLeft"
};
var ArrowUp2 = {
  key: "ArrowUp",
  which: 38,
  keyCode: 38,
  code: "ArrowUp"
};
var ArrowRight2 = {
  key: "ArrowRight",
  which: 39,
  keyCode: 39,
  code: "ArrowRight"
};
var ArrowDown = {
  key: "ArrowDown",
  which: 40,
  keyCode: 40,
  code: "ArrowDown"
};
var Delete = {
  key: "Delete",
  which: 8,
  keyCode: 8,
  code: "ArrowDecimal"
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Accordion/AccordionItem.js
var defaultRenderToggle = (props) => import_react10.default.createElement("button", _extends({
  type: "button"
}, props));
function AccordionItem(_ref) {
  let {
    children,
    className: customClassName = "",
    open = false,
    onHeadingClick,
    renderExpando = defaultRenderToggle,
    // remove renderExpando in next major release
    renderToggle,
    title = "title",
    disabled: controlledDisabled,
    handleAnimationEnd,
    ...rest3
  } = _ref;
  const [isOpen, setIsOpen] = (0, import_react10.useState)(open);
  const [prevIsOpen, setPrevIsOpen] = (0, import_react10.useState)(open);
  const accordionState = (0, import_react10.useContext)(AccordionContext);
  const disabledIsControlled = typeof controlledDisabled === "boolean";
  const disabled = disabledIsControlled ? controlledDisabled : accordionState.disabled;
  const id = useId("accordion-item");
  const prefix = usePrefix();
  const className = (0, import_classnames2.default)({
    [`${prefix}--accordion__item`]: true,
    [`${prefix}--accordion__item--active`]: isOpen && !disabled,
    [`${prefix}--accordion__item--disabled`]: disabled,
    [customClassName]: !!customClassName
  });
  const Toggle2 = renderToggle || renderExpando;
  const content = import_react10.default.useCallback((node) => {
    if (!node) {
      return;
    }
    if (isOpen) {
      node.style.maxBlockSize = "";
    }
  }, [isOpen]);
  if (open !== prevIsOpen) {
    setIsOpen(open);
    setPrevIsOpen(open);
  }
  function onClick(event) {
    const nextValue = !isOpen;
    setIsOpen(nextValue);
    if (onHeadingClick) {
      onHeadingClick({
        isOpen: nextValue,
        event
      });
    }
  }
  function onKeyDown(event) {
    if (isOpen && match(event, Escape)) {
      setIsOpen(false);
    }
  }
  function onAnimationEnd(event) {
    if (handleAnimationEnd) {
      handleAnimationEnd(event);
    }
  }
  return import_react10.default.createElement("li", _extends({
    className
  }, rest3), import_react10.default.createElement(Toggle2, {
    disabled,
    "aria-controls": id,
    "aria-expanded": isOpen,
    className: `${prefix}--accordion__heading`,
    onClick,
    onKeyDown,
    type: "button"
  }, import_react10.default.createElement(ChevronRight, {
    className: `${prefix}--accordion__arrow`
  }), import_react10.default.createElement(Text, {
    as: "div",
    className: `${prefix}--accordion__title`
  }, title)), import_react10.default.createElement("div", {
    ref: content,
    className: `${prefix}--accordion__wrapper`,
    onTransitionEnd: onAnimationEnd
  }, import_react10.default.createElement("div", {
    id,
    className: `${prefix}--accordion__content`
  }, children)));
}
AccordionItem.propTypes = {
  /**
   * Provide the contents of your AccordionItem
   */
  children: import_prop_types4.default.node,
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types4.default.string,
  /**
   * Specify whether an individual AccordionItem should be disabled
   */
  disabled: import_prop_types4.default.bool,
  /**
   * The handler of the massaged `click` event.
   */
  onClick: import_prop_types4.default.func,
  /**
   * The handler of the massaged `click` event on the heading.
   */
  onHeadingClick: import_prop_types4.default.func,
  /**
   * `true` to open the expand.
   */
  open: import_prop_types4.default.bool,
  /**
   * The callback function to render the expand button.
   * Can be a React component class.
   */
  renderExpando: deprecate(import_prop_types4.default.func, "The `renderExpando` prop has been deprecated and will be removed in the next major release of Carbon. Use the `renderToggle` prop instead."),
  /**
   * The callback function to render the expand button.
   * Can be a React component class.
   */
  renderToggle: import_prop_types4.default.func,
  /**
   * The accordion title.
   */
  title: import_prop_types4.default.node
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Accordion/Accordion.Skeleton.js
var import_prop_types6 = __toESM(require_prop_types());
var import_react13 = __toESM(require_react());
var import_classnames4 = __toESM(require_classnames());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/SkeletonText/SkeletonText.js
var import_prop_types5 = __toESM(require_prop_types());
var import_react12 = __toESM(require_react());
var import_classnames3 = __toESM(require_classnames());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/internal/useIsomorphicEffect.js
var import_react11 = __toESM(require_react());
var useIsomorphicEffect = typeof window !== "undefined" ? import_react11.useLayoutEffect : import_react11.useEffect;
var useIsomorphicEffect$1 = useIsomorphicEffect;

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/SkeletonText/SkeletonText.js
var randoms = [0.973051493507435, 0.15334737213558558, 0.5671034553053769];
function getRandomInt(min4, max4, n2) {
  return Math.floor(randoms[n2 % 3] * (max4 - min4 + 1)) + min4;
}
var SkeletonText = (_ref) => {
  let {
    paragraph = false,
    lineCount = 3,
    width = "100%",
    heading = false,
    className = "",
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const skeletonTextClasses = (0, import_classnames3.default)({
    [`${prefix}--skeleton__text`]: true,
    [`${prefix}--skeleton__heading`]: heading,
    [className]: className
  });
  const widthNum = parseInt(width, 10);
  const widthPx = width.includes("px");
  const widthPercent = width.includes("%");
  let lineCountNumber = 1;
  if (paragraph) {
    lineCountNumber = lineCount;
  }
  const refs = (0, import_react12.useRef)([]);
  useIsomorphicEffect$1(() => {
    refs.current.map((item, j) => {
      const randomPercentWidth = getRandomInt(0, 75, j) + "px";
      const randomPxWidth = getRandomInt(Math.max(widthNum - 75, 0), widthNum, j) + "px";
      if (item) {
        if (widthPercent && paragraph) {
          item.style.width = `calc(${width} - ${randomPercentWidth})`;
        } else if (widthPx && paragraph) {
          item.style.width = randomPxWidth;
        } else {
          item.style.width = width;
        }
      }
    });
  }, [lineCountNumber, paragraph, refs, width, widthNum, widthPercent, widthPx]);
  const lines = [];
  for (let i = 0; i < lineCountNumber; i++) {
    lines.push(import_react12.default.createElement("p", _extends({
      className: skeletonTextClasses,
      key: i,
      ref: (el) => refs.current = [...refs.current, el]
    }, rest3)));
  }
  if (lineCountNumber !== 1) {
    return import_react12.default.createElement("div", null, lines);
  }
  return import_react12.default.createElement(import_react12.default.Fragment, null, lines);
};
SkeletonText.propTypes = {
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types5.default.string,
  /**
   * generates skeleton text at a larger size
   */
  heading: import_prop_types5.default.bool,
  /**
   * the number of lines shown if paragraph is true
   */
  lineCount: import_prop_types5.default.number,
  /**
   * will generate multiple lines of text
   */
  paragraph: import_prop_types5.default.bool,
  /**
   * width (in px or %) of single line of text or max-width of paragraph lines
   */
  width: import_prop_types5.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Accordion/Accordion.Skeleton.js
var _SkeletonText;
var _SkeletonText2;
var _SkeletonText3;
function AccordionSkeleton(_ref) {
  let {
    align = "end",
    className,
    count: count2 = 4,
    isFlush,
    open = true,
    ordered = false,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const classes = (0, import_classnames4.default)(`${prefix}--accordion`, `${prefix}--skeleton`, className, {
    [`${prefix}--accordion--${align}`]: align,
    [`${prefix}--accordion--flush`]: isFlush && align !== "start"
  });
  const numSkeletonItems = open ? count2 - 1 : count2;
  const ListTag = ordered ? "ol" : "ul";
  return import_react13.default.createElement(ListTag, _extends({
    className: classes
  }, rest3), open && import_react13.default.createElement("li", {
    className: `${prefix}--accordion__item ${prefix}--accordion__item--active`
  }, import_react13.default.createElement("span", {
    className: `${prefix}--accordion__heading`
  }, import_react13.default.createElement(ChevronRight, {
    className: `${prefix}--accordion__arrow`
  }), import_react13.default.createElement(SkeletonText, {
    className: `${prefix}--accordion__title`
  })), import_react13.default.createElement("div", {
    className: `${prefix}--accordion__content`
  }, _SkeletonText || (_SkeletonText = import_react13.default.createElement(SkeletonText, {
    width: "90%"
  })), _SkeletonText2 || (_SkeletonText2 = import_react13.default.createElement(SkeletonText, {
    width: "80%"
  })), _SkeletonText3 || (_SkeletonText3 = import_react13.default.createElement(SkeletonText, {
    width: "95%"
  })))), Array.from({
    length: numSkeletonItems
  }).map((_, i) => import_react13.default.createElement(AccordionSkeletonItem, {
    key: i
  })));
}
AccordionSkeleton.propTypes = {
  /**
   * Specify the alignment of the accordion heading title and chevron.
   */
  align: import_prop_types6.default.oneOf(["start", "end"]),
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types6.default.string,
  /**
   * Set number of items to render
   */
  count: import_prop_types6.default.number,
  /**
   * Specify whether an individual AccordionItem should be flush, default is false
   */
  isFlush: import_prop_types6.default.bool,
  /**
   * `false` to not display the first item opened
   */
  open: import_prop_types6.default.bool
};
function AccordionSkeletonItem() {
  const prefix = usePrefix();
  return import_react13.default.createElement("li", {
    className: `${prefix}--accordion__item`
  }, import_react13.default.createElement("span", {
    className: `${prefix}--accordion__heading`
  }, import_react13.default.createElement(ChevronRight, {
    className: `${prefix}--accordion__arrow`
  }), import_react13.default.createElement(SkeletonText, {
    className: `${prefix}--accordion__title`
  })));
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/AspectRatio/AspectRatio.js
var import_classnames5 = __toESM(require_classnames());
var import_prop_types7 = __toESM(require_prop_types());
var import_react14 = __toESM(require_react());
var AspectRatio = (_ref) => {
  let {
    as: BaseComponent = "div",
    className: containerClassName,
    children,
    ratio = "1x1",
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const className = (0, import_classnames5.default)(containerClassName, `${prefix}--aspect-ratio`, `${prefix}--aspect-ratio--${ratio}`);
  return import_react14.default.createElement(BaseComponent, _extends({
    className
  }, rest3), children);
};
AspectRatio.propTypes = {
  /**
   * Provide a custom component or string to be rendered as the outermost node
   * of the component. This is useful if you want to deviate from the default
   * `div` tag, where you could specify `section` or `article` instead.
   *
   * ```jsx
   * <AspectRatio as="article">My content</AspectRatio>
   * ```
   */
  as: import_prop_types7.default.elementType,
  /**
   * Specify the content that will be placed in the aspect ratio
   */
  children: import_prop_types7.default.node,
  /**
   * Specify a class name for the outermost node of the component
   */
  className: import_prop_types7.default.string,
  /**
   * Specify the ratio to be used by the aspect ratio container. This will
   * determine what aspect ratio your content will be displayed in.
   */
  ratio: import_prop_types7.default.oneOf(["16x9", "9x16", "2x1", "1x2", "4x3", "3x4", "3x2", "2x3", "1x1"])
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Breadcrumb/Breadcrumb.js
var import_prop_types8 = __toESM(require_prop_types());
var import_react15 = __toESM(require_react());
var import_classnames6 = __toESM(require_classnames());
var Breadcrumb = import_react15.default.forwardRef(function Breadcrumb2(_ref, ref) {
  let {
    "aria-label": ariaLabel,
    children,
    className: customClassNameNav,
    noTrailingSlash,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const className = (0, import_classnames6.default)({
    [`${prefix}--breadcrumb`]: true,
    [`${prefix}--breadcrumb--no-trailing-slash`]: noTrailingSlash
  });
  return import_react15.default.createElement("nav", _extends({
    className: customClassNameNav,
    "aria-label": ariaLabel ? ariaLabel : "Breadcrumb",
    ref
  }, rest3), import_react15.default.createElement("ol", {
    className
  }, children));
});
Breadcrumb.displayName = "Breadcrumb";
Breadcrumb.propTypes = {
  /**
   * Specify the label for the breadcrumb container
   */
  "aria-label": import_prop_types8.default.string,
  /**
   * Pass in the BreadcrumbItem's for your Breadcrumb
   */
  children: import_prop_types8.default.node,
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types8.default.string,
  /**
   * Optional prop to omit the trailing slash for the breadcrumbs
   */
  noTrailingSlash: import_prop_types8.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Breadcrumb/BreadcrumbItem.js
var import_prop_types10 = __toESM(require_prop_types());
var import_react17 = __toESM(require_react());
var import_classnames8 = __toESM(require_classnames());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Link/Link.js
var import_classnames7 = __toESM(require_classnames());
var import_prop_types9 = __toESM(require_prop_types());
var import_react16 = __toESM(require_react());
var Link = import_react16.default.forwardRef((_ref, ref) => {
  let {
    as: BaseComponent,
    children,
    className: customClassName,
    href,
    disabled = false,
    inline: inline5 = false,
    visited = false,
    renderIcon: Icon,
    size: size6,
    target,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const className = (0, import_classnames7.default)(`${prefix}--link`, customClassName, {
    [`${prefix}--link--disabled`]: disabled,
    [`${prefix}--link--inline`]: inline5,
    [`${prefix}--link--visited`]: visited,
    [`${prefix}--link--${size6}`]: size6
  });
  const rel = target === "_blank" ? "noopener" : void 0;
  const linkProps = {
    className: BaseComponent ? void 0 : className,
    rel,
    target
  };
  if (!disabled) {
    linkProps.href = href;
  } else {
    linkProps.role = "link";
    linkProps["aria-disabled"] = true;
  }
  const BaseComponentAsAny = BaseComponent ?? "a";
  return import_react16.default.createElement(BaseComponentAsAny, _extends({
    ref
  }, linkProps, rest3), children, !inline5 && Icon && import_react16.default.createElement("div", {
    className: `${prefix}--link__icon`
  }, import_react16.default.createElement(Icon, null)));
});
Link.displayName = "Link";
Link.propTypes = {
  /**
   * Provide a custom element or component to render the top-level node for the
   * component.
   */
  as: import_prop_types9.default.elementType,
  /**
   * Provide the content for the Link
   */
  children: import_prop_types9.default.node,
  /**
   * Provide a custom className to be applied to the containing `<a>` node
   */
  className: import_prop_types9.default.string,
  /**
   * Specify if the control should be disabled, or not
   */
  disabled: import_prop_types9.default.bool,
  /**
   * Provide the `href` attribute for the `<a>` node
   */
  href: import_prop_types9.default.string,
  /**
   * Specify whether you want the inline version of this control
   */
  inline: import_prop_types9.default.bool,
  /**
   * Optional prop to render an icon next to the link.
   * Can be a React component class
   */
  renderIcon: import_prop_types9.default.oneOfType([import_prop_types9.default.func, import_prop_types9.default.object]),
  /**
   * Specify the size of the Link. Currently supports either `sm`, 'md' (default) or 'lg` as an option.
   */
  size: import_prop_types9.default.oneOf(["sm", "md", "lg"]),
  /**
   * Specify whether you want the link to receive visited styles after the link has been clicked
   */
  visited: import_prop_types9.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Breadcrumb/BreadcrumbItem.js
var BreadcrumbItem = import_react17.default.forwardRef(function BreadcrumbItem2(_ref, ref) {
  let {
    "aria-current": ariaCurrent,
    children,
    className: customClassName = "",
    href,
    isCurrentPage,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const className = (0, import_classnames8.default)({
    [`${prefix}--breadcrumb-item`]: true,
    // We set the current class only if `isCurrentPage` is passed in and we do
    // not have an `aria-current="page"` set for the breadcrumb item
    [`${prefix}--breadcrumb-item--current`]: isCurrentPage && ariaCurrent !== "page",
    [customClassName]: !!customClassName
  });
  const child = children;
  if (child.type && child.type.displayName !== void 0 && child.type.displayName.includes("OverflowMenu")) {
    const horizontalOverflowIcon = import_react17.default.createElement(OverflowMenuHorizontal, {
      className: `${prefix}--overflow-menu__icon`
    });
    return import_react17.default.createElement("li", _extends({
      className
    }, rest3), import_react17.default.cloneElement(child, {
      menuOptionsClass: `${prefix}--breadcrumb-menu-options`,
      menuOffset: {
        top: 10,
        left: 59
      },
      renderIcon: () => horizontalOverflowIcon
    }));
  }
  if (typeof children === "string") {
    return import_react17.default.createElement("li", _extends({
      className,
      ref
    }, rest3), href ? import_react17.default.createElement(Link, {
      href,
      "aria-current": ariaCurrent || isCurrentPage
    }, children) : import_react17.default.createElement(Text, {
      "aria-current": ariaCurrent || isCurrentPage,
      className: `${prefix}--link`
    }, children));
  }
  return import_react17.default.createElement("li", _extends({
    className,
    ref
  }, rest3), import_react17.default.cloneElement(child, {
    "aria-current": ariaCurrent,
    className: (0, import_classnames8.default)(`${prefix}--link`, child.props.className)
  }));
});
BreadcrumbItem.displayName = "BreadcrumbItem";
BreadcrumbItem.propTypes = {
  "aria-current": import_prop_types10.default.oneOfType([import_prop_types10.default.bool, import_prop_types10.default.oneOf(["false", "true", "page", "step", "location", "date", "time"])]),
  /**
   * Pass in content that will be inside of the BreadcrumbItem
   */
  children: import_prop_types10.default.node,
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types10.default.string,
  /**
   * Optional string representing the link location for the BreadcrumbItem
   */
  href: import_prop_types10.default.string,
  /**
   * Provide if this breadcrumb item represents the current page
   */
  isCurrentPage: import_prop_types10.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Breadcrumb/Breadcrumb.Skeleton.js
var import_prop_types11 = __toESM(require_prop_types());
var import_react18 = __toESM(require_react());
var import_classnames9 = __toESM(require_classnames());
var _Item;
var _Item2;
var _Item3;
function Item() {
  const prefix = usePrefix();
  return import_react18.default.createElement("div", {
    className: `${prefix}--breadcrumb-item`
  }, import_react18.default.createElement("span", {
    className: `${prefix}--link`
  }, " "));
}
function BreadcrumbSkeleton(_ref) {
  let {
    className,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const classes = (0, import_classnames9.default)(`${prefix}--breadcrumb`, `${prefix}--skeleton`, className);
  return import_react18.default.createElement("div", _extends({
    className: classes
  }, rest3), _Item || (_Item = import_react18.default.createElement(Item, null)), _Item2 || (_Item2 = import_react18.default.createElement(Item, null)), _Item3 || (_Item3 = import_react18.default.createElement(Item, null)));
}
BreadcrumbSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types11.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Button/Button.js
var import_prop_types17 = __toESM(require_prop_types());
var import_react32 = __toESM(require_react());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/IconButton/index.js
var import_prop_types16 = __toESM(require_prop_types());
var import_react31 = __toESM(require_react());
var import_classnames14 = __toESM(require_classnames());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Tooltip/DefinitionTooltip.js
var import_classnames11 = __toESM(require_classnames());
var import_prop_types14 = __toESM(require_prop_types());
var import_react26 = __toESM(require_react());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Popover/index.js
var import_classnames10 = __toESM(require_classnames());
var import_prop_types13 = __toESM(require_prop_types());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/prop-types/deprecateValuesWithin.js
var didWarnAboutDeprecation2 = {};
function deprecateValuesWithin(propType, allowedValues, propMappingFunction10) {
  return function checker(props, propName, componentName) {
    if (props[propName] === void 0) {
      return;
    }
    if (!didWarnAboutDeprecation2[componentName] || !didWarnAboutDeprecation2[componentName][propName]) {
      didWarnAboutDeprecation2[componentName] = {
        ...didWarnAboutDeprecation2[componentName],
        [propName]: true
      };
      const deprecatedValue = props[propName];
      const newValue = propMappingFunction10 ? propMappingFunction10(deprecatedValue) : null;
      if (allowedValues && !allowedValues.includes(deprecatedValue)) {
        const message = propMappingFunction10 ? `"${deprecatedValue}" is a deprecated value for the "${propName}" prop on the "${componentName}" component. Use "${newValue}" instead. "${deprecatedValue}" will be removed in the next major release.` : `"${deprecatedValue}" is a deprecated value for the "${propName}" prop on the "${componentName}" component. Allowed values is/are: ${allowedValues.join(", ")}.  "${deprecatedValue}" will be removed in the next major release. `;
        true ? warning(false, message) : void 0;
      }
    }
    for (var _len = arguments.length, rest3 = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      rest3[_key - 3] = arguments[_key];
    }
    return propType(props, propName, componentName, ...rest3);
  };
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Popover/index.js
var import_react24 = __toESM(require_react());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/internal/useMergedRefs.js
var import_react19 = __toESM(require_react());
var useMergedRefs = (refs) => {
  return (0, import_react19.useCallback)((node) => {
    refs.forEach((ref) => {
      if (typeof ref === "function") {
        ref(node);
      } else if (ref !== null && ref !== void 0) {
        ref.current = node;
      }
    });
  }, refs);
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/internal/useEvent.js
var import_react20 = __toESM(require_react());
function useEvent(elementOrRef, eventName, callback) {
  const savedCallback = (0, import_react20.useRef)(null);
  (0, import_react20.useEffect)(() => {
    savedCallback.current = callback;
  }, [callback]);
  (0, import_react20.useEffect)(() => {
    var _a;
    const handler = (event) => {
      if (savedCallback.current) {
        savedCallback.current(event);
      }
    };
    const element = "current" in elementOrRef ? elementOrRef.current : elementOrRef;
    (_a = element == null ? void 0 : element.addEventListener) == null ? void 0 : _a.call(element, eventName, handler);
    return () => {
      var _a2;
      (_a2 = element == null ? void 0 : element.removeEventListener) == null ? void 0 : _a2.call(element, eventName, handler);
    };
  }, [elementOrRef, eventName]);
}
function useWindowEvent(eventName, callback) {
  const savedCallback = (0, import_react20.useRef)(null);
  (0, import_react20.useEffect)(() => {
    savedCallback.current = callback;
  }, [callback]);
  (0, import_react20.useEffect)(() => {
    function handler(event) {
      if (savedCallback.current) {
        savedCallback.current(event);
      }
    }
    window.addEventListener(eventName, handler);
    return () => {
      window.removeEventListener(eventName, handler);
    };
  }, [eventName]);
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/tools/createPropAdapter.js
function mapPopoverAlignProp(align) {
  switch (align) {
    case "top-left":
      return "top-start";
    case "top-right":
      return "top-end";
    case "bottom-left":
      return "bottom-start";
    case "bottom-right":
      return "bottom-end";
    case "left-bottom":
      return "left-end";
    case "left-top":
      return "left-start";
    case "right-bottom":
      return "right-end";
    case "right-top":
      return "right-start";
    default:
      return align;
  }
}

// ../node_modules/.pnpm/@floating-ui+react@0.26.28_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@floating-ui/react/dist/floating-ui.react.mjs
var React2 = __toESM(require_react(), 1);
var import_react22 = __toESM(require_react(), 1);

// ../node_modules/.pnpm/@floating-ui+utils@0.2.9/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e2) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// ../node_modules/.pnpm/@floating-ui+react@0.26.28_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs
function activeElement(doc) {
  let activeElement2 = doc.activeElement;
  while (((_activeElement = activeElement2) == null || (_activeElement = _activeElement.shadowRoot) == null ? void 0 : _activeElement.activeElement) != null) {
    var _activeElement;
    activeElement2 = activeElement2.shadowRoot.activeElement;
  }
  return activeElement2;
}
function contains(parent, child) {
  if (!parent || !child) {
    return false;
  }
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
  if (parent.contains(child)) {
    return true;
  }
  if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    while (next) {
      if (parent === next) {
        return true;
      }
      next = next.parentNode || next.host;
    }
  }
  return false;
}
function getPlatform() {
  const uaData = navigator.userAgentData;
  if (uaData != null && uaData.platform) {
    return uaData.platform;
  }
  return navigator.platform;
}
function getUserAgent() {
  const uaData = navigator.userAgentData;
  if (uaData && Array.isArray(uaData.brands)) {
    return uaData.brands.map((_ref) => {
      let {
        brand,
        version
      } = _ref;
      return brand + "/" + version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isVirtualClick(event) {
  if (event.mozInputSource === 0 && event.isTrusted) {
    return true;
  }
  if (isAndroid() && event.pointerType) {
    return event.type === "click" && event.buttons === 1;
  }
  return event.detail === 0 && !event.pointerType;
}
function isVirtualPointerEvent(event) {
  if (isJSDOM()) return false;
  return !isAndroid() && event.width === 0 && event.height === 0 || isAndroid() && event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "mouse" || // iOS VoiceOver returns 0.333• for width/height.
  event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "touch";
}
function isSafari() {
  return /apple/i.test(navigator.vendor);
}
function isAndroid() {
  const re = /android/i;
  return re.test(getPlatform()) || re.test(getUserAgent());
}
function isJSDOM() {
  return getUserAgent().includes("jsdom/");
}
function isMouseLikePointerType(pointerType, strict) {
  const values = ["mouse", "pen"];
  if (!strict) {
    values.push("", void 0);
  }
  return values.includes(pointerType);
}
function getDocument(node) {
  return (node == null ? void 0 : node.ownerDocument) || document;
}
function getTarget(event) {
  if ("composedPath" in event) {
    return event.composedPath()[0];
  }
  return event.target;
}
var TYPEABLE_SELECTOR = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
function isTypeableElement(element) {
  return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);
}
function stopEvent(event) {
  event.preventDefault();
  event.stopPropagation();
}
function isTypeableCombobox(element) {
  if (!element) return false;
  return element.getAttribute("role") === "combobox" && isTypeableElement(element);
}

// ../node_modules/.pnpm/@floating-ui+utils@0.2.9/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// ../node_modules/.pnpm/tabbable@6.2.0/node_modules/tabbable/dist/index.esm.js
var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
var candidateSelector = candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches2 = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  var _element$getRootNode;
  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function(element) {
  return element === null || element === void 0 ? void 0 : element.ownerDocument;
};
var isInert = function isInert2(node, lookUp) {
  var _node$getAttribute;
  if (lookUp === void 0) {
    lookUp = true;
  }
  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, "inert");
  var inert = inertAtt === "" || inertAtt === "true";
  var result = inert || lookUp && node && isInert2(node.parentNode);
  return result;
};
var isContentEditable = function isContentEditable2(node) {
  var _node$getAttribute2;
  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, "contenteditable");
  return attValue === "" || attValue === "true";
};
var getCandidates = function getCandidates2(el, includeContainer, filter2) {
  if (isInert(el)) {
    return [];
  }
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches2.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter2);
  return candidates;
};
var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (isInert(element, false)) {
      continue;
    }
    if (element.tagName === "SLOT") {
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively2(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scopeParent: element,
          candidates: nestedCandidates
        });
      }
    } else {
      var validCandidate = matches2.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }
      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
      typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var hasTabIndex = function hasTabIndex2(node) {
  return !isNaN(parseInt(node.getAttribute("tabindex"), 10));
};
var getTabIndex = function getTabIndex2(node) {
  if (!node) {
    throw new Error("No node provided");
  }
  if (node.tabIndex < 0) {
    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {
      return 0;
    }
  }
  return node.tabIndex;
};
var getSortOrderTabIndex = function getSortOrderTabIndex2(node, isScope) {
  var tabIndex = getTabIndex(node);
  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {
    return 0;
  }
  return tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a, b) {
  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
};
var isInput = function isInput2(node) {
  return node.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node) {
  return isInput(node) && node.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node) {
  var r2 = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r2;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].checked && nodes[i].form === form) {
      return nodes[i];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode(node);
  var queryRadios = function queryRadios2(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio2(node) {
  return isInput(node) && node.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node) {
  return isRadio(node) && !isTabbableRadio(node);
};
var isNodeAttached = function isNodeAttached2(node) {
  var _nodeRoot;
  var nodeRoot = node && getRootNode(node);
  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
  var attached = false;
  if (nodeRoot && nodeRoot !== node) {
    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
    while (!attached && nodeRootHost) {
      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
      nodeRoot = getRootNode(nodeRootHost);
      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
    }
  }
  return attached;
};
var isZeroArea = function isZeroArea2(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden2(node, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
  if (getComputedStyle(node).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches2.call(node, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches2.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
    if (typeof getShadowRoot === "function") {
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          node = rootNode.host;
        } else {
          node = parentElement;
        }
      }
      node = originalNode;
    }
    if (isNodeAttached(node)) {
      return !node.getClientRects().length;
    }
    if (displayCheck !== "legacy-full") {
      return true;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    while (parentNode) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i = 0; i < parentNode.children.length; i++) {
          var child = parentNode.children.item(i);
          if (child.tagName === "LEGEND") {
            return matches2.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
          }
        }
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
  if (node.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  isInert(node) || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
  if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var sortByOrder = function sortByOrder2(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function(item, i) {
    var isScope = !!item.scopeParent;
    var element = isScope ? item.scopeParent : item;
    var candidateTabindex = getSortOrderTabIndex(element, isScope);
    var elements = isScope ? sortByOrder2(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i,
        tabIndex: candidateTabindex,
        item,
        isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var isTabbable = function isTabbable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches2.call(node, candidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorTabbable(options, node);
};
var focusableCandidateSelector = candidateSelectors.concat("iframe").join(",");

// ../node_modules/.pnpm/@floating-ui+react@0.26.28_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@floating-ui/react/dist/floating-ui.react.mjs
var ReactDOM2 = __toESM(require_react_dom(), 1);

// ../node_modules/.pnpm/@floating-ui+core@1.6.9/node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max4 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset5 = clamp(min$1, center, max4);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset5 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max4 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset5,
        centerOffset: center - offset5 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements3 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides3 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides3[0]], overflow[sides3[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements3[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// ../node_modules/.pnpm/@floating-ui+dom@1.6.13/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId2;
  const root = getDocumentElement(element);
  function cleanup2() {
    var _io;
    clearTimeout(timeoutId2);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup2();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId2 = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e2) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup2;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var flip2 = flip;
var size2 = size;
var arrow2 = arrow;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// ../node_modules/.pnpm/@floating-ui+react-dom@2.1.2_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
var React = __toESM(require_react(), 1);
var import_react21 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);
var index = typeof document !== "undefined" ? import_react21.useLayoutEffect : import_react21.useEffect;
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b.toString()) {
    return true;
  }
  let length;
  let i;
  let keys2;
  if (a && b && typeof a === "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b.length) return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys2 = Object.keys(a);
    length = keys2.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys2[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key = keys2[i];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React.useState(null);
  const [_floating, _setFloating] = React.useState(null);
  const setReference = React.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React.useRef(null);
  const floatingRef = React.useRef(null);
  const dataRef = React.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = React.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x = roundByDPR(elements.floating, data.x);
    const y = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x + "px, " + y + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x,
      top: y
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
var arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
var offset3 = (options, deps) => ({
  ...offset2(options),
  options: [options, deps]
});
var flip3 = (options, deps) => ({
  ...flip2(options),
  options: [options, deps]
});
var size3 = (options, deps) => ({
  ...size2(options),
  options: [options, deps]
});
var arrow3 = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});

// ../node_modules/.pnpm/@floating-ui+react@0.26.28_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@floating-ui/react/dist/floating-ui.react.mjs
function useMergeRefs(refs) {
  return React2.useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }
    return (value) => {
      refs.forEach((ref) => {
        if (typeof ref === "function") {
          ref(value);
        } else if (ref != null) {
          ref.current = value;
        }
      });
    };
  }, refs);
}
var SafeReact = {
  ...React2
};
var useInsertionEffect = SafeReact.useInsertionEffect;
var useSafeInsertionEffect = useInsertionEffect || ((fn) => fn());
function useEffectEvent(callback) {
  const ref = React2.useRef(() => {
    if (true) {
      throw new Error("Cannot call an event handler while rendering.");
    }
  });
  useSafeInsertionEffect(() => {
    ref.current = callback;
  });
  return React2.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref.current == null ? void 0 : ref.current(...args);
  }, []);
}
var ARROW_UP = "ArrowUp";
var ARROW_DOWN = "ArrowDown";
var ARROW_LEFT = "ArrowLeft";
var ARROW_RIGHT = "ArrowRight";
function isDifferentRow(index4, cols, prevRow) {
  return Math.floor(index4 / cols) !== prevRow;
}
function isIndexOutOfBounds(listRef, index4) {
  return index4 < 0 || index4 >= listRef.current.length;
}
function getMinIndex(listRef, disabledIndices) {
  return findNonDisabledIndex(listRef, {
    disabledIndices
  });
}
function getMaxIndex(listRef, disabledIndices) {
  return findNonDisabledIndex(listRef, {
    decrement: true,
    startingIndex: listRef.current.length,
    disabledIndices
  });
}
function findNonDisabledIndex(listRef, _temp) {
  let {
    startingIndex = -1,
    decrement = false,
    disabledIndices,
    amount = 1
  } = _temp === void 0 ? {} : _temp;
  const list = listRef.current;
  let index4 = startingIndex;
  do {
    index4 += decrement ? -amount : amount;
  } while (index4 >= 0 && index4 <= list.length - 1 && isDisabled(list, index4, disabledIndices));
  return index4;
}
function getGridNavigatedIndex(elementsRef, _ref) {
  let {
    event,
    orientation,
    loop,
    rtl,
    cols,
    disabledIndices,
    minIndex,
    maxIndex,
    prevIndex,
    stopEvent: stop = false
  } = _ref;
  let nextIndex = prevIndex;
  if (event.key === ARROW_UP) {
    stop && stopEvent(event);
    if (prevIndex === -1) {
      nextIndex = maxIndex;
    } else {
      nextIndex = findNonDisabledIndex(elementsRef, {
        startingIndex: nextIndex,
        amount: cols,
        decrement: true,
        disabledIndices
      });
      if (loop && (prevIndex - cols < minIndex || nextIndex < 0)) {
        const col = prevIndex % cols;
        const maxCol = maxIndex % cols;
        const offset5 = maxIndex - (maxCol - col);
        if (maxCol === col) {
          nextIndex = maxIndex;
        } else {
          nextIndex = maxCol > col ? offset5 : offset5 - cols;
        }
      }
    }
    if (isIndexOutOfBounds(elementsRef, nextIndex)) {
      nextIndex = prevIndex;
    }
  }
  if (event.key === ARROW_DOWN) {
    stop && stopEvent(event);
    if (prevIndex === -1) {
      nextIndex = minIndex;
    } else {
      nextIndex = findNonDisabledIndex(elementsRef, {
        startingIndex: prevIndex,
        amount: cols,
        disabledIndices
      });
      if (loop && prevIndex + cols > maxIndex) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex % cols - cols,
          amount: cols,
          disabledIndices
        });
      }
    }
    if (isIndexOutOfBounds(elementsRef, nextIndex)) {
      nextIndex = prevIndex;
    }
  }
  if (orientation === "both") {
    const prevRow = floor(prevIndex / cols);
    if (event.key === (rtl ? ARROW_LEFT : ARROW_RIGHT)) {
      stop && stopEvent(event);
      if (prevIndex % cols !== cols - 1) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex,
          disabledIndices
        });
        if (loop && isDifferentRow(nextIndex, cols, prevRow)) {
          nextIndex = findNonDisabledIndex(elementsRef, {
            startingIndex: prevIndex - prevIndex % cols - 1,
            disabledIndices
          });
        }
      } else if (loop) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex - prevIndex % cols - 1,
          disabledIndices
        });
      }
      if (isDifferentRow(nextIndex, cols, prevRow)) {
        nextIndex = prevIndex;
      }
    }
    if (event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT)) {
      stop && stopEvent(event);
      if (prevIndex % cols !== 0) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex,
          decrement: true,
          disabledIndices
        });
        if (loop && isDifferentRow(nextIndex, cols, prevRow)) {
          nextIndex = findNonDisabledIndex(elementsRef, {
            startingIndex: prevIndex + (cols - prevIndex % cols),
            decrement: true,
            disabledIndices
          });
        }
      } else if (loop) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex + (cols - prevIndex % cols),
          decrement: true,
          disabledIndices
        });
      }
      if (isDifferentRow(nextIndex, cols, prevRow)) {
        nextIndex = prevIndex;
      }
    }
    const lastRow = floor(maxIndex / cols) === prevRow;
    if (isIndexOutOfBounds(elementsRef, nextIndex)) {
      if (loop && lastRow) {
        nextIndex = event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT) ? maxIndex : findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex - prevIndex % cols - 1,
          disabledIndices
        });
      } else {
        nextIndex = prevIndex;
      }
    }
  }
  return nextIndex;
}
function buildCellMap(sizes2, cols, dense) {
  const cellMap = [];
  let startIndex = 0;
  sizes2.forEach((_ref2, index4) => {
    let {
      width,
      height
    } = _ref2;
    if (width > cols) {
      if (true) {
        throw new Error("[Floating UI]: Invalid grid - item width at index " + index4 + " is greater than grid columns");
      }
    }
    let itemPlaced = false;
    if (dense) {
      startIndex = 0;
    }
    while (!itemPlaced) {
      const targetCells = [];
      for (let i = 0; i < width; i++) {
        for (let j = 0; j < height; j++) {
          targetCells.push(startIndex + i + j * cols);
        }
      }
      if (startIndex % cols + width <= cols && targetCells.every((cell) => cellMap[cell] == null)) {
        targetCells.forEach((cell) => {
          cellMap[cell] = index4;
        });
        itemPlaced = true;
      } else {
        startIndex++;
      }
    }
  });
  return [...cellMap];
}
function getCellIndexOfCorner(index4, sizes2, cellMap, cols, corner) {
  if (index4 === -1) return -1;
  const firstCellIndex = cellMap.indexOf(index4);
  const sizeItem = sizes2[index4];
  switch (corner) {
    case "tl":
      return firstCellIndex;
    case "tr":
      if (!sizeItem) {
        return firstCellIndex;
      }
      return firstCellIndex + sizeItem.width - 1;
    case "bl":
      if (!sizeItem) {
        return firstCellIndex;
      }
      return firstCellIndex + (sizeItem.height - 1) * cols;
    case "br":
      return cellMap.lastIndexOf(index4);
  }
}
function getCellIndices(indices, cellMap) {
  return cellMap.flatMap((index4, cellIndex) => indices.includes(index4) ? [cellIndex] : []);
}
function isDisabled(list, index4, disabledIndices) {
  if (disabledIndices) {
    return disabledIndices.includes(index4);
  }
  const element = list[index4];
  return element == null || element.hasAttribute("disabled") || element.getAttribute("aria-disabled") === "true";
}
var index2 = typeof document !== "undefined" ? import_react22.useLayoutEffect : import_react22.useEffect;
function sortByDocumentPosition(a, b) {
  const position = a.compareDocumentPosition(b);
  if (position & Node.DOCUMENT_POSITION_FOLLOWING || position & Node.DOCUMENT_POSITION_CONTAINED_BY) {
    return -1;
  }
  if (position & Node.DOCUMENT_POSITION_PRECEDING || position & Node.DOCUMENT_POSITION_CONTAINS) {
    return 1;
  }
  return 0;
}
function areMapsEqual(map1, map2) {
  if (map1.size !== map2.size) {
    return false;
  }
  for (const [key, value] of map1.entries()) {
    if (value !== map2.get(key)) {
      return false;
    }
  }
  return true;
}
var FloatingListContext = React2.createContext({
  register: () => {
  },
  unregister: () => {
  },
  map: /* @__PURE__ */ new Map(),
  elementsRef: {
    current: []
  }
});
function FloatingList(props) {
  const {
    children,
    elementsRef,
    labelsRef
  } = props;
  const [map2, setMap] = React2.useState(() => /* @__PURE__ */ new Map());
  const register = React2.useCallback((node) => {
    setMap((prevMap) => new Map(prevMap).set(node, null));
  }, []);
  const unregister = React2.useCallback((node) => {
    setMap((prevMap) => {
      const map3 = new Map(prevMap);
      map3.delete(node);
      return map3;
    });
  }, []);
  index2(() => {
    const newMap = new Map(map2);
    const nodes = Array.from(newMap.keys()).sort(sortByDocumentPosition);
    nodes.forEach((node, index4) => {
      newMap.set(node, index4);
    });
    if (!areMapsEqual(map2, newMap)) {
      setMap(newMap);
    }
  }, [map2]);
  return React2.createElement(FloatingListContext.Provider, {
    value: React2.useMemo(() => ({
      register,
      unregister,
      map: map2,
      elementsRef,
      labelsRef
    }), [register, unregister, map2, elementsRef, labelsRef])
  }, children);
}
function useListItem(props) {
  if (props === void 0) {
    props = {};
  }
  const {
    label
  } = props;
  const {
    register,
    unregister,
    map: map2,
    elementsRef,
    labelsRef
  } = React2.useContext(FloatingListContext);
  const [index$1, setIndex] = React2.useState(null);
  const componentRef = React2.useRef(null);
  const ref = React2.useCallback((node) => {
    componentRef.current = node;
    if (index$1 !== null) {
      elementsRef.current[index$1] = node;
      if (labelsRef) {
        var _node$textContent;
        const isLabelDefined = label !== void 0;
        labelsRef.current[index$1] = isLabelDefined ? label : (_node$textContent = node == null ? void 0 : node.textContent) != null ? _node$textContent : null;
      }
    }
  }, [index$1, elementsRef, labelsRef, label]);
  index2(() => {
    const node = componentRef.current;
    if (node) {
      register(node);
      return () => {
        unregister(node);
      };
    }
  }, [register, unregister]);
  index2(() => {
    const index4 = componentRef.current ? map2.get(componentRef.current) : null;
    if (index4 != null) {
      setIndex(index4);
    }
  }, [map2]);
  return React2.useMemo(() => ({
    ref,
    index: index$1 == null ? -1 : index$1
  }), [index$1, ref]);
}
function renderJsx(render, computedProps) {
  if (typeof render === "function") {
    return render(computedProps);
  }
  if (render) {
    return React2.cloneElement(render, computedProps);
  }
  return React2.createElement("div", computedProps);
}
var CompositeContext = React2.createContext({
  activeIndex: 0,
  onNavigate: () => {
  }
});
var horizontalKeys = [ARROW_LEFT, ARROW_RIGHT];
var verticalKeys = [ARROW_UP, ARROW_DOWN];
var allKeys = [...horizontalKeys, ...verticalKeys];
var Composite = React2.forwardRef(function Composite2(props, forwardedRef) {
  const {
    render,
    orientation = "both",
    loop = true,
    rtl = false,
    cols = 1,
    disabledIndices,
    activeIndex: externalActiveIndex,
    onNavigate: externalSetActiveIndex,
    itemSizes,
    dense = false,
    ...domProps
  } = props;
  const [internalActiveIndex, internalSetActiveIndex] = React2.useState(0);
  const activeIndex = externalActiveIndex != null ? externalActiveIndex : internalActiveIndex;
  const onNavigate = useEffectEvent(externalSetActiveIndex != null ? externalSetActiveIndex : internalSetActiveIndex);
  const elementsRef = React2.useRef([]);
  const renderElementProps = render && typeof render !== "function" ? render.props : {};
  const contextValue = React2.useMemo(() => ({
    activeIndex,
    onNavigate
  }), [activeIndex, onNavigate]);
  const isGrid = cols > 1;
  function handleKeyDown(event) {
    if (!allKeys.includes(event.key)) return;
    let nextIndex = activeIndex;
    const minIndex = getMinIndex(elementsRef, disabledIndices);
    const maxIndex = getMaxIndex(elementsRef, disabledIndices);
    const horizontalEndKey = rtl ? ARROW_LEFT : ARROW_RIGHT;
    const horizontalStartKey = rtl ? ARROW_RIGHT : ARROW_LEFT;
    if (isGrid) {
      const sizes2 = itemSizes || Array.from({
        length: elementsRef.current.length
      }, () => ({
        width: 1,
        height: 1
      }));
      const cellMap = buildCellMap(sizes2, cols, dense);
      const minGridIndex = cellMap.findIndex((index4) => index4 != null && !isDisabled(elementsRef.current, index4, disabledIndices));
      const maxGridIndex = cellMap.reduce((foundIndex, index4, cellIndex) => index4 != null && !isDisabled(elementsRef.current, index4, disabledIndices) ? cellIndex : foundIndex, -1);
      const maybeNextIndex = cellMap[getGridNavigatedIndex({
        current: cellMap.map((itemIndex) => itemIndex ? elementsRef.current[itemIndex] : null)
      }, {
        event,
        orientation,
        loop,
        rtl,
        cols,
        // treat undefined (empty grid spaces) as disabled indices so we
        // don't end up in them
        disabledIndices: getCellIndices([...disabledIndices || elementsRef.current.map((_, index4) => isDisabled(elementsRef.current, index4) ? index4 : void 0), void 0], cellMap),
        minIndex: minGridIndex,
        maxIndex: maxGridIndex,
        prevIndex: getCellIndexOfCorner(
          activeIndex > maxIndex ? minIndex : activeIndex,
          sizes2,
          cellMap,
          cols,
          // use a corner matching the edge closest to the direction we're
          // moving in so we don't end up in the same item. Prefer
          // top/left over bottom/right.
          event.key === ARROW_DOWN ? "bl" : event.key === horizontalEndKey ? "tr" : "tl"
        )
      })];
      if (maybeNextIndex != null) {
        nextIndex = maybeNextIndex;
      }
    }
    const toEndKeys = {
      horizontal: [horizontalEndKey],
      vertical: [ARROW_DOWN],
      both: [horizontalEndKey, ARROW_DOWN]
    }[orientation];
    const toStartKeys = {
      horizontal: [horizontalStartKey],
      vertical: [ARROW_UP],
      both: [horizontalStartKey, ARROW_UP]
    }[orientation];
    const preventedKeys = isGrid ? allKeys : {
      horizontal: horizontalKeys,
      vertical: verticalKeys,
      both: allKeys
    }[orientation];
    if (nextIndex === activeIndex && [...toEndKeys, ...toStartKeys].includes(event.key)) {
      if (loop && nextIndex === maxIndex && toEndKeys.includes(event.key)) {
        nextIndex = minIndex;
      } else if (loop && nextIndex === minIndex && toStartKeys.includes(event.key)) {
        nextIndex = maxIndex;
      } else {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: nextIndex,
          decrement: toStartKeys.includes(event.key),
          disabledIndices
        });
      }
    }
    if (nextIndex !== activeIndex && !isIndexOutOfBounds(elementsRef, nextIndex)) {
      var _elementsRef$current$;
      event.stopPropagation();
      if (preventedKeys.includes(event.key)) {
        event.preventDefault();
      }
      onNavigate(nextIndex);
      (_elementsRef$current$ = elementsRef.current[nextIndex]) == null || _elementsRef$current$.focus();
    }
  }
  const computedProps = {
    ...domProps,
    ...renderElementProps,
    ref: forwardedRef,
    "aria-orientation": orientation === "both" ? void 0 : orientation,
    onKeyDown(e2) {
      domProps.onKeyDown == null || domProps.onKeyDown(e2);
      renderElementProps.onKeyDown == null || renderElementProps.onKeyDown(e2);
      handleKeyDown(e2);
    }
  };
  return React2.createElement(CompositeContext.Provider, {
    value: contextValue
  }, React2.createElement(FloatingList, {
    elementsRef
  }, renderJsx(render, computedProps)));
});
var CompositeItem = React2.forwardRef(function CompositeItem2(props, forwardedRef) {
  const {
    render,
    ...domProps
  } = props;
  const renderElementProps = render && typeof render !== "function" ? render.props : {};
  const {
    activeIndex,
    onNavigate
  } = React2.useContext(CompositeContext);
  const {
    ref,
    index: index4
  } = useListItem();
  const mergedRef = useMergeRefs([ref, forwardedRef, renderElementProps.ref]);
  const isActive = activeIndex === index4;
  const computedProps = {
    ...domProps,
    ...renderElementProps,
    ref: mergedRef,
    tabIndex: isActive ? 0 : -1,
    "data-active": isActive ? "" : void 0,
    onFocus(e2) {
      domProps.onFocus == null || domProps.onFocus(e2);
      renderElementProps.onFocus == null || renderElementProps.onFocus(e2);
      onNavigate(index4);
    }
  };
  return renderJsx(render, computedProps);
});
function _extends2() {
  _extends2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
var serverHandoffComplete = false;
var count = 0;
var genId = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++
);
function useFloatingId() {
  const [id, setId] = React2.useState(() => serverHandoffComplete ? genId() : void 0);
  index2(() => {
    if (id == null) {
      setId(genId());
    }
  }, []);
  React2.useEffect(() => {
    serverHandoffComplete = true;
  }, []);
  return id;
}
var useReactId2 = SafeReact.useId;
var useId2 = useReactId2 || useFloatingId;
var devMessageSet;
if (true) {
  devMessageSet = /* @__PURE__ */ new Set();
}
function warn() {
  var _devMessageSet;
  for (var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++) {
    messages[_key] = arguments[_key];
  }
  const message = "Floating UI: " + messages.join(" ");
  if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(message))) {
    var _devMessageSet2;
    (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(message);
    console.warn(message);
  }
}
function error() {
  var _devMessageSet3;
  for (var _len2 = arguments.length, messages = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    messages[_key2] = arguments[_key2];
  }
  const message = "Floating UI: " + messages.join(" ");
  if (!((_devMessageSet3 = devMessageSet) != null && _devMessageSet3.has(message))) {
    var _devMessageSet4;
    (_devMessageSet4 = devMessageSet) == null || _devMessageSet4.add(message);
    console.error(message);
  }
}
var FloatingArrow = React2.forwardRef(function FloatingArrow2(props, ref) {
  const {
    context: {
      placement,
      elements: {
        floating
      },
      middlewareData: {
        arrow: arrow5,
        shift: shift5
      }
    },
    width = 14,
    height = 7,
    tipRadius = 0,
    strokeWidth = 0,
    staticOffset,
    stroke,
    d,
    style: {
      transform,
      ...restStyle
    } = {},
    ...rest3
  } = props;
  if (true) {
    if (!ref) {
      warn("The `ref` prop is required for `FloatingArrow`.");
    }
  }
  const clipPathId = useId2();
  const [isRTL2, setIsRTL] = React2.useState(false);
  index2(() => {
    if (!floating) return;
    const isRTL3 = getComputedStyle2(floating).direction === "rtl";
    if (isRTL3) {
      setIsRTL(true);
    }
  }, [floating]);
  if (!floating) {
    return null;
  }
  const [side, alignment] = placement.split("-");
  const isVerticalSide = side === "top" || side === "bottom";
  let computedStaticOffset = staticOffset;
  if (isVerticalSide && shift5 != null && shift5.x || !isVerticalSide && shift5 != null && shift5.y) {
    computedStaticOffset = null;
  }
  const computedStrokeWidth = strokeWidth * 2;
  const halfStrokeWidth = computedStrokeWidth / 2;
  const svgX = width / 2 * (tipRadius / -8 + 1);
  const svgY = height / 2 * tipRadius / 4;
  const isCustomShape = !!d;
  const yOffsetProp = computedStaticOffset && alignment === "end" ? "bottom" : "top";
  let xOffsetProp = computedStaticOffset && alignment === "end" ? "right" : "left";
  if (computedStaticOffset && isRTL2) {
    xOffsetProp = alignment === "end" ? "left" : "right";
  }
  const arrowX = (arrow5 == null ? void 0 : arrow5.x) != null ? computedStaticOffset || arrow5.x : "";
  const arrowY = (arrow5 == null ? void 0 : arrow5.y) != null ? computedStaticOffset || arrow5.y : "";
  const dValue = d || "M0,0" + (" H" + width) + (" L" + (width - svgX) + "," + (height - svgY)) + (" Q" + width / 2 + "," + height + " " + svgX + "," + (height - svgY)) + " Z";
  const rotation = {
    top: isCustomShape ? "rotate(180deg)" : "",
    left: isCustomShape ? "rotate(90deg)" : "rotate(-90deg)",
    bottom: isCustomShape ? "" : "rotate(180deg)",
    right: isCustomShape ? "rotate(-90deg)" : "rotate(90deg)"
  }[side];
  return React2.createElement("svg", _extends2({}, rest3, {
    "aria-hidden": true,
    ref,
    width: isCustomShape ? width : width + computedStrokeWidth,
    height: width,
    viewBox: "0 0 " + width + " " + (height > width ? height : width),
    style: {
      position: "absolute",
      pointerEvents: "none",
      [xOffsetProp]: arrowX,
      [yOffsetProp]: arrowY,
      [side]: isVerticalSide || isCustomShape ? "100%" : "calc(100% - " + computedStrokeWidth / 2 + "px)",
      transform: [rotation, transform].filter((t2) => !!t2).join(" "),
      ...restStyle
    }
  }), computedStrokeWidth > 0 && React2.createElement("path", {
    clipPath: "url(#" + clipPathId + ")",
    fill: "none",
    stroke,
    strokeWidth: computedStrokeWidth + (d ? 0 : 1),
    d: dValue
  }), React2.createElement("path", {
    stroke: computedStrokeWidth && !d ? rest3.fill : "none",
    d: dValue
  }), React2.createElement("clipPath", {
    id: clipPathId
  }, React2.createElement("rect", {
    x: -halfStrokeWidth,
    y: halfStrokeWidth * (isCustomShape ? -1 : 1),
    width: width + computedStrokeWidth,
    height: width
  })));
});
function createPubSub() {
  const map2 = /* @__PURE__ */ new Map();
  return {
    emit(event, data) {
      var _map$get;
      (_map$get = map2.get(event)) == null || _map$get.forEach((handler) => handler(data));
    },
    on(event, listener) {
      map2.set(event, [...map2.get(event) || [], listener]);
    },
    off(event, listener) {
      var _map$get2;
      map2.set(event, ((_map$get2 = map2.get(event)) == null ? void 0 : _map$get2.filter((l2) => l2 !== listener)) || []);
    }
  };
}
var FloatingNodeContext = React2.createContext(null);
var FloatingTreeContext = React2.createContext(null);
var useFloatingParentNodeId = () => {
  var _React$useContext;
  return ((_React$useContext = React2.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
};
var useFloatingTree = () => React2.useContext(FloatingTreeContext);
function createAttribute(name) {
  return "data-floating-ui-" + name;
}
function useLatestRef2(value) {
  const ref = (0, import_react22.useRef)(value);
  index2(() => {
    ref.current = value;
  });
  return ref;
}
var safePolygonIdentifier = createAttribute("safe-polygon");
function getDelay(value, prop, pointerType) {
  if (pointerType && !isMouseLikePointerType(pointerType)) {
    return 0;
  }
  if (typeof value === "number") {
    return value;
  }
  return value == null ? void 0 : value[prop];
}
function useHover(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    dataRef,
    events,
    elements
  } = context;
  const {
    enabled: enabled2 = true,
    delay: delay3 = 0,
    handleClose = null,
    mouseOnly = false,
    restMs = 0,
    move = true
  } = props;
  const tree = useFloatingTree();
  const parentId = useFloatingParentNodeId();
  const handleCloseRef = useLatestRef2(handleClose);
  const delayRef = useLatestRef2(delay3);
  const openRef = useLatestRef2(open);
  const pointerTypeRef = React2.useRef();
  const timeoutRef = React2.useRef(-1);
  const handlerRef = React2.useRef();
  const restTimeoutRef = React2.useRef(-1);
  const blockMouseMoveRef = React2.useRef(true);
  const performedPointerEventsMutationRef = React2.useRef(false);
  const unbindMouseMoveRef = React2.useRef(() => {
  });
  const restTimeoutPendingRef = React2.useRef(false);
  const isHoverOpen = React2.useCallback(() => {
    var _dataRef$current$open;
    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;
    return (type == null ? void 0 : type.includes("mouse")) && type !== "mousedown";
  }, [dataRef]);
  React2.useEffect(() => {
    if (!enabled2) return;
    function onOpenChange2(_ref) {
      let {
        open: open2
      } = _ref;
      if (!open2) {
        clearTimeout(timeoutRef.current);
        clearTimeout(restTimeoutRef.current);
        blockMouseMoveRef.current = true;
        restTimeoutPendingRef.current = false;
      }
    }
    events.on("openchange", onOpenChange2);
    return () => {
      events.off("openchange", onOpenChange2);
    };
  }, [enabled2, events]);
  React2.useEffect(() => {
    if (!enabled2) return;
    if (!handleCloseRef.current) return;
    if (!open) return;
    function onLeave(event) {
      if (isHoverOpen()) {
        onOpenChange(false, event, "hover");
      }
    }
    const html = getDocument(elements.floating).documentElement;
    html.addEventListener("mouseleave", onLeave);
    return () => {
      html.removeEventListener("mouseleave", onLeave);
    };
  }, [elements.floating, open, onOpenChange, enabled2, handleCloseRef, isHoverOpen]);
  const closeWithDelay = React2.useCallback(function(event, runElseBranch, reason) {
    if (runElseBranch === void 0) {
      runElseBranch = true;
    }
    if (reason === void 0) {
      reason = "hover";
    }
    const closeDelay = getDelay(delayRef.current, "close", pointerTypeRef.current);
    if (closeDelay && !handlerRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = window.setTimeout(() => onOpenChange(false, event, reason), closeDelay);
    } else if (runElseBranch) {
      clearTimeout(timeoutRef.current);
      onOpenChange(false, event, reason);
    }
  }, [delayRef, onOpenChange]);
  const cleanupMouseMoveHandler = useEffectEvent(() => {
    unbindMouseMoveRef.current();
    handlerRef.current = void 0;
  });
  const clearPointerEvents = useEffectEvent(() => {
    if (performedPointerEventsMutationRef.current) {
      const body = getDocument(elements.floating).body;
      body.style.pointerEvents = "";
      body.removeAttribute(safePolygonIdentifier);
      performedPointerEventsMutationRef.current = false;
    }
  });
  const isClickLikeOpenEvent = useEffectEvent(() => {
    return dataRef.current.openEvent ? ["click", "mousedown"].includes(dataRef.current.openEvent.type) : false;
  });
  React2.useEffect(() => {
    if (!enabled2) return;
    function onMouseEnter(event) {
      clearTimeout(timeoutRef.current);
      blockMouseMoveRef.current = false;
      if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || restMs > 0 && !getDelay(delayRef.current, "open")) {
        return;
      }
      const openDelay = getDelay(delayRef.current, "open", pointerTypeRef.current);
      if (openDelay) {
        timeoutRef.current = window.setTimeout(() => {
          if (!openRef.current) {
            onOpenChange(true, event, "hover");
          }
        }, openDelay);
      } else if (!open) {
        onOpenChange(true, event, "hover");
      }
    }
    function onMouseLeave(event) {
      if (isClickLikeOpenEvent()) return;
      unbindMouseMoveRef.current();
      const doc = getDocument(elements.floating);
      clearTimeout(restTimeoutRef.current);
      restTimeoutPendingRef.current = false;
      if (handleCloseRef.current && dataRef.current.floatingContext) {
        if (!open) {
          clearTimeout(timeoutRef.current);
        }
        handlerRef.current = handleCloseRef.current({
          ...dataRef.current.floatingContext,
          tree,
          x: event.clientX,
          y: event.clientY,
          onClose() {
            clearPointerEvents();
            cleanupMouseMoveHandler();
            if (!isClickLikeOpenEvent()) {
              closeWithDelay(event, true, "safe-polygon");
            }
          }
        });
        const handler = handlerRef.current;
        doc.addEventListener("mousemove", handler);
        unbindMouseMoveRef.current = () => {
          doc.removeEventListener("mousemove", handler);
        };
        return;
      }
      const shouldClose = pointerTypeRef.current === "touch" ? !contains(elements.floating, event.relatedTarget) : true;
      if (shouldClose) {
        closeWithDelay(event);
      }
    }
    function onScrollMouseLeave(event) {
      if (isClickLikeOpenEvent()) return;
      if (!dataRef.current.floatingContext) return;
      handleCloseRef.current == null || handleCloseRef.current({
        ...dataRef.current.floatingContext,
        tree,
        x: event.clientX,
        y: event.clientY,
        onClose() {
          clearPointerEvents();
          cleanupMouseMoveHandler();
          if (!isClickLikeOpenEvent()) {
            closeWithDelay(event);
          }
        }
      })(event);
    }
    if (isElement(elements.domReference)) {
      var _elements$floating;
      const ref = elements.domReference;
      open && ref.addEventListener("mouseleave", onScrollMouseLeave);
      (_elements$floating = elements.floating) == null || _elements$floating.addEventListener("mouseleave", onScrollMouseLeave);
      move && ref.addEventListener("mousemove", onMouseEnter, {
        once: true
      });
      ref.addEventListener("mouseenter", onMouseEnter);
      ref.addEventListener("mouseleave", onMouseLeave);
      return () => {
        var _elements$floating2;
        open && ref.removeEventListener("mouseleave", onScrollMouseLeave);
        (_elements$floating2 = elements.floating) == null || _elements$floating2.removeEventListener("mouseleave", onScrollMouseLeave);
        move && ref.removeEventListener("mousemove", onMouseEnter);
        ref.removeEventListener("mouseenter", onMouseEnter);
        ref.removeEventListener("mouseleave", onMouseLeave);
      };
    }
  }, [elements, enabled2, context, mouseOnly, restMs, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, openRef, tree, delayRef, handleCloseRef, dataRef, isClickLikeOpenEvent]);
  index2(() => {
    var _handleCloseRef$curre;
    if (!enabled2) return;
    if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && _handleCloseRef$curre.__options.blockPointerEvents && isHoverOpen()) {
      performedPointerEventsMutationRef.current = true;
      const floatingEl = elements.floating;
      if (isElement(elements.domReference) && floatingEl) {
        var _tree$nodesRef$curren;
        const body = getDocument(elements.floating).body;
        body.setAttribute(safePolygonIdentifier, "");
        const ref = elements.domReference;
        const parentFloating = tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find((node) => node.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren.elements.floating;
        if (parentFloating) {
          parentFloating.style.pointerEvents = "";
        }
        body.style.pointerEvents = "none";
        ref.style.pointerEvents = "auto";
        floatingEl.style.pointerEvents = "auto";
        return () => {
          body.style.pointerEvents = "";
          ref.style.pointerEvents = "";
          floatingEl.style.pointerEvents = "";
        };
      }
    }
  }, [enabled2, open, parentId, elements, tree, handleCloseRef, isHoverOpen]);
  index2(() => {
    if (!open) {
      pointerTypeRef.current = void 0;
      restTimeoutPendingRef.current = false;
      cleanupMouseMoveHandler();
      clearPointerEvents();
    }
  }, [open, cleanupMouseMoveHandler, clearPointerEvents]);
  React2.useEffect(() => {
    return () => {
      cleanupMouseMoveHandler();
      clearTimeout(timeoutRef.current);
      clearTimeout(restTimeoutRef.current);
      clearPointerEvents();
    };
  }, [enabled2, elements.domReference, cleanupMouseMoveHandler, clearPointerEvents]);
  const reference = React2.useMemo(() => {
    function setPointerRef(event) {
      pointerTypeRef.current = event.pointerType;
    }
    return {
      onPointerDown: setPointerRef,
      onPointerEnter: setPointerRef,
      onMouseMove(event) {
        const {
          nativeEvent
        } = event;
        function handleMouseMove() {
          if (!blockMouseMoveRef.current && !openRef.current) {
            onOpenChange(true, nativeEvent, "hover");
          }
        }
        if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current)) {
          return;
        }
        if (open || restMs === 0) {
          return;
        }
        if (restTimeoutPendingRef.current && event.movementX ** 2 + event.movementY ** 2 < 2) {
          return;
        }
        clearTimeout(restTimeoutRef.current);
        if (pointerTypeRef.current === "touch") {
          handleMouseMove();
        } else {
          restTimeoutPendingRef.current = true;
          restTimeoutRef.current = window.setTimeout(handleMouseMove, restMs);
        }
      }
    };
  }, [mouseOnly, onOpenChange, open, openRef, restMs]);
  const floating = React2.useMemo(() => ({
    onMouseEnter() {
      clearTimeout(timeoutRef.current);
    },
    onMouseLeave(event) {
      if (!isClickLikeOpenEvent()) {
        closeWithDelay(event.nativeEvent, false);
      }
    }
  }), [closeWithDelay, isClickLikeOpenEvent]);
  return React2.useMemo(() => enabled2 ? {
    reference,
    floating
  } : {}, [enabled2, reference, floating]);
}
var NOOP = () => {
};
var FloatingDelayGroupContext = React2.createContext({
  delay: 0,
  initialDelay: 0,
  timeoutMs: 0,
  currentId: null,
  setCurrentId: NOOP,
  setState: NOOP,
  isInstantPhase: false
});
var rafId = 0;
function enqueueFocus(el, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    preventScroll = false,
    cancelPrevious = true,
    sync = false
  } = options;
  cancelPrevious && cancelAnimationFrame(rafId);
  const exec = () => el == null ? void 0 : el.focus({
    preventScroll
  });
  if (sync) {
    exec();
  } else {
    rafId = requestAnimationFrame(exec);
  }
}
function getAncestors(nodes, id) {
  var _nodes$find;
  let allAncestors = [];
  let currentParentId = (_nodes$find = nodes.find((node) => node.id === id)) == null ? void 0 : _nodes$find.parentId;
  while (currentParentId) {
    const currentNode = nodes.find((node) => node.id === currentParentId);
    currentParentId = currentNode == null ? void 0 : currentNode.parentId;
    if (currentNode) {
      allAncestors = allAncestors.concat(currentNode);
    }
  }
  return allAncestors;
}
function getChildren(nodes, id) {
  let allChildren = nodes.filter((node) => {
    var _node$context;
    return node.parentId === id && ((_node$context = node.context) == null ? void 0 : _node$context.open);
  });
  let currentChildren = allChildren;
  while (currentChildren.length) {
    currentChildren = nodes.filter((node) => {
      var _currentChildren;
      return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some((n2) => {
        var _node$context2;
        return node.parentId === n2.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);
      });
    });
    allChildren = allChildren.concat(currentChildren);
  }
  return allChildren;
}
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledElementsSet = /* @__PURE__ */ new WeakSet();
var markerMap = {};
var lockCount$1 = 0;
var supportsInert = () => typeof HTMLElement !== "undefined" && "inert" in HTMLElement.prototype;
var unwrapHost = (node) => node && (node.host || unwrapHost(node.parentNode));
var correctElements = (parent, targets) => targets.map((target) => {
  if (parent.contains(target)) {
    return target;
  }
  const correctedTarget = unwrapHost(target);
  if (parent.contains(correctedTarget)) {
    return correctedTarget;
  }
  return null;
}).filter((x) => x != null);
function applyAttributeToOthers(uncorrectedAvoidElements, body, ariaHidden, inert) {
  const markerName = "data-floating-ui-inert";
  const controlAttribute = inert ? "inert" : ariaHidden ? "aria-hidden" : null;
  const avoidElements = correctElements(body, uncorrectedAvoidElements);
  const elementsToKeep = /* @__PURE__ */ new Set();
  const elementsToStop = new Set(avoidElements);
  const hiddenElements = [];
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  const markerCounter = markerMap[markerName];
  avoidElements.forEach(keep);
  deep(body);
  elementsToKeep.clear();
  function keep(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    el.parentNode && keep(el.parentNode);
  }
  function deep(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    [].forEach.call(parent.children, (node) => {
      if (getNodeName(node) === "script") return;
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        const attr2 = controlAttribute ? node.getAttribute(controlAttribute) : null;
        const alreadyHidden = attr2 !== null && attr2 !== "false";
        const counterValue = (counterMap.get(node) || 0) + 1;
        const markerValue = (markerCounter.get(node) || 0) + 1;
        counterMap.set(node, counterValue);
        markerCounter.set(node, markerValue);
        hiddenElements.push(node);
        if (counterValue === 1 && alreadyHidden) {
          uncontrolledElementsSet.add(node);
        }
        if (markerValue === 1) {
          node.setAttribute(markerName, "");
        }
        if (!alreadyHidden && controlAttribute) {
          node.setAttribute(controlAttribute, "true");
        }
      }
    });
  }
  lockCount$1++;
  return () => {
    hiddenElements.forEach((element) => {
      const counterValue = (counterMap.get(element) || 0) - 1;
      const markerValue = (markerCounter.get(element) || 0) - 1;
      counterMap.set(element, counterValue);
      markerCounter.set(element, markerValue);
      if (!counterValue) {
        if (!uncontrolledElementsSet.has(element) && controlAttribute) {
          element.removeAttribute(controlAttribute);
        }
        uncontrolledElementsSet.delete(element);
      }
      if (!markerValue) {
        element.removeAttribute(markerName);
      }
    });
    lockCount$1--;
    if (!lockCount$1) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledElementsSet = /* @__PURE__ */ new WeakSet();
      markerMap = {};
    }
  };
}
function markOthers(avoidElements, ariaHidden, inert) {
  if (ariaHidden === void 0) {
    ariaHidden = false;
  }
  if (inert === void 0) {
    inert = false;
  }
  const body = getDocument(avoidElements[0]).body;
  return applyAttributeToOthers(avoidElements.concat(Array.from(body.querySelectorAll("[aria-live]"))), body, ariaHidden, inert);
}
var getTabbableOptions = () => ({
  getShadowRoot: true,
  displayCheck: (
    // JSDOM does not support the `tabbable` library. To solve this we can
    // check if `ResizeObserver` is a real function (not polyfilled), which
    // determines if the current environment is JSDOM-like.
    typeof ResizeObserver === "function" && ResizeObserver.toString().includes("[native code]") ? "full" : "none"
  )
});
function getTabbableIn(container, direction) {
  const allTabbable = tabbable(container, getTabbableOptions());
  if (direction === "prev") {
    allTabbable.reverse();
  }
  const activeIndex = allTabbable.indexOf(activeElement(getDocument(container)));
  const nextTabbableElements = allTabbable.slice(activeIndex + 1);
  return nextTabbableElements[0];
}
function getNextTabbable() {
  return getTabbableIn(document.body, "next");
}
function getPreviousTabbable() {
  return getTabbableIn(document.body, "prev");
}
function isOutsideEvent(event, container) {
  const containerElement = container || event.currentTarget;
  const relatedTarget = event.relatedTarget;
  return !relatedTarget || !contains(containerElement, relatedTarget);
}
var HIDDEN_STYLES = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "fixed",
  whiteSpace: "nowrap",
  width: "1px",
  top: 0,
  left: 0
};
var timeoutId;
function setActiveElementOnTab(event) {
  if (event.key === "Tab") {
    event.target;
    clearTimeout(timeoutId);
  }
}
var FocusGuard = React2.forwardRef(function FocusGuard2(props, ref) {
  const [role, setRole] = React2.useState();
  index2(() => {
    if (isSafari()) {
      setRole("button");
    }
    document.addEventListener("keydown", setActiveElementOnTab);
    return () => {
      document.removeEventListener("keydown", setActiveElementOnTab);
    };
  }, []);
  const restProps = {
    ref,
    tabIndex: 0,
    // Role is only for VoiceOver
    role,
    "aria-hidden": role ? void 0 : true,
    [createAttribute("focus-guard")]: "",
    style: HIDDEN_STYLES
  };
  return React2.createElement("span", _extends2({}, props, restProps));
});
var PortalContext = React2.createContext(null);
var attr = createAttribute("portal");
var usePortalContext = () => React2.useContext(PortalContext);
var FOCUSABLE_ATTRIBUTE = "data-floating-ui-focusable";
function getFloatingFocusElement(floatingElement) {
  if (!floatingElement) {
    return null;
  }
  return floatingElement.hasAttribute(FOCUSABLE_ATTRIBUTE) ? floatingElement : floatingElement.querySelector("[" + FOCUSABLE_ATTRIBUTE + "]") || floatingElement;
}
var LIST_LIMIT = 20;
var previouslyFocusedElements = [];
function addPreviouslyFocusedElement(element) {
  previouslyFocusedElements = previouslyFocusedElements.filter((el) => el.isConnected);
  let tabbableEl = element;
  if (!tabbableEl || getNodeName(tabbableEl) === "body") return;
  if (!isTabbable(tabbableEl, getTabbableOptions())) {
    const tabbableChild = tabbable(tabbableEl, getTabbableOptions())[0];
    if (tabbableChild) {
      tabbableEl = tabbableChild;
    }
  }
  previouslyFocusedElements.push(tabbableEl);
  if (previouslyFocusedElements.length > LIST_LIMIT) {
    previouslyFocusedElements = previouslyFocusedElements.slice(-LIST_LIMIT);
  }
}
function getPreviouslyFocusedElement() {
  return previouslyFocusedElements.slice().reverse().find((el) => el.isConnected);
}
var VisuallyHiddenDismiss = React2.forwardRef(function VisuallyHiddenDismiss2(props, ref) {
  return React2.createElement("button", _extends2({}, props, {
    type: "button",
    ref,
    tabIndex: -1,
    style: HIDDEN_STYLES
  }));
});
function FloatingFocusManager(props) {
  const {
    context,
    children,
    disabled = false,
    order = ["content"],
    guards: _guards = true,
    initialFocus = 0,
    returnFocus = true,
    restoreFocus = false,
    modal = true,
    visuallyHiddenDismiss = false,
    closeOnFocusOut = true
  } = props;
  const {
    open,
    refs,
    nodeId,
    onOpenChange,
    events,
    dataRef,
    floatingId,
    elements: {
      domReference,
      floating
    }
  } = context;
  const ignoreInitialFocus = typeof initialFocus === "number" && initialFocus < 0;
  const isUntrappedTypeableCombobox = isTypeableCombobox(domReference) && ignoreInitialFocus;
  const guards = supportsInert() ? _guards : true;
  const orderRef = useLatestRef2(order);
  const initialFocusRef = useLatestRef2(initialFocus);
  const returnFocusRef = useLatestRef2(returnFocus);
  const tree = useFloatingTree();
  const portalContext = usePortalContext();
  const startDismissButtonRef = React2.useRef(null);
  const endDismissButtonRef = React2.useRef(null);
  const preventReturnFocusRef = React2.useRef(false);
  const isPointerDownRef = React2.useRef(false);
  const tabbableIndexRef = React2.useRef(-1);
  const isInsidePortal = portalContext != null;
  const floatingFocusElement = getFloatingFocusElement(floating);
  const getTabbableContent = useEffectEvent(function(container) {
    if (container === void 0) {
      container = floatingFocusElement;
    }
    return container ? tabbable(container, getTabbableOptions()) : [];
  });
  const getTabbableElements = useEffectEvent((container) => {
    const content = getTabbableContent(container);
    return orderRef.current.map((type) => {
      if (domReference && type === "reference") {
        return domReference;
      }
      if (floatingFocusElement && type === "floating") {
        return floatingFocusElement;
      }
      return content;
    }).filter(Boolean).flat();
  });
  React2.useEffect(() => {
    if (disabled) return;
    if (!modal) return;
    function onKeyDown(event) {
      if (event.key === "Tab") {
        if (contains(floatingFocusElement, activeElement(getDocument(floatingFocusElement))) && getTabbableContent().length === 0 && !isUntrappedTypeableCombobox) {
          stopEvent(event);
        }
        const els = getTabbableElements();
        const target = getTarget(event);
        if (orderRef.current[0] === "reference" && target === domReference) {
          stopEvent(event);
          if (event.shiftKey) {
            enqueueFocus(els[els.length - 1]);
          } else {
            enqueueFocus(els[1]);
          }
        }
        if (orderRef.current[1] === "floating" && target === floatingFocusElement && event.shiftKey) {
          stopEvent(event);
          enqueueFocus(els[0]);
        }
      }
    }
    const doc = getDocument(floatingFocusElement);
    doc.addEventListener("keydown", onKeyDown);
    return () => {
      doc.removeEventListener("keydown", onKeyDown);
    };
  }, [disabled, domReference, floatingFocusElement, modal, orderRef, isUntrappedTypeableCombobox, getTabbableContent, getTabbableElements]);
  React2.useEffect(() => {
    if (disabled) return;
    if (!floating) return;
    function handleFocusIn(event) {
      const target = getTarget(event);
      const tabbableContent = getTabbableContent();
      const tabbableIndex = tabbableContent.indexOf(target);
      if (tabbableIndex !== -1) {
        tabbableIndexRef.current = tabbableIndex;
      }
    }
    floating.addEventListener("focusin", handleFocusIn);
    return () => {
      floating.removeEventListener("focusin", handleFocusIn);
    };
  }, [disabled, floating, getTabbableContent]);
  React2.useEffect(() => {
    if (disabled) return;
    if (!closeOnFocusOut) return;
    function handlePointerDown() {
      isPointerDownRef.current = true;
      setTimeout(() => {
        isPointerDownRef.current = false;
      });
    }
    function handleFocusOutside(event) {
      const relatedTarget = event.relatedTarget;
      queueMicrotask(() => {
        const movedToUnrelatedNode = !(contains(domReference, relatedTarget) || contains(floating, relatedTarget) || contains(relatedTarget, floating) || contains(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || relatedTarget != null && relatedTarget.hasAttribute(createAttribute("focus-guard")) || tree && (getChildren(tree.nodesRef.current, nodeId).find((node) => {
          var _node$context, _node$context2;
          return contains((_node$context = node.context) == null ? void 0 : _node$context.elements.floating, relatedTarget) || contains((_node$context2 = node.context) == null ? void 0 : _node$context2.elements.domReference, relatedTarget);
        }) || getAncestors(tree.nodesRef.current, nodeId).find((node) => {
          var _node$context3, _node$context4;
          return ((_node$context3 = node.context) == null ? void 0 : _node$context3.elements.floating) === relatedTarget || ((_node$context4 = node.context) == null ? void 0 : _node$context4.elements.domReference) === relatedTarget;
        })));
        if (restoreFocus && movedToUnrelatedNode && activeElement(getDocument(floatingFocusElement)) === getDocument(floatingFocusElement).body) {
          if (isHTMLElement(floatingFocusElement)) {
            floatingFocusElement.focus();
          }
          const prevTabbableIndex = tabbableIndexRef.current;
          const tabbableContent = getTabbableContent();
          const nodeToFocus = tabbableContent[prevTabbableIndex] || tabbableContent[tabbableContent.length - 1] || floatingFocusElement;
          if (isHTMLElement(nodeToFocus)) {
            nodeToFocus.focus();
          }
        }
        if ((isUntrappedTypeableCombobox ? true : !modal) && relatedTarget && movedToUnrelatedNode && !isPointerDownRef.current && // Fix React 18 Strict Mode returnFocus due to double rendering.
        relatedTarget !== getPreviouslyFocusedElement()) {
          preventReturnFocusRef.current = true;
          onOpenChange(false, event, "focus-out");
        }
      });
    }
    if (floating && isHTMLElement(domReference)) {
      domReference.addEventListener("focusout", handleFocusOutside);
      domReference.addEventListener("pointerdown", handlePointerDown);
      floating.addEventListener("focusout", handleFocusOutside);
      return () => {
        domReference.removeEventListener("focusout", handleFocusOutside);
        domReference.removeEventListener("pointerdown", handlePointerDown);
        floating.removeEventListener("focusout", handleFocusOutside);
      };
    }
  }, [disabled, domReference, floating, floatingFocusElement, modal, nodeId, tree, portalContext, onOpenChange, closeOnFocusOut, restoreFocus, getTabbableContent, isUntrappedTypeableCombobox]);
  React2.useEffect(() => {
    var _portalContext$portal;
    if (disabled) return;
    const portalNodes = Array.from((portalContext == null || (_portalContext$portal = portalContext.portalNode) == null ? void 0 : _portalContext$portal.querySelectorAll("[" + createAttribute("portal") + "]")) || []);
    if (floating) {
      const insideElements = [floating, ...portalNodes, startDismissButtonRef.current, endDismissButtonRef.current, orderRef.current.includes("reference") || isUntrappedTypeableCombobox ? domReference : null].filter((x) => x != null);
      const cleanup2 = modal || isUntrappedTypeableCombobox ? markOthers(insideElements, guards, !guards) : markOthers(insideElements);
      return () => {
        cleanup2();
      };
    }
  }, [disabled, domReference, floating, modal, orderRef, portalContext, isUntrappedTypeableCombobox, guards]);
  index2(() => {
    if (disabled || !isHTMLElement(floatingFocusElement)) return;
    const doc = getDocument(floatingFocusElement);
    const previouslyFocusedElement = activeElement(doc);
    queueMicrotask(() => {
      const focusableElements = getTabbableElements(floatingFocusElement);
      const initialFocusValue = initialFocusRef.current;
      const elToFocus = (typeof initialFocusValue === "number" ? focusableElements[initialFocusValue] : initialFocusValue.current) || floatingFocusElement;
      const focusAlreadyInsideFloatingEl = contains(floatingFocusElement, previouslyFocusedElement);
      if (!ignoreInitialFocus && !focusAlreadyInsideFloatingEl && open) {
        enqueueFocus(elToFocus, {
          preventScroll: elToFocus === floatingFocusElement
        });
      }
    });
  }, [disabled, open, floatingFocusElement, ignoreInitialFocus, getTabbableElements, initialFocusRef]);
  index2(() => {
    if (disabled || !floatingFocusElement) return;
    let preventReturnFocusScroll = false;
    const doc = getDocument(floatingFocusElement);
    const previouslyFocusedElement = activeElement(doc);
    const contextData = dataRef.current;
    let openEvent = contextData.openEvent;
    addPreviouslyFocusedElement(previouslyFocusedElement);
    function onOpenChange2(_ref) {
      let {
        open: open2,
        reason,
        event,
        nested
      } = _ref;
      if (open2) {
        openEvent = event;
      }
      if (reason === "escape-key" && refs.domReference.current) {
        addPreviouslyFocusedElement(refs.domReference.current);
      }
      if (reason === "hover" && event.type === "mouseleave") {
        preventReturnFocusRef.current = true;
      }
      if (reason !== "outside-press") return;
      if (nested) {
        preventReturnFocusRef.current = false;
        preventReturnFocusScroll = true;
      } else {
        preventReturnFocusRef.current = !(isVirtualClick(event) || isVirtualPointerEvent(event));
      }
    }
    events.on("openchange", onOpenChange2);
    const fallbackEl = doc.createElement("span");
    fallbackEl.setAttribute("tabindex", "-1");
    fallbackEl.setAttribute("aria-hidden", "true");
    Object.assign(fallbackEl.style, HIDDEN_STYLES);
    if (isInsidePortal && domReference) {
      domReference.insertAdjacentElement("afterend", fallbackEl);
    }
    function getReturnElement() {
      if (typeof returnFocusRef.current === "boolean") {
        return getPreviouslyFocusedElement() || fallbackEl;
      }
      return returnFocusRef.current.current || fallbackEl;
    }
    return () => {
      events.off("openchange", onOpenChange2);
      const activeEl = activeElement(doc);
      const isFocusInsideFloatingTree = contains(floating, activeEl) || tree && getChildren(tree.nodesRef.current, nodeId).some((node) => {
        var _node$context5;
        return contains((_node$context5 = node.context) == null ? void 0 : _node$context5.elements.floating, activeEl);
      });
      const shouldFocusReference = isFocusInsideFloatingTree || openEvent && ["click", "mousedown"].includes(openEvent.type);
      if (shouldFocusReference && refs.domReference.current) {
        addPreviouslyFocusedElement(refs.domReference.current);
      }
      const returnElement = getReturnElement();
      queueMicrotask(() => {
        if (
          // eslint-disable-next-line react-hooks/exhaustive-deps
          returnFocusRef.current && !preventReturnFocusRef.current && isHTMLElement(returnElement) && // If the focus moved somewhere else after mount, avoid returning focus
          // since it likely entered a different element which should be
          // respected: https://github.com/floating-ui/floating-ui/issues/2607
          (returnElement !== activeEl && activeEl !== doc.body ? isFocusInsideFloatingTree : true)
        ) {
          returnElement.focus({
            preventScroll: preventReturnFocusScroll
          });
        }
        fallbackEl.remove();
      });
    };
  }, [disabled, floating, floatingFocusElement, returnFocusRef, dataRef, refs, events, tree, nodeId, isInsidePortal, domReference]);
  React2.useEffect(() => {
    queueMicrotask(() => {
      preventReturnFocusRef.current = false;
    });
  }, [disabled]);
  index2(() => {
    if (disabled) return;
    if (!portalContext) return;
    portalContext.setFocusManagerState({
      modal,
      closeOnFocusOut,
      open,
      onOpenChange,
      refs
    });
    return () => {
      portalContext.setFocusManagerState(null);
    };
  }, [disabled, portalContext, modal, open, onOpenChange, refs, closeOnFocusOut]);
  index2(() => {
    if (disabled) return;
    if (!floatingFocusElement) return;
    if (typeof MutationObserver !== "function") return;
    if (ignoreInitialFocus) return;
    const handleMutation = () => {
      const tabIndex = floatingFocusElement.getAttribute("tabindex");
      const tabbableContent = getTabbableContent();
      const activeEl = activeElement(getDocument(floating));
      const tabbableIndex = tabbableContent.indexOf(activeEl);
      if (tabbableIndex !== -1) {
        tabbableIndexRef.current = tabbableIndex;
      }
      if (orderRef.current.includes("floating") || activeEl !== refs.domReference.current && tabbableContent.length === 0) {
        if (tabIndex !== "0") {
          floatingFocusElement.setAttribute("tabindex", "0");
        }
      } else if (tabIndex !== "-1") {
        floatingFocusElement.setAttribute("tabindex", "-1");
      }
    };
    handleMutation();
    const observer = new MutationObserver(handleMutation);
    observer.observe(floatingFocusElement, {
      childList: true,
      subtree: true,
      attributes: true
    });
    return () => {
      observer.disconnect();
    };
  }, [disabled, floating, floatingFocusElement, refs, orderRef, getTabbableContent, ignoreInitialFocus]);
  function renderDismissButton(location) {
    if (disabled || !visuallyHiddenDismiss || !modal) {
      return null;
    }
    return React2.createElement(VisuallyHiddenDismiss, {
      ref: location === "start" ? startDismissButtonRef : endDismissButtonRef,
      onClick: (event) => onOpenChange(false, event.nativeEvent)
    }, typeof visuallyHiddenDismiss === "string" ? visuallyHiddenDismiss : "Dismiss");
  }
  const shouldRenderGuards = !disabled && guards && (modal ? !isUntrappedTypeableCombobox : true) && (isInsidePortal || modal);
  return React2.createElement(React2.Fragment, null, shouldRenderGuards && React2.createElement(FocusGuard, {
    "data-type": "inside",
    ref: portalContext == null ? void 0 : portalContext.beforeInsideRef,
    onFocus: (event) => {
      if (modal) {
        const els = getTabbableElements();
        enqueueFocus(order[0] === "reference" ? els[0] : els[els.length - 1]);
      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {
        preventReturnFocusRef.current = false;
        if (isOutsideEvent(event, portalContext.portalNode)) {
          const nextTabbable = getNextTabbable() || domReference;
          nextTabbable == null || nextTabbable.focus();
        } else {
          var _portalContext$before;
          (_portalContext$before = portalContext.beforeOutsideRef.current) == null || _portalContext$before.focus();
        }
      }
    }
  }), !isUntrappedTypeableCombobox && renderDismissButton("start"), children, renderDismissButton("end"), shouldRenderGuards && React2.createElement(FocusGuard, {
    "data-type": "inside",
    ref: portalContext == null ? void 0 : portalContext.afterInsideRef,
    onFocus: (event) => {
      if (modal) {
        enqueueFocus(getTabbableElements()[0]);
      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {
        if (closeOnFocusOut) {
          preventReturnFocusRef.current = true;
        }
        if (isOutsideEvent(event, portalContext.portalNode)) {
          const prevTabbable = getPreviousTabbable() || domReference;
          prevTabbable == null || prevTabbable.focus();
        } else {
          var _portalContext$afterO;
          (_portalContext$afterO = portalContext.afterOutsideRef.current) == null || _portalContext$afterO.focus();
        }
      }
    }
  }));
}
var lockCount = 0;
function enableScrollLock() {
  const isIOS = /iP(hone|ad|od)|iOS/.test(getPlatform());
  const bodyStyle = document.body.style;
  const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;
  const paddingProp = scrollbarX ? "paddingLeft" : "paddingRight";
  const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
  const scrollX = bodyStyle.left ? parseFloat(bodyStyle.left) : window.scrollX;
  const scrollY = bodyStyle.top ? parseFloat(bodyStyle.top) : window.scrollY;
  bodyStyle.overflow = "hidden";
  if (scrollbarWidth) {
    bodyStyle[paddingProp] = scrollbarWidth + "px";
  }
  if (isIOS) {
    var _window$visualViewpor, _window$visualViewpor2;
    const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;
    const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;
    Object.assign(bodyStyle, {
      position: "fixed",
      top: -(scrollY - Math.floor(offsetTop)) + "px",
      left: -(scrollX - Math.floor(offsetLeft)) + "px",
      right: "0"
    });
  }
  return () => {
    Object.assign(bodyStyle, {
      overflow: "",
      [paddingProp]: ""
    });
    if (isIOS) {
      Object.assign(bodyStyle, {
        position: "",
        top: "",
        left: "",
        right: ""
      });
      window.scrollTo(scrollX, scrollY);
    }
  };
}
var cleanup = () => {
};
var FloatingOverlay = React2.forwardRef(function FloatingOverlay2(props, ref) {
  const {
    lockScroll = false,
    ...rest3
  } = props;
  index2(() => {
    if (!lockScroll) return;
    lockCount++;
    if (lockCount === 1) {
      cleanup = enableScrollLock();
    }
    return () => {
      lockCount--;
      if (lockCount === 0) {
        cleanup();
      }
    };
  }, [lockScroll]);
  return React2.createElement("div", _extends2({
    ref
  }, rest3, {
    style: {
      position: "fixed",
      overflow: "auto",
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...rest3.style
    }
  }));
});
function useFloatingRootContext(options) {
  const {
    open = false,
    onOpenChange: onOpenChangeProp,
    elements: elementsProp
  } = options;
  const floatingId = useId2();
  const dataRef = React2.useRef({});
  const [events] = React2.useState(() => createPubSub());
  const nested = useFloatingParentNodeId() != null;
  if (true) {
    const optionDomReference = elementsProp.reference;
    if (optionDomReference && !isElement(optionDomReference)) {
      error("Cannot pass a virtual element to the `elements.reference` option,", "as it must be a real DOM element. Use `refs.setPositionReference()`", "instead.");
    }
  }
  const [positionReference, setPositionReference] = React2.useState(elementsProp.reference);
  const onOpenChange = useEffectEvent((open2, event, reason) => {
    dataRef.current.openEvent = open2 ? event : void 0;
    events.emit("openchange", {
      open: open2,
      event,
      reason,
      nested
    });
    onOpenChangeProp == null || onOpenChangeProp(open2, event, reason);
  });
  const refs = React2.useMemo(() => ({
    setPositionReference
  }), []);
  const elements = React2.useMemo(() => ({
    reference: positionReference || elementsProp.reference || null,
    floating: elementsProp.floating || null,
    domReference: elementsProp.reference
  }), [positionReference, elementsProp.reference, elementsProp.floating]);
  return React2.useMemo(() => ({
    dataRef,
    open,
    onOpenChange,
    elements,
    events,
    floatingId,
    refs
  }), [open, onOpenChange, elements, events, floatingId, refs]);
}
function useFloating2(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    nodeId
  } = options;
  const internalRootContext = useFloatingRootContext({
    ...options,
    elements: {
      reference: null,
      floating: null,
      ...options.elements
    }
  });
  const rootContext = options.rootContext || internalRootContext;
  const computedElements = rootContext.elements;
  const [_domReference, setDomReference] = React2.useState(null);
  const [positionReference, _setPositionReference] = React2.useState(null);
  const optionDomReference = computedElements == null ? void 0 : computedElements.domReference;
  const domReference = optionDomReference || _domReference;
  const domReferenceRef = React2.useRef(null);
  const tree = useFloatingTree();
  index2(() => {
    if (domReference) {
      domReferenceRef.current = domReference;
    }
  }, [domReference]);
  const position = useFloating({
    ...options,
    elements: {
      ...computedElements,
      ...positionReference && {
        reference: positionReference
      }
    }
  });
  const setPositionReference = React2.useCallback((node) => {
    const computedPositionReference = isElement(node) ? {
      getBoundingClientRect: () => node.getBoundingClientRect(),
      contextElement: node
    } : node;
    _setPositionReference(computedPositionReference);
    position.refs.setReference(computedPositionReference);
  }, [position.refs]);
  const setReference = React2.useCallback((node) => {
    if (isElement(node) || node === null) {
      domReferenceRef.current = node;
      setDomReference(node);
    }
    if (isElement(position.refs.reference.current) || position.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    node !== null && !isElement(node)) {
      position.refs.setReference(node);
    }
  }, [position.refs]);
  const refs = React2.useMemo(() => ({
    ...position.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position.refs, setReference, setPositionReference]);
  const elements = React2.useMemo(() => ({
    ...position.elements,
    domReference
  }), [position.elements, domReference]);
  const context = React2.useMemo(() => ({
    ...position,
    ...rootContext,
    refs,
    elements,
    nodeId
  }), [position, refs, elements, nodeId, rootContext]);
  index2(() => {
    rootContext.dataRef.current.floatingContext = context;
    const node = tree == null ? void 0 : tree.nodesRef.current.find((node2) => node2.id === nodeId);
    if (node) {
      node.context = context;
    }
  });
  return React2.useMemo(() => ({
    ...position,
    context,
    refs,
    elements
  }), [position, refs, elements, context]);
}
var ACTIVE_KEY = "active";
var SELECTED_KEY = "selected";
function mergeProps(userProps, propsList, elementKey) {
  const map2 = /* @__PURE__ */ new Map();
  const isItem = elementKey === "item";
  let domUserProps = userProps;
  if (isItem && userProps) {
    const {
      [ACTIVE_KEY]: _,
      [SELECTED_KEY]: __,
      ...validProps
    } = userProps;
    domUserProps = validProps;
  }
  return {
    ...elementKey === "floating" && {
      tabIndex: -1,
      [FOCUSABLE_ATTRIBUTE]: ""
    },
    ...domUserProps,
    ...propsList.map((value) => {
      const propsOrGetProps = value ? value[elementKey] : null;
      if (typeof propsOrGetProps === "function") {
        return userProps ? propsOrGetProps(userProps) : null;
      }
      return propsOrGetProps;
    }).concat(userProps).reduce((acc, props) => {
      if (!props) {
        return acc;
      }
      Object.entries(props).forEach((_ref) => {
        let [key, value] = _ref;
        if (isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)) {
          return;
        }
        if (key.indexOf("on") === 0) {
          if (!map2.has(key)) {
            map2.set(key, []);
          }
          if (typeof value === "function") {
            var _map$get;
            (_map$get = map2.get(key)) == null || _map$get.push(value);
            acc[key] = function() {
              var _map$get2;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return (_map$get2 = map2.get(key)) == null ? void 0 : _map$get2.map((fn) => fn(...args)).find((val) => val !== void 0);
            };
          }
        } else {
          acc[key] = value;
        }
      });
      return acc;
    }, {})
  };
}
function useInteractions(propsList) {
  if (propsList === void 0) {
    propsList = [];
  }
  const referenceDeps = propsList.map((key) => key == null ? void 0 : key.reference);
  const floatingDeps = propsList.map((key) => key == null ? void 0 : key.floating);
  const itemDeps = propsList.map((key) => key == null ? void 0 : key.item);
  const getReferenceProps = React2.useCallback(
    (userProps) => mergeProps(userProps, propsList, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    referenceDeps
  );
  const getFloatingProps = React2.useCallback(
    (userProps) => mergeProps(userProps, propsList, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    floatingDeps
  );
  const getItemProps = React2.useCallback(
    (userProps) => mergeProps(userProps, propsList, "item"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    itemDeps
  );
  return React2.useMemo(() => ({
    getReferenceProps,
    getFloatingProps,
    getItemProps
  }), [getReferenceProps, getFloatingProps, getItemProps]);
}
function isPointInPolygon(point, polygon) {
  const [x, y] = point;
  let isInside2 = false;
  const length = polygon.length;
  for (let i = 0, j = length - 1; i < length; j = i++) {
    const [xi, yi] = polygon[i] || [0, 0];
    const [xj, yj] = polygon[j] || [0, 0];
    const intersect = yi >= y !== yj >= y && x <= (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect) {
      isInside2 = !isInside2;
    }
  }
  return isInside2;
}
function isInside(point, rect) {
  return point[0] >= rect.x && point[0] <= rect.x + rect.width && point[1] >= rect.y && point[1] <= rect.y + rect.height;
}
function safePolygon(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    buffer = 0.5,
    blockPointerEvents = false,
    requireIntent = true
  } = options;
  let timeoutId2;
  let hasLanded = false;
  let lastX = null;
  let lastY = null;
  let lastCursorTime = performance.now();
  function getCursorSpeed(x, y) {
    const currentTime = performance.now();
    const elapsedTime = currentTime - lastCursorTime;
    if (lastX === null || lastY === null || elapsedTime === 0) {
      lastX = x;
      lastY = y;
      lastCursorTime = currentTime;
      return null;
    }
    const deltaX = x - lastX;
    const deltaY = y - lastY;
    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    const speed = distance / elapsedTime;
    lastX = x;
    lastY = y;
    lastCursorTime = currentTime;
    return speed;
  }
  const fn = (_ref) => {
    let {
      x,
      y,
      placement,
      elements,
      onClose,
      nodeId,
      tree
    } = _ref;
    return function onMouseMove(event) {
      function close() {
        clearTimeout(timeoutId2);
        onClose();
      }
      clearTimeout(timeoutId2);
      if (!elements.domReference || !elements.floating || placement == null || x == null || y == null) {
        return;
      }
      const {
        clientX,
        clientY
      } = event;
      const clientPoint = [clientX, clientY];
      const target = getTarget(event);
      const isLeave = event.type === "mouseleave";
      const isOverFloatingEl = contains(elements.floating, target);
      const isOverReferenceEl = contains(elements.domReference, target);
      const refRect = elements.domReference.getBoundingClientRect();
      const rect = elements.floating.getBoundingClientRect();
      const side = placement.split("-")[0];
      const cursorLeaveFromRight = x > rect.right - rect.width / 2;
      const cursorLeaveFromBottom = y > rect.bottom - rect.height / 2;
      const isOverReferenceRect = isInside(clientPoint, refRect);
      const isFloatingWider = rect.width > refRect.width;
      const isFloatingTaller = rect.height > refRect.height;
      const left = (isFloatingWider ? refRect : rect).left;
      const right = (isFloatingWider ? refRect : rect).right;
      const top = (isFloatingTaller ? refRect : rect).top;
      const bottom = (isFloatingTaller ? refRect : rect).bottom;
      if (isOverFloatingEl) {
        hasLanded = true;
        if (!isLeave) {
          return;
        }
      }
      if (isOverReferenceEl) {
        hasLanded = false;
      }
      if (isOverReferenceEl && !isLeave) {
        hasLanded = true;
        return;
      }
      if (isLeave && isElement(event.relatedTarget) && contains(elements.floating, event.relatedTarget)) {
        return;
      }
      if (tree && getChildren(tree.nodesRef.current, nodeId).some((_ref2) => {
        let {
          context
        } = _ref2;
        return context == null ? void 0 : context.open;
      })) {
        return;
      }
      if (side === "top" && y >= refRect.bottom - 1 || side === "bottom" && y <= refRect.top + 1 || side === "left" && x >= refRect.right - 1 || side === "right" && x <= refRect.left + 1) {
        return close();
      }
      let rectPoly = [];
      switch (side) {
        case "top":
          rectPoly = [[left, refRect.top + 1], [left, rect.bottom - 1], [right, rect.bottom - 1], [right, refRect.top + 1]];
          break;
        case "bottom":
          rectPoly = [[left, rect.top + 1], [left, refRect.bottom - 1], [right, refRect.bottom - 1], [right, rect.top + 1]];
          break;
        case "left":
          rectPoly = [[rect.right - 1, bottom], [rect.right - 1, top], [refRect.left + 1, top], [refRect.left + 1, bottom]];
          break;
        case "right":
          rectPoly = [[refRect.right - 1, bottom], [refRect.right - 1, top], [rect.left + 1, top], [rect.left + 1, bottom]];
          break;
      }
      function getPolygon(_ref3) {
        let [x2, y2] = _ref3;
        switch (side) {
          case "top": {
            const cursorPointOne = [isFloatingWider ? x2 + buffer / 2 : cursorLeaveFromRight ? x2 + buffer * 4 : x2 - buffer * 4, y2 + buffer + 1];
            const cursorPointTwo = [isFloatingWider ? x2 - buffer / 2 : cursorLeaveFromRight ? x2 + buffer * 4 : x2 - buffer * 4, y2 + buffer + 1];
            const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer]];
            return [cursorPointOne, cursorPointTwo, ...commonPoints];
          }
          case "bottom": {
            const cursorPointOne = [isFloatingWider ? x2 + buffer / 2 : cursorLeaveFromRight ? x2 + buffer * 4 : x2 - buffer * 4, y2 - buffer];
            const cursorPointTwo = [isFloatingWider ? x2 - buffer / 2 : cursorLeaveFromRight ? x2 + buffer * 4 : x2 - buffer * 4, y2 - buffer];
            const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer]];
            return [cursorPointOne, cursorPointTwo, ...commonPoints];
          }
          case "left": {
            const cursorPointOne = [x2 + buffer + 1, isFloatingTaller ? y2 + buffer / 2 : cursorLeaveFromBottom ? y2 + buffer * 4 : y2 - buffer * 4];
            const cursorPointTwo = [x2 + buffer + 1, isFloatingTaller ? y2 - buffer / 2 : cursorLeaveFromBottom ? y2 + buffer * 4 : y2 - buffer * 4];
            const commonPoints = [[cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer, rect.bottom]];
            return [...commonPoints, cursorPointOne, cursorPointTwo];
          }
          case "right": {
            const cursorPointOne = [x2 - buffer, isFloatingTaller ? y2 + buffer / 2 : cursorLeaveFromBottom ? y2 + buffer * 4 : y2 - buffer * 4];
            const cursorPointTwo = [x2 - buffer, isFloatingTaller ? y2 - buffer / 2 : cursorLeaveFromBottom ? y2 + buffer * 4 : y2 - buffer * 4];
            const commonPoints = [[cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer, rect.bottom]];
            return [cursorPointOne, cursorPointTwo, ...commonPoints];
          }
        }
      }
      if (isPointInPolygon([clientX, clientY], rectPoly)) {
        return;
      }
      if (hasLanded && !isOverReferenceRect) {
        return close();
      }
      if (!isLeave && requireIntent) {
        const cursorSpeed = getCursorSpeed(event.clientX, event.clientY);
        const cursorSpeedThreshold = 0.1;
        if (cursorSpeed !== null && cursorSpeed < cursorSpeedThreshold) {
          return close();
        }
      }
      if (!isPointInPolygon([clientX, clientY], getPolygon([x, y]))) {
        close();
      } else if (!hasLanded && requireIntent) {
        timeoutId2 = window.setTimeout(close, 40);
      }
    };
  };
  fn.__options = {
    blockPointerEvents
  };
  return fn;
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs.js
var sides2 = ["top", "right", "bottom", "left"];
var alignments2 = ["start", "end"];
var placements2 = sides2.reduce((acc, side) => acc.concat(side, side + "-" + alignments2[0], side + "-" + alignments2[1]), []);
function evaluate2(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function expandPaddingObject2(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject2(padding) {
  return typeof padding !== "number" ? expandPaddingObject2(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect2(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/node_modules/@floating-ui/core/dist/floating-ui.core.mjs.js
async function detectOverflow3(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate2(options, state);
  const paddingObject = getPaddingObject2(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect2(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect2(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides2.some((side) => overflow[side] >= 0);
}
var hide4 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate2(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow3(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow3(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs.js
var hide5 = hide4;

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FeatureFlags/index.js
var import_prop_types12 = __toESM(require_prop_types());
var import_react23 = __toESM(require_react());
var FeatureFlagContext = (0, import_react23.createContext)(FeatureFlags);
function FeatureFlags2(_ref) {
  let {
    children,
    flags = {},
    enableV12TileDefaultIcons = false,
    enableV12TileRadioIcons = false,
    enableV12Overflowmenu = false,
    enableTreeviewControllable = false,
    enableExperimentalFocusWrapWithoutSentinels = false,
    enableV12DynamicFloatingStyles = false
  } = _ref;
  const parentScope = (0, import_react23.useContext)(FeatureFlagContext);
  const [prevParentScope, setPrevParentScope] = (0, import_react23.useState)(parentScope);
  const combinedFlags = {
    "enable-v12-tile-default-icons": enableV12TileDefaultIcons,
    "enable-v12-tile-radio-icons": enableV12TileRadioIcons,
    "enable-v12-overflowmenu": enableV12Overflowmenu,
    "enable-treeview-controllable": enableTreeviewControllable,
    "enable-experimental-focus-wrap-without-sentinels": enableExperimentalFocusWrapWithoutSentinels,
    "enable-v12-dynamic-floating-styles": enableV12DynamicFloatingStyles,
    ...flags
  };
  const [scope, updateScope] = (0, import_react23.useState)(() => {
    const scope2 = createScope(combinedFlags);
    scope2.mergeWithScope(parentScope);
    return scope2;
  });
  if (parentScope !== prevParentScope) {
    const scope2 = createScope(combinedFlags);
    scope2.mergeWithScope(parentScope);
    updateScope(scope2);
    setPrevParentScope(parentScope);
  }
  useChangedValue(combinedFlags, isEqual, (changedFlags) => {
    const scope2 = createScope(changedFlags);
    scope2.mergeWithScope(parentScope);
    updateScope(scope2);
  });
  return import_react23.default.createElement(FeatureFlagContext.Provider, {
    value: scope
  }, children);
}
FeatureFlags2.propTypes = {
  children: import_prop_types12.default.node,
  /**
   * Provide the feature flags to enabled or disabled in the current Rea,ct tree
   */
  flags: deprecate(import_prop_types12.default.objectOf(import_prop_types12.default.bool), `The \`flags\` prop for \`FeatureFlag\` has been deprecated. Please run the \`featureflag-deprecate-flags-prop\` codemod to migrate to individual boolean props.npx @carbon/upgrade migrate featureflag-deprecate-flags-prop --write`),
  enableV12TileDefaultIcons: import_prop_types12.default.bool,
  enableV12TileRadioIcons: import_prop_types12.default.bool,
  enableV12Overflowmenu: import_prop_types12.default.bool,
  enableTreeviewControllable: import_prop_types12.default.bool,
  enableExperimentalFocusWrapWithoutSentinels: import_prop_types12.default.bool,
  enableV12DynamicFloatingStyles: import_prop_types12.default.bool
};
function useChangedValue(value, compare2, callback) {
  const initialRender = (0, import_react23.useRef)(false);
  const savedCallback = (0, import_react23.useRef)(callback);
  const [prevValue, setPrevValue] = (0, import_react23.useState)(value);
  if (!compare2(prevValue, value)) {
    setPrevValue(value);
  }
  (0, import_react23.useEffect)(() => {
    savedCallback.current = callback;
  });
  (0, import_react23.useEffect)(() => {
    if (initialRender.current) {
      savedCallback.current(prevValue);
    }
  }, [prevValue]);
  (0, import_react23.useEffect)(() => {
    initialRender.current = true;
  }, []);
}
function useFeatureFlag(flag) {
  const scope = (0, import_react23.useContext)(FeatureFlagContext);
  return scope.enabled(flag);
}
function useFeatureFlags() {
  return (0, import_react23.useContext)(FeatureFlagContext);
}
function isEqual(a, b) {
  if (a === b) {
    return true;
  }
  for (const key of Object.keys(a)) {
    if (a[key] !== b[key]) {
      return false;
    }
  }
  for (const key of Object.keys(b)) {
    if (b[key] !== a[key]) {
      return false;
    }
  }
  return true;
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Popover/index.js
var PopoverContext = import_react24.default.createContext({
  setFloating: {
    current: null
  },
  caretRef: {
    current: null
  },
  autoAlign: null
});
var propMappingFunction = (deprecatedValue) => {
  const mapping = {
    "top-left": "top-start",
    "top-right": "top-end",
    "bottom-left": "bottom-start",
    "bottom-right": "bottom-end",
    "left-bottom": "left-end",
    "left-top": "left-start",
    "right-bottom": "right-end",
    "right-top": "right-start"
  };
  return mapping[deprecatedValue];
};
var Popover = import_react24.default.forwardRef(function PopoverRenderFunction(_ref, forwardRef13) {
  var _a;
  let {
    isTabTip,
    align: initialAlign = isTabTip ? "bottom-start" : "bottom",
    as: BaseComponent = "span",
    autoAlign = false,
    autoAlignBoundary,
    caret = isTabTip ? false : true,
    className: customClassName,
    children,
    dropShadow = true,
    highContrast = false,
    onRequestClose,
    open,
    alignmentAxisOffset,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const floating = (0, import_react24.useRef)(null);
  const caretRef = (0, import_react24.useRef)(null);
  const popover = (0, import_react24.useRef)(null);
  const enableFloatingStyles = useFeatureFlag("enable-v12-dynamic-floating-styles") || autoAlign;
  let align = mapPopoverAlignProp(initialAlign);
  useWindowEvent("blur", () => {
    if (open) {
      onRequestClose == null ? void 0 : onRequestClose();
    }
  });
  useWindowEvent("click", (event) => {
    var _a2;
    if (open && !((_a2 = popover == null ? void 0 : popover.current) == null ? void 0 : _a2.contains(event.target))) {
      onRequestClose == null ? void 0 : onRequestClose();
    }
  });
  const initialCaretHeight = import_react24.default.Children.toArray(children).some((x) => {
    var _a2, _b, _c, _d;
    return ((_b = (_a2 = x == null ? void 0 : x.props) == null ? void 0 : _a2.className) == null ? void 0 : _b.includes("slug")) || ((_d = (_c = x == null ? void 0 : x.props) == null ? void 0 : _c.className) == null ? void 0 : _d.includes("ai-label"));
  }) ? 7 : 6;
  const popoverDimensions = (0, import_react24.useRef)({
    offset: 10,
    caretHeight: initialCaretHeight
  });
  useIsomorphicEffect$1(() => {
    if (caret && popover.current) {
      const getStyle = window.getComputedStyle(popover.current, null);
      const offsetProperty = getStyle.getPropertyValue("--cds-popover-offset");
      const caretProperty = getStyle.getPropertyValue("--cds-popover-caret-height");
      if (offsetProperty) {
        popoverDimensions.current.offset = offsetProperty.includes("px") ? Number(offsetProperty.split("px", 1)[0]) * 1 : Number(offsetProperty.split("rem", 1)[0]) * 16;
      }
      if (caretProperty) {
        popoverDimensions.current.caretHeight = caretProperty.includes("px") ? Number(caretProperty.split("px", 1)[0]) * 1 : Number(caretProperty.split("rem", 1)[0]) * 16;
      }
    }
  });
  const {
    refs,
    floatingStyles,
    placement,
    middlewareData
  } = useFloating2(
    enableFloatingStyles ? {
      placement: align,
      // The floating element is positioned relative to its nearest
      // containing block (usually the viewport). It will in many cases also
      // “break” the floating element out of a clipping ancestor.
      // https://floating-ui.com/docs/misc#clipping
      strategy: "fixed",
      // Middleware order matters, arrow should be last
      middleware: [offset3(!isTabTip ? {
        alignmentAxis: alignmentAxisOffset,
        mainAxis: (_a = popoverDimensions == null ? void 0 : popoverDimensions.current) == null ? void 0 : _a.offset
      } : 0), autoAlign && flip3({
        fallbackPlacements: align.includes("bottom") ? ["bottom", "bottom-start", "bottom-end", "right", "right-start", "right-end", "left", "left-start", "left-end", "top", "top-start", "top-end"] : ["top", "top-start", "top-end", "left", "left-start", "left-end", "right", "right-start", "right-end", "bottom", "bottom-start", "bottom-end"],
        fallbackStrategy: "initialPlacement",
        fallbackAxisSideDirection: "start",
        boundary: autoAlignBoundary
      }), arrow3({
        element: caretRef
      }), autoAlign && hide5()],
      whileElementsMounted: autoUpdate
    } : {}
    // When autoAlign is turned off & the `enable-v12-dynamic-floating-styles` feature flag is not
    // enabled, floating-ui will not be used
  );
  const value = (0, import_react24.useMemo)(() => {
    return {
      floating,
      setFloating: refs.setFloating,
      caretRef,
      autoAlign
    };
  }, [refs.setFloating, autoAlign]);
  if (isTabTip) {
    const tabTipAlignments = ["bottom-start", "bottom-end"];
    if (!tabTipAlignments.includes(align)) {
      align = "bottom-start";
    }
  }
  (0, import_react24.useEffect)(() => {
    var _a2, _b;
    if (enableFloatingStyles) {
      const updatedFloatingStyles = {
        ...floatingStyles,
        visibility: ((_a2 = middlewareData.hide) == null ? void 0 : _a2.referenceHidden) ? "hidden" : "visible"
      };
      Object.keys(updatedFloatingStyles).forEach((style) => {
        if (refs.floating.current) {
          refs.floating.current.style[style] = updatedFloatingStyles[style];
        }
      });
      if (caret && middlewareData && middlewareData.arrow && (caretRef == null ? void 0 : caretRef.current)) {
        const {
          x,
          y
        } = middlewareData.arrow;
        const staticSide = {
          top: "bottom",
          right: "left",
          bottom: "top",
          left: "right"
        }[placement.split("-")[0]];
        caretRef.current.style.left = x != null ? `${x}px` : "";
        caretRef.current.style.top = y != null ? `${y}px` : "";
        caretRef.current.style.right = "";
        caretRef.current.style.bottom = "";
        if (staticSide) {
          caretRef.current.style[staticSide] = `${-((_b = popoverDimensions == null ? void 0 : popoverDimensions.current) == null ? void 0 : _b.caretHeight)}px`;
        }
      }
    }
  }, [floatingStyles, refs.floating, enableFloatingStyles, middlewareData, placement, caret]);
  const ref = useMergedRefs([forwardRef13, popover]);
  const currentAlignment = autoAlign && placement !== align ? placement : align;
  const className = (0, import_classnames10.default)({
    [`${prefix}--popover-container`]: true,
    [`${prefix}--popover--caret`]: caret,
    [`${prefix}--popover--drop-shadow`]: dropShadow,
    [`${prefix}--popover--high-contrast`]: highContrast,
    [`${prefix}--popover--open`]: open,
    [`${prefix}--popover--auto-align ${prefix}--autoalign`]: enableFloatingStyles,
    [`${prefix}--popover--${currentAlignment}`]: true,
    [`${prefix}--popover--tab-tip`]: isTabTip
  }, customClassName);
  const mappedChildren = import_react24.default.Children.map(children, (child) => {
    var _a2, _b;
    const item = child;
    const displayName = (_a2 = item == null ? void 0 : item.type) == null ? void 0 : _a2.displayName;
    const isTriggerElement = (item == null ? void 0 : item.type) === "button";
    const isTriggerComponent = enableFloatingStyles && displayName && ["ToggletipButton"].includes(displayName);
    const isAllowedTriggerComponent = enableFloatingStyles && !["ToggletipContent", "PopoverContent"].includes(displayName);
    if (import_react24.default.isValidElement(item) && (isTriggerElement || isTriggerComponent || isAllowedTriggerComponent)) {
      const className2 = (_b = item == null ? void 0 : item.props) == null ? void 0 : _b.className;
      const ref2 = (item == null ? void 0 : item.props).ref;
      const tabTipClasses = (0, import_classnames10.default)(`${prefix}--popover--tab-tip__button`, className2);
      return import_react24.default.cloneElement(item, {
        className: isTabTip && (item == null ? void 0 : item.type) === "button" ? tabTipClasses : className2 || "",
        // With cloneElement, if you pass a `ref`, it overrides the original ref.
        // https://react.dev/reference/react/cloneElement#parameters
        // The block below works around this and ensures that the original ref is still
        // called while allowing the floating-ui reference element to be set as well.
        // `useMergedRefs` can't be used here because hooks can't be called from within a callback.
        // More here: https://github.com/facebook/react/issues/8873#issuecomment-489579878
        ref: (node) => {
          var _a3, _b2;
          if (enableFloatingStyles && ((_a3 = item == null ? void 0 : item.type) == null ? void 0 : _a3.displayName) !== "PopoverContent" || enableFloatingStyles && ((_b2 = item == null ? void 0 : item.type) == null ? void 0 : _b2.displayName) === "ToggletipButton") {
            refs.setReference(node);
          }
          if (typeof ref2 === "function") {
            ref2(node);
          } else if (ref2 !== null && ref2 !== void 0) {
            ref2.current = node;
          }
        }
      });
    } else {
      return item;
    }
  });
  const BaseComponentAsAny = BaseComponent;
  return import_react24.default.createElement(PopoverContext.Provider, {
    value
  }, import_react24.default.createElement(BaseComponentAsAny, _extends({}, rest3, {
    className,
    ref
  }), enableFloatingStyles || isTabTip ? mappedChildren : children));
});
if (true) {
  Popover.displayName = "Popover";
}
Popover.propTypes = {
  /**
   * Specify how the popover should align with the trigger element
   */
  align: deprecateValuesWithin(
    import_prop_types13.default.oneOf([
      "top",
      "top-left",
      // deprecated use top-start instead
      "top-right",
      // deprecated use top-end instead
      "bottom",
      "bottom-left",
      // deprecated use bottom-start instead
      "bottom-right",
      // deprecated use bottom-end instead
      "left",
      "left-bottom",
      // deprecated use left-end instead
      "left-top",
      // deprecated use left-start instead
      "right",
      "right-bottom",
      // deprecated use right-end instead
      "right-top",
      // deprecated use right-start instead
      // new values to match floating-ui
      "top-start",
      "top-end",
      "bottom-start",
      "bottom-end",
      "left-end",
      "left-start",
      "right-end",
      "right-start"
    ]),
    //allowed prop values
    ["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "left", "left-start", "left-end", "right", "right-start", "right-end"],
    //optional mapper function
    propMappingFunction
  ),
  /**
   * Provide a custom element or component to render the top-level node for the
   * component.
   */
  as: import_prop_types13.default.oneOfType([import_prop_types13.default.string, import_prop_types13.default.elementType]),
  /**
   * Will auto-align the popover on first render if it is not visible. This prop is currently experimental and is subject to future changes.
   */
  autoAlign: import_prop_types13.default.bool,
  /**
   * Specify a bounding element to be used for autoAlign calculations. The viewport is used by default. This prop is currently experimental and is subject to future changes.
   */
  autoAlignBoundary: import_prop_types13.default.oneOfType([import_prop_types13.default.oneOf(["clippingAncestors"]), import_prop_types13.default.elementType, import_prop_types13.default.arrayOf(import_prop_types13.default.elementType), import_prop_types13.default.exact({
    x: import_prop_types13.default.number.isRequired,
    y: import_prop_types13.default.number.isRequired,
    width: import_prop_types13.default.number.isRequired,
    height: import_prop_types13.default.number.isRequired
  })]),
  /**
   * Specify whether a caret should be rendered
   */
  caret: import_prop_types13.default.bool,
  /**
   * Provide elements to be rendered inside of the component
   */
  children: import_prop_types13.default.node,
  /**
   * Provide a custom class name to be added to the outermost node in the
   * component
   */
  className: import_prop_types13.default.string,
  /**
   * Specify whether a drop shadow should be rendered on the popover
   */
  dropShadow: import_prop_types13.default.bool,
  /**
   * Render the component using the high-contrast variant
   */
  highContrast: import_prop_types13.default.bool,
  /**
   * Render the component using the tab tip variant
   */
  isTabTip: import_prop_types13.default.bool,
  /**
   * Specify a handler for closing popover.
   * The handler should take care of closing the popover, e.g. changing the `open` prop.
   */
  onRequestClose: import_prop_types13.default.func,
  /**
   * Specify whether the component is currently open or closed
   */
  open: import_prop_types13.default.bool.isRequired
};
function PopoverContentRenderFunction(_ref2, forwardRef13) {
  let {
    className,
    children,
    ...rest3
  } = _ref2;
  const prefix = usePrefix();
  const {
    setFloating,
    caretRef,
    autoAlign
  } = import_react24.default.useContext(PopoverContext);
  const ref = useMergedRefs([setFloating, forwardRef13]);
  const enableFloatingStyles = useFeatureFlag("enable-v12-dynamic-floating-styles") || autoAlign;
  return import_react24.default.createElement("span", _extends({}, rest3, {
    className: `${prefix}--popover`
  }), import_react24.default.createElement("span", {
    className: (0, import_classnames10.default)(`${prefix}--popover-content`, className),
    ref
  }, children, enableFloatingStyles && import_react24.default.createElement("span", {
    className: (0, import_classnames10.default)({
      [`${prefix}--popover-caret`]: true,
      [`${prefix}--popover--auto-align`]: true
    }),
    ref: caretRef
  })), !enableFloatingStyles && import_react24.default.createElement("span", {
    className: (0, import_classnames10.default)({
      [`${prefix}--popover-caret`]: true
    }),
    ref: caretRef
  }));
}
var PopoverContent = import_react24.default.forwardRef(PopoverContentRenderFunction);
PopoverContent.displayName = "PopoverContent";
PopoverContent.propTypes = {
  /**
   * Provide elements to be rendered inside of the component
   */
  children: import_prop_types13.default.node,
  /**
   * Provide a custom class name to be added to the outermost node in the
   * component
   */
  className: import_prop_types13.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Tooltip/DefinitionTooltip.js
var DefinitionTooltip = (_ref) => {
  let {
    align = "bottom-start",
    className,
    children,
    definition,
    defaultOpen = false,
    id,
    openOnHover,
    tooltipText,
    triggerClassName,
    ...rest3
  } = _ref;
  const [isOpen, setOpen] = (0, import_react26.useState)(defaultOpen);
  const prefix = usePrefix();
  const tooltipId = useFallbackId(id);
  function onKeyDown(event) {
    if (isOpen && match(event, Escape)) {
      event.stopPropagation();
      setOpen(false);
    }
  }
  return import_react26.default.createElement(Popover, {
    align,
    className,
    dropShadow: false,
    highContrast: true,
    onMouseLeave: () => {
      setOpen(false);
    },
    onMouseEnter: () => {
      openOnHover ? setOpen(true) : null;
    },
    onFocus: () => {
      setOpen(true);
    },
    open: isOpen
  }, import_react26.default.createElement("button", _extends({}, rest3, {
    className: (0, import_classnames11.default)(`${prefix}--definition-term`, triggerClassName),
    "aria-controls": tooltipId,
    "aria-expanded": isOpen,
    onBlur: () => {
      setOpen(false);
    },
    onMouseDown: (event) => {
      if (event.button === 0) setOpen(!isOpen);
    },
    onKeyDown,
    type: "button"
  }), children), import_react26.default.createElement(PopoverContent, {
    className: `${prefix}--definition-tooltip`,
    id: tooltipId
  }, tooltipText ?? definition));
};
DefinitionTooltip.propTypes = {
  /**
   * Specify how the trigger should align with the tooltip
   */
  align: import_prop_types14.default.oneOf([
    "top",
    "top-left",
    // deprecated use top-start instead
    "top-right",
    // deprecated use top-end instead
    "bottom",
    "bottom-left",
    // deprecated use bottom-start instead
    "bottom-right",
    // deprecated use bottom-end instead
    "left",
    "left-bottom",
    // deprecated use left-end instead
    "left-top",
    // deprecated use left-start instead
    "right",
    "right-bottom",
    // deprecated use right-end instead
    "right-top",
    // deprecated use right-start instead
    // new values to match floating-ui
    "top-start",
    "top-end",
    "bottom-start",
    "bottom-end",
    "left-end",
    "left-start",
    "right-end",
    "right-start"
  ]),
  /**
   * The `children` prop will be used as the value that is being defined
   */
  children: import_prop_types14.default.node.isRequired,
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types14.default.string,
  /**
   * Specify whether the tooltip should be open when it first renders
   */
  defaultOpen: import_prop_types14.default.bool,
  /**
   * The `definition` prop is used as the content inside of the tooltip that
   * appears when a user interacts with the element rendered by the `children`
   * prop
   */
  definition: import_prop_types14.default.node.isRequired,
  /**
   * Provide a value that will be assigned as the id of the tooltip
   */
  id: import_prop_types14.default.string,
  /**
   * Specifies whether or not the `DefinitionTooltip` should open on hover or not
   */
  openOnHover: import_prop_types14.default.bool,
  /**
   * [Deprecated in v11] Please use the `definition` prop instead.
   *
   * Provide the text that will be displayed in the tooltip when it is rendered.
   */
  tooltipText: deprecate(import_prop_types14.default.node, "The tooltipText prop has been deprecated. Please use the `definition` prop instead."),
  /**
   * The CSS class name of the trigger element
   */
  triggerClassName: import_prop_types14.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Tooltip/Tooltip.js
var import_classnames12 = __toESM(require_classnames());
var import_prop_types15 = __toESM(require_prop_types());
var import_react29 = __toESM(require_react());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/internal/useDelayedState.js
var import_react27 = __toESM(require_react());
function useDelayedState(initialState) {
  const [state, setState] = (0, import_react27.useState)(initialState);
  const timeoutId2 = (0, import_react27.useRef)(null);
  const setStateWithDelay = (0, import_react27.useCallback)(function(stateToSet) {
    let delayMs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    window.clearTimeout(timeoutId2.current ?? void 0);
    timeoutId2.current = null;
    if (delayMs === 0) {
      setState(stateToSet);
      return;
    }
    timeoutId2.current = window.setTimeout(() => {
      setState(stateToSet);
      timeoutId2.current = null;
    }, delayMs);
  }, []);
  (0, import_react27.useEffect)(() => {
    return () => {
      window.clearTimeout(timeoutId2.current ?? void 0);
    };
  }, []);
  return [state, setStateWithDelay];
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/internal/useNoInteractiveChildren.js
var import_react28 = __toESM(require_react());
function useNoInteractiveChildren(ref) {
  let message = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "component should have no interactive child nodes";
  if (true) {
    (0, import_react28.useEffect)(() => {
      const node = ref.current ? getInteractiveContent(ref.current) : false;
      if (node) {
        throw new Error(`Error: ${message}.

Instead found: ${node.outerHTML}`);
      }
    });
  }
}
function useInteractiveChildrenNeedDescription(ref) {
  let message = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : `interactive child node(s) should have an \`aria-describedby\` property`;
  if (true) {
    (0, import_react28.useEffect)(() => {
      const node = ref.current ? getInteractiveContent(ref.current) : false;
      if (node && !node.hasAttribute("aria-describedby")) {
        throw new Error(`Error: ${message}.

Instead found: ${node.outerHTML}`);
      }
    });
  }
}
function getInteractiveContent(node) {
  if (!node || !node.childNodes) {
    return null;
  }
  if (isFocusable(node)) {
    return node;
  }
  for (const childNode of node.childNodes) {
    const interactiveNode = getInteractiveContent(childNode);
    if (interactiveNode) {
      return interactiveNode;
    }
  }
  return null;
}
function getRoleContent(node) {
  var _a;
  if (!node || !node.childNodes) {
    return null;
  }
  if (((_a = node == null ? void 0 : node.getAttribute) == null ? void 0 : _a.call(node, "role")) && node.getAttribute("role") !== "") {
    return node;
  }
  for (const childNode of node.childNodes) {
    const roleNode = getRoleContent(childNode);
    if (roleNode) {
      return roleNode;
    }
  }
  return null;
}
function isFocusable(element) {
  if (element.tabIndex === void 0 || element.tabIndex < 0) {
    return false;
  }
  if (element.disabled) {
    return false;
  }
  switch (element.nodeName) {
    case "A":
      return !!element.href && element.rel !== "ignore";
    case "INPUT":
      return element.type !== "hidden";
    default:
      return true;
  }
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Tooltip/Tooltip.js
var DRAG_STOP_EVENT_TYPES = /* @__PURE__ */ new Set(["mouseup", "touchend", "touchcancel"]);
function Tooltip(_ref) {
  let {
    align = "top",
    className: customClassName,
    children,
    label,
    description,
    enterDelayMs = 100,
    leaveDelayMs = 300,
    defaultOpen = false,
    closeOnActivation = false,
    ...rest3
  } = _ref;
  const tooltipRef = (0, import_react29.useRef)(null);
  const [open, setOpen] = useDelayedState(defaultOpen);
  const [isDragging, setIsDragging] = (0, import_react29.useState)(false);
  const [focusByMouse, setFocusByMouse] = (0, import_react29.useState)(false);
  const [isPointerIntersecting, setIsPointerIntersecting] = (0, import_react29.useState)(false);
  const id = useId("tooltip");
  const prefix = usePrefix();
  const child = import_react29.default.Children.only(children);
  const triggerProps = {
    onFocus: () => !focusByMouse && setOpen(true),
    onBlur: () => {
      setOpen(false);
      setFocusByMouse(false);
    },
    onClick: () => closeOnActivation && setOpen(false),
    // This should be placed on the trigger in case the element is disabled
    onMouseEnter,
    onMouseLeave,
    onMouseDown,
    onMouseMove,
    onTouchStart: onDragStart
  };
  function getChildEventHandlers(childProps) {
    const eventHandlerFunctions = Object.keys(triggerProps).filter((prop) => prop.startsWith("on"));
    const eventHandlers = {};
    eventHandlerFunctions.forEach((functionName) => {
      eventHandlers[functionName] = (evt) => {
        triggerProps[functionName](evt);
        if (childProps == null ? void 0 : childProps[functionName]) {
          childProps == null ? void 0 : childProps[functionName](evt);
        }
      };
    });
    return eventHandlers;
  }
  if (label) {
    triggerProps["aria-labelledby"] = id;
  } else {
    triggerProps["aria-describedby"] = id;
  }
  const onKeyDown = (0, import_react29.useCallback)((event) => {
    if (open && match(event, Escape)) {
      event.stopPropagation();
      setOpen(false);
    }
    if (open && closeOnActivation && (match(event, Enter) || match(event, Space))) {
      setOpen(false);
    }
  }, [closeOnActivation, open, setOpen]);
  useIsomorphicEffect$1(() => {
    if (!open) {
      return void 0;
    }
    function handleKeyDown(event) {
      if (match(event, Escape)) {
        onKeyDown(event);
      }
    }
    document.addEventListener("keydown", handleKeyDown);
    return () => {
      document.removeEventListener("keydown", handleKeyDown);
    };
  }, [open, onKeyDown]);
  function onMouseEnter() {
    if (!(rest3 == null ? void 0 : rest3.onMouseEnter)) {
      setIsPointerIntersecting(true);
      setOpen(true, enterDelayMs);
    }
  }
  function onMouseDown() {
    setFocusByMouse(true);
    onDragStart();
  }
  function onMouseLeave() {
    setIsPointerIntersecting(false);
    if (isDragging) {
      return;
    }
    setOpen(false, leaveDelayMs);
  }
  function onMouseMove(evt) {
    if (evt.buttons === 1) {
      setIsDragging(true);
    } else {
      setIsDragging(false);
    }
  }
  function onDragStart() {
    setIsDragging(true);
  }
  const onDragStop = (0, import_react29.useCallback)(() => {
    setIsDragging(false);
    if (!isPointerIntersecting) {
      setOpen(false, leaveDelayMs);
    }
  }, [isPointerIntersecting, leaveDelayMs, setOpen]);
  useNoInteractiveChildren(tooltipRef, "The Tooltip component must have no interactive content rendered by the`label` or `description` prop");
  (0, import_react29.useEffect)(() => {
    if (isDragging) {
      DRAG_STOP_EVENT_TYPES.forEach((eventType) => {
        document.addEventListener(eventType, onDragStop);
      });
    }
    return () => {
      DRAG_STOP_EVENT_TYPES.forEach((eventType) => {
        document.removeEventListener(eventType, onDragStop);
      });
    };
  }, [isDragging, onDragStop]);
  return (
    // @ts-ignore-error Popover throws a TS error everytime is imported
    import_react29.default.createElement(Popover, _extends({}, rest3, {
      align,
      className: (0, import_classnames12.default)(`${prefix}--tooltip`, customClassName),
      dropShadow: false,
      highContrast: true,
      onKeyDown,
      onMouseLeave,
      open
    }), import_react29.default.createElement("div", {
      className: `${prefix}--tooltip-trigger__wrapper`
    }, child !== void 0 ? import_react29.default.cloneElement(child, {
      ...triggerProps,
      ...getChildEventHandlers(child.props)
    }) : null), import_react29.default.createElement(PopoverContent, {
      "aria-hidden": open ? "false" : "true",
      className: `${prefix}--tooltip-content`,
      id,
      onMouseEnter,
      role: "tooltip"
    }, label || description))
  );
}
Tooltip.propTypes = {
  /**
   * Specify how the trigger should align with the tooltip
   */
  align: import_prop_types15.default.oneOf([
    "top",
    "top-left",
    // deprecated use top-start instead
    "top-right",
    // deprecated use top-end instead
    "bottom",
    "bottom-left",
    // deprecated use bottom-start instead
    "bottom-right",
    // deprecated use bottom-end instead
    "left",
    "left-bottom",
    // deprecated use left-end instead
    "left-top",
    // deprecated use left-start instead
    "right",
    "right-bottom",
    // deprecated use right-end instead
    "right-top",
    // deprecated use right-start instead
    // new values to match floating-ui
    "top-start",
    "top-end",
    "bottom-start",
    "bottom-end",
    "left-end",
    "left-start",
    "right-end",
    "right-start"
  ]),
  /**
   * Pass in the child to which the tooltip will be applied
   */
  children: import_prop_types15.default.node,
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types15.default.string,
  /**
   * Determines wether the tooltip should close when inner content is activated (click, Enter or Space)
   */
  closeOnActivation: import_prop_types15.default.bool,
  /**
   * Specify whether the tooltip should be open when it first renders
   */
  defaultOpen: import_prop_types15.default.bool,
  /**
   * Provide the description to be rendered inside of the Tooltip. The
   * description will use `aria-describedby` and will describe the child node
   * in addition to the text rendered inside of the child. This means that if you
   * have text in the child node, that it will be announced alongside the
   * description to the screen reader.
   *
   * Note: if label and description are both provided, label will be used and
   * description will not be used
   */
  description: import_prop_types15.default.node,
  /**
   * Specify the duration in milliseconds to delay before displaying the tooltip
   */
  enterDelayMs: import_prop_types15.default.number,
  /**
   * Provide the label to be rendered inside of the Tooltip. The label will use
   * `aria-labelledby` and will fully describe the child node that is provided.
   * This means that if you have text in the child node, that it will not be
   * announced to the screen reader.
   *
   * Note: if label and description are both provided, description will not be
   * used
   */
  label: import_prop_types15.default.node,
  /**
   * Specify the duration in milliseconds to delay before hiding the tooltip
   */
  leaveDelayMs: import_prop_types15.default.number
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Button/ButtonBase.js
var import_react30 = __toESM(require_react());
var import_classnames13 = __toESM(require_classnames());
var ButtonBase = import_react30.default.forwardRef(function ButtonBase2(_ref, ref) {
  let {
    as,
    children,
    className,
    dangerDescription = "danger",
    disabled = false,
    hasIconOnly = false,
    href,
    iconDescription,
    isExpressive = false,
    isSelected,
    kind = "primary",
    onBlur,
    onClick,
    onFocus,
    onMouseEnter,
    onMouseLeave,
    renderIcon: ButtonImageElement,
    size: size6,
    tabIndex,
    type = "button",
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const buttonClasses = (0, import_classnames13.default)(className, {
    [`${prefix}--btn`]: true,
    [`${prefix}--btn--sm`]: size6 === "sm" && !isExpressive,
    // TODO: V12 - Remove this class
    [`${prefix}--btn--md`]: size6 === "md" && !isExpressive,
    // TODO: V12 - Remove this class
    [`${prefix}--btn--xl`]: size6 === "xl",
    // TODO: V12 - Remove this class
    [`${prefix}--btn--2xl`]: size6 === "2xl",
    // TODO: V12 - Remove this class
    [`${prefix}--layout--size-${size6}`]: size6,
    [`${prefix}--btn--${kind}`]: kind,
    [`${prefix}--btn--disabled`]: disabled,
    [`${prefix}--btn--expressive`]: isExpressive,
    [`${prefix}--btn--icon-only`]: hasIconOnly && !(className == null ? void 0 : className.includes(`${prefix}--btn--icon-only`)),
    [`${prefix}--btn--selected`]: hasIconOnly && isSelected && kind === "ghost"
  });
  const commonProps = {
    tabIndex,
    className: buttonClasses,
    ref
  };
  const buttonImage = !ButtonImageElement ? null : import_react30.default.createElement(ButtonImageElement, {
    "aria-label": iconDescription,
    className: `${prefix}--btn__icon`,
    "aria-hidden": "true"
  });
  const dangerButtonVariants = ["danger", "danger--tertiary", "danger--ghost"];
  let component = "button";
  const assistiveId = useId("danger-description");
  const {
    "aria-pressed": ariaPressed,
    "aria-describedby": ariaDescribedBy
  } = rest3;
  let otherProps = {
    disabled,
    type,
    "aria-describedby": dangerButtonVariants.includes(kind) ? assistiveId : ariaDescribedBy || void 0,
    "aria-pressed": ariaPressed ?? (hasIconOnly && kind === "ghost" ? isSelected : void 0)
  };
  const anchorProps = {
    href
  };
  let assistiveText = null;
  if (dangerButtonVariants.includes(kind)) {
    assistiveText = import_react30.default.createElement("span", {
      id: assistiveId,
      className: `${prefix}--visually-hidden`
    }, dangerDescription);
  }
  if (as) {
    component = as;
    otherProps = {
      ...otherProps,
      ...anchorProps
    };
  } else if (href && !disabled) {
    component = "a";
    otherProps = anchorProps;
  }
  return import_react30.default.createElement(component, {
    onMouseEnter,
    onMouseLeave,
    onFocus,
    onBlur,
    onClick,
    ...rest3,
    ...commonProps,
    ...otherProps
  }, assistiveText, children, buttonImage);
});

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/IconButton/index.js
var IconButtonKinds = ["primary", "secondary", "ghost", "tertiary"];
var propMappingFunction2 = (deprecatedValue) => {
  const mapping = {
    "top-left": "top-start",
    "top-right": "top-end",
    "bottom-left": "bottom-start",
    "bottom-right": "bottom-end",
    "left-bottom": "left-end",
    "left-top": "left-start",
    "right-bottom": "right-end",
    "right-top": "right-start"
  };
  return mapping[deprecatedValue];
};
var IconButton = import_react31.default.forwardRef(function IconButton2(_ref, ref) {
  let {
    align,
    autoAlign = false,
    children,
    className,
    closeOnActivation = true,
    defaultOpen = false,
    disabled,
    enterDelayMs = 100,
    kind,
    label,
    leaveDelayMs = 100,
    wrapperClasses,
    size: size6,
    isSelected,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const tooltipClasses = (0, import_classnames14.default)(wrapperClasses, `${prefix}--icon-tooltip`, {
    [`${prefix}--icon-tooltip--disabled`]: disabled
  });
  return import_react31.default.createElement(Tooltip, {
    align,
    autoAlign,
    closeOnActivation,
    className: tooltipClasses,
    defaultOpen,
    enterDelayMs,
    label,
    leaveDelayMs
  }, import_react31.default.createElement(ButtonBase, _extends({}, rest3, {
    disabled,
    kind,
    ref,
    size: size6,
    className: (0, import_classnames14.default)(`${prefix}--btn--icon-only`, {
      [`${prefix}--btn--selected`]: isSelected
    }, className)
  }), children));
});
IconButton.propTypes = {
  /**
   * Specify how the trigger should align with the tooltip
   */
  align: deprecateValuesWithin(
    import_prop_types16.default.oneOf([
      "top",
      "top-left",
      // deprecated use top-start instead
      "top-right",
      // deprecated use top-end instead
      "bottom",
      "bottom-left",
      // deprecated use bottom-start instead
      "bottom-right",
      // deprecated use bottom-end instead
      "left",
      "left-bottom",
      // deprecated use left-end instead
      "left-top",
      // deprecated use left-start instead
      "right",
      "right-bottom",
      // deprecated use right-end instead
      "right-top",
      // deprecated use right-start instead
      // new values to match floating-ui
      "top-start",
      "top-end",
      "bottom-start",
      "bottom-end",
      "left-end",
      "left-start",
      "right-end",
      "right-start"
    ]),
    //allowed prop values
    ["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "left", "left-start", "left-end", "right", "right-start", "right-end"],
    //optional mapper function
    propMappingFunction2
  ),
  /**
   * **Experimental**: Will attempt to automatically align the tooltip
   */
  autoAlign: import_prop_types16.default.bool,
  /**
   * Optionally specify an href for your IconButton to become an `<a>` element
   */
  href: import_prop_types16.default.string,
  /**
   * Provide an icon or asset to be rendered inside of the IconButton
   */
  children: import_prop_types16.default.node,
  /**
   * Specify an optional className to be added to your Button
   */
  className: import_prop_types16.default.string,
  /**
   * Determines whether the tooltip should close when inner content is activated (click, Enter or Space)
   */
  closeOnActivation: import_prop_types16.default.bool,
  /**
   * Specify whether the tooltip should be open when it first renders
   */
  defaultOpen: import_prop_types16.default.bool,
  /**
   * Specify whether the Button should be disabled, or not
   */
  disabled: import_prop_types16.default.bool,
  /**
   * Specify the duration in milliseconds to delay before displaying the tooltip
   */
  enterDelayMs: import_prop_types16.default.number,
  /**
   * Specify whether the IconButton is currently selected
   */
  isSelected: import_prop_types16.default.bool,
  /**
   * Specify the type of button to be used as the base for the IconButton
   */
  kind: import_prop_types16.default.oneOf(IconButtonKinds),
  /**
   * Provide the label to be rendered inside of the Tooltip. The label will use
   * `aria-labelledby` and will fully describe the child node that is provided.
   * This means that if you have text in the child node it will not be
   * announced to the screen reader.
   */
  label: import_prop_types16.default.node.isRequired,
  /**
   * Specify the duration in milliseconds to delay before hiding the tooltip
   */
  leaveDelayMs: import_prop_types16.default.number,
  /**
   * Specify the size of the Button. Defaults to `md`.
   */
  size: import_prop_types16.default.oneOf(["sm", "md", "lg"]),
  /**
   * Specify an optional className to be added to your Tooltip wrapper
   */
  wrapperClasses: import_prop_types16.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/tools/events.js
var composeEventHandlers = (fns) => function(event) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  for (let i = 0; i < fns.length; i++) {
    if (event.defaultPrevented) {
      break;
    }
    const fn = fns[i];
    if (typeof fn === "function") {
      fn(event, ...args);
    }
  }
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Button/Button.js
var ButtonKinds = ["primary", "secondary", "danger", "ghost", "danger--primary", "danger--ghost", "danger--tertiary", "tertiary"];
var ButtonSizes = ["sm", "md", "lg", "xl", "2xl"];
var ButtonTooltipAlignments = ["start", "center", "end"];
var ButtonTooltipPositions = ["top", "right", "bottom", "left"];
function isIconOnlyButton(hasIconOnly, _kind) {
  if (hasIconOnly === true) {
    return true;
  }
  return false;
}
var Button = import_react32.default.forwardRef((props, ref) => {
  const tooltipRef = (0, import_react32.useRef)(null);
  const {
    as,
    autoAlign = false,
    children,
    hasIconOnly = false,
    iconDescription,
    kind = "primary",
    onBlur,
    onClick,
    onFocus,
    onMouseEnter,
    onMouseLeave,
    renderIcon: ButtonImageElement,
    size: size6,
    tooltipAlignment = "center",
    tooltipPosition = "top",
    ...rest3
  } = props;
  const handleClick2 = (evt) => {
    if (evt.target === tooltipRef.current) {
      evt.preventDefault();
    }
  };
  const iconOnlyImage = !ButtonImageElement ? null : import_react32.default.createElement(ButtonImageElement, null);
  if (!isIconOnlyButton(hasIconOnly)) {
    const {
      tooltipAlignment: tooltipAlignment2,
      ...propsWithoutTooltipAlignment
    } = props;
    return import_react32.default.createElement(ButtonBase, _extends({
      ref
    }, propsWithoutTooltipAlignment));
  } else {
    let align = void 0;
    if (tooltipPosition === "top" || tooltipPosition === "bottom") {
      if (tooltipAlignment === "center") {
        align = tooltipPosition;
      }
      if (tooltipAlignment === "end") {
        align = `${tooltipPosition}-end`;
      }
      if (tooltipAlignment === "start") {
        align = `${tooltipPosition}-start`;
      }
    }
    if (tooltipPosition === "right" || tooltipPosition === "left") {
      align = tooltipPosition;
    }
    return import_react32.default.createElement(IconButton, _extends({}, rest3, {
      ref,
      as,
      align,
      label: iconDescription,
      kind,
      size: size6,
      onMouseEnter,
      onMouseLeave,
      onFocus,
      onBlur,
      autoAlign,
      onClick: composeEventHandlers([onClick, handleClick2]),
      renderIcon: iconOnlyImage ? null : ButtonImageElement
      // avoid doubling the icon.
    }), iconOnlyImage ?? children);
  }
});
Button.displayName = "Button";
Button.propTypes = {
  /**
   * Specify how the button itself should be rendered.
   * Make sure to apply all props to the root node and render children appropriately
   */
  as: import_prop_types17.default.oneOfType([import_prop_types17.default.func, import_prop_types17.default.string, import_prop_types17.default.elementType]),
  /**
   * **Experimental**: Will attempt to automatically align the tooltip
   */
  autoAlign: import_prop_types17.default.bool,
  /**
   * Specify the content of your Button
   */
  children: import_prop_types17.default.node,
  /**
   * Specify an optional className to be added to your Button
   */
  className: import_prop_types17.default.string,
  /**
   * Specify the message read by screen readers for the danger button variant
   */
  dangerDescription: import_prop_types17.default.string,
  /**
   * Specify whether the Button should be disabled, or not
   */
  disabled: import_prop_types17.default.bool,
  /**
   * Specify if the button is an icon-only button
   */
  hasIconOnly: import_prop_types17.default.bool,
  /**
   * Optionally specify an href for your Button to become an `<a>` element
   */
  href: import_prop_types17.default.string,
  /**
   * If specifying the `renderIcon` prop, provide a description for that icon that can
   * be read by screen readers
   */
  iconDescription: (props) => {
    if (props.renderIcon && !props.children && !props.iconDescription) {
      return new Error("renderIcon property specified without also providing an iconDescription property.");
    }
    return null;
  },
  /**
   * Specify whether the Button is expressive, or not
   */
  isExpressive: import_prop_types17.default.bool,
  /**
   * Specify whether the Button is currently selected. Only applies to the Ghost variant.
   */
  isSelected: import_prop_types17.default.bool,
  /**
   * Specify the kind of Button you want to create
   */
  kind: (props, propName, componentName) => {
    const {
      hasIconOnly
    } = props;
    const validKinds = hasIconOnly ? IconButtonKinds : ButtonKinds;
    if (props[propName] === void 0) {
      return null;
    }
    if (!validKinds.includes(props[propName])) {
      return new Error(`Invalid prop \`${propName}\` supplied to \`${componentName}\`. Expected one of ${validKinds.join(", ")}.`);
    }
    return null;
  },
  /**
   * Provide an optional function to be called when the button element
   * loses focus
   */
  onBlur: import_prop_types17.default.func,
  /**
   * Provide an optional function to be called when the button element
   * is clicked
   */
  onClick: import_prop_types17.default.func,
  /**
   * Provide an optional function to be called when the button element
   * receives focus
   */
  onFocus: import_prop_types17.default.func,
  /**
   * Provide an optional function to be called when the mouse
   * enters the button element
   */
  onMouseEnter: import_prop_types17.default.func,
  /**
   * Provide an optional function to be called when the mouse
   * leaves the button element
   */
  onMouseLeave: import_prop_types17.default.func,
  /**
   * Optional prop to allow overriding the icon rendering.
   * Can be a React component class
   */
  renderIcon: import_prop_types17.default.oneOfType([import_prop_types17.default.func, import_prop_types17.default.object]),
  /**
   * Optional prop to specify the role of the Button
   */
  role: import_prop_types17.default.string,
  /**
   * Specify the size of the button, from the following list of sizes:
   */
  size: import_prop_types17.default.oneOf(["sm", "md", "lg", "xl", "2xl"]),
  /**
   * Optional prop to specify the tabIndex of the Button
   */
  tabIndex: import_prop_types17.default.number,
  /**
   * Specify the alignment of the tooltip to the icon-only button.
   * Can be one of: start, center, or end.
   */
  tooltipAlignment: import_prop_types17.default.oneOf(["start", "center", "end"]),
  /**
   * Specify the direction of the tooltip for icon-only buttons.
   * Can be either top, right, bottom, or left.
   */
  tooltipPosition: import_prop_types17.default.oneOf(["top", "right", "bottom", "left"]),
  /**
   * Optional prop to specify the type of the Button
   */
  type: import_prop_types17.default.oneOf(["button", "reset", "submit"])
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Button/Button.Skeleton.js
var import_prop_types18 = __toESM(require_prop_types());
var import_react33 = __toESM(require_react());
var import_classnames15 = __toESM(require_classnames());
var ButtonSkeleton = (_ref) => {
  let {
    className,
    small = false,
    href,
    size: size6 = "lg",
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const buttonClasses = (0, import_classnames15.default)(className, {
    [`${prefix}--skeleton`]: true,
    [`${prefix}--btn`]: true,
    [`${prefix}--btn--sm`]: small || size6 === "sm",
    [`${prefix}--btn--md`]: size6 === "md",
    [`${prefix}--btn--lg`]: size6 === "lg",
    [`${prefix}--btn--xl`]: size6 === "xl",
    [`${prefix}--btn--2xl`]: size6 === "2xl"
  });
  const commonProps = {
    className: buttonClasses,
    ...rest3
  };
  const button = import_react33.default.createElement("div", commonProps);
  const anchor = import_react33.default.createElement("a", _extends({}, commonProps, {
    href,
    role: "button"
  }));
  return href ? anchor : button;
};
ButtonSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types18.default.string,
  /**
   * Optionally specify an href for your Button to become an `<a>` element
   */
  href: import_prop_types18.default.string,
  /**
   * Specify the size of the button, from a list of available sizes.
   * For `default` buttons, this prop can remain unspecified or use `default`.
   * In the next major release of Carbon, `default`, `field`, and `small` will be removed
   */
  size: import_prop_types18.default.oneOf(["sm", "md", "lg", "xl", "2xl"]),
  /**
   * @deprecated This property will be removed in the next major Carbon version,
   * use size={sm} instead.
   *
   * Specify whether the Button should be a small variant
   */
  small: import_prop_types18.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ButtonSet/ButtonSet.js
var import_react34 = __toESM(require_react());
var import_prop_types19 = __toESM(require_prop_types());
var import_classnames16 = __toESM(require_classnames());
var ButtonSet = import_react34.default.forwardRef(function ButtonSet2(_ref, ref) {
  let {
    children,
    className,
    stacked,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const buttonSetClasses = (0, import_classnames16.default)(className, `${prefix}--btn-set`, {
    [`${prefix}--btn-set--stacked`]: stacked
  });
  return import_react34.default.createElement("div", _extends({}, rest3, {
    className: buttonSetClasses,
    ref
  }), children);
});
ButtonSet.displayName = "ButtonSet";
ButtonSet.propTypes = {
  /**
   * Specify the content of your ButtonSet
   */
  children: import_prop_types19.default.node,
  /**
   * Specify an optional className to be added to your ButtonSet
   */
  className: import_prop_types19.default.string,
  /**
   * Specify the button arrangement of the set (vertically stacked or
   * horizontal)
   */
  stacked: import_prop_types19.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Checkbox/Checkbox.js
var import_prop_types20 = __toESM(require_prop_types());
var import_react35 = __toESM(require_react());
var import_classnames17 = __toESM(require_classnames());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/internal/noopFn.js
var noopFn = () => {
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Checkbox/Checkbox.js
var Checkbox2 = import_react35.default.forwardRef((_ref, ref) => {
  var _a, _b;
  let {
    className,
    decorator,
    helperText,
    id,
    labelText,
    onChange = noopFn,
    onClick,
    indeterminate = false,
    invalid,
    invalidText,
    hideLabel,
    readOnly,
    title = "",
    warn: warn2,
    warnText,
    slug,
    ...other
  } = _ref;
  const prefix = usePrefix();
  const showWarning = !readOnly && !invalid && warn2;
  const showHelper = !invalid && !warn2;
  const checkboxGroupInstanceId = useId();
  const helperId = !helperText ? void 0 : `checkbox-helper-text-${checkboxGroupInstanceId}`;
  const helper = helperText ? import_react35.default.createElement("div", {
    id: helperId,
    className: `${prefix}--form__helper-text`
  }, helperText) : null;
  const wrapperClasses = (0, import_classnames17.default)(`${prefix}--form-item`, `${prefix}--checkbox-wrapper`, className, {
    [`${prefix}--checkbox-wrapper--readonly`]: readOnly,
    [`${prefix}--checkbox-wrapper--invalid`]: !readOnly && invalid,
    [`${prefix}--checkbox-wrapper--warning`]: showWarning,
    [`${prefix}--checkbox-wrapper--slug`]: slug,
    [`${prefix}--checkbox-wrapper--decorator`]: decorator
  });
  const innerLabelClasses = (0, import_classnames17.default)(`${prefix}--checkbox-label-text`, {
    [`${prefix}--visually-hidden`]: hideLabel
  });
  let normalizedDecorator = import_react35.default.isValidElement(slug ?? decorator) ? slug ?? decorator : null;
  if (normalizedDecorator && ((_a = normalizedDecorator["type"]) == null ? void 0 : _a.displayName) === "AILabel") {
    const size6 = ((_b = normalizedDecorator.props) == null ? void 0 : _b["kind"]) === "inline" ? "md" : "mini";
    normalizedDecorator = import_react35.default.cloneElement(normalizedDecorator, {
      size: size6
    });
  }
  return import_react35.default.createElement("div", {
    className: wrapperClasses
  }, import_react35.default.createElement("input", _extends({}, other, {
    type: "checkbox",
    "data-invalid": invalid ? true : void 0,
    onChange: (evt) => {
      if (!readOnly && onChange) {
        onChange(evt, {
          checked: evt.target.checked,
          id
        });
      }
    },
    className: `${prefix}--checkbox`,
    id,
    ref: (el) => {
      if (el) {
        el.indeterminate = indeterminate ?? false;
      }
      if (typeof ref === "function") {
        ref(el);
      } else if (ref && "current" in ref) {
        ref.current = el;
      }
    },
    "aria-readonly": readOnly,
    onClick: (evt) => {
      if (readOnly) {
        evt.preventDefault();
      }
      if (onClick) {
        onClick(evt);
      }
    }
  })), import_react35.default.createElement("label", {
    htmlFor: id,
    className: `${prefix}--checkbox-label`,
    title
  }, import_react35.default.createElement(Text, {
    className: innerLabelClasses
  }, labelText, slug ? normalizedDecorator : decorator ? import_react35.default.createElement("div", {
    className: `${prefix}--checkbox-wrapper-inner--decorator`
  }, normalizedDecorator) : "")), import_react35.default.createElement("div", {
    className: `${prefix}--checkbox__validation-msg`
  }, !readOnly && invalid && import_react35.default.createElement(import_react35.default.Fragment, null, import_react35.default.createElement(WarningFilled, {
    className: `${prefix}--checkbox__invalid-icon`
  }), import_react35.default.createElement("div", {
    className: `${prefix}--form-requirement`
  }, invalidText)), showWarning && import_react35.default.createElement(import_react35.default.Fragment, null, import_react35.default.createElement(WarningAltFilled, {
    className: `${prefix}--checkbox__invalid-icon ${prefix}--checkbox__invalid-icon--warning`
  }), import_react35.default.createElement("div", {
    className: `${prefix}--form-requirement`
  }, warnText))), showHelper && helper);
});
Checkbox2.propTypes = {
  /**
   * Specify whether the underlying input should be checked
   */
  checked: import_prop_types20.default.bool,
  /**
   * Specify an optional className to be applied to the <label> node
   */
  className: import_prop_types20.default.string,
  /**
   * **Experimental**: Provide a decorator component to be rendered inside the `Checkbox` component
   */
  decorator: import_prop_types20.default.node,
  /**
   * Specify whether the underlying input should be checked by default
   */
  defaultChecked: import_prop_types20.default.bool,
  /**
   * Specify whether the Checkbox should be disabled
   */
  disabled: import_prop_types20.default.bool,
  /**
   * Provide text for the form group for additional help
   */
  helperText: import_prop_types20.default.node,
  /**
   * Specify whether the label should be hidden, or not
   */
  hideLabel: import_prop_types20.default.bool,
  /**
   * Provide an `id` to uniquely identify the Checkbox input
   */
  id: import_prop_types20.default.string.isRequired,
  /**
   * Specify whether the Checkbox is in an indeterminate state
   */
  indeterminate: import_prop_types20.default.bool,
  /**
   * Specify whether the Checkbox is currently invalid
   */
  invalid: import_prop_types20.default.bool,
  /**
   * Provide the text that is displayed when the Checkbox is in an invalid state
   */
  invalidText: import_prop_types20.default.node,
  /**
   * Provide a label to provide a description of the Checkbox input that you are
   * exposing to the user
   */
  labelText: import_prop_types20.default.node.isRequired,
  /**
   * Provide an optional handler that is called when the internal state of
   * Checkbox changes. This handler is called with event and state info.
   * `(event, { checked, id }) => void`
   */
  onChange: import_prop_types20.default.func,
  /**
   * Specify whether the Checkbox is read-only
   */
  readOnly: import_prop_types20.default.bool,
  /**
   * **Experimental**: Provide a `Slug` component to be rendered inside the `Checkbox` component
   */
  slug: deprecate(import_prop_types20.default.node, "The `slug` prop has been deprecated and will be removed in the next major version. Use the decorator prop instead."),
  /**
   * Specify a title for the <label> node for the Checkbox
   */
  title: import_prop_types20.default.string,
  /**
   * Specify whether the Checkbox is currently in warning state
   */
  warn: import_prop_types20.default.bool,
  /**
   * Provide the text that is displayed when the Checkbox is in warning state
   */
  warnText: import_prop_types20.default.node
};
Checkbox2.displayName = "Checkbox";

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Checkbox/Checkbox.Skeleton.js
var import_prop_types21 = __toESM(require_prop_types());
var import_react36 = __toESM(require_react());
var import_classnames18 = __toESM(require_classnames());
var CheckboxSkeleton = (_ref) => {
  let {
    className,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  return import_react36.default.createElement("div", _extends({
    className: (0, import_classnames18.default)(`${prefix}--form-item`, `${prefix}--checkbox-wrapper`, `${prefix}--checkbox-skeleton`, className)
  }, rest3), import_react36.default.createElement("div", {
    className: `${prefix}--checkbox-label`
  }, import_react36.default.createElement("span", {
    className: `${prefix}--checkbox-label-text ${prefix}--skeleton`
  })));
};
CheckboxSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types21.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/CheckboxGroup/CheckboxGroup.js
var import_prop_types22 = __toESM(require_prop_types());
var import_react37 = __toESM(require_react());
var import_classnames19 = __toESM(require_classnames());
var CheckboxGroup = (_ref) => {
  var _a;
  let {
    children,
    className,
    decorator,
    helperText,
    invalid,
    invalidText,
    legendId,
    legendText,
    readOnly,
    warn: warn2,
    warnText,
    slug,
    orientation = "vertical",
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const showWarning = !readOnly && !invalid && warn2;
  const showHelper = !invalid && !warn2;
  const checkboxGroupInstanceId = useId();
  const helperId = !helperText ? void 0 : `checkbox-group-helper-text-${checkboxGroupInstanceId}`;
  const helper = helperText ? import_react37.default.createElement("div", {
    id: helperId,
    className: `${prefix}--form__helper-text`
  }, helperText) : null;
  const fieldsetClasses = (0, import_classnames19.default)(`${prefix}--checkbox-group`, className, {
    [`${prefix}--checkbox-group--${orientation}`]: orientation === "horizontal",
    [`${prefix}--checkbox-group--readonly`]: readOnly,
    [`${prefix}--checkbox-group--invalid`]: !readOnly && invalid,
    [`${prefix}--checkbox-group--warning`]: showWarning,
    [`${prefix}--checkbox-group--slug`]: slug,
    [`${prefix}--checkbox-group--decorator`]: decorator
  });
  let normalizedDecorator = import_react37.default.isValidElement(slug ?? decorator) ? slug ?? decorator : null;
  if (normalizedDecorator && ((_a = normalizedDecorator["type"]) == null ? void 0 : _a.displayName) === "AILabel") {
    normalizedDecorator = import_react37.default.cloneElement(normalizedDecorator, {
      size: "mini",
      kind: "default"
    });
  }
  return import_react37.default.createElement("fieldset", _extends({
    className: fieldsetClasses,
    "data-invalid": invalid ? true : void 0,
    "aria-labelledby": rest3["aria-labelledby"] || legendId,
    "aria-readonly": readOnly,
    "aria-describedby": !invalid && !warn2 && helper ? helperId : void 0
  }, rest3), import_react37.default.createElement("legend", {
    className: `${prefix}--label`,
    id: legendId || rest3["aria-labelledby"]
  }, legendText, slug ? normalizedDecorator : decorator ? import_react37.default.createElement("div", {
    className: `${prefix}--checkbox-group-inner--decorator`
  }, normalizedDecorator) : ""), children, import_react37.default.createElement("div", {
    className: `${prefix}--checkbox-group__validation-msg`
  }, !readOnly && invalid && import_react37.default.createElement(import_react37.default.Fragment, null, import_react37.default.createElement(WarningFilled, {
    className: `${prefix}--checkbox__invalid-icon`
  }), import_react37.default.createElement("div", {
    className: `${prefix}--form-requirement`
  }, invalidText)), showWarning && import_react37.default.createElement(import_react37.default.Fragment, null, import_react37.default.createElement(WarningAltFilled, {
    className: `${prefix}--checkbox__invalid-icon ${prefix}--checkbox__invalid-icon--warning`
  }), import_react37.default.createElement("div", {
    className: `${prefix}--form-requirement`
  }, warnText))), showHelper && helper);
};
CheckboxGroup.propTypes = {
  /**
   * Provide the children form elements to be rendered inside of the <fieldset>
   */
  children: import_prop_types22.default.node,
  /**
   * Provide a custom className to be applied to the containing <fieldset> node
   */
  className: import_prop_types22.default.string,
  /**
   * **Experimental**: Provide a decorator component to be rendered inside the `CheckboxGroup` component
   */
  decorator: import_prop_types22.default.node,
  /**
   * Provide text for the form group for additional help
   */
  helperText: import_prop_types22.default.node,
  /**
   * Specify whether the form group is currently invalid
   */
  invalid: import_prop_types22.default.bool,
  /**
   * Provide the text that is displayed when the form group is in an invalid state
   */
  invalidText: import_prop_types22.default.node,
  /**
   * Provide id for the fieldset <legend> which corresponds to the fieldset
   * `aria-labelledby`
   */
  legendId: import_prop_types22.default.node,
  /**
   * Provide the text to be rendered inside of the fieldset <legend>
   */
  legendText: import_prop_types22.default.node.isRequired,
  /**
   * Provide the orientation for how the checkbox should be displayed
   */
  orientation: import_prop_types22.default.oneOf(["horizontal", "vertical"]),
  /**
   * Whether the CheckboxGroup should be read-only
   */
  readOnly: import_prop_types22.default.bool,
  /**
   * **Experimental**: Provide a `Slug` component to be rendered inside the `CheckboxGroup` component
   */
  slug: deprecate(import_prop_types22.default.node, "The `slug` prop has been deprecated and will be removed in the next major version. Use the decorator prop instead."),
  /**
   * Specify whether the form group is currently in warning state
   */
  warn: import_prop_types22.default.bool,
  /**
   * Provide the text that is displayed when the form group is in warning state
   */
  warnText: import_prop_types22.default.node
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ClassPrefix/index.js
var import_prop_types23 = __toESM(require_prop_types());
var import_react38 = __toESM(require_react());
function ClassPrefix(_ref) {
  let {
    children,
    prefix
  } = _ref;
  return import_react38.default.createElement(PrefixContext.Provider, {
    value: prefix
  }, children);
}
ClassPrefix.propTypes = {
  children: import_prop_types23.default.node,
  /**
   * The value used to prefix the CSS selectors used by Carbon components
   */
  prefix: import_prop_types23.default.string.isRequired
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/CodeSnippet/CodeSnippet.js
var import_prop_types27 = __toESM(require_prop_types());
var import_react42 = __toESM(require_react());
var import_classnames23 = __toESM(require_classnames());
var import_polyfilled = __toESM(require_polyfilled());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Copy/Copy.js
var import_prop_types24 = __toESM(require_prop_types());
var import_react39 = __toESM(require_react());

// ../node_modules/.pnpm/es-toolkit@1.32.0/node_modules/es-toolkit/dist/function/partial.mjs
function partial(func, ...partialArgs) {
  return function(...providedArgs) {
    const args = [];
    let startIndex = 0;
    for (let i = 0; i < partialArgs.length; i++) {
      const arg = partialArgs[i];
      if (arg === partial.placeholder) {
        args.push(providedArgs[startIndex++]);
      } else {
        args.push(arg);
      }
    }
    for (let i = startIndex; i < providedArgs.length; i++) {
      args.push(providedArgs[i]);
    }
    return func.apply(this, args);
  };
}
var partialPlaceholder = Symbol("partial.placeholder");
partial.placeholder = partialPlaceholder;

// ../node_modules/.pnpm/es-toolkit@1.32.0/node_modules/es-toolkit/dist/function/partialRight.mjs
function partialRight(func, ...partialArgs) {
  return function(...providedArgs) {
    const placeholderLength = partialArgs.filter((arg) => arg === partialRightPlaceholder).length;
    const rangeLength = Math.max(providedArgs.length - placeholderLength, 0);
    const args = [];
    let providedIndex = 0;
    for (let i = 0; i < rangeLength; i++) {
      args.push(providedArgs[providedIndex++]);
    }
    for (let i = 0; i < partialArgs.length; i++) {
      const arg = partialArgs[i];
      if (arg === partialRight.placeholder) {
        args.push(providedArgs[providedIndex++]);
      } else {
        args.push(arg);
      }
    }
    return func.apply(this, args);
  };
}
var partialRightPlaceholder = Symbol("partialRight.placeholder");
partialRight.placeholder = partialRightPlaceholder;

// ../node_modules/.pnpm/es-toolkit@1.32.0/node_modules/es-toolkit/dist/function/retry.mjs
var DEFAULT_RETRIES = Number.POSITIVE_INFINITY;

// ../node_modules/.pnpm/es-toolkit@1.32.0/node_modules/es-toolkit/dist/string/words.mjs
var CASE_SPLIT_PATTERN = new RegExp("\\p{Lu}?\\p{Ll}+|[0-9]+|\\p{Lu}+(?!\\p{Ll})|\\p{Emoji_Presentation}|\\p{Extended_Pictographic}|\\p{L}+", "gu");

// ../node_modules/.pnpm/es-toolkit@1.32.0/node_modules/es-toolkit/dist/string/deburr.mjs
var deburrMap = new Map(Object.entries({
  Æ: "Ae",
  Ð: "D",
  Ø: "O",
  Þ: "Th",
  ß: "ss",
  æ: "ae",
  ð: "d",
  ø: "o",
  þ: "th",
  Đ: "D",
  đ: "d",
  Ħ: "H",
  ħ: "h",
  ı: "i",
  Ĳ: "IJ",
  ĳ: "ij",
  ĸ: "k",
  Ŀ: "L",
  ŀ: "l",
  Ł: "L",
  ł: "l",
  ŉ: "'n",
  Ŋ: "N",
  ŋ: "n",
  Œ: "Oe",
  œ: "oe",
  Ŧ: "T",
  ŧ: "t",
  ſ: "s"
}));

// ../node_modules/.pnpm/es-toolkit@1.32.0/node_modules/es-toolkit/dist/compat/array/sortedIndexBy.mjs
var MAX_ARRAY_LENGTH = 4294967295;
var MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1;

// ../node_modules/.pnpm/es-toolkit@1.32.0/node_modules/es-toolkit/dist/compat/array/sortedIndex.mjs
var MAX_ARRAY_LENGTH2 = 4294967295;
var HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH2 >>> 1;

// ../node_modules/.pnpm/es-toolkit@1.32.0/node_modules/es-toolkit/dist/compat/function/bind.mjs
function bind(func, thisObj, ...partialArgs) {
  const bound = function(...providedArgs) {
    const args = [];
    let startIndex = 0;
    for (let i = 0; i < partialArgs.length; i++) {
      const arg = partialArgs[i];
      if (arg === bind.placeholder) {
        args.push(providedArgs[startIndex++]);
      } else {
        args.push(arg);
      }
    }
    for (let i = startIndex; i < providedArgs.length; i++) {
      args.push(providedArgs[i]);
    }
    if (this instanceof bound) {
      return new func(...args);
    }
    return func.apply(thisObj, args);
  };
  return bound;
}
var bindPlaceholder = Symbol("bind.placeholder");
bind.placeholder = bindPlaceholder;

// ../node_modules/.pnpm/es-toolkit@1.32.0/node_modules/es-toolkit/dist/compat/function/bindKey.mjs
function bindKey(object, key, ...partialArgs) {
  const bound = function(...providedArgs) {
    const args = [];
    let startIndex = 0;
    for (let i = 0; i < partialArgs.length; i++) {
      const arg = partialArgs[i];
      if (arg === bindKey.placeholder) {
        args.push(providedArgs[startIndex++]);
      } else {
        args.push(arg);
      }
    }
    for (let i = startIndex; i < providedArgs.length; i++) {
      args.push(providedArgs[i]);
    }
    if (this instanceof bound) {
      return new object[key](...args);
    }
    return object[key].apply(object, args);
  };
  return bound;
}
var bindKeyPlaceholder = Symbol("bindKey.placeholder");
bindKey.placeholder = bindKeyPlaceholder;

// ../node_modules/.pnpm/es-toolkit@1.32.0/node_modules/es-toolkit/dist/compat/function/curry.mjs
function curry(func, arity = func.length, guard) {
  arity = guard ? func.length : arity;
  arity = Number.parseInt(arity, 10);
  if (Number.isNaN(arity) || arity < 1) {
    arity = 0;
  }
  const wrapper = function(...partialArgs) {
    const holders = partialArgs.filter((item) => item === curry.placeholder);
    const length = partialArgs.length - holders.length;
    if (length < arity) {
      return makeCurry(func, arity - length, partialArgs);
    }
    if (this instanceof wrapper) {
      return new func(...partialArgs);
    }
    return func.apply(this, partialArgs);
  };
  wrapper.placeholder = curryPlaceholder;
  return wrapper;
}
function makeCurry(func, arity, partialArgs) {
  function wrapper(...providedArgs) {
    const holders = providedArgs.filter((item) => item === curry.placeholder);
    const length = providedArgs.length - holders.length;
    providedArgs = composeArgs(providedArgs, partialArgs);
    if (length < arity) {
      return makeCurry(func, arity - length, providedArgs);
    }
    if (this instanceof wrapper) {
      return new func(...providedArgs);
    }
    return func.apply(this, providedArgs);
  }
  wrapper.placeholder = curryPlaceholder;
  return wrapper;
}
function composeArgs(providedArgs, partialArgs) {
  const args = [];
  let startIndex = 0;
  for (let i = 0; i < partialArgs.length; i++) {
    const arg = partialArgs[i];
    if (arg === curry.placeholder && startIndex < providedArgs.length) {
      args.push(providedArgs[startIndex++]);
    } else {
      args.push(arg);
    }
  }
  for (let i = startIndex; i < providedArgs.length; i++) {
    args.push(providedArgs[i]);
  }
  return args;
}
var curryPlaceholder = Symbol("curry.placeholder");
curry.placeholder = curryPlaceholder;

// ../node_modules/.pnpm/es-toolkit@1.32.0/node_modules/es-toolkit/dist/compat/function/curryRight.mjs
function curryRight(func, arity = func.length, guard) {
  arity = guard ? func.length : arity;
  arity = Number.parseInt(arity, 10);
  if (Number.isNaN(arity) || arity < 1) {
    arity = 0;
  }
  const wrapper = function(...partialArgs) {
    const holders = partialArgs.filter((item) => item === curryRight.placeholder);
    const length = partialArgs.length - holders.length;
    if (length < arity) {
      return makeCurryRight(func, arity - length, partialArgs);
    }
    if (this instanceof wrapper) {
      return new func(...partialArgs);
    }
    return func.apply(this, partialArgs);
  };
  wrapper.placeholder = curryRightPlaceholder;
  return wrapper;
}
function makeCurryRight(func, arity, partialArgs) {
  function wrapper(...providedArgs) {
    const holders = providedArgs.filter((item) => item === curryRight.placeholder);
    const length = providedArgs.length - holders.length;
    providedArgs = composeArgs2(providedArgs, partialArgs);
    if (length < arity) {
      return makeCurryRight(func, arity - length, providedArgs);
    }
    if (this instanceof wrapper) {
      return new func(...providedArgs);
    }
    return func.apply(this, providedArgs);
  }
  wrapper.placeholder = curryRightPlaceholder;
  return wrapper;
}
function composeArgs2(providedArgs, partialArgs) {
  const placeholderLength = partialArgs.filter((arg) => arg === curryRight.placeholder).length;
  const rangeLength = Math.max(providedArgs.length - placeholderLength, 0);
  const args = [];
  let providedIndex = 0;
  for (let i = 0; i < rangeLength; i++) {
    args.push(providedArgs[providedIndex++]);
  }
  for (let i = 0; i < partialArgs.length; i++) {
    const arg = partialArgs[i];
    if (arg === curryRight.placeholder) {
      if (providedIndex < providedArgs.length) {
        args.push(providedArgs[providedIndex++]);
      } else {
        args.push(arg);
      }
    } else {
      args.push(arg);
    }
  }
  return args;
}
var curryRightPlaceholder = Symbol("curryRight.placeholder");
curryRight.placeholder = curryRightPlaceholder;

// ../node_modules/.pnpm/es-toolkit@1.32.0/node_modules/es-toolkit/dist/function/debounce.mjs
function debounce(func, debounceMs, { signal, edges } = {}) {
  let pendingThis = void 0;
  let pendingArgs = null;
  const leading = edges != null && edges.includes("leading");
  const trailing = edges == null || edges.includes("trailing");
  const invoke2 = () => {
    if (pendingArgs !== null) {
      func.apply(pendingThis, pendingArgs);
      pendingThis = void 0;
      pendingArgs = null;
    }
  };
  const onTimerEnd = () => {
    if (trailing) {
      invoke2();
    }
    cancel();
  };
  let timeoutId2 = null;
  const schedule = () => {
    if (timeoutId2 != null) {
      clearTimeout(timeoutId2);
    }
    timeoutId2 = setTimeout(() => {
      timeoutId2 = null;
      onTimerEnd();
    }, debounceMs);
  };
  const cancelTimer = () => {
    if (timeoutId2 !== null) {
      clearTimeout(timeoutId2);
      timeoutId2 = null;
    }
  };
  const cancel = () => {
    cancelTimer();
    pendingThis = void 0;
    pendingArgs = null;
  };
  const flush = () => {
    cancelTimer();
    invoke2();
  };
  const debounced = function(...args) {
    if (signal == null ? void 0 : signal.aborted) {
      return;
    }
    pendingThis = this;
    pendingArgs = args;
    const isFirstCall = timeoutId2 == null;
    schedule();
    if (leading && isFirstCall) {
      invoke2();
    }
  };
  debounced.schedule = schedule;
  debounced.cancel = cancel;
  debounced.flush = flush;
  signal == null ? void 0 : signal.addEventListener("abort", cancel, { once: true });
  return debounced;
}

// ../node_modules/.pnpm/es-toolkit@1.32.0/node_modules/es-toolkit/dist/compat/function/debounce.mjs
function debounce2(func, debounceMs = 0, options = {}) {
  if (typeof options !== "object") {
    options = {};
  }
  const { signal, leading = false, trailing = true, maxWait } = options;
  const edges = Array(2);
  if (leading) {
    edges[0] = "leading";
  }
  if (trailing) {
    edges[1] = "trailing";
  }
  let result = void 0;
  let pendingAt = null;
  const _debounced = debounce(function(...args) {
    result = func.apply(this, args);
    pendingAt = null;
  }, debounceMs, { signal, edges });
  const debounced = function(...args) {
    if (maxWait != null) {
      if (pendingAt === null) {
        pendingAt = Date.now();
      } else {
        if (Date.now() - pendingAt >= maxWait) {
          result = func.apply(this, args);
          pendingAt = Date.now();
          _debounced.cancel();
          _debounced.schedule();
          return result;
        }
      }
    }
    _debounced.apply(this, args);
    return result;
  };
  const flush = () => {
    _debounced.flush();
    return result;
  };
  debounced.cancel = _debounced.cancel;
  debounced.flush = flush;
  return debounced;
}

// ../node_modules/.pnpm/es-toolkit@1.32.0/node_modules/es-toolkit/dist/compat/function/throttle.mjs
function throttle2(func, throttleMs = 0, options = {}) {
  if (typeof options !== "object") {
    options = {};
  }
  const { leading = true, trailing = true, signal } = options;
  return debounce2(func, throttleMs, {
    leading,
    trailing,
    signal,
    maxWait: throttleMs
  });
}

// ../node_modules/.pnpm/es-toolkit@1.32.0/node_modules/es-toolkit/dist/compat/_internal/MAX_SAFE_INTEGER.mjs
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Copy/Copy.js
var import_classnames20 = __toESM(require_classnames());
var propMappingFunction3 = (deprecatedValue) => {
  const mapping = {
    "top-left": "top-start",
    "top-right": "top-end",
    "bottom-left": "bottom-start",
    "bottom-right": "bottom-end",
    "left-bottom": "left-end",
    "left-top": "left-start",
    "right-bottom": "right-end",
    "right-top": "right-start"
  };
  return mapping[deprecatedValue];
};
function Copy2(_ref) {
  let {
    align = "bottom",
    autoAlign = false,
    children,
    className,
    feedback = "Copied!",
    feedbackTimeout = 2e3,
    onAnimationEnd,
    onClick = noopFn,
    ...other
  } = _ref;
  const [animation, setAnimation] = (0, import_react39.useState)("");
  const prefix = usePrefix();
  const classNames = (0, import_classnames20.default)(className, `${prefix}--copy`, {
    [`${prefix}--copy-btn--animating`]: animation,
    [`${prefix}--copy-btn--${animation}`]: animation
  });
  const handleFadeOut = (0, import_react39.useCallback)(debounce2(() => {
    setAnimation("fade-out");
  }, feedbackTimeout), [feedbackTimeout]);
  const handleClick2 = (0, import_react39.useCallback)(() => {
    setAnimation("fade-in");
    handleFadeOut();
  }, [handleFadeOut]);
  const handleAnimationEnd = (event) => {
    if (event.animationName === `${prefix}--hide-feedback`) {
      setAnimation("");
    }
  };
  (0, import_react39.useEffect)(() => () => {
    handleFadeOut.cancel();
  }, [handleFadeOut]);
  const initialLabel = other["aria-label"] ?? "";
  return import_react39.default.createElement(IconButton, _extends({
    closeOnActivation: false,
    align,
    autoAlign,
    className: classNames,
    label: animation ? feedback : initialLabel,
    onClick: composeEventHandlers([onClick, handleClick2]),
    onAnimationEnd: composeEventHandlers([onAnimationEnd, handleAnimationEnd])
  }, other, {
    "aria-label": !children && (animation ? feedback : other["aria-label"]) || void 0
  }), children);
}
Copy2.propTypes = {
  /**
   * Specify how the trigger should align with the tooltip
   */
  align: deprecateValuesWithin(
    import_prop_types24.default.oneOf([
      "top",
      "top-left",
      // deprecated use top-start instead
      "top-right",
      // deprecated use top-end instead
      "bottom",
      "bottom-left",
      // deprecated use bottom-start instead
      "bottom-right",
      // deprecated use bottom-end instead
      "left",
      "left-bottom",
      // deprecated use left-end instead
      "left-top",
      // deprecated use left-start instead
      "right",
      "right-bottom",
      // deprecated use right-end instead
      "right-top",
      // deprecated use right-start instead
      // new values to match floating-ui
      "top-start",
      "top-end",
      "bottom-start",
      "bottom-end",
      "left-end",
      "left-start",
      "right-end",
      "right-start"
    ]),
    //allowed prop values
    ["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "left", "left-start", "left-end", "right", "right-start", "right-end"],
    //optional mapper function
    propMappingFunction3
  ),
  /**
   * **Experimental**: Will attempt to automatically align the tooltip
   */
  autoAlign: import_prop_types24.default.bool,
  /**
   * Pass in content to be rendered in the underlying `<button>`
   */
  children: import_prop_types24.default.node,
  /**
   * Specify an optional className to be applied to the underlying `<button>`
   */
  className: import_prop_types24.default.string,
  /**
   * Specify the string that is displayed when the button is clicked and the
   * content is copied
   */
  feedback: import_prop_types24.default.string,
  /**
   * Specify the time it takes for the feedback message to timeout
   */
  feedbackTimeout: import_prop_types24.default.number,
  /**
   * Specify an optional `onAnimationEnd` handler that is called when the underlying
   * animation ends
   */
  onAnimationEnd: import_prop_types24.default.func,
  /**
   * Specify an optional `onClick` handler that is called when the underlying
   * `<button>` is clicked
   */
  onClick: import_prop_types24.default.func
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/CopyButton/CopyButton.js
var import_prop_types26 = __toESM(require_prop_types());
var import_react41 = __toESM(require_react());
var import_classnames22 = __toESM(require_classnames());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Layout/index.js
var import_classnames21 = __toESM(require_classnames());
var import_prop_types25 = __toESM(require_prop_types());
var import_react40 = __toESM(require_react());
var sizes = ["xs", "sm", "md", "lg", "xl", "2xl"];
var densities = ["condensed", "normal"];
var Layout = import_react40.default.forwardRef(function Layout2(_ref, forwardRef13) {
  let {
    as: BaseComponent = "div",
    children,
    className,
    density,
    size: size6,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const classes = (0, import_classnames21.default)(className, `${prefix}--layout`, {
    [`${prefix}--layout--size-${size6}`]: size6 && sizes.includes(size6),
    [`${prefix}--layout--density-${density}`]: density && densities.includes(density)
  });
  return import_react40.default.createElement(BaseComponent, _extends({}, rest3, {
    ref: forwardRef13,
    className: classes
  }), children);
});
Layout.propTypes = {
  /**
   * Specify a custom component or element to be rendered as the top-level
   * element in the component
   */
  as: import_prop_types25.default.oneOfType([import_prop_types25.default.func, import_prop_types25.default.string, import_prop_types25.default.elementType]),
  /**
   * Provide child elements to be rendered inside of `Layout`
   */
  children: import_prop_types25.default.node,
  /**
   * Provide a custom class name to be used on the outermost element rendered by
   * the component
   */
  className: import_prop_types25.default.string,
  /**
   * Specify the desired density of components within this layout
   */
  density: import_prop_types25.default.oneOf(densities),
  /**
   * Specify the desired size of components within this layout
   */
  size: import_prop_types25.default.oneOf(sizes)
};
var LayoutConstraint = import_react40.default.forwardRef(function Layout3(_ref2, forwardRef13) {
  let {
    as: BaseComponent = "div",
    children,
    className,
    density,
    size: size6,
    ...rest3
  } = _ref2;
  const prefix = usePrefix();
  const classes = (0, import_classnames21.default)(className, Object.entries({
    size: size6,
    density
  }).map((_ref3) => {
    let [group, constraints] = _ref3;
    return {
      [`${prefix}--layout-constraint--${group}__default-${constraints == null ? void 0 : constraints.default}`]: constraints == null ? void 0 : constraints.default,
      [`${prefix}--layout-constraint--${group}__min-${constraints == null ? void 0 : constraints.min}`]: constraints == null ? void 0 : constraints.min,
      [`${prefix}--layout-constraint--${group}__max-${constraints == null ? void 0 : constraints.max}`]: constraints == null ? void 0 : constraints.max
    };
  }));
  return import_react40.default.createElement(BaseComponent, _extends({}, rest3, {
    ref: forwardRef13,
    className: classes
  }), children);
});
LayoutConstraint.propTypes = {
  /**
   * Specify a custom component or element to be rendered as the top-level
   * element in the component
   */
  as: import_prop_types25.default.oneOfType([import_prop_types25.default.func, import_prop_types25.default.string, import_prop_types25.default.elementType]),
  /**
   * Provide child elements to be rendered inside of `LayoutConstraint`
   */
  children: import_prop_types25.default.node,
  /**
   * Provide a custom class name to be used on the outermost element rendered by
   * the component
   */
  className: import_prop_types25.default.string,
  /**
   * Specify the desired layout density constraints of this element's children
   */
  density: import_prop_types25.default.shape({
    min: import_prop_types25.default.oneOf(densities),
    default: import_prop_types25.default.oneOf(densities),
    max: import_prop_types25.default.oneOf(densities)
  }),
  /**
   * Specify the desired layout size constraints of this element's children
   */
  size: import_prop_types25.default.shape({
    min: import_prop_types25.default.oneOf(sizes),
    default: import_prop_types25.default.oneOf(sizes),
    max: import_prop_types25.default.oneOf(sizes)
  })
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/CopyButton/CopyButton.js
var propMappingFunction4 = (deprecatedValue) => {
  const mapping = {
    "top-left": "top-start",
    "top-right": "top-end",
    "bottom-left": "bottom-start",
    "bottom-right": "bottom-end",
    "left-bottom": "left-end",
    "left-top": "left-start",
    "right-bottom": "right-end",
    "right-top": "right-start"
  };
  return mapping[deprecatedValue];
};
function CopyButton(_ref) {
  let {
    align = "bottom",
    autoAlign = false,
    feedback = "Copied!",
    feedbackTimeout = 2e3,
    iconDescription = "Copy to clipboard",
    className,
    onClick = noopFn,
    ...other
  } = _ref;
  const prefix = usePrefix();
  return import_react41.default.createElement(LayoutConstraint, {
    size: {
      default: "md",
      max: "lg"
    }
  }, import_react41.default.createElement(Copy2, _extends({
    feedback,
    feedbackTimeout,
    onClick,
    align,
    autoAlign,
    className: (0, import_classnames22.default)(className, `${prefix}--copy-btn`),
    "aria-label": iconDescription
  }, other), import_react41.default.createElement(Copy, {
    className: `${prefix}--snippet__icon`
  })));
}
CopyButton.propTypes = {
  /**
   * Specify how the trigger should align with the tooltip
   */
  align: deprecateValuesWithin(
    import_prop_types26.default.oneOf([
      "top",
      "top-left",
      // deprecated use top-start instead
      "top-right",
      // deprecated use top-end instead
      "bottom",
      "bottom-left",
      // deprecated use bottom-start instead
      "bottom-right",
      // deprecated use bottom-end instead
      "left",
      "left-bottom",
      // deprecated use left-end instead
      "left-top",
      // deprecated use left-start instead
      "right",
      "right-bottom",
      // deprecated use right-end instead
      "right-top",
      // deprecated use right-start instead
      // new values to match floating-ui
      "top-start",
      "top-end",
      "bottom-start",
      "bottom-end",
      "left-end",
      "left-start",
      "right-end",
      "right-start"
    ]),
    //allowed prop values
    ["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "left", "left-start", "left-end", "right", "right-start", "right-end"],
    //optional mapper function
    propMappingFunction4
  ),
  /**
   * **Experimental**: Will attempt to automatically align the tooltip
   */
  autoAlign: import_prop_types26.default.bool,
  /**
   * Specify an optional className to be applied to the underlying `<button>`
   */
  className: import_prop_types26.default.string,
  /**
   * Specify the string that is displayed when the button is clicked and the
   * content is copied
   */
  feedback: import_prop_types26.default.string,
  /**
   * Specify the time it takes for the feedback message to timeout
   */
  feedbackTimeout: import_prop_types26.default.number,
  /**
   * Provide a description for the icon representing the copy action that can
   * be read by screen readers
   */
  iconDescription: import_prop_types26.default.string,
  /**
   * Specify an optional `onClick` handler that is called when the underlying
   * `<button>` is clicked
   */
  onClick: import_prop_types26.default.func
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/tools/uniqueId.js
var lastId = 0;
function uniqueId2() {
  let prefix = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "id";
  lastId++;
  return `${prefix}${lastId}`;
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/CodeSnippet/CodeSnippet.js
var import_copy_to_clipboard = __toESM(require_copy_to_clipboard());
var rowHeightInPixels = 16;
var defaultMaxCollapsedNumberOfRows = 15;
var defaultMaxExpandedNumberOfRows = 0;
var defaultMinCollapsedNumberOfRows = 3;
var defaultMinExpandedNumberOfRows = 16;
var propMappingFunction5 = (deprecatedValue) => {
  const mapping = {
    "top-left": "top-start",
    "top-right": "top-end",
    "bottom-left": "bottom-start",
    "bottom-right": "bottom-end",
    "left-bottom": "left-end",
    "left-top": "left-start",
    "right-bottom": "right-end",
    "right-top": "right-start"
  };
  return mapping[deprecatedValue];
};
function CodeSnippet(_ref) {
  let {
    align = "bottom",
    autoAlign = false,
    className,
    type = "single",
    children,
    disabled,
    feedback,
    feedbackTimeout,
    onClick,
    ["aria-label"]: ariaLabel = "Copy to clipboard",
    ariaLabel: deprecatedAriaLabel,
    copyText,
    copyButtonDescription,
    light,
    showMoreText = "Show more",
    showLessText = "Show less",
    hideCopyButton,
    wrapText = false,
    maxCollapsedNumberOfRows = defaultMaxCollapsedNumberOfRows,
    maxExpandedNumberOfRows = defaultMaxExpandedNumberOfRows,
    minCollapsedNumberOfRows = defaultMinCollapsedNumberOfRows,
    minExpandedNumberOfRows = defaultMinExpandedNumberOfRows,
    ...rest3
  } = _ref;
  const [expandedCode, setExpandedCode] = (0, import_react42.useState)(false);
  const [shouldShowMoreLessBtn, setShouldShowMoreLessBtn] = (0, import_react42.useState)(false);
  const {
    current: uid
  } = (0, import_react42.useRef)(uniqueId2());
  const codeContentRef = (0, import_react42.useRef)(null);
  const codeContainerRef = (0, import_react42.useRef)(null);
  const innerCodeRef = (0, import_react42.useRef)(null);
  const [hasLeftOverflow, setHasLeftOverflow] = (0, import_react42.useState)(false);
  const [hasRightOverflow, setHasRightOverflow] = (0, import_react42.useState)(false);
  const getCodeRef = (0, import_react42.useCallback)(() => {
    if (type === "single") {
      return codeContainerRef;
    }
    if (type === "multi") {
      return codeContentRef;
    } else {
      return innerCodeRef;
    }
  }, [type]);
  const prefix = usePrefix();
  const getCodeRefDimensions = (0, import_react42.useCallback)(() => {
    const {
      clientWidth: codeClientWidth = 0,
      scrollLeft: codeScrollLeft = 0,
      scrollWidth: codeScrollWidth = 0
    } = getCodeRef().current || {};
    return {
      horizontalOverflow: codeScrollWidth > codeClientWidth,
      codeClientWidth,
      codeScrollWidth,
      codeScrollLeft
    };
  }, [getCodeRef]);
  const handleScroll = (0, import_react42.useCallback)(() => {
    if (type === "inline" || type === "single" && !(codeContainerRef == null ? void 0 : codeContainerRef.current) || type === "multi" && !(codeContentRef == null ? void 0 : codeContentRef.current)) {
      return;
    }
    const {
      horizontalOverflow,
      codeClientWidth,
      codeScrollWidth,
      codeScrollLeft
    } = getCodeRefDimensions();
    setHasLeftOverflow(horizontalOverflow && !!codeScrollLeft);
    setHasRightOverflow(horizontalOverflow && codeScrollLeft + codeClientWidth !== codeScrollWidth);
  }, [type, getCodeRefDimensions]);
  (0, import_polyfilled.default)({
    ref: getCodeRef(),
    onResize: () => {
      if ((codeContentRef == null ? void 0 : codeContentRef.current) && type === "multi") {
        const {
          height
        } = codeContentRef.current.getBoundingClientRect();
        if (maxCollapsedNumberOfRows > 0 && (maxExpandedNumberOfRows <= 0 || maxExpandedNumberOfRows > maxCollapsedNumberOfRows) && height > maxCollapsedNumberOfRows * rowHeightInPixels) {
          setShouldShowMoreLessBtn(true);
        } else {
          setShouldShowMoreLessBtn(false);
        }
        if (expandedCode && minExpandedNumberOfRows > 0 && height <= minExpandedNumberOfRows * rowHeightInPixels) {
          setExpandedCode(false);
        }
      }
      if ((codeContentRef == null ? void 0 : codeContentRef.current) && type === "multi" || (codeContainerRef == null ? void 0 : codeContainerRef.current) && type === "single") {
        handleScroll();
      }
    }
  });
  (0, import_react42.useEffect)(() => {
    handleScroll();
  }, [handleScroll]);
  const handleCopyClick = (evt) => {
    var _a;
    if (copyText || (innerCodeRef == null ? void 0 : innerCodeRef.current)) {
      (0, import_copy_to_clipboard.default)(copyText ?? ((_a = innerCodeRef == null ? void 0 : innerCodeRef.current) == null ? void 0 : _a.innerText) ?? "");
    }
    if (onClick) {
      onClick(evt);
    }
  };
  const codeSnippetClasses = (0, import_classnames23.default)(className, `${prefix}--snippet`, {
    [`${prefix}--snippet--${type}`]: type,
    [`${prefix}--snippet--disabled`]: type !== "inline" && disabled,
    [`${prefix}--snippet--expand`]: expandedCode,
    [`${prefix}--snippet--light`]: light,
    [`${prefix}--snippet--no-copy`]: hideCopyButton,
    [`${prefix}--snippet--wraptext`]: wrapText,
    [`${prefix}--snippet--has-right-overflow`]: type == "multi" && hasRightOverflow
  });
  const expandCodeBtnText = expandedCode ? showLessText : showMoreText;
  if (type === "inline") {
    if (hideCopyButton) {
      return import_react42.default.createElement("span", {
        className: codeSnippetClasses
      }, import_react42.default.createElement("code", {
        id: uid,
        ref: innerCodeRef
      }, children));
    }
    return import_react42.default.createElement(Copy2, _extends({}, rest3, {
      align,
      autoAlign,
      onClick: handleCopyClick,
      "aria-label": deprecatedAriaLabel || ariaLabel,
      "aria-describedby": uid,
      className: codeSnippetClasses,
      feedback,
      feedbackTimeout
    }), import_react42.default.createElement("code", {
      id: uid,
      ref: innerCodeRef
    }, children));
  }
  const containerStyle = {};
  if (type === "multi") {
    const styles = {};
    if (expandedCode) {
      if (maxExpandedNumberOfRows > 0) {
        styles.maxHeight = maxExpandedNumberOfRows * rowHeightInPixels;
      }
      if (minExpandedNumberOfRows > 0) {
        styles.minHeight = minExpandedNumberOfRows * rowHeightInPixels;
      }
    } else {
      if (maxCollapsedNumberOfRows > 0) {
        styles.maxHeight = maxCollapsedNumberOfRows * rowHeightInPixels;
      }
      if (minCollapsedNumberOfRows > 0) {
        styles.minHeight = minCollapsedNumberOfRows * rowHeightInPixels;
      }
    }
    if (Object.keys(styles).length) {
      containerStyle.style = styles;
    }
  }
  return import_react42.default.createElement("div", _extends({}, rest3, {
    className: codeSnippetClasses
  }), import_react42.default.createElement("div", _extends({
    ref: codeContainerRef,
    role: type === "single" || type === "multi" ? "textbox" : void 0,
    tabIndex: (type === "single" || type === "multi") && !disabled ? 0 : void 0,
    className: `${prefix}--snippet-container`,
    "aria-label": deprecatedAriaLabel || ariaLabel || "code-snippet",
    "aria-readonly": type === "single" || type === "multi" ? true : void 0,
    "aria-multiline": type === "multi" ? true : void 0,
    onScroll: type === "single" && handleScroll || void 0
  }, containerStyle), import_react42.default.createElement("pre", {
    ref: codeContentRef,
    onScroll: type === "multi" && handleScroll || void 0
  }, import_react42.default.createElement("code", {
    ref: innerCodeRef
  }, children))), hasLeftOverflow && import_react42.default.createElement("div", {
    className: `${prefix}--snippet__overflow-indicator--left`
  }), hasRightOverflow && type !== "multi" && import_react42.default.createElement("div", {
    className: `${prefix}--snippet__overflow-indicator--right`
  }), !hideCopyButton && import_react42.default.createElement(CopyButton, {
    align,
    autoAlign,
    size: type === "multi" ? "sm" : "md",
    disabled,
    onClick: handleCopyClick,
    feedback,
    feedbackTimeout,
    iconDescription: copyButtonDescription
  }), shouldShowMoreLessBtn && import_react42.default.createElement(Button, {
    kind: "ghost",
    size: "sm",
    className: `${prefix}--snippet-btn--expand`,
    disabled,
    onClick: () => setExpandedCode(!expandedCode)
  }, import_react42.default.createElement("span", {
    className: `${prefix}--snippet-btn--text`
  }, expandCodeBtnText), import_react42.default.createElement(ChevronDown, {
    className: `${prefix}--icon-chevron--down ${prefix}--snippet__icon`,
    name: "chevron--down",
    role: "img"
  })));
}
CodeSnippet.propTypes = {
  /**
   * Specify how the trigger should align with the tooltip
   */
  align: deprecateValuesWithin(
    import_prop_types27.default.oneOf([
      "top",
      "top-left",
      // deprecated use top-start instead
      "top-right",
      // deprecated use top-end instead
      "bottom",
      "bottom-left",
      // deprecated use bottom-start instead
      "bottom-right",
      // deprecated use bottom-end instead
      "left",
      "left-bottom",
      // deprecated use left-end instead
      "left-top",
      // deprecated use left-start instead
      "right",
      "right-bottom",
      // deprecated use right-end instead
      "right-top",
      // deprecated use right-start instead
      // new values to match floating-ui
      "top-start",
      "top-end",
      "bottom-start",
      "bottom-end",
      "left-end",
      "left-start",
      "right-end",
      "right-start"
    ]),
    //allowed prop values
    ["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "left", "left-start", "left-end", "right", "right-start", "right-end"],
    //optional mapper function
    propMappingFunction5
  ),
  /**
   * Specify a label to be read by screen readers on the containing textbox
   * node
   */
  ["aria-label"]: import_prop_types27.default.string,
  /**
   * Deprecated, please use `aria-label` instead.
   * Specify a label to be read by screen readers on the containing textbox
   * node
   */
  ariaLabel: deprecate(import_prop_types27.default.string, "This prop syntax has been deprecated. Please use the new `aria-label`."),
  /**
   * **Experimental**: Will attempt to automatically align the tooltip
   */
  autoAlign: import_prop_types27.default.bool,
  /**
   * Provide the content of your CodeSnippet as a node or string
   */
  children: import_prop_types27.default.node,
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types27.default.string,
  /**
   * Specify the description for the Copy Button
   */
  copyButtonDescription: import_prop_types27.default.string,
  /**
   * Optional text to copy. If not specified, the `children` node's `innerText`
   * will be used as the copy value.
   */
  copyText: import_prop_types27.default.string,
  /**
   * Specify whether or not the CodeSnippet should be disabled
   */
  disabled: import_prop_types27.default.bool,
  /**
   * Specify the string displayed when the snippet is copied
   */
  feedback: import_prop_types27.default.string,
  /**
   * Specify the time it takes for the feedback message to timeout
   */
  feedbackTimeout: import_prop_types27.default.number,
  /**
   * Specify whether or not a copy button should be used/rendered.
   */
  hideCopyButton: import_prop_types27.default.bool,
  /**
   * Specify whether you are using the light variant of the Code Snippet,
   * typically used for inline snippet to display an alternate color
   */
  light: deprecate(import_prop_types27.default.bool, "The `light` prop for `CodeSnippet` has been deprecated in favor of the new `Layer` component. It will be removed in the next major release."),
  /**
   * Specify the maximum number of rows to be shown when in collapsed view
   */
  maxCollapsedNumberOfRows: import_prop_types27.default.number,
  /**
   * Specify the maximum number of rows to be shown when in expanded view
   */
  maxExpandedNumberOfRows: import_prop_types27.default.number,
  /**
   * Specify the minimum number of rows to be shown when in collapsed view
   */
  minCollapsedNumberOfRows: import_prop_types27.default.number,
  /**
   * Specify the minimum number of rows to be shown when in expanded view
   */
  minExpandedNumberOfRows: import_prop_types27.default.number,
  /**
   * An optional handler to listen to the `onClick` even fired by the Copy
   * Button
   */
  onClick: import_prop_types27.default.func,
  /**
   * Specify a string that is displayed when the Code Snippet has been
   * interacted with to show more lines
   */
  showLessText: import_prop_types27.default.string,
  /**
   * Specify a string that is displayed when the Code Snippet text is more
   * than 15 lines
   */
  showMoreText: import_prop_types27.default.string,
  /**
   * Provide the type of Code Snippet
   */
  type: import_prop_types27.default.oneOf(["single", "inline", "multi"]),
  /**
   * Specify whether or not to wrap the text.
   */
  wrapText: import_prop_types27.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/CodeSnippet/CodeSnippet.Skeleton.js
var import_classnames24 = __toESM(require_classnames());
var import_prop_types28 = __toESM(require_prop_types());
var import_react43 = __toESM(require_react());
var _span;
var _span2;
var _span3;
var _span4;
function CodeSnippetSkeleton(_ref) {
  let {
    className: containerClassName,
    type = "single",
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const className = (0, import_classnames24.default)(containerClassName, {
    [`${prefix}--snippet`]: true,
    [`${prefix}--skeleton`]: true,
    [`${prefix}--snippet--single`]: type === "single",
    [`${prefix}--snippet--multi`]: type === "multi"
  });
  if (type === "single") {
    return import_react43.default.createElement("div", _extends({
      className
    }, rest3), import_react43.default.createElement("div", {
      className: `${prefix}--snippet-container`
    }, _span || (_span = import_react43.default.createElement("span", null))));
  }
  if (type === "multi") {
    return import_react43.default.createElement("div", _extends({
      className
    }, rest3), import_react43.default.createElement("div", {
      className: `${prefix}--snippet-container`
    }, _span2 || (_span2 = import_react43.default.createElement("span", null)), _span3 || (_span3 = import_react43.default.createElement("span", null)), _span4 || (_span4 = import_react43.default.createElement("span", null))));
  }
}
CodeSnippetSkeleton.propTypes = {
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types28.default.string,
  /**
   * The type of the code snippet, including single or multi
   */
  type: import_prop_types28.default.oneOf(["single", "multi"])
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ComboBox/ComboBox.js
var import_classnames33 = __toESM(require_classnames());

// ../node_modules/.pnpm/@babel+runtime@7.26.7/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(r2, e2) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (-1 !== e2.indexOf(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}

// ../node_modules/.pnpm/@babel+runtime@7.26.7/node_modules/@babel/runtime/helpers/esm/extends.js
function _extends3() {
  return _extends3 = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends3.apply(null, arguments);
}

// ../node_modules/.pnpm/@babel+runtime@7.26.7/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(t2, e2) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
    return t3.__proto__ = e3, t3;
  }, _setPrototypeOf(t2, e2);
}

// ../node_modules/.pnpm/@babel+runtime@7.26.7/node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose(t2, o2) {
  t2.prototype = Object.create(o2.prototype), t2.prototype.constructor = t2, _setPrototypeOf(t2, o2);
}

// ../node_modules/.pnpm/downshift@9.0.8_react@19.0.0/node_modules/downshift/dist/downshift.esm.js
var import_prop_types29 = __toESM(require_prop_types());
var import_react44 = __toESM(require_react());
var import_react_is = __toESM(require_react_is());

// ../node_modules/.pnpm/compute-scroll-into-view@3.1.1/node_modules/compute-scroll-into-view/dist/index.js
var t = (t2) => "object" == typeof t2 && null != t2 && 1 === t2.nodeType;
var e = (t2, e2) => (!e2 || "hidden" !== t2) && ("visible" !== t2 && "clip" !== t2);
var n = (t2, n2) => {
  if (t2.clientHeight < t2.scrollHeight || t2.clientWidth < t2.scrollWidth) {
    const o2 = getComputedStyle(t2, null);
    return e(o2.overflowY, n2) || e(o2.overflowX, n2) || ((t3) => {
      const e2 = ((t4) => {
        if (!t4.ownerDocument || !t4.ownerDocument.defaultView) return null;
        try {
          return t4.ownerDocument.defaultView.frameElement;
        } catch (t5) {
          return null;
        }
      })(t3);
      return !!e2 && (e2.clientHeight < t3.scrollHeight || e2.clientWidth < t3.scrollWidth);
    })(t2);
  }
  return false;
};
var o = (t2, e2, n2, o2, l2, r2, i, s) => r2 < t2 && i > e2 || r2 > t2 && i < e2 ? 0 : r2 <= t2 && s <= n2 || i >= e2 && s >= n2 ? r2 - t2 - o2 : i > e2 && s < n2 || r2 < t2 && s > n2 ? i - e2 + l2 : 0;
var l = (t2) => {
  const e2 = t2.parentElement;
  return null == e2 ? t2.getRootNode().host || null : e2;
};
var r = (e2, r2) => {
  var i, s, d, h;
  if ("undefined" == typeof document) return [];
  const { scrollMode: c, block: f, inline: u, boundary: a, skipOverflowHiddenElements: g } = r2, p = "function" == typeof a ? a : (t2) => t2 !== a;
  if (!t(e2)) throw new TypeError("Invalid target");
  const m = document.scrollingElement || document.documentElement, w = [];
  let W = e2;
  for (; t(W) && p(W); ) {
    if (W = l(W), W === m) {
      w.push(W);
      break;
    }
    null != W && W === document.body && n(W) && !n(document.documentElement) || null != W && n(W, g) && w.push(W);
  }
  const b = null != (s = null == (i = window.visualViewport) ? void 0 : i.width) ? s : innerWidth, H = null != (h = null == (d = window.visualViewport) ? void 0 : d.height) ? h : innerHeight, { scrollX: y, scrollY: M } = window, { height: v, width: E, top: x, right: C, bottom: I, left: R } = e2.getBoundingClientRect(), { top: T, right: B, bottom: F, left: V } = ((t2) => {
    const e3 = window.getComputedStyle(t2);
    return { top: parseFloat(e3.scrollMarginTop) || 0, right: parseFloat(e3.scrollMarginRight) || 0, bottom: parseFloat(e3.scrollMarginBottom) || 0, left: parseFloat(e3.scrollMarginLeft) || 0 };
  })(e2);
  let k = "start" === f || "nearest" === f ? x - T : "end" === f ? I + F : x + v / 2 - T + F, D = "center" === u ? R + E / 2 - V + B : "end" === u ? C + B : R - V;
  const L = [];
  for (let t2 = 0; t2 < w.length; t2++) {
    const e3 = w[t2], { height: l2, width: r3, top: i2, right: s2, bottom: d2, left: h2 } = e3.getBoundingClientRect();
    if ("if-needed" === c && x >= 0 && R >= 0 && I <= H && C <= b && (e3 === m && !n(e3) || x >= i2 && I <= d2 && R >= h2 && C <= s2)) return L;
    const a2 = getComputedStyle(e3), g2 = parseInt(a2.borderLeftWidth, 10), p2 = parseInt(a2.borderTopWidth, 10), W2 = parseInt(a2.borderRightWidth, 10), T2 = parseInt(a2.borderBottomWidth, 10);
    let B2 = 0, F2 = 0;
    const V2 = "offsetWidth" in e3 ? e3.offsetWidth - e3.clientWidth - g2 - W2 : 0, S = "offsetHeight" in e3 ? e3.offsetHeight - e3.clientHeight - p2 - T2 : 0, X = "offsetWidth" in e3 ? 0 === e3.offsetWidth ? 0 : r3 / e3.offsetWidth : 0, Y = "offsetHeight" in e3 ? 0 === e3.offsetHeight ? 0 : l2 / e3.offsetHeight : 0;
    if (m === e3) B2 = "start" === f ? k : "end" === f ? k - H : "nearest" === f ? o(M, M + H, H, p2, T2, M + k, M + k + v, v) : k - H / 2, F2 = "start" === u ? D : "center" === u ? D - b / 2 : "end" === u ? D - b : o(y, y + b, b, g2, W2, y + D, y + D + E, E), B2 = Math.max(0, B2 + M), F2 = Math.max(0, F2 + y);
    else {
      B2 = "start" === f ? k - i2 - p2 : "end" === f ? k - d2 + T2 + S : "nearest" === f ? o(i2, d2, l2, p2, T2 + S, k, k + v, v) : k - (i2 + l2 / 2) + S / 2, F2 = "start" === u ? D - h2 - g2 : "center" === u ? D - (h2 + r3 / 2) + V2 / 2 : "end" === u ? D - s2 + W2 + V2 : o(h2, s2, r3, g2, W2 + V2, D, D + E, E);
      const { scrollLeft: t3, scrollTop: n2 } = e3;
      B2 = 0 === Y ? 0 : Math.max(0, Math.min(n2 + B2 / Y, e3.scrollHeight - l2 / Y + S)), F2 = 0 === X ? 0 : Math.max(0, Math.min(t3 + F2 / X, e3.scrollWidth - r3 / X + V2)), k += n2 - B2, D += t3 - F2;
    }
    L.push({ el: e3, top: B2, left: F2 });
  }
  return L;
};

// ../node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs
var __assign = function() {
  __assign = Object.assign || function __assign3(t2) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t2[p] = s[p];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};

// ../node_modules/.pnpm/downshift@9.0.8_react@19.0.0/node_modules/downshift/dist/downshift.esm.js
var idCounter = 0;
function cbToCb(cb) {
  return typeof cb === "function" ? cb : noop2;
}
function noop2() {
}
function scrollIntoView(node, menuNode) {
  if (!node) {
    return;
  }
  var actions = r(node, {
    boundary: menuNode,
    block: "nearest",
    scrollMode: "if-needed"
  });
  actions.forEach(function(_ref) {
    var el = _ref.el, top = _ref.top, left = _ref.left;
    el.scrollTop = top;
    el.scrollLeft = left;
  });
}
function isOrContainsNode(parent, child, environment) {
  var result = parent === child || child instanceof environment.Node && parent.contains && parent.contains(child);
  return result;
}
function debounce3(fn, time) {
  var timeoutId2;
  function cancel() {
    if (timeoutId2) {
      clearTimeout(timeoutId2);
    }
  }
  function wrapper() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    cancel();
    timeoutId2 = setTimeout(function() {
      timeoutId2 = null;
      fn.apply(void 0, args);
    }, time);
  }
  wrapper.cancel = cancel;
  return wrapper;
}
function callAllEventHandlers() {
  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    fns[_key2] = arguments[_key2];
  }
  return function(event) {
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }
    return fns.some(function(fn) {
      if (fn) {
        fn.apply(void 0, [event].concat(args));
      }
      return event.preventDownshiftDefault || event.hasOwnProperty("nativeEvent") && event.nativeEvent.preventDownshiftDefault;
    });
  };
}
function handleRefs() {
  for (var _len4 = arguments.length, refs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    refs[_key4] = arguments[_key4];
  }
  return function(node) {
    refs.forEach(function(ref) {
      if (typeof ref === "function") {
        ref(node);
      } else if (ref) {
        ref.current = node;
      }
    });
  };
}
function generateId() {
  return String(idCounter++);
}
function getA11yStatusMessage(_ref2) {
  var isOpen = _ref2.isOpen, resultCount = _ref2.resultCount, previousResultCount = _ref2.previousResultCount;
  if (!isOpen) {
    return "";
  }
  if (!resultCount) {
    return "No results are available.";
  }
  if (resultCount !== previousResultCount) {
    return resultCount + " result" + (resultCount === 1 ? " is" : "s are") + " available, use up and down arrow keys to navigate. Press Enter key to select.";
  }
  return "";
}
function unwrapArray(arg, defaultValue) {
  arg = Array.isArray(arg) ? (
    /* istanbul ignore next (preact) */
    arg[0]
  ) : arg;
  if (!arg && defaultValue) {
    return defaultValue;
  } else {
    return arg;
  }
}
function isDOMElement(element) {
  return typeof element.type === "string";
}
function getElementProps(element) {
  return element.props;
}
function requiredProp(fnName, propName) {
  console.error('The property "' + propName + '" is required in "' + fnName + '"');
}
var stateKeys = ["highlightedIndex", "inputValue", "isOpen", "selectedItem", "type"];
function pickState(state) {
  if (state === void 0) {
    state = {};
  }
  var result = {};
  stateKeys.forEach(function(k) {
    if (state.hasOwnProperty(k)) {
      result[k] = state[k];
    }
  });
  return result;
}
function getState(state, props) {
  if (!state || !props) {
    return state;
  }
  return Object.keys(state).reduce(function(prevState, key) {
    prevState[key] = isControlledProp(props, key) ? props[key] : state[key];
    return prevState;
  }, {});
}
function isControlledProp(props, key) {
  return props[key] !== void 0;
}
function normalizeArrowKey(event) {
  var key = event.key, keyCode = event.keyCode;
  if (keyCode >= 37 && keyCode <= 40 && key.indexOf("Arrow") !== 0) {
    return "Arrow" + key;
  }
  return key;
}
function isPlainObject3(obj) {
  return Object.prototype.toString.call(obj) === "[object Object]";
}
function getHighlightedIndex(start, offset5, items, isItemDisabled2, circular) {
  if (circular === void 0) {
    circular = false;
  }
  var count2 = items.length;
  if (count2 === 0) {
    return -1;
  }
  var itemsLastIndex = count2 - 1;
  if (typeof start !== "number" || start < 0 || start > itemsLastIndex) {
    start = offset5 > 0 ? -1 : itemsLastIndex + 1;
  }
  var current = start + offset5;
  if (current < 0) {
    current = circular ? itemsLastIndex : 0;
  } else if (current > itemsLastIndex) {
    current = circular ? 0 : itemsLastIndex;
  }
  var highlightedIndex = getNonDisabledIndex(current, offset5 < 0, items, isItemDisabled2, circular);
  if (highlightedIndex === -1) {
    return start >= count2 ? -1 : start;
  }
  return highlightedIndex;
}
function getNonDisabledIndex(start, backwards, items, isItemDisabled2, circular) {
  if (circular === void 0) {
    circular = false;
  }
  var count2 = items.length;
  if (backwards) {
    for (var index4 = start; index4 >= 0; index4--) {
      if (!isItemDisabled2(items[index4], index4)) {
        return index4;
      }
    }
  } else {
    for (var _index = start; _index < count2; _index++) {
      if (!isItemDisabled2(items[_index], _index)) {
        return _index;
      }
    }
  }
  if (circular) {
    return getNonDisabledIndex(backwards ? count2 - 1 : 0, backwards, items, isItemDisabled2);
  }
  return -1;
}
function targetWithinDownshift(target, downshiftElements, environment, checkActiveElement) {
  if (checkActiveElement === void 0) {
    checkActiveElement = true;
  }
  return environment && downshiftElements.some(function(contextNode) {
    return contextNode && (isOrContainsNode(contextNode, target, environment) || checkActiveElement && isOrContainsNode(contextNode, environment.document.activeElement, environment));
  });
}
var validateControlledUnchanged = noop2;
if (true) {
  validateControlledUnchanged = function validateControlledUnchanged2(state, prevProps, nextProps) {
    var warningDescription = "This prop should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled Downshift element for the lifetime of the component. More info: https://github.com/downshift-js/downshift#control-props";
    Object.keys(state).forEach(function(propKey) {
      if (prevProps[propKey] !== void 0 && nextProps[propKey] === void 0) {
        console.error('downshift: A component has changed the controlled prop "' + propKey + '" to be uncontrolled. ' + warningDescription);
      } else if (prevProps[propKey] === void 0 && nextProps[propKey] !== void 0) {
        console.error('downshift: A component has changed the uncontrolled prop "' + propKey + '" to be controlled. ' + warningDescription);
      }
    });
  };
}
var cleanupStatus = debounce3(function(documentProp) {
  getStatusDiv(documentProp).textContent = "";
}, 500);
function getStatusDiv(documentProp) {
  var statusDiv = documentProp.getElementById("a11y-status-message");
  if (statusDiv) {
    return statusDiv;
  }
  statusDiv = documentProp.createElement("div");
  statusDiv.setAttribute("id", "a11y-status-message");
  statusDiv.setAttribute("role", "status");
  statusDiv.setAttribute("aria-live", "polite");
  statusDiv.setAttribute("aria-relevant", "additions text");
  Object.assign(statusDiv.style, {
    border: "0",
    clip: "rect(0 0 0 0)",
    height: "1px",
    margin: "-1px",
    overflow: "hidden",
    padding: "0",
    position: "absolute",
    width: "1px"
  });
  documentProp.body.appendChild(statusDiv);
  return statusDiv;
}
function setStatus(status, documentProp) {
  if (!status || !documentProp) {
    return;
  }
  var div = getStatusDiv(documentProp);
  div.textContent = status;
  cleanupStatus(documentProp);
}
function cleanupStatusDiv(documentProp) {
  var statusDiv = documentProp == null ? void 0 : documentProp.getElementById("a11y-status-message");
  if (statusDiv) {
    statusDiv.remove();
  }
}
var unknown = true ? "__autocomplete_unknown__" : 0;
var mouseUp = true ? "__autocomplete_mouseup__" : 1;
var itemMouseEnter = true ? "__autocomplete_item_mouseenter__" : 2;
var keyDownArrowUp = true ? "__autocomplete_keydown_arrow_up__" : 3;
var keyDownArrowDown = true ? "__autocomplete_keydown_arrow_down__" : 4;
var keyDownEscape = true ? "__autocomplete_keydown_escape__" : 5;
var keyDownEnter = true ? "__autocomplete_keydown_enter__" : 6;
var keyDownHome = true ? "__autocomplete_keydown_home__" : 7;
var keyDownEnd = true ? "__autocomplete_keydown_end__" : 8;
var clickItem = true ? "__autocomplete_click_item__" : 9;
var blurInput = true ? "__autocomplete_blur_input__" : 10;
var changeInput = true ? "__autocomplete_change_input__" : 11;
var keyDownSpaceButton = true ? "__autocomplete_keydown_space_button__" : 12;
var clickButton = true ? "__autocomplete_click_button__" : 13;
var blurButton = true ? "__autocomplete_blur_button__" : 14;
var controlledPropUpdatedSelectedItem = true ? "__autocomplete_controlled_prop_updated_selected_item__" : 15;
var touchEnd = true ? "__autocomplete_touchend__" : 16;
var stateChangeTypes$3 = Object.freeze({
  __proto__: null,
  blurButton,
  blurInput,
  changeInput,
  clickButton,
  clickItem,
  controlledPropUpdatedSelectedItem,
  itemMouseEnter,
  keyDownArrowDown,
  keyDownArrowUp,
  keyDownEnd,
  keyDownEnter,
  keyDownEscape,
  keyDownHome,
  keyDownSpaceButton,
  mouseUp,
  touchEnd,
  unknown
});
var _excluded$3 = ["refKey", "ref"];
var _excluded2$3 = ["onClick", "onPress", "onKeyDown", "onKeyUp", "onBlur"];
var _excluded3$2 = ["onKeyDown", "onBlur", "onChange", "onInput", "onChangeText"];
var _excluded4$2 = ["refKey", "ref"];
var _excluded5 = ["onMouseMove", "onMouseDown", "onClick", "onPress", "index", "item"];
var Downshift = function() {
  var Downshift2 = function(_Component) {
    function Downshift3(_props) {
      var _this;
      _this = _Component.call(this, _props) || this;
      _this.id = _this.props.id || "downshift-" + generateId();
      _this.menuId = _this.props.menuId || _this.id + "-menu";
      _this.labelId = _this.props.labelId || _this.id + "-label";
      _this.inputId = _this.props.inputId || _this.id + "-input";
      _this.getItemId = _this.props.getItemId || function(index4) {
        return _this.id + "-item-" + index4;
      };
      _this.items = [];
      _this.itemCount = null;
      _this.previousResultCount = 0;
      _this.timeoutIds = [];
      _this.internalSetTimeout = function(fn, time) {
        var id = setTimeout(function() {
          _this.timeoutIds = _this.timeoutIds.filter(function(i) {
            return i !== id;
          });
          fn();
        }, time);
        _this.timeoutIds.push(id);
      };
      _this.setItemCount = function(count2) {
        _this.itemCount = count2;
      };
      _this.unsetItemCount = function() {
        _this.itemCount = null;
      };
      _this.isItemDisabled = function(_item, index4) {
        var currentElementNode = _this.getItemNodeFromIndex(index4);
        return currentElementNode && currentElementNode.hasAttribute("disabled");
      };
      _this.setHighlightedIndex = function(highlightedIndex, otherStateToSet) {
        if (highlightedIndex === void 0) {
          highlightedIndex = _this.props.defaultHighlightedIndex;
        }
        if (otherStateToSet === void 0) {
          otherStateToSet = {};
        }
        otherStateToSet = pickState(otherStateToSet);
        _this.internalSetState(_extends3({
          highlightedIndex
        }, otherStateToSet));
      };
      _this.clearSelection = function(cb) {
        _this.internalSetState({
          selectedItem: null,
          inputValue: "",
          highlightedIndex: _this.props.defaultHighlightedIndex,
          isOpen: _this.props.defaultIsOpen
        }, cb);
      };
      _this.selectItem = function(item, otherStateToSet, cb) {
        otherStateToSet = pickState(otherStateToSet);
        _this.internalSetState(_extends3({
          isOpen: _this.props.defaultIsOpen,
          highlightedIndex: _this.props.defaultHighlightedIndex,
          selectedItem: item,
          inputValue: _this.props.itemToString(item)
        }, otherStateToSet), cb);
      };
      _this.selectItemAtIndex = function(itemIndex, otherStateToSet, cb) {
        var item = _this.items[itemIndex];
        if (item == null) {
          return;
        }
        _this.selectItem(item, otherStateToSet, cb);
      };
      _this.selectHighlightedItem = function(otherStateToSet, cb) {
        return _this.selectItemAtIndex(_this.getState().highlightedIndex, otherStateToSet, cb);
      };
      _this.internalSetState = function(stateToSet, cb) {
        var isItemSelected, onChangeArg;
        var onStateChangeArg = {};
        var isStateToSetFunction = typeof stateToSet === "function";
        if (!isStateToSetFunction && stateToSet.hasOwnProperty("inputValue")) {
          _this.props.onInputValueChange(stateToSet.inputValue, _extends3({}, _this.getStateAndHelpers(), stateToSet));
        }
        return _this.setState(function(state) {
          var _newStateToSet;
          state = _this.getState(state);
          var newStateToSet = isStateToSetFunction ? stateToSet(state) : stateToSet;
          newStateToSet = _this.props.stateReducer(state, newStateToSet);
          isItemSelected = newStateToSet.hasOwnProperty("selectedItem");
          var nextState = {};
          if (isItemSelected && newStateToSet.selectedItem !== state.selectedItem) {
            onChangeArg = newStateToSet.selectedItem;
          }
          (_newStateToSet = newStateToSet).type || (_newStateToSet.type = unknown);
          Object.keys(newStateToSet).forEach(function(key) {
            if (state[key] !== newStateToSet[key]) {
              onStateChangeArg[key] = newStateToSet[key];
            }
            if (key === "type") {
              return;
            }
            newStateToSet[key];
            if (!isControlledProp(_this.props, key)) {
              nextState[key] = newStateToSet[key];
            }
          });
          if (isStateToSetFunction && newStateToSet.hasOwnProperty("inputValue")) {
            _this.props.onInputValueChange(newStateToSet.inputValue, _extends3({}, _this.getStateAndHelpers(), newStateToSet));
          }
          return nextState;
        }, function() {
          cbToCb(cb)();
          var hasMoreStateThanType = Object.keys(onStateChangeArg).length > 1;
          if (hasMoreStateThanType) {
            _this.props.onStateChange(onStateChangeArg, _this.getStateAndHelpers());
          }
          if (isItemSelected) {
            _this.props.onSelect(stateToSet.selectedItem, _this.getStateAndHelpers());
          }
          if (onChangeArg !== void 0) {
            _this.props.onChange(onChangeArg, _this.getStateAndHelpers());
          }
          _this.props.onUserAction(onStateChangeArg, _this.getStateAndHelpers());
        });
      };
      _this.rootRef = function(node) {
        return _this._rootNode = node;
      };
      _this.getRootProps = function(_temp, _temp2) {
        var _extends22;
        var _ref = _temp === void 0 ? {} : _temp, _ref$refKey = _ref.refKey, refKey = _ref$refKey === void 0 ? "ref" : _ref$refKey, ref = _ref.ref, rest3 = _objectWithoutPropertiesLoose(_ref, _excluded$3);
        var _ref2 = _temp2 === void 0 ? {} : _temp2, _ref2$suppressRefErro = _ref2.suppressRefError, suppressRefError = _ref2$suppressRefErro === void 0 ? false : _ref2$suppressRefErro;
        _this.getRootProps.called = true;
        _this.getRootProps.refKey = refKey;
        _this.getRootProps.suppressRefError = suppressRefError;
        var _this$getState = _this.getState(), isOpen = _this$getState.isOpen;
        return _extends3((_extends22 = {}, _extends22[refKey] = handleRefs(ref, _this.rootRef), _extends22.role = "combobox", _extends22["aria-expanded"] = isOpen, _extends22["aria-haspopup"] = "listbox", _extends22["aria-owns"] = isOpen ? _this.menuId : void 0, _extends22["aria-labelledby"] = _this.labelId, _extends22), rest3);
      };
      _this.keyDownHandlers = {
        ArrowDown: function ArrowDown2(event) {
          var _this2 = this;
          event.preventDefault();
          if (this.getState().isOpen) {
            var amount = event.shiftKey ? 5 : 1;
            this.moveHighlightedIndex(amount, {
              type: keyDownArrowDown
            });
          } else {
            this.internalSetState({
              isOpen: true,
              type: keyDownArrowDown
            }, function() {
              var itemCount = _this2.getItemCount();
              if (itemCount > 0) {
                var _this2$getState = _this2.getState(), highlightedIndex = _this2$getState.highlightedIndex;
                var nextHighlightedIndex = getHighlightedIndex(highlightedIndex, 1, {
                  length: itemCount
                }, _this2.isItemDisabled, true);
                _this2.setHighlightedIndex(nextHighlightedIndex, {
                  type: keyDownArrowDown
                });
              }
            });
          }
        },
        ArrowUp: function ArrowUp3(event) {
          var _this3 = this;
          event.preventDefault();
          if (this.getState().isOpen) {
            var amount = event.shiftKey ? -5 : -1;
            this.moveHighlightedIndex(amount, {
              type: keyDownArrowUp
            });
          } else {
            this.internalSetState({
              isOpen: true,
              type: keyDownArrowUp
            }, function() {
              var itemCount = _this3.getItemCount();
              if (itemCount > 0) {
                var _this3$getState = _this3.getState(), highlightedIndex = _this3$getState.highlightedIndex;
                var nextHighlightedIndex = getHighlightedIndex(highlightedIndex, -1, {
                  length: itemCount
                }, _this3.isItemDisabled, true);
                _this3.setHighlightedIndex(nextHighlightedIndex, {
                  type: keyDownArrowUp
                });
              }
            });
          }
        },
        Enter: function Enter2(event) {
          if (event.which === 229) {
            return;
          }
          var _this$getState2 = this.getState(), isOpen = _this$getState2.isOpen, highlightedIndex = _this$getState2.highlightedIndex;
          if (isOpen && highlightedIndex != null) {
            event.preventDefault();
            var item = this.items[highlightedIndex];
            var itemNode = this.getItemNodeFromIndex(highlightedIndex);
            if (item == null || itemNode && itemNode.hasAttribute("disabled")) {
              return;
            }
            this.selectHighlightedItem({
              type: keyDownEnter
            });
          }
        },
        Escape: function Escape2(event) {
          event.preventDefault();
          this.reset(_extends3({
            type: keyDownEscape
          }, !this.state.isOpen && {
            selectedItem: null,
            inputValue: ""
          }));
        }
      };
      _this.buttonKeyDownHandlers = _extends3({}, _this.keyDownHandlers, {
        " ": function _(event) {
          event.preventDefault();
          this.toggleMenu({
            type: keyDownSpaceButton
          });
        }
      });
      _this.inputKeyDownHandlers = _extends3({}, _this.keyDownHandlers, {
        Home: function Home2(event) {
          var _this$getState3 = this.getState(), isOpen = _this$getState3.isOpen;
          if (!isOpen) {
            return;
          }
          event.preventDefault();
          var itemCount = this.getItemCount();
          if (itemCount <= 0 || !isOpen) {
            return;
          }
          var newHighlightedIndex = getNonDisabledIndex(0, false, {
            length: itemCount
          }, this.isItemDisabled);
          this.setHighlightedIndex(newHighlightedIndex, {
            type: keyDownHome
          });
        },
        End: function End2(event) {
          var _this$getState4 = this.getState(), isOpen = _this$getState4.isOpen;
          if (!isOpen) {
            return;
          }
          event.preventDefault();
          var itemCount = this.getItemCount();
          if (itemCount <= 0 || !isOpen) {
            return;
          }
          var newHighlightedIndex = getNonDisabledIndex(itemCount - 1, true, {
            length: itemCount
          }, this.isItemDisabled);
          this.setHighlightedIndex(newHighlightedIndex, {
            type: keyDownEnd
          });
        }
      });
      _this.getToggleButtonProps = function(_temp3) {
        var _ref3 = _temp3 === void 0 ? {} : _temp3, onClick = _ref3.onClick;
        _ref3.onPress;
        var onKeyDown = _ref3.onKeyDown, onKeyUp = _ref3.onKeyUp, onBlur = _ref3.onBlur, rest3 = _objectWithoutPropertiesLoose(_ref3, _excluded2$3);
        var _this$getState5 = _this.getState(), isOpen = _this$getState5.isOpen;
        var enabledEventHandlers = {
          onClick: callAllEventHandlers(onClick, _this.buttonHandleClick),
          onKeyDown: callAllEventHandlers(onKeyDown, _this.buttonHandleKeyDown),
          onKeyUp: callAllEventHandlers(onKeyUp, _this.buttonHandleKeyUp),
          onBlur: callAllEventHandlers(onBlur, _this.buttonHandleBlur)
        };
        var eventHandlers = rest3.disabled ? {} : enabledEventHandlers;
        return _extends3({
          type: "button",
          role: "button",
          "aria-label": isOpen ? "close menu" : "open menu",
          "aria-haspopup": true,
          "data-toggle": true
        }, eventHandlers, rest3);
      };
      _this.buttonHandleKeyUp = function(event) {
        event.preventDefault();
      };
      _this.buttonHandleKeyDown = function(event) {
        var key = normalizeArrowKey(event);
        if (_this.buttonKeyDownHandlers[key]) {
          _this.buttonKeyDownHandlers[key].call(_this, event);
        }
      };
      _this.buttonHandleClick = function(event) {
        event.preventDefault();
        if (_this.props.environment) {
          var _this$props$environme = _this.props.environment.document, body = _this$props$environme.body, activeElement2 = _this$props$environme.activeElement;
          if (body && body === activeElement2) {
            event.target.focus();
          }
        }
        if (false) {
          _this.toggleMenu({
            type: clickButton
          });
        } else {
          _this.internalSetTimeout(function() {
            return _this.toggleMenu({
              type: clickButton
            });
          });
        }
      };
      _this.buttonHandleBlur = function(event) {
        var blurTarget = event.target;
        _this.internalSetTimeout(function() {
          if (_this.isMouseDown || !_this.props.environment) {
            return;
          }
          var activeElement2 = _this.props.environment.document.activeElement;
          if ((activeElement2 == null || activeElement2.id !== _this.inputId) && activeElement2 !== blurTarget) {
            _this.reset({
              type: blurButton
            });
          }
        });
      };
      _this.getLabelProps = function(props) {
        return _extends3({
          htmlFor: _this.inputId,
          id: _this.labelId
        }, props);
      };
      _this.getInputProps = function(_temp4) {
        var _ref4 = _temp4 === void 0 ? {} : _temp4, onKeyDown = _ref4.onKeyDown, onBlur = _ref4.onBlur, onChange = _ref4.onChange, onInput = _ref4.onInput;
        _ref4.onChangeText;
        var rest3 = _objectWithoutPropertiesLoose(_ref4, _excluded3$2);
        var onChangeKey;
        var eventHandlers = {};
        {
          onChangeKey = "onChange";
        }
        var _this$getState6 = _this.getState(), inputValue = _this$getState6.inputValue, isOpen = _this$getState6.isOpen, highlightedIndex = _this$getState6.highlightedIndex;
        if (!rest3.disabled) {
          var _eventHandlers;
          eventHandlers = (_eventHandlers = {}, _eventHandlers[onChangeKey] = callAllEventHandlers(onChange, onInput, _this.inputHandleChange), _eventHandlers.onKeyDown = callAllEventHandlers(onKeyDown, _this.inputHandleKeyDown), _eventHandlers.onBlur = callAllEventHandlers(onBlur, _this.inputHandleBlur), _eventHandlers);
        }
        return _extends3({
          "aria-autocomplete": "list",
          "aria-activedescendant": isOpen && typeof highlightedIndex === "number" && highlightedIndex >= 0 ? _this.getItemId(highlightedIndex) : void 0,
          "aria-controls": isOpen ? _this.menuId : void 0,
          "aria-labelledby": rest3 && rest3["aria-label"] ? void 0 : _this.labelId,
          // https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion
          // revert back since autocomplete="nope" is ignored on latest Chrome and Opera
          autoComplete: "off",
          value: inputValue,
          id: _this.inputId
        }, eventHandlers, rest3);
      };
      _this.inputHandleKeyDown = function(event) {
        var key = normalizeArrowKey(event);
        if (key && _this.inputKeyDownHandlers[key]) {
          _this.inputKeyDownHandlers[key].call(_this, event);
        }
      };
      _this.inputHandleChange = function(event) {
        _this.internalSetState({
          type: changeInput,
          isOpen: true,
          inputValue: event.target.value,
          highlightedIndex: _this.props.defaultHighlightedIndex
        });
      };
      _this.inputHandleBlur = function() {
        _this.internalSetTimeout(function() {
          var _activeElement$datase;
          if (_this.isMouseDown || !_this.props.environment) {
            return;
          }
          var activeElement2 = _this.props.environment.document.activeElement;
          var downshiftButtonIsActive = (activeElement2 == null || (_activeElement$datase = activeElement2.dataset) == null ? void 0 : _activeElement$datase.toggle) && _this._rootNode && _this._rootNode.contains(activeElement2);
          if (!downshiftButtonIsActive) {
            _this.reset({
              type: blurInput
            });
          }
        });
      };
      _this.menuRef = function(node) {
        _this._menuNode = node;
      };
      _this.getMenuProps = function(_temp5, _temp6) {
        var _extends32;
        var _ref5 = _temp5 === void 0 ? {} : _temp5, _ref5$refKey = _ref5.refKey, refKey = _ref5$refKey === void 0 ? "ref" : _ref5$refKey, ref = _ref5.ref, props = _objectWithoutPropertiesLoose(_ref5, _excluded4$2);
        var _ref6 = _temp6 === void 0 ? {} : _temp6, _ref6$suppressRefErro = _ref6.suppressRefError, suppressRefError = _ref6$suppressRefErro === void 0 ? false : _ref6$suppressRefErro;
        _this.getMenuProps.called = true;
        _this.getMenuProps.refKey = refKey;
        _this.getMenuProps.suppressRefError = suppressRefError;
        return _extends3((_extends32 = {}, _extends32[refKey] = handleRefs(ref, _this.menuRef), _extends32.role = "listbox", _extends32["aria-labelledby"] = props && props["aria-label"] ? void 0 : _this.labelId, _extends32.id = _this.menuId, _extends32), props);
      };
      _this.getItemProps = function(_temp7) {
        var _enabledEventHandlers;
        var _ref7 = _temp7 === void 0 ? {} : _temp7, onMouseMove = _ref7.onMouseMove, onMouseDown = _ref7.onMouseDown, onClick = _ref7.onClick;
        _ref7.onPress;
        var index4 = _ref7.index, _ref7$item = _ref7.item, item = _ref7$item === void 0 ? false ? (
          /* istanbul ignore next */
          void 0
        ) : requiredProp("getItemProps", "item") : _ref7$item, rest3 = _objectWithoutPropertiesLoose(_ref7, _excluded5);
        if (index4 === void 0) {
          _this.items.push(item);
          index4 = _this.items.indexOf(item);
        } else {
          _this.items[index4] = item;
        }
        var onSelectKey = "onClick";
        var customClickHandler = onClick;
        var enabledEventHandlers = (_enabledEventHandlers = {
          // onMouseMove is used over onMouseEnter here. onMouseMove
          // is only triggered on actual mouse movement while onMouseEnter
          // can fire on DOM changes, interrupting keyboard navigation
          onMouseMove: callAllEventHandlers(onMouseMove, function() {
            if (index4 === _this.getState().highlightedIndex) {
              return;
            }
            _this.setHighlightedIndex(index4, {
              type: itemMouseEnter
            });
            _this.avoidScrolling = true;
            _this.internalSetTimeout(function() {
              return _this.avoidScrolling = false;
            }, 250);
          }),
          onMouseDown: callAllEventHandlers(onMouseDown, function(event) {
            event.preventDefault();
          })
        }, _enabledEventHandlers[onSelectKey] = callAllEventHandlers(customClickHandler, function() {
          _this.selectItemAtIndex(index4, {
            type: clickItem
          });
        }), _enabledEventHandlers);
        var eventHandlers = rest3.disabled ? {
          onMouseDown: enabledEventHandlers.onMouseDown
        } : enabledEventHandlers;
        return _extends3({
          id: _this.getItemId(index4),
          role: "option",
          "aria-selected": _this.getState().highlightedIndex === index4
        }, eventHandlers, rest3);
      };
      _this.clearItems = function() {
        _this.items = [];
      };
      _this.reset = function(otherStateToSet, cb) {
        if (otherStateToSet === void 0) {
          otherStateToSet = {};
        }
        otherStateToSet = pickState(otherStateToSet);
        _this.internalSetState(function(_ref8) {
          var selectedItem = _ref8.selectedItem;
          return _extends3({
            isOpen: _this.props.defaultIsOpen,
            highlightedIndex: _this.props.defaultHighlightedIndex,
            inputValue: _this.props.itemToString(selectedItem)
          }, otherStateToSet);
        }, cb);
      };
      _this.toggleMenu = function(otherStateToSet, cb) {
        if (otherStateToSet === void 0) {
          otherStateToSet = {};
        }
        otherStateToSet = pickState(otherStateToSet);
        _this.internalSetState(function(_ref9) {
          var isOpen = _ref9.isOpen;
          return _extends3({
            isOpen: !isOpen
          }, isOpen && {
            highlightedIndex: _this.props.defaultHighlightedIndex
          }, otherStateToSet);
        }, function() {
          var _this$getState7 = _this.getState(), isOpen = _this$getState7.isOpen, highlightedIndex = _this$getState7.highlightedIndex;
          if (isOpen) {
            if (_this.getItemCount() > 0 && typeof highlightedIndex === "number") {
              _this.setHighlightedIndex(highlightedIndex, otherStateToSet);
            }
          }
          cbToCb(cb)();
        });
      };
      _this.openMenu = function(cb) {
        _this.internalSetState({
          isOpen: true
        }, cb);
      };
      _this.closeMenu = function(cb) {
        _this.internalSetState({
          isOpen: false
        }, cb);
      };
      _this.updateStatus = debounce3(function() {
        var _this$props;
        if (!((_this$props = _this.props) != null && (_this$props = _this$props.environment) != null && _this$props.document)) {
          return;
        }
        var state = _this.getState();
        var item = _this.items[state.highlightedIndex];
        var resultCount = _this.getItemCount();
        var status = _this.props.getA11yStatusMessage(_extends3({
          itemToString: _this.props.itemToString,
          previousResultCount: _this.previousResultCount,
          resultCount,
          highlightedItem: item
        }, state));
        _this.previousResultCount = resultCount;
        setStatus(status, _this.props.environment.document);
      }, 200);
      var _this$props2 = _this.props, defaultHighlightedIndex = _this$props2.defaultHighlightedIndex, _this$props2$initialH = _this$props2.initialHighlightedIndex, _highlightedIndex = _this$props2$initialH === void 0 ? defaultHighlightedIndex : _this$props2$initialH, defaultIsOpen = _this$props2.defaultIsOpen, _this$props2$initialI = _this$props2.initialIsOpen, _isOpen = _this$props2$initialI === void 0 ? defaultIsOpen : _this$props2$initialI, _this$props2$initialI2 = _this$props2.initialInputValue, _inputValue = _this$props2$initialI2 === void 0 ? "" : _this$props2$initialI2, _this$props2$initialS = _this$props2.initialSelectedItem, _selectedItem = _this$props2$initialS === void 0 ? null : _this$props2$initialS;
      var _state = _this.getState({
        highlightedIndex: _highlightedIndex,
        isOpen: _isOpen,
        inputValue: _inputValue,
        selectedItem: _selectedItem
      });
      if (_state.selectedItem != null && _this.props.initialInputValue === void 0) {
        _state.inputValue = _this.props.itemToString(_state.selectedItem);
      }
      _this.state = _state;
      return _this;
    }
    _inheritsLoose(Downshift3, _Component);
    var _proto = Downshift3.prototype;
    _proto.internalClearTimeouts = function internalClearTimeouts() {
      this.timeoutIds.forEach(function(id) {
        clearTimeout(id);
      });
      this.timeoutIds = [];
    };
    _proto.getState = function getState$1(stateToMerge) {
      if (stateToMerge === void 0) {
        stateToMerge = this.state;
      }
      return getState(stateToMerge, this.props);
    };
    _proto.getItemCount = function getItemCount() {
      var itemCount = this.items.length;
      if (this.itemCount != null) {
        itemCount = this.itemCount;
      } else if (this.props.itemCount !== void 0) {
        itemCount = this.props.itemCount;
      }
      return itemCount;
    };
    _proto.getItemNodeFromIndex = function getItemNodeFromIndex(index4) {
      return this.props.environment ? this.props.environment.document.getElementById(this.getItemId(index4)) : null;
    };
    _proto.scrollHighlightedItemIntoView = function scrollHighlightedItemIntoView() {
      {
        var node = this.getItemNodeFromIndex(this.getState().highlightedIndex);
        this.props.scrollIntoView(node, this._menuNode);
      }
    };
    _proto.moveHighlightedIndex = function moveHighlightedIndex(amount, otherStateToSet) {
      var itemCount = this.getItemCount();
      var _this$getState8 = this.getState(), highlightedIndex = _this$getState8.highlightedIndex;
      if (itemCount > 0) {
        var nextHighlightedIndex = getHighlightedIndex(highlightedIndex, amount, {
          length: itemCount
        }, this.isItemDisabled, true);
        this.setHighlightedIndex(nextHighlightedIndex, otherStateToSet);
      }
    };
    _proto.getStateAndHelpers = function getStateAndHelpers() {
      var _this$getState9 = this.getState(), highlightedIndex = _this$getState9.highlightedIndex, inputValue = _this$getState9.inputValue, selectedItem = _this$getState9.selectedItem, isOpen = _this$getState9.isOpen;
      var itemToString3 = this.props.itemToString;
      var id = this.id;
      var getRootProps = this.getRootProps, getToggleButtonProps = this.getToggleButtonProps, getLabelProps = this.getLabelProps, getMenuProps = this.getMenuProps, getInputProps = this.getInputProps, getItemProps = this.getItemProps, openMenu = this.openMenu, closeMenu = this.closeMenu, toggleMenu = this.toggleMenu, selectItem = this.selectItem, selectItemAtIndex = this.selectItemAtIndex, selectHighlightedItem = this.selectHighlightedItem, setHighlightedIndex = this.setHighlightedIndex, clearSelection = this.clearSelection, clearItems = this.clearItems, reset = this.reset, setItemCount = this.setItemCount, unsetItemCount = this.unsetItemCount, setState = this.internalSetState;
      return {
        // prop getters
        getRootProps,
        getToggleButtonProps,
        getLabelProps,
        getMenuProps,
        getInputProps,
        getItemProps,
        // actions
        reset,
        openMenu,
        closeMenu,
        toggleMenu,
        selectItem,
        selectItemAtIndex,
        selectHighlightedItem,
        setHighlightedIndex,
        clearSelection,
        clearItems,
        setItemCount,
        unsetItemCount,
        setState,
        // props
        itemToString: itemToString3,
        // derived
        id,
        // state
        highlightedIndex,
        inputValue,
        isOpen,
        selectedItem
      };
    };
    _proto.componentDidMount = function componentDidMount() {
      var _this4 = this;
      if (this.getMenuProps.called && !this.getMenuProps.suppressRefError) {
        validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);
      }
      if (!this.props.environment) {
        this.cleanup = function() {
          _this4.internalClearTimeouts();
        };
      } else {
        var onMouseDown = function onMouseDown2() {
          _this4.isMouseDown = true;
        };
        var onMouseUp = function onMouseUp2(event) {
          _this4.isMouseDown = false;
          var contextWithinDownshift = targetWithinDownshift(event.target, [_this4._rootNode, _this4._menuNode], _this4.props.environment);
          if (!contextWithinDownshift && _this4.getState().isOpen) {
            _this4.reset({
              type: mouseUp
            }, function() {
              return _this4.props.onOuterClick(_this4.getStateAndHelpers());
            });
          }
        };
        var onTouchStart = function onTouchStart2() {
          _this4.isTouchMove = false;
        };
        var onTouchMove = function onTouchMove2() {
          _this4.isTouchMove = true;
        };
        var onTouchEnd = function onTouchEnd2(event) {
          var contextWithinDownshift = targetWithinDownshift(event.target, [_this4._rootNode, _this4._menuNode], _this4.props.environment, false);
          if (!_this4.isTouchMove && !contextWithinDownshift && _this4.getState().isOpen) {
            _this4.reset({
              type: touchEnd
            }, function() {
              return _this4.props.onOuterClick(_this4.getStateAndHelpers());
            });
          }
        };
        var environment = this.props.environment;
        environment.addEventListener("mousedown", onMouseDown);
        environment.addEventListener("mouseup", onMouseUp);
        environment.addEventListener("touchstart", onTouchStart);
        environment.addEventListener("touchmove", onTouchMove);
        environment.addEventListener("touchend", onTouchEnd);
        this.cleanup = function() {
          _this4.internalClearTimeouts();
          _this4.updateStatus.cancel();
          environment.removeEventListener("mousedown", onMouseDown);
          environment.removeEventListener("mouseup", onMouseUp);
          environment.removeEventListener("touchstart", onTouchStart);
          environment.removeEventListener("touchmove", onTouchMove);
          environment.removeEventListener("touchend", onTouchEnd);
        };
      }
    };
    _proto.shouldScroll = function shouldScroll(prevState, prevProps) {
      var _ref10 = this.props.highlightedIndex === void 0 ? this.getState() : this.props, currentHighlightedIndex = _ref10.highlightedIndex;
      var _ref11 = prevProps.highlightedIndex === void 0 ? prevState : prevProps, prevHighlightedIndex = _ref11.highlightedIndex;
      var scrollWhenOpen = currentHighlightedIndex && this.getState().isOpen && !prevState.isOpen;
      var scrollWhenNavigating = currentHighlightedIndex !== prevHighlightedIndex;
      return scrollWhenOpen || scrollWhenNavigating;
    };
    _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
      if (true) {
        validateControlledUnchanged(this.state, prevProps, this.props);
        if (this.getMenuProps.called && !this.getMenuProps.suppressRefError) {
          validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);
        }
      }
      if (isControlledProp(this.props, "selectedItem") && this.props.selectedItemChanged(prevProps.selectedItem, this.props.selectedItem)) {
        this.internalSetState({
          type: controlledPropUpdatedSelectedItem,
          inputValue: this.props.itemToString(this.props.selectedItem)
        });
      }
      if (!this.avoidScrolling && this.shouldScroll(prevState, prevProps)) {
        this.scrollHighlightedItemIntoView();
      }
      {
        this.updateStatus();
      }
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      this.cleanup();
    };
    _proto.render = function render() {
      var children = unwrapArray(this.props.children, noop2);
      this.clearItems();
      this.getRootProps.called = false;
      this.getRootProps.refKey = void 0;
      this.getRootProps.suppressRefError = void 0;
      this.getMenuProps.called = false;
      this.getMenuProps.refKey = void 0;
      this.getMenuProps.suppressRefError = void 0;
      this.getLabelProps.called = false;
      this.getInputProps.called = false;
      var element = unwrapArray(children(this.getStateAndHelpers()));
      if (!element) {
        return null;
      }
      if (this.getRootProps.called || this.props.suppressRefError) {
        if (!this.getRootProps.suppressRefError && !this.props.suppressRefError) {
          validateGetRootPropsCalledCorrectly(element, this.getRootProps);
        }
        return element;
      } else if (isDOMElement(element)) {
        return (0, import_react44.cloneElement)(element, this.getRootProps(getElementProps(element)));
      }
      if (true) {
        throw new Error("downshift: If you return a non-DOM element, you must apply the getRootProps function");
      }
      return void 0;
    };
    return Downshift3;
  }(import_react44.Component);
  Downshift2.defaultProps = {
    defaultHighlightedIndex: null,
    defaultIsOpen: false,
    getA11yStatusMessage,
    itemToString: function itemToString3(i) {
      if (i == null) {
        return "";
      }
      if (isPlainObject3(i) && !i.hasOwnProperty("toString")) {
        console.warn("downshift: An object was passed to the default implementation of `itemToString`. You should probably provide your own `itemToString` implementation. Please refer to the `itemToString` API documentation.", "The object that was passed:", i);
      }
      return String(i);
    },
    onStateChange: noop2,
    onInputValueChange: noop2,
    onUserAction: noop2,
    onChange: noop2,
    onSelect: noop2,
    onOuterClick: noop2,
    selectedItemChanged: function selectedItemChanged(prevItem, item) {
      return prevItem !== item;
    },
    environment: (
      /* istanbul ignore next (ssr) */
      typeof window === "undefined" || false ? void 0 : window
    ),
    stateReducer: function stateReducer3(state, stateToSet) {
      return stateToSet;
    },
    suppressRefError: false,
    scrollIntoView
  };
  Downshift2.stateChangeTypes = stateChangeTypes$3;
  return Downshift2;
}();
true ? Downshift.propTypes = {
  children: import_prop_types29.default.func,
  defaultHighlightedIndex: import_prop_types29.default.number,
  defaultIsOpen: import_prop_types29.default.bool,
  initialHighlightedIndex: import_prop_types29.default.number,
  initialSelectedItem: import_prop_types29.default.any,
  initialInputValue: import_prop_types29.default.string,
  initialIsOpen: import_prop_types29.default.bool,
  getA11yStatusMessage: import_prop_types29.default.func,
  itemToString: import_prop_types29.default.func,
  onChange: import_prop_types29.default.func,
  onSelect: import_prop_types29.default.func,
  onStateChange: import_prop_types29.default.func,
  onInputValueChange: import_prop_types29.default.func,
  onUserAction: import_prop_types29.default.func,
  onOuterClick: import_prop_types29.default.func,
  selectedItemChanged: import_prop_types29.default.func,
  stateReducer: import_prop_types29.default.func,
  itemCount: import_prop_types29.default.number,
  id: import_prop_types29.default.string,
  environment: import_prop_types29.default.shape({
    addEventListener: import_prop_types29.default.func.isRequired,
    removeEventListener: import_prop_types29.default.func.isRequired,
    document: import_prop_types29.default.shape({
      createElement: import_prop_types29.default.func.isRequired,
      getElementById: import_prop_types29.default.func.isRequired,
      activeElement: import_prop_types29.default.any.isRequired,
      body: import_prop_types29.default.any.isRequired
    }).isRequired,
    Node: import_prop_types29.default.func.isRequired
  }),
  suppressRefError: import_prop_types29.default.bool,
  scrollIntoView: import_prop_types29.default.func,
  // things we keep in state for uncontrolled components
  // but can accept as props for controlled components
  /* eslint-disable react/no-unused-prop-types */
  selectedItem: import_prop_types29.default.any,
  isOpen: import_prop_types29.default.bool,
  inputValue: import_prop_types29.default.string,
  highlightedIndex: import_prop_types29.default.number,
  labelId: import_prop_types29.default.string,
  inputId: import_prop_types29.default.string,
  menuId: import_prop_types29.default.string,
  getItemId: import_prop_types29.default.func
  /* eslint-enable react/no-unused-prop-types */
} : void 0;
var Downshift$1 = Downshift;
function validateGetMenuPropsCalledCorrectly(node, _ref12) {
  var refKey = _ref12.refKey;
  if (!node) {
    console.error('downshift: The ref prop "' + refKey + '" from getMenuProps was not applied correctly on your menu element.');
  }
}
function validateGetRootPropsCalledCorrectly(element, _ref13) {
  var refKey = _ref13.refKey;
  var refKeySpecified = refKey !== "ref";
  var isComposite = !isDOMElement(element);
  if (isComposite && !refKeySpecified && !(0, import_react_is.isForwardRef)(element)) {
    console.error("downshift: You returned a non-DOM element. You must specify a refKey in getRootProps");
  } else if (!isComposite && refKeySpecified) {
    console.error('downshift: You returned a DOM element. You should not specify a refKey in getRootProps. You specified "' + refKey + '"');
  }
  if (!(0, import_react_is.isForwardRef)(element) && !getElementProps(element)[refKey]) {
    console.error('downshift: You must apply the ref prop "' + refKey + '" from getRootProps onto your root element.');
  }
}
var dropdownDefaultStateValues = {
  highlightedIndex: -1,
  isOpen: false,
  selectedItem: null,
  inputValue: ""
};
function callOnChangeProps(action, state, newState) {
  var props = action.props, type = action.type;
  var changes = {};
  Object.keys(state).forEach(function(key) {
    invokeOnChangeHandler(key, action, state, newState);
    if (newState[key] !== state[key]) {
      changes[key] = newState[key];
    }
  });
  if (props.onStateChange && Object.keys(changes).length) {
    props.onStateChange(_extends3({
      type
    }, changes));
  }
}
function invokeOnChangeHandler(key, action, state, newState) {
  var props = action.props, type = action.type;
  var handler = "on" + capitalizeString(key) + "Change";
  if (props[handler] && newState[key] !== void 0 && newState[key] !== state[key]) {
    props[handler](_extends3({
      type
    }, newState));
  }
}
function stateReducer(s, a) {
  return a.changes;
}
var updateA11yStatus = debounce3(function(status, document2) {
  setStatus(status, document2);
}, 200);
var useIsomorphicLayoutEffect2 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? import_react44.useLayoutEffect : import_react44.useEffect;
var useElementIds = "useId" in import_react44.default ? function useElementIds2(_ref) {
  var id = _ref.id, labelId = _ref.labelId, menuId = _ref.menuId, getItemId = _ref.getItemId, toggleButtonId = _ref.toggleButtonId, inputId = _ref.inputId;
  var reactId = "downshift-" + import_react44.default.useId();
  if (!id) {
    id = reactId;
  }
  var elementIdsRef = (0, import_react44.useRef)({
    labelId: labelId || id + "-label",
    menuId: menuId || id + "-menu",
    getItemId: getItemId || function(index4) {
      return id + "-item-" + index4;
    },
    toggleButtonId: toggleButtonId || id + "-toggle-button",
    inputId: inputId || id + "-input"
  });
  return elementIdsRef.current;
} : function useElementIds3(_ref2) {
  var _ref2$id = _ref2.id, id = _ref2$id === void 0 ? "downshift-" + generateId() : _ref2$id, labelId = _ref2.labelId, menuId = _ref2.menuId, getItemId = _ref2.getItemId, toggleButtonId = _ref2.toggleButtonId, inputId = _ref2.inputId;
  var elementIdsRef = (0, import_react44.useRef)({
    labelId: labelId || id + "-label",
    menuId: menuId || id + "-menu",
    getItemId: getItemId || function(index4) {
      return id + "-item-" + index4;
    },
    toggleButtonId: toggleButtonId || id + "-toggle-button",
    inputId: inputId || id + "-input"
  });
  return elementIdsRef.current;
};
function getItemAndIndex(itemProp, indexProp, items, errorMessage) {
  var item, index4;
  if (itemProp === void 0) {
    if (indexProp === void 0) {
      throw new Error(errorMessage);
    }
    item = items[indexProp];
    index4 = indexProp;
  } else {
    index4 = indexProp === void 0 ? items.indexOf(itemProp) : indexProp;
    item = itemProp;
  }
  return [item, index4];
}
function isAcceptedCharacterKey(key) {
  return /^\S{1}$/.test(key);
}
function capitalizeString(string) {
  return "" + string.slice(0, 1).toUpperCase() + string.slice(1);
}
function useLatestRef3(val) {
  var ref = (0, import_react44.useRef)(val);
  ref.current = val;
  return ref;
}
function useEnhancedReducer(reducer, props, createInitialState, isStateEqual2) {
  var prevStateRef = (0, import_react44.useRef)();
  var actionRef = (0, import_react44.useRef)();
  var enhancedReducer = (0, import_react44.useCallback)(function(state2, action2) {
    actionRef.current = action2;
    state2 = getState(state2, action2.props);
    var changes = reducer(state2, action2);
    var newState = action2.props.stateReducer(state2, _extends3({}, action2, {
      changes
    }));
    return newState;
  }, [reducer]);
  var _useReducer = (0, import_react44.useReducer)(enhancedReducer, props, createInitialState), state = _useReducer[0], dispatch = _useReducer[1];
  var propsRef = useLatestRef3(props);
  var dispatchWithProps = (0, import_react44.useCallback)(function(action2) {
    return dispatch(_extends3({
      props: propsRef.current
    }, action2));
  }, [propsRef]);
  var action = actionRef.current;
  (0, import_react44.useEffect)(function() {
    var prevState = getState(prevStateRef.current, action == null ? void 0 : action.props);
    var shouldCallOnChangeProps = action && prevStateRef.current && !isStateEqual2(prevState, state);
    if (shouldCallOnChangeProps) {
      callOnChangeProps(action, prevState, state);
    }
    prevStateRef.current = state;
  }, [state, action, isStateEqual2]);
  return [state, dispatchWithProps];
}
function useControlledReducer$1(reducer, props, createInitialState, isStateEqual2) {
  var _useEnhancedReducer = useEnhancedReducer(reducer, props, createInitialState, isStateEqual2), state = _useEnhancedReducer[0], dispatch = _useEnhancedReducer[1];
  return [getState(state, props), dispatch];
}
var defaultProps$3 = {
  itemToString: function itemToString(item) {
    return item ? String(item) : "";
  },
  itemToKey: function itemToKey(item) {
    return item;
  },
  stateReducer,
  scrollIntoView,
  environment: (
    /* istanbul ignore next (ssr) */
    typeof window === "undefined" || false ? void 0 : window
  )
};
function getDefaultValue$1(props, propKey, defaultStateValues2) {
  if (defaultStateValues2 === void 0) {
    defaultStateValues2 = dropdownDefaultStateValues;
  }
  var defaultValue = props["default" + capitalizeString(propKey)];
  if (defaultValue !== void 0) {
    return defaultValue;
  }
  return defaultStateValues2[propKey];
}
function getInitialValue$1(props, propKey, defaultStateValues2) {
  if (defaultStateValues2 === void 0) {
    defaultStateValues2 = dropdownDefaultStateValues;
  }
  var value = props[propKey];
  if (value !== void 0) {
    return value;
  }
  var initialValue = props["initial" + capitalizeString(propKey)];
  if (initialValue !== void 0) {
    return initialValue;
  }
  return getDefaultValue$1(props, propKey, defaultStateValues2);
}
function getInitialState$2(props) {
  var selectedItem = getInitialValue$1(props, "selectedItem");
  var isOpen = getInitialValue$1(props, "isOpen");
  var highlightedIndex = getInitialHighlightedIndex(props);
  var inputValue = getInitialValue$1(props, "inputValue");
  return {
    highlightedIndex: highlightedIndex < 0 && selectedItem && isOpen ? props.items.findIndex(function(item) {
      return props.itemToKey(item) === props.itemToKey(selectedItem);
    }) : highlightedIndex,
    isOpen,
    selectedItem,
    inputValue
  };
}
function getHighlightedIndexOnOpen(props, state, offset5) {
  var items = props.items, initialHighlightedIndex = props.initialHighlightedIndex, defaultHighlightedIndex = props.defaultHighlightedIndex, isItemDisabled2 = props.isItemDisabled, itemToKey2 = props.itemToKey;
  var selectedItem = state.selectedItem, highlightedIndex = state.highlightedIndex;
  if (items.length === 0) {
    return -1;
  }
  if (initialHighlightedIndex !== void 0 && highlightedIndex === initialHighlightedIndex && !isItemDisabled2(items[initialHighlightedIndex], initialHighlightedIndex)) {
    return initialHighlightedIndex;
  }
  if (defaultHighlightedIndex !== void 0 && !isItemDisabled2(items[defaultHighlightedIndex], defaultHighlightedIndex)) {
    return defaultHighlightedIndex;
  }
  if (selectedItem) {
    return items.findIndex(function(item) {
      return itemToKey2(selectedItem) === itemToKey2(item);
    });
  }
  if (offset5 < 0 && !isItemDisabled2(items[items.length - 1], items.length - 1)) {
    return items.length - 1;
  }
  if (offset5 > 0 && !isItemDisabled2(items[0], 0)) {
    return 0;
  }
  return -1;
}
function useMouseAndTouchTracker(environment, handleBlur, downshiftElementsRefs) {
  var mouseAndTouchTrackersRef = (0, import_react44.useRef)({
    isMouseDown: false,
    isTouchMove: false,
    isTouchEnd: false
  });
  (0, import_react44.useEffect)(function() {
    if (!environment) {
      return noop2;
    }
    var downshiftElements = downshiftElementsRefs.map(function(ref) {
      return ref.current;
    });
    function onMouseDown() {
      mouseAndTouchTrackersRef.current.isTouchEnd = false;
      mouseAndTouchTrackersRef.current.isMouseDown = true;
    }
    function onMouseUp(event) {
      mouseAndTouchTrackersRef.current.isMouseDown = false;
      if (!targetWithinDownshift(event.target, downshiftElements, environment)) {
        handleBlur();
      }
    }
    function onTouchStart() {
      mouseAndTouchTrackersRef.current.isTouchEnd = false;
      mouseAndTouchTrackersRef.current.isTouchMove = false;
    }
    function onTouchMove() {
      mouseAndTouchTrackersRef.current.isTouchMove = true;
    }
    function onTouchEnd(event) {
      mouseAndTouchTrackersRef.current.isTouchEnd = true;
      if (!mouseAndTouchTrackersRef.current.isTouchMove && !targetWithinDownshift(event.target, downshiftElements, environment, false)) {
        handleBlur();
      }
    }
    environment.addEventListener("mousedown", onMouseDown);
    environment.addEventListener("mouseup", onMouseUp);
    environment.addEventListener("touchstart", onTouchStart);
    environment.addEventListener("touchmove", onTouchMove);
    environment.addEventListener("touchend", onTouchEnd);
    return function cleanup2() {
      environment.removeEventListener("mousedown", onMouseDown);
      environment.removeEventListener("mouseup", onMouseUp);
      environment.removeEventListener("touchstart", onTouchStart);
      environment.removeEventListener("touchmove", onTouchMove);
      environment.removeEventListener("touchend", onTouchEnd);
    };
  }, [downshiftElementsRefs, environment, handleBlur]);
  return mouseAndTouchTrackersRef.current;
}
var useGetterPropsCalledChecker = function useGetterPropsCalledChecker2() {
  return noop2;
};
if (true) {
  useGetterPropsCalledChecker = function useGetterPropsCalledChecker3() {
    for (var _len = arguments.length, propKeys = new Array(_len), _key = 0; _key < _len; _key++) {
      propKeys[_key] = arguments[_key];
    }
    var getterPropsCalledRef = (0, import_react44.useRef)(propKeys.reduce(function(acc, propKey) {
      acc[propKey] = {};
      return acc;
    }, {}));
    (0, import_react44.useEffect)(function() {
      Object.keys(getterPropsCalledRef.current).forEach(function(propKey) {
        var propCallInfo = getterPropsCalledRef.current[propKey];
        if (!Object.keys(propCallInfo).length) {
          console.error("downshift: You forgot to call the " + propKey + " getter function on your component / element.");
          return;
        }
        var suppressRefError = propCallInfo.suppressRefError, refKey = propCallInfo.refKey, elementRef = propCallInfo.elementRef;
        if (suppressRefError) {
          return;
        }
        if (!(elementRef != null && elementRef.current)) {
          console.error('downshift: The ref prop "' + refKey + '" from ' + propKey + " was not applied correctly on your element.");
        }
      });
    }, []);
    var setGetterPropCallInfo = (0, import_react44.useCallback)(function(propKey, suppressRefError, refKey, elementRef) {
      getterPropsCalledRef.current[propKey] = {
        suppressRefError,
        refKey,
        elementRef
      };
    }, []);
    return setGetterPropCallInfo;
  };
}
function useA11yMessageStatus(getA11yStatusMessage2, options, dependencyArray, environment) {
  if (environment === void 0) {
    environment = {};
  }
  var document2 = environment.document;
  var isInitialMount = useIsInitialMount();
  (0, import_react44.useEffect)(function() {
    if (!getA11yStatusMessage2 || isInitialMount || false || !document2) {
      return;
    }
    var status = getA11yStatusMessage2(options);
    updateA11yStatus(status, document2);
  }, dependencyArray);
  (0, import_react44.useEffect)(function() {
    return function() {
      updateA11yStatus.cancel();
      cleanupStatusDiv(document2);
    };
  }, [document2]);
}
function useScrollIntoView(_ref3) {
  var highlightedIndex = _ref3.highlightedIndex, isOpen = _ref3.isOpen, itemRefs = _ref3.itemRefs, getItemNodeFromIndex = _ref3.getItemNodeFromIndex, menuElement = _ref3.menuElement, scrollIntoViewProp = _ref3.scrollIntoView;
  var shouldScrollRef = (0, import_react44.useRef)(true);
  useIsomorphicLayoutEffect2(function() {
    if (highlightedIndex < 0 || !isOpen || !Object.keys(itemRefs.current).length) {
      return;
    }
    if (shouldScrollRef.current === false) {
      shouldScrollRef.current = true;
    } else {
      scrollIntoViewProp(getItemNodeFromIndex(highlightedIndex), menuElement);
    }
  }, [highlightedIndex]);
  return shouldScrollRef;
}
var useControlPropsValidator = noop2;
if (true) {
  useControlPropsValidator = function useControlPropsValidator2(_ref4) {
    var props = _ref4.props, state = _ref4.state;
    var prevPropsRef = (0, import_react44.useRef)(props);
    var isInitialMount = useIsInitialMount();
    (0, import_react44.useEffect)(function() {
      if (isInitialMount) {
        return;
      }
      validateControlledUnchanged(state, prevPropsRef.current, props);
      prevPropsRef.current = props;
    }, [state, props, isInitialMount]);
  };
}
function getChangesOnSelection(props, highlightedIndex, inputValue) {
  var _props$items;
  if (inputValue === void 0) {
    inputValue = true;
  }
  var shouldSelect = ((_props$items = props.items) == null ? void 0 : _props$items.length) && highlightedIndex >= 0;
  return _extends3({
    isOpen: false,
    highlightedIndex: -1
  }, shouldSelect && _extends3({
    selectedItem: props.items[highlightedIndex],
    isOpen: getDefaultValue$1(props, "isOpen"),
    highlightedIndex: getDefaultValue$1(props, "highlightedIndex")
  }, inputValue && {
    inputValue: props.itemToString(props.items[highlightedIndex])
  }));
}
function isDropdownsStateEqual(prevState, newState) {
  return prevState.isOpen === newState.isOpen && prevState.inputValue === newState.inputValue && prevState.highlightedIndex === newState.highlightedIndex && prevState.selectedItem === newState.selectedItem;
}
function useIsInitialMount() {
  var isInitialMountRef = import_react44.default.useRef(true);
  import_react44.default.useEffect(function() {
    isInitialMountRef.current = false;
    return function() {
      isInitialMountRef.current = true;
    };
  }, []);
  return isInitialMountRef.current;
}
function getDefaultHighlightedIndex(props) {
  var highlightedIndex = getDefaultValue$1(props, "highlightedIndex");
  if (highlightedIndex > -1 && props.isItemDisabled(props.items[highlightedIndex], highlightedIndex)) {
    return -1;
  }
  return highlightedIndex;
}
function getInitialHighlightedIndex(props) {
  var highlightedIndex = getInitialValue$1(props, "highlightedIndex");
  if (highlightedIndex > -1 && props.isItemDisabled(props.items[highlightedIndex], highlightedIndex)) {
    return -1;
  }
  return highlightedIndex;
}
var commonPropTypes = {
  environment: import_prop_types29.default.shape({
    addEventListener: import_prop_types29.default.func.isRequired,
    removeEventListener: import_prop_types29.default.func.isRequired,
    document: import_prop_types29.default.shape({
      createElement: import_prop_types29.default.func.isRequired,
      getElementById: import_prop_types29.default.func.isRequired,
      activeElement: import_prop_types29.default.any.isRequired,
      body: import_prop_types29.default.any.isRequired
    }).isRequired,
    Node: import_prop_types29.default.func.isRequired
  }),
  itemToString: import_prop_types29.default.func,
  itemToKey: import_prop_types29.default.func,
  stateReducer: import_prop_types29.default.func
};
var commonDropdownPropTypes = _extends3({}, commonPropTypes, {
  getA11yStatusMessage: import_prop_types29.default.func,
  highlightedIndex: import_prop_types29.default.number,
  defaultHighlightedIndex: import_prop_types29.default.number,
  initialHighlightedIndex: import_prop_types29.default.number,
  isOpen: import_prop_types29.default.bool,
  defaultIsOpen: import_prop_types29.default.bool,
  initialIsOpen: import_prop_types29.default.bool,
  selectedItem: import_prop_types29.default.any,
  initialSelectedItem: import_prop_types29.default.any,
  defaultSelectedItem: import_prop_types29.default.any,
  id: import_prop_types29.default.string,
  labelId: import_prop_types29.default.string,
  menuId: import_prop_types29.default.string,
  getItemId: import_prop_types29.default.func,
  toggleButtonId: import_prop_types29.default.string,
  onSelectedItemChange: import_prop_types29.default.func,
  onHighlightedIndexChange: import_prop_types29.default.func,
  onStateChange: import_prop_types29.default.func,
  onIsOpenChange: import_prop_types29.default.func,
  scrollIntoView: import_prop_types29.default.func
});
function downshiftCommonReducer(state, action, stateChangeTypes2) {
  var type = action.type, props = action.props;
  var changes;
  switch (type) {
    case stateChangeTypes2.ItemMouseMove:
      changes = {
        highlightedIndex: action.disabled ? -1 : action.index
      };
      break;
    case stateChangeTypes2.MenuMouseLeave:
      changes = {
        highlightedIndex: -1
      };
      break;
    case stateChangeTypes2.ToggleButtonClick:
    case stateChangeTypes2.FunctionToggleMenu:
      changes = {
        isOpen: !state.isOpen,
        highlightedIndex: state.isOpen ? -1 : getHighlightedIndexOnOpen(props, state, 0)
      };
      break;
    case stateChangeTypes2.FunctionOpenMenu:
      changes = {
        isOpen: true,
        highlightedIndex: getHighlightedIndexOnOpen(props, state, 0)
      };
      break;
    case stateChangeTypes2.FunctionCloseMenu:
      changes = {
        isOpen: false
      };
      break;
    case stateChangeTypes2.FunctionSetHighlightedIndex:
      changes = {
        highlightedIndex: props.isItemDisabled(props.items[action.highlightedIndex], action.highlightedIndex) ? -1 : action.highlightedIndex
      };
      break;
    case stateChangeTypes2.FunctionSetInputValue:
      changes = {
        inputValue: action.inputValue
      };
      break;
    case stateChangeTypes2.FunctionReset:
      changes = {
        highlightedIndex: getDefaultHighlightedIndex(props),
        isOpen: getDefaultValue$1(props, "isOpen"),
        selectedItem: getDefaultValue$1(props, "selectedItem"),
        inputValue: getDefaultValue$1(props, "inputValue")
      };
      break;
    default:
      throw new Error("Reducer called without proper action type.");
  }
  return _extends3({}, state, changes);
}
function getItemIndexByCharacterKey(_a) {
  var keysSoFar = _a.keysSoFar, highlightedIndex = _a.highlightedIndex, items = _a.items, itemToString3 = _a.itemToString, isItemDisabled2 = _a.isItemDisabled;
  var lowerCasedKeysSoFar = keysSoFar.toLowerCase();
  for (var index4 = 0; index4 < items.length; index4++) {
    var offsetIndex = (index4 + highlightedIndex + (keysSoFar.length < 2 ? 1 : 0)) % items.length;
    var item = items[offsetIndex];
    if (item !== void 0 && itemToString3(item).toLowerCase().startsWith(lowerCasedKeysSoFar) && !isItemDisabled2(item, offsetIndex)) {
      return offsetIndex;
    }
  }
  return highlightedIndex;
}
var propTypes$2 = __assign(__assign({}, commonDropdownPropTypes), { items: import_prop_types29.default.array.isRequired, isItemDisabled: import_prop_types29.default.func });
var defaultProps$2 = __assign(__assign({}, defaultProps$3), { isItemDisabled: function() {
  return false;
} });
var validatePropTypes$2 = noop2;
if (true) {
  validatePropTypes$2 = function(options, caller) {
    import_prop_types29.default.checkPropTypes(propTypes$2, options, "prop", caller.name);
  };
}
var ToggleButtonClick$1 = true ? "__togglebutton_click__" : 0;
var ToggleButtonKeyDownArrowDown = true ? "__togglebutton_keydown_arrow_down__" : 1;
var ToggleButtonKeyDownArrowUp = true ? "__togglebutton_keydown_arrow_up__" : 2;
var ToggleButtonKeyDownCharacter = true ? "__togglebutton_keydown_character__" : 3;
var ToggleButtonKeyDownEscape = true ? "__togglebutton_keydown_escape__" : 4;
var ToggleButtonKeyDownHome = true ? "__togglebutton_keydown_home__" : 5;
var ToggleButtonKeyDownEnd = true ? "__togglebutton_keydown_end__" : 6;
var ToggleButtonKeyDownEnter = true ? "__togglebutton_keydown_enter__" : 7;
var ToggleButtonKeyDownSpaceButton = true ? "__togglebutton_keydown_space_button__" : 8;
var ToggleButtonKeyDownPageUp = true ? "__togglebutton_keydown_page_up__" : 9;
var ToggleButtonKeyDownPageDown = true ? "__togglebutton_keydown_page_down__" : 10;
var ToggleButtonBlur = true ? "__togglebutton_blur__" : 11;
var MenuMouseLeave$1 = true ? "__menu_mouse_leave__" : 12;
var ItemMouseMove$1 = true ? "__item_mouse_move__" : 13;
var ItemClick$1 = true ? "__item_click__" : 14;
var FunctionToggleMenu$1 = true ? "__function_toggle_menu__" : 15;
var FunctionOpenMenu$1 = true ? "__function_open_menu__" : 16;
var FunctionCloseMenu$1 = true ? "__function_close_menu__" : 17;
var FunctionSetHighlightedIndex$1 = true ? "__function_set_highlighted_index__" : 18;
var FunctionSelectItem$1 = true ? "__function_select_item__" : 19;
var FunctionSetInputValue$1 = true ? "__function_set_input_value__" : 20;
var FunctionReset$2 = true ? "__function_reset__" : 21;
var stateChangeTypes$2 = Object.freeze({
  __proto__: null,
  FunctionCloseMenu: FunctionCloseMenu$1,
  FunctionOpenMenu: FunctionOpenMenu$1,
  FunctionReset: FunctionReset$2,
  FunctionSelectItem: FunctionSelectItem$1,
  FunctionSetHighlightedIndex: FunctionSetHighlightedIndex$1,
  FunctionSetInputValue: FunctionSetInputValue$1,
  FunctionToggleMenu: FunctionToggleMenu$1,
  ItemClick: ItemClick$1,
  ItemMouseMove: ItemMouseMove$1,
  MenuMouseLeave: MenuMouseLeave$1,
  ToggleButtonBlur,
  ToggleButtonClick: ToggleButtonClick$1,
  ToggleButtonKeyDownArrowDown,
  ToggleButtonKeyDownArrowUp,
  ToggleButtonKeyDownCharacter,
  ToggleButtonKeyDownEnd,
  ToggleButtonKeyDownEnter,
  ToggleButtonKeyDownEscape,
  ToggleButtonKeyDownHome,
  ToggleButtonKeyDownPageDown,
  ToggleButtonKeyDownPageUp,
  ToggleButtonKeyDownSpaceButton
});
function downshiftSelectReducer(state, action) {
  var _props$items;
  var type = action.type, props = action.props, altKey = action.altKey;
  var changes;
  switch (type) {
    case ItemClick$1:
      changes = {
        isOpen: getDefaultValue$1(props, "isOpen"),
        highlightedIndex: getDefaultHighlightedIndex(props),
        selectedItem: props.items[action.index]
      };
      break;
    case ToggleButtonKeyDownCharacter:
      {
        var lowercasedKey = action.key;
        var inputValue = "" + state.inputValue + lowercasedKey;
        var prevHighlightedIndex = !state.isOpen && state.selectedItem ? props.items.findIndex(function(item) {
          return props.itemToKey(item) === props.itemToKey(state.selectedItem);
        }) : state.highlightedIndex;
        var highlightedIndex = getItemIndexByCharacterKey({
          keysSoFar: inputValue,
          highlightedIndex: prevHighlightedIndex,
          items: props.items,
          itemToString: props.itemToString,
          isItemDisabled: props.isItemDisabled
        });
        changes = {
          inputValue,
          highlightedIndex,
          isOpen: true
        };
      }
      break;
    case ToggleButtonKeyDownArrowDown:
      {
        var _highlightedIndex = state.isOpen ? getHighlightedIndex(state.highlightedIndex, 1, props.items, props.isItemDisabled) : altKey && state.selectedItem == null ? -1 : getHighlightedIndexOnOpen(props, state, 1);
        changes = {
          highlightedIndex: _highlightedIndex,
          isOpen: true
        };
      }
      break;
    case ToggleButtonKeyDownArrowUp:
      if (state.isOpen && altKey) {
        changes = getChangesOnSelection(props, state.highlightedIndex, false);
      } else {
        var _highlightedIndex2 = state.isOpen ? getHighlightedIndex(state.highlightedIndex, -1, props.items, props.isItemDisabled) : getHighlightedIndexOnOpen(props, state, -1);
        changes = {
          highlightedIndex: _highlightedIndex2,
          isOpen: true
        };
      }
      break;
    // only triggered when menu is open.
    case ToggleButtonKeyDownEnter:
    case ToggleButtonKeyDownSpaceButton:
      changes = getChangesOnSelection(props, state.highlightedIndex, false);
      break;
    case ToggleButtonKeyDownHome:
      changes = {
        highlightedIndex: getNonDisabledIndex(0, false, props.items, props.isItemDisabled),
        isOpen: true
      };
      break;
    case ToggleButtonKeyDownEnd:
      changes = {
        highlightedIndex: getNonDisabledIndex(props.items.length - 1, true, props.items, props.isItemDisabled),
        isOpen: true
      };
      break;
    case ToggleButtonKeyDownPageUp:
      changes = {
        highlightedIndex: getHighlightedIndex(state.highlightedIndex, -10, props.items, props.isItemDisabled)
      };
      break;
    case ToggleButtonKeyDownPageDown:
      changes = {
        highlightedIndex: getHighlightedIndex(state.highlightedIndex, 10, props.items, props.isItemDisabled)
      };
      break;
    case ToggleButtonKeyDownEscape:
      changes = {
        isOpen: false,
        highlightedIndex: -1
      };
      break;
    case ToggleButtonBlur:
      changes = _extends3({
        isOpen: false,
        highlightedIndex: -1
      }, state.highlightedIndex >= 0 && ((_props$items = props.items) == null ? void 0 : _props$items.length) && {
        selectedItem: props.items[state.highlightedIndex]
      });
      break;
    case FunctionSelectItem$1:
      changes = {
        selectedItem: action.selectedItem
      };
      break;
    default:
      return downshiftCommonReducer(state, action, stateChangeTypes$2);
  }
  return _extends3({}, state, changes);
}
var _excluded$2 = ["onClick"];
var _excluded2$2 = ["onMouseLeave", "refKey", "ref"];
var _excluded3$1 = ["onBlur", "onClick", "onPress", "onKeyDown", "refKey", "ref"];
var _excluded4$1 = ["item", "index", "onMouseMove", "onClick", "onMouseDown", "onPress", "refKey", "disabled", "ref"];
useSelect.stateChangeTypes = stateChangeTypes$2;
function useSelect(userProps) {
  if (userProps === void 0) {
    userProps = {};
  }
  validatePropTypes$2(userProps, useSelect);
  var props = _extends3({}, defaultProps$2, userProps);
  var scrollIntoView2 = props.scrollIntoView, environment = props.environment, getA11yStatusMessage2 = props.getA11yStatusMessage;
  var _useControlledReducer = useControlledReducer$1(downshiftSelectReducer, props, getInitialState$2, isDropdownsStateEqual), state = _useControlledReducer[0], dispatch = _useControlledReducer[1];
  var isOpen = state.isOpen, highlightedIndex = state.highlightedIndex, selectedItem = state.selectedItem, inputValue = state.inputValue;
  var toggleButtonRef = (0, import_react44.useRef)(null);
  var menuRef = (0, import_react44.useRef)(null);
  var itemRefs = (0, import_react44.useRef)({});
  var clearTimeoutRef = (0, import_react44.useRef)(null);
  var elementIds = useElementIds(props);
  var latest = useLatestRef3({
    state,
    props
  });
  var getItemNodeFromIndex = (0, import_react44.useCallback)(function(index4) {
    return itemRefs.current[elementIds.getItemId(index4)];
  }, [elementIds]);
  useA11yMessageStatus(getA11yStatusMessage2, state, [isOpen, highlightedIndex, selectedItem, inputValue], environment);
  var shouldScrollRef = useScrollIntoView({
    menuElement: menuRef.current,
    highlightedIndex,
    isOpen,
    itemRefs,
    scrollIntoView: scrollIntoView2,
    getItemNodeFromIndex
  });
  (0, import_react44.useEffect)(function() {
    clearTimeoutRef.current = debounce3(function(outerDispatch) {
      outerDispatch({
        type: FunctionSetInputValue$1,
        inputValue: ""
      });
    }, 500);
    return function() {
      clearTimeoutRef.current.cancel();
    };
  }, []);
  (0, import_react44.useEffect)(function() {
    if (!inputValue) {
      return;
    }
    clearTimeoutRef.current(dispatch);
  }, [dispatch, inputValue]);
  useControlPropsValidator({
    props,
    state
  });
  (0, import_react44.useEffect)(function() {
    var focusOnOpen = getInitialValue$1(props, "isOpen");
    if (focusOnOpen && toggleButtonRef.current) {
      toggleButtonRef.current.focus();
    }
  }, []);
  var mouseAndTouchTrackers = useMouseAndTouchTracker(environment, (0, import_react44.useCallback)(function handleBlur() {
    if (latest.current.state.isOpen) {
      dispatch({
        type: ToggleButtonBlur
      });
    }
  }, [dispatch, latest]), (0, import_react44.useMemo)(function() {
    return [menuRef, toggleButtonRef];
  }, [menuRef.current, toggleButtonRef.current]));
  var setGetterPropCallInfo = useGetterPropsCalledChecker("getMenuProps", "getToggleButtonProps");
  (0, import_react44.useEffect)(function() {
    if (!isOpen) {
      itemRefs.current = {};
    }
  }, [isOpen]);
  var toggleButtonKeyDownHandlers = (0, import_react44.useMemo)(function() {
    return {
      ArrowDown: function ArrowDown2(event) {
        event.preventDefault();
        dispatch({
          type: ToggleButtonKeyDownArrowDown,
          altKey: event.altKey
        });
      },
      ArrowUp: function ArrowUp3(event) {
        event.preventDefault();
        dispatch({
          type: ToggleButtonKeyDownArrowUp,
          altKey: event.altKey
        });
      },
      Home: function Home2(event) {
        event.preventDefault();
        dispatch({
          type: ToggleButtonKeyDownHome
        });
      },
      End: function End2(event) {
        event.preventDefault();
        dispatch({
          type: ToggleButtonKeyDownEnd
        });
      },
      Escape: function Escape2() {
        if (latest.current.state.isOpen) {
          dispatch({
            type: ToggleButtonKeyDownEscape
          });
        }
      },
      Enter: function Enter2(event) {
        event.preventDefault();
        dispatch({
          type: latest.current.state.isOpen ? ToggleButtonKeyDownEnter : ToggleButtonClick$1
        });
      },
      PageUp: function PageUp(event) {
        if (latest.current.state.isOpen) {
          event.preventDefault();
          dispatch({
            type: ToggleButtonKeyDownPageUp
          });
        }
      },
      PageDown: function PageDown(event) {
        if (latest.current.state.isOpen) {
          event.preventDefault();
          dispatch({
            type: ToggleButtonKeyDownPageDown
          });
        }
      },
      " ": function _(event) {
        event.preventDefault();
        var currentState = latest.current.state;
        if (!currentState.isOpen) {
          dispatch({
            type: ToggleButtonClick$1
          });
          return;
        }
        if (currentState.inputValue) {
          dispatch({
            type: ToggleButtonKeyDownCharacter,
            key: " "
          });
        } else {
          dispatch({
            type: ToggleButtonKeyDownSpaceButton
          });
        }
      }
    };
  }, [dispatch, latest]);
  var toggleMenu = (0, import_react44.useCallback)(function() {
    dispatch({
      type: FunctionToggleMenu$1
    });
  }, [dispatch]);
  var closeMenu = (0, import_react44.useCallback)(function() {
    dispatch({
      type: FunctionCloseMenu$1
    });
  }, [dispatch]);
  var openMenu = (0, import_react44.useCallback)(function() {
    dispatch({
      type: FunctionOpenMenu$1
    });
  }, [dispatch]);
  var setHighlightedIndex = (0, import_react44.useCallback)(function(newHighlightedIndex) {
    dispatch({
      type: FunctionSetHighlightedIndex$1,
      highlightedIndex: newHighlightedIndex
    });
  }, [dispatch]);
  var selectItem = (0, import_react44.useCallback)(function(newSelectedItem) {
    dispatch({
      type: FunctionSelectItem$1,
      selectedItem: newSelectedItem
    });
  }, [dispatch]);
  var reset = (0, import_react44.useCallback)(function() {
    dispatch({
      type: FunctionReset$2
    });
  }, [dispatch]);
  var setInputValue = (0, import_react44.useCallback)(function(newInputValue) {
    dispatch({
      type: FunctionSetInputValue$1,
      inputValue: newInputValue
    });
  }, [dispatch]);
  var getLabelProps = (0, import_react44.useCallback)(function(_temp) {
    var _ref = _temp === void 0 ? {} : _temp, onClick = _ref.onClick, labelProps = _objectWithoutPropertiesLoose(_ref, _excluded$2);
    var labelHandleClick = function labelHandleClick2() {
      var _toggleButtonRef$curr;
      (_toggleButtonRef$curr = toggleButtonRef.current) == null || _toggleButtonRef$curr.focus();
    };
    return _extends3({
      id: elementIds.labelId,
      htmlFor: elementIds.toggleButtonId,
      onClick: callAllEventHandlers(onClick, labelHandleClick)
    }, labelProps);
  }, [elementIds]);
  var getMenuProps = (0, import_react44.useCallback)(function(_temp2, _temp3) {
    var _extends22;
    var _ref2 = _temp2 === void 0 ? {} : _temp2, onMouseLeave = _ref2.onMouseLeave, _ref2$refKey = _ref2.refKey, refKey = _ref2$refKey === void 0 ? "ref" : _ref2$refKey, ref = _ref2.ref, rest3 = _objectWithoutPropertiesLoose(_ref2, _excluded2$2);
    var _ref3 = _temp3 === void 0 ? {} : _temp3, _ref3$suppressRefErro = _ref3.suppressRefError, suppressRefError = _ref3$suppressRefErro === void 0 ? false : _ref3$suppressRefErro;
    var menuHandleMouseLeave = function menuHandleMouseLeave2() {
      dispatch({
        type: MenuMouseLeave$1
      });
    };
    setGetterPropCallInfo("getMenuProps", suppressRefError, refKey, menuRef);
    return _extends3((_extends22 = {}, _extends22[refKey] = handleRefs(ref, function(menuNode) {
      menuRef.current = menuNode;
    }), _extends22.id = elementIds.menuId, _extends22.role = "listbox", _extends22["aria-labelledby"] = rest3 && rest3["aria-label"] ? void 0 : "" + elementIds.labelId, _extends22.onMouseLeave = callAllEventHandlers(onMouseLeave, menuHandleMouseLeave), _extends22), rest3);
  }, [dispatch, setGetterPropCallInfo, elementIds]);
  var getToggleButtonProps = (0, import_react44.useCallback)(function(_temp4, _temp5) {
    var _extends32;
    var _ref4 = _temp4 === void 0 ? {} : _temp4, onBlur = _ref4.onBlur, onClick = _ref4.onClick;
    _ref4.onPress;
    var onKeyDown = _ref4.onKeyDown, _ref4$refKey = _ref4.refKey, refKey = _ref4$refKey === void 0 ? "ref" : _ref4$refKey, ref = _ref4.ref, rest3 = _objectWithoutPropertiesLoose(_ref4, _excluded3$1);
    var _ref5 = _temp5 === void 0 ? {} : _temp5, _ref5$suppressRefErro = _ref5.suppressRefError, suppressRefError = _ref5$suppressRefErro === void 0 ? false : _ref5$suppressRefErro;
    var latestState = latest.current.state;
    var toggleButtonHandleClick = function toggleButtonHandleClick2() {
      dispatch({
        type: ToggleButtonClick$1
      });
    };
    var toggleButtonHandleBlur = function toggleButtonHandleBlur2() {
      if (latestState.isOpen && !mouseAndTouchTrackers.isMouseDown) {
        dispatch({
          type: ToggleButtonBlur
        });
      }
    };
    var toggleButtonHandleKeyDown = function toggleButtonHandleKeyDown2(event) {
      var key = normalizeArrowKey(event);
      if (key && toggleButtonKeyDownHandlers[key]) {
        toggleButtonKeyDownHandlers[key](event);
      } else if (isAcceptedCharacterKey(key)) {
        dispatch({
          type: ToggleButtonKeyDownCharacter,
          key
        });
      }
    };
    var toggleProps = _extends3((_extends32 = {}, _extends32[refKey] = handleRefs(ref, function(toggleButtonNode) {
      toggleButtonRef.current = toggleButtonNode;
    }), _extends32["aria-activedescendant"] = latestState.isOpen && latestState.highlightedIndex > -1 ? elementIds.getItemId(latestState.highlightedIndex) : "", _extends32["aria-controls"] = elementIds.menuId, _extends32["aria-expanded"] = latest.current.state.isOpen, _extends32["aria-haspopup"] = "listbox", _extends32["aria-labelledby"] = rest3 && rest3["aria-label"] ? void 0 : "" + elementIds.labelId, _extends32.id = elementIds.toggleButtonId, _extends32.role = "combobox", _extends32.tabIndex = 0, _extends32.onBlur = callAllEventHandlers(onBlur, toggleButtonHandleBlur), _extends32), rest3);
    if (!rest3.disabled) {
      {
        toggleProps.onClick = callAllEventHandlers(onClick, toggleButtonHandleClick);
        toggleProps.onKeyDown = callAllEventHandlers(onKeyDown, toggleButtonHandleKeyDown);
      }
    }
    setGetterPropCallInfo("getToggleButtonProps", suppressRefError, refKey, toggleButtonRef);
    return toggleProps;
  }, [dispatch, elementIds, latest, mouseAndTouchTrackers, setGetterPropCallInfo, toggleButtonKeyDownHandlers]);
  var getItemProps = (0, import_react44.useCallback)(function(_temp6) {
    var _extends4;
    var _ref6 = _temp6 === void 0 ? {} : _temp6, itemProp = _ref6.item, indexProp = _ref6.index, onMouseMove = _ref6.onMouseMove, onClick = _ref6.onClick, onMouseDown = _ref6.onMouseDown;
    _ref6.onPress;
    var _ref6$refKey = _ref6.refKey, refKey = _ref6$refKey === void 0 ? "ref" : _ref6$refKey, disabledProp = _ref6.disabled, ref = _ref6.ref, rest3 = _objectWithoutPropertiesLoose(_ref6, _excluded4$1);
    if (disabledProp !== void 0) {
      console.warn('Passing "disabled" as an argument to getItemProps is not supported anymore. Please use the isItemDisabled prop from useSelect.');
    }
    var _latest$current = latest.current, latestState = _latest$current.state, latestProps = _latest$current.props;
    var _getItemAndIndex = getItemAndIndex(itemProp, indexProp, latestProps.items, "Pass either item or index to getItemProps!"), item = _getItemAndIndex[0], index4 = _getItemAndIndex[1];
    var disabled = latestProps.isItemDisabled(item, index4);
    var itemHandleMouseMove = function itemHandleMouseMove2() {
      if (mouseAndTouchTrackers.isTouchEnd || index4 === latestState.highlightedIndex) {
        return;
      }
      shouldScrollRef.current = false;
      dispatch({
        type: ItemMouseMove$1,
        index: index4,
        disabled
      });
    };
    var itemHandleClick = function itemHandleClick2() {
      dispatch({
        type: ItemClick$1,
        index: index4
      });
    };
    var itemHandleMouseDown = function itemHandleMouseDown2(e2) {
      return e2.preventDefault();
    };
    var itemProps = _extends3((_extends4 = {}, _extends4[refKey] = handleRefs(ref, function(itemNode) {
      if (itemNode) {
        itemRefs.current[elementIds.getItemId(index4)] = itemNode;
      }
    }), _extends4["aria-disabled"] = disabled, _extends4["aria-selected"] = item === latestState.selectedItem, _extends4.id = elementIds.getItemId(index4), _extends4.role = "option", _extends4), rest3);
    if (!disabled) {
      {
        itemProps.onClick = callAllEventHandlers(onClick, itemHandleClick);
      }
    }
    itemProps.onMouseMove = callAllEventHandlers(onMouseMove, itemHandleMouseMove);
    itemProps.onMouseDown = callAllEventHandlers(onMouseDown, itemHandleMouseDown);
    return itemProps;
  }, [latest, elementIds, mouseAndTouchTrackers, shouldScrollRef, dispatch]);
  return {
    // prop getters.
    getToggleButtonProps,
    getLabelProps,
    getMenuProps,
    getItemProps,
    // actions.
    toggleMenu,
    openMenu,
    closeMenu,
    setHighlightedIndex,
    selectItem,
    reset,
    setInputValue,
    // state.
    highlightedIndex,
    isOpen,
    selectedItem,
    inputValue
  };
}
var InputKeyDownArrowDown = true ? "__input_keydown_arrow_down__" : 0;
var InputKeyDownArrowUp = true ? "__input_keydown_arrow_up__" : 1;
var InputKeyDownEscape = true ? "__input_keydown_escape__" : 2;
var InputKeyDownHome = true ? "__input_keydown_home__" : 3;
var InputKeyDownEnd = true ? "__input_keydown_end__" : 4;
var InputKeyDownPageUp = true ? "__input_keydown_page_up__" : 5;
var InputKeyDownPageDown = true ? "__input_keydown_page_down__" : 6;
var InputKeyDownEnter = true ? "__input_keydown_enter__" : 7;
var InputChange = true ? "__input_change__" : 8;
var InputBlur = true ? "__input_blur__" : 9;
var InputClick = true ? "__input_click__" : 10;
var MenuMouseLeave = true ? "__menu_mouse_leave__" : 11;
var ItemMouseMove = true ? "__item_mouse_move__" : 12;
var ItemClick = true ? "__item_click__" : 13;
var ToggleButtonClick = true ? "__togglebutton_click__" : 14;
var FunctionToggleMenu = true ? "__function_toggle_menu__" : 15;
var FunctionOpenMenu = true ? "__function_open_menu__" : 16;
var FunctionCloseMenu = true ? "__function_close_menu__" : 17;
var FunctionSetHighlightedIndex = true ? "__function_set_highlighted_index__" : 18;
var FunctionSelectItem = true ? "__function_select_item__" : 19;
var FunctionSetInputValue = true ? "__function_set_input_value__" : 20;
var FunctionReset$1 = true ? "__function_reset__" : 21;
var ControlledPropUpdatedSelectedItem = true ? "__controlled_prop_updated_selected_item__" : 22;
var stateChangeTypes$1 = Object.freeze({
  __proto__: null,
  ControlledPropUpdatedSelectedItem,
  FunctionCloseMenu,
  FunctionOpenMenu,
  FunctionReset: FunctionReset$1,
  FunctionSelectItem,
  FunctionSetHighlightedIndex,
  FunctionSetInputValue,
  FunctionToggleMenu,
  InputBlur,
  InputChange,
  InputClick,
  InputKeyDownArrowDown,
  InputKeyDownArrowUp,
  InputKeyDownEnd,
  InputKeyDownEnter,
  InputKeyDownEscape,
  InputKeyDownHome,
  InputKeyDownPageDown,
  InputKeyDownPageUp,
  ItemClick,
  ItemMouseMove,
  MenuMouseLeave,
  ToggleButtonClick
});
function getInitialState$1(props) {
  var initialState = getInitialState$2(props);
  var selectedItem = initialState.selectedItem;
  var inputValue = initialState.inputValue;
  if (inputValue === "" && selectedItem && props.defaultInputValue === void 0 && props.initialInputValue === void 0 && props.inputValue === void 0) {
    inputValue = props.itemToString(selectedItem);
  }
  return _extends3({}, initialState, {
    inputValue
  });
}
var propTypes$1 = _extends3({}, commonDropdownPropTypes, {
  items: import_prop_types29.default.array.isRequired,
  isItemDisabled: import_prop_types29.default.func,
  inputValue: import_prop_types29.default.string,
  defaultInputValue: import_prop_types29.default.string,
  initialInputValue: import_prop_types29.default.string,
  inputId: import_prop_types29.default.string,
  onInputValueChange: import_prop_types29.default.func
});
function useControlledReducer(reducer, props, createInitialState, isStateEqual2) {
  var previousSelectedItemRef = (0, import_react44.useRef)();
  var _useEnhancedReducer = useEnhancedReducer(reducer, props, createInitialState, isStateEqual2), state = _useEnhancedReducer[0], dispatch = _useEnhancedReducer[1];
  var isInitialMount = useIsInitialMount();
  (0, import_react44.useEffect)(function() {
    if (!isControlledProp(props, "selectedItem")) {
      return;
    }
    if (!isInitialMount) {
      var shouldCallDispatch = props.itemToKey(props.selectedItem) !== props.itemToKey(previousSelectedItemRef.current);
      if (shouldCallDispatch) {
        dispatch({
          type: ControlledPropUpdatedSelectedItem,
          inputValue: props.itemToString(props.selectedItem)
        });
      }
    }
    previousSelectedItemRef.current = state.selectedItem === previousSelectedItemRef.current ? props.selectedItem : state.selectedItem;
  }, [state.selectedItem, props.selectedItem]);
  return [getState(state, props), dispatch];
}
var validatePropTypes$1 = noop2;
if (true) {
  validatePropTypes$1 = function validatePropTypes2(options, caller) {
    import_prop_types29.default.checkPropTypes(propTypes$1, options, "prop", caller.name);
  };
}
var defaultProps$1 = _extends3({}, defaultProps$3, {
  isItemDisabled: function isItemDisabled() {
    return false;
  }
});
function downshiftUseComboboxReducer(state, action) {
  var _props$items;
  var type = action.type, props = action.props, altKey = action.altKey;
  var changes;
  switch (type) {
    case ItemClick:
      changes = {
        isOpen: getDefaultValue$1(props, "isOpen"),
        highlightedIndex: getDefaultHighlightedIndex(props),
        selectedItem: props.items[action.index],
        inputValue: props.itemToString(props.items[action.index])
      };
      break;
    case InputKeyDownArrowDown:
      if (state.isOpen) {
        changes = {
          highlightedIndex: getHighlightedIndex(state.highlightedIndex, 1, props.items, props.isItemDisabled, true)
        };
      } else {
        changes = {
          highlightedIndex: altKey && state.selectedItem == null ? -1 : getHighlightedIndexOnOpen(props, state, 1),
          isOpen: props.items.length >= 0
        };
      }
      break;
    case InputKeyDownArrowUp:
      if (state.isOpen) {
        if (altKey) {
          changes = getChangesOnSelection(props, state.highlightedIndex);
        } else {
          changes = {
            highlightedIndex: getHighlightedIndex(state.highlightedIndex, -1, props.items, props.isItemDisabled, true)
          };
        }
      } else {
        changes = {
          highlightedIndex: getHighlightedIndexOnOpen(props, state, -1),
          isOpen: props.items.length >= 0
        };
      }
      break;
    case InputKeyDownEnter:
      changes = getChangesOnSelection(props, state.highlightedIndex);
      break;
    case InputKeyDownEscape:
      changes = _extends3({
        isOpen: false,
        highlightedIndex: -1
      }, !state.isOpen && {
        selectedItem: null,
        inputValue: ""
      });
      break;
    case InputKeyDownPageUp:
      changes = {
        highlightedIndex: getHighlightedIndex(state.highlightedIndex, -10, props.items, props.isItemDisabled, true)
      };
      break;
    case InputKeyDownPageDown:
      changes = {
        highlightedIndex: getHighlightedIndex(state.highlightedIndex, 10, props.items, props.isItemDisabled, true)
      };
      break;
    case InputKeyDownHome:
      changes = {
        highlightedIndex: getNonDisabledIndex(0, false, props.items, props.isItemDisabled)
      };
      break;
    case InputKeyDownEnd:
      changes = {
        highlightedIndex: getNonDisabledIndex(props.items.length - 1, true, props.items, props.isItemDisabled)
      };
      break;
    case InputBlur:
      changes = _extends3({
        isOpen: false,
        highlightedIndex: -1
      }, state.highlightedIndex >= 0 && ((_props$items = props.items) == null ? void 0 : _props$items.length) && action.selectItem && {
        selectedItem: props.items[state.highlightedIndex],
        inputValue: props.itemToString(props.items[state.highlightedIndex])
      });
      break;
    case InputChange:
      changes = {
        isOpen: true,
        highlightedIndex: getDefaultHighlightedIndex(props),
        inputValue: action.inputValue
      };
      break;
    case InputClick:
      changes = {
        isOpen: !state.isOpen,
        highlightedIndex: state.isOpen ? -1 : getHighlightedIndexOnOpen(props, state, 0)
      };
      break;
    case FunctionSelectItem:
      changes = {
        selectedItem: action.selectedItem,
        inputValue: props.itemToString(action.selectedItem)
      };
      break;
    case ControlledPropUpdatedSelectedItem:
      changes = {
        inputValue: action.inputValue
      };
      break;
    default:
      return downshiftCommonReducer(state, action, stateChangeTypes$1);
  }
  return _extends3({}, state, changes);
}
var _excluded$1 = ["onMouseLeave", "refKey", "ref"];
var _excluded2$1 = ["item", "index", "refKey", "ref", "onMouseMove", "onMouseDown", "onClick", "onPress", "disabled"];
var _excluded3 = ["onClick", "onPress", "refKey", "ref"];
var _excluded4 = ["onKeyDown", "onChange", "onInput", "onBlur", "onChangeText", "onClick", "refKey", "ref"];
useCombobox.stateChangeTypes = stateChangeTypes$1;
function useCombobox(userProps) {
  if (userProps === void 0) {
    userProps = {};
  }
  validatePropTypes$1(userProps, useCombobox);
  var props = _extends3({}, defaultProps$1, userProps);
  var items = props.items, scrollIntoView2 = props.scrollIntoView, environment = props.environment, getA11yStatusMessage2 = props.getA11yStatusMessage;
  var _useControlledReducer = useControlledReducer(downshiftUseComboboxReducer, props, getInitialState$1, isDropdownsStateEqual), state = _useControlledReducer[0], dispatch = _useControlledReducer[1];
  var isOpen = state.isOpen, highlightedIndex = state.highlightedIndex, selectedItem = state.selectedItem, inputValue = state.inputValue;
  var menuRef = (0, import_react44.useRef)(null);
  var itemRefs = (0, import_react44.useRef)({});
  var inputRef = (0, import_react44.useRef)(null);
  var toggleButtonRef = (0, import_react44.useRef)(null);
  var isInitialMount = useIsInitialMount();
  var elementIds = useElementIds(props);
  var previousResultCountRef = (0, import_react44.useRef)();
  var latest = useLatestRef3({
    state,
    props
  });
  var getItemNodeFromIndex = (0, import_react44.useCallback)(function(index4) {
    return itemRefs.current[elementIds.getItemId(index4)];
  }, [elementIds]);
  useA11yMessageStatus(getA11yStatusMessage2, state, [isOpen, highlightedIndex, selectedItem, inputValue], environment);
  var shouldScrollRef = useScrollIntoView({
    menuElement: menuRef.current,
    highlightedIndex,
    isOpen,
    itemRefs,
    scrollIntoView: scrollIntoView2,
    getItemNodeFromIndex
  });
  useControlPropsValidator({
    props,
    state
  });
  (0, import_react44.useEffect)(function() {
    var focusOnOpen = getInitialValue$1(props, "isOpen");
    if (focusOnOpen && inputRef.current) {
      inputRef.current.focus();
    }
  }, []);
  (0, import_react44.useEffect)(function() {
    if (!isInitialMount) {
      previousResultCountRef.current = items.length;
    }
  });
  var mouseAndTouchTrackers = useMouseAndTouchTracker(environment, (0, import_react44.useCallback)(function handleBlur() {
    if (latest.current.state.isOpen) {
      dispatch({
        type: InputBlur,
        selectItem: false
      });
    }
  }, [dispatch, latest]), (0, import_react44.useMemo)(function() {
    return [menuRef, toggleButtonRef, inputRef];
  }, [menuRef.current, toggleButtonRef.current, inputRef.current]));
  var setGetterPropCallInfo = useGetterPropsCalledChecker("getInputProps", "getMenuProps");
  (0, import_react44.useEffect)(function() {
    if (!isOpen) {
      itemRefs.current = {};
    }
  }, [isOpen]);
  (0, import_react44.useEffect)(function() {
    var _inputRef$current;
    if (!isOpen || !(environment != null && environment.document) || !(inputRef != null && (_inputRef$current = inputRef.current) != null && _inputRef$current.focus)) {
      return;
    }
    if (environment.document.activeElement !== inputRef.current) {
      inputRef.current.focus();
    }
  }, [isOpen, environment]);
  var inputKeyDownHandlers = (0, import_react44.useMemo)(function() {
    return {
      ArrowDown: function ArrowDown2(event) {
        event.preventDefault();
        dispatch({
          type: InputKeyDownArrowDown,
          altKey: event.altKey
        });
      },
      ArrowUp: function ArrowUp3(event) {
        event.preventDefault();
        dispatch({
          type: InputKeyDownArrowUp,
          altKey: event.altKey
        });
      },
      Home: function Home2(event) {
        if (!latest.current.state.isOpen) {
          return;
        }
        event.preventDefault();
        dispatch({
          type: InputKeyDownHome
        });
      },
      End: function End2(event) {
        if (!latest.current.state.isOpen) {
          return;
        }
        event.preventDefault();
        dispatch({
          type: InputKeyDownEnd
        });
      },
      Escape: function Escape2(event) {
        var latestState = latest.current.state;
        if (latestState.isOpen || latestState.inputValue || latestState.selectedItem || latestState.highlightedIndex > -1) {
          event.preventDefault();
          dispatch({
            type: InputKeyDownEscape
          });
        }
      },
      Enter: function Enter2(event) {
        var latestState = latest.current.state;
        if (!latestState.isOpen || event.which === 229) {
          return;
        }
        event.preventDefault();
        dispatch({
          type: InputKeyDownEnter
        });
      },
      PageUp: function PageUp(event) {
        if (latest.current.state.isOpen) {
          event.preventDefault();
          dispatch({
            type: InputKeyDownPageUp
          });
        }
      },
      PageDown: function PageDown(event) {
        if (latest.current.state.isOpen) {
          event.preventDefault();
          dispatch({
            type: InputKeyDownPageDown
          });
        }
      }
    };
  }, [dispatch, latest]);
  var getLabelProps = (0, import_react44.useCallback)(function(labelProps) {
    return _extends3({
      id: elementIds.labelId,
      htmlFor: elementIds.inputId
    }, labelProps);
  }, [elementIds]);
  var getMenuProps = (0, import_react44.useCallback)(function(_temp, _temp2) {
    var _extends22;
    var _ref = _temp === void 0 ? {} : _temp, onMouseLeave = _ref.onMouseLeave, _ref$refKey = _ref.refKey, refKey = _ref$refKey === void 0 ? "ref" : _ref$refKey, ref = _ref.ref, rest3 = _objectWithoutPropertiesLoose(_ref, _excluded$1);
    var _ref2 = _temp2 === void 0 ? {} : _temp2, _ref2$suppressRefErro = _ref2.suppressRefError, suppressRefError = _ref2$suppressRefErro === void 0 ? false : _ref2$suppressRefErro;
    setGetterPropCallInfo("getMenuProps", suppressRefError, refKey, menuRef);
    return _extends3((_extends22 = {}, _extends22[refKey] = handleRefs(ref, function(menuNode) {
      menuRef.current = menuNode;
    }), _extends22.id = elementIds.menuId, _extends22.role = "listbox", _extends22["aria-labelledby"] = rest3 && rest3["aria-label"] ? void 0 : "" + elementIds.labelId, _extends22.onMouseLeave = callAllEventHandlers(onMouseLeave, function() {
      dispatch({
        type: MenuMouseLeave
      });
    }), _extends22), rest3);
  }, [dispatch, setGetterPropCallInfo, elementIds]);
  var getItemProps = (0, import_react44.useCallback)(function(_temp3) {
    var _extends32, _ref4;
    var _ref3 = _temp3 === void 0 ? {} : _temp3, itemProp = _ref3.item, indexProp = _ref3.index, _ref3$refKey = _ref3.refKey, refKey = _ref3$refKey === void 0 ? "ref" : _ref3$refKey, ref = _ref3.ref, onMouseMove = _ref3.onMouseMove, onMouseDown = _ref3.onMouseDown, onClick = _ref3.onClick;
    _ref3.onPress;
    var disabledProp = _ref3.disabled, rest3 = _objectWithoutPropertiesLoose(_ref3, _excluded2$1);
    if (disabledProp !== void 0) {
      console.warn('Passing "disabled" as an argument to getItemProps is not supported anymore. Please use the isItemDisabled prop from useCombobox.');
    }
    var _latest$current = latest.current, latestProps = _latest$current.props, latestState = _latest$current.state;
    var _getItemAndIndex = getItemAndIndex(itemProp, indexProp, latestProps.items, "Pass either item or index to getItemProps!"), item = _getItemAndIndex[0], index4 = _getItemAndIndex[1];
    var disabled = latestProps.isItemDisabled(item, index4);
    var onSelectKey = "onClick";
    var customClickHandler = onClick;
    var itemHandleMouseMove = function itemHandleMouseMove2() {
      if (mouseAndTouchTrackers.isTouchEnd || index4 === latestState.highlightedIndex) {
        return;
      }
      shouldScrollRef.current = false;
      dispatch({
        type: ItemMouseMove,
        index: index4,
        disabled
      });
    };
    var itemHandleClick = function itemHandleClick2() {
      dispatch({
        type: ItemClick,
        index: index4
      });
    };
    var itemHandleMouseDown = function itemHandleMouseDown2(e2) {
      return e2.preventDefault();
    };
    return _extends3((_extends32 = {}, _extends32[refKey] = handleRefs(ref, function(itemNode) {
      if (itemNode) {
        itemRefs.current[elementIds.getItemId(index4)] = itemNode;
      }
    }), _extends32["aria-disabled"] = disabled, _extends32["aria-selected"] = index4 === latestState.highlightedIndex, _extends32.id = elementIds.getItemId(index4), _extends32.role = "option", _extends32), !disabled && (_ref4 = {}, _ref4[onSelectKey] = callAllEventHandlers(customClickHandler, itemHandleClick), _ref4), {
      onMouseMove: callAllEventHandlers(onMouseMove, itemHandleMouseMove),
      onMouseDown: callAllEventHandlers(onMouseDown, itemHandleMouseDown)
    }, rest3);
  }, [dispatch, elementIds, latest, mouseAndTouchTrackers, shouldScrollRef]);
  var getToggleButtonProps = (0, import_react44.useCallback)(function(_temp4) {
    var _extends4;
    var _ref5 = _temp4 === void 0 ? {} : _temp4, onClick = _ref5.onClick;
    _ref5.onPress;
    var _ref5$refKey = _ref5.refKey, refKey = _ref5$refKey === void 0 ? "ref" : _ref5$refKey, ref = _ref5.ref, rest3 = _objectWithoutPropertiesLoose(_ref5, _excluded3);
    var latestState = latest.current.state;
    var toggleButtonHandleClick = function toggleButtonHandleClick2() {
      dispatch({
        type: ToggleButtonClick
      });
    };
    return _extends3((_extends4 = {}, _extends4[refKey] = handleRefs(ref, function(toggleButtonNode) {
      toggleButtonRef.current = toggleButtonNode;
    }), _extends4["aria-controls"] = elementIds.menuId, _extends4["aria-expanded"] = latestState.isOpen, _extends4.id = elementIds.toggleButtonId, _extends4.tabIndex = -1, _extends4), !rest3.disabled && _extends3({}, {
      onClick: callAllEventHandlers(onClick, toggleButtonHandleClick)
    }), rest3);
  }, [dispatch, latest, elementIds]);
  var getInputProps = (0, import_react44.useCallback)(function(_temp5, _temp6) {
    var _extends5;
    var _ref6 = _temp5 === void 0 ? {} : _temp5, onKeyDown = _ref6.onKeyDown, onChange = _ref6.onChange, onInput = _ref6.onInput, onBlur = _ref6.onBlur;
    _ref6.onChangeText;
    var onClick = _ref6.onClick, _ref6$refKey = _ref6.refKey, refKey = _ref6$refKey === void 0 ? "ref" : _ref6$refKey, ref = _ref6.ref, rest3 = _objectWithoutPropertiesLoose(_ref6, _excluded4);
    var _ref7 = _temp6 === void 0 ? {} : _temp6, _ref7$suppressRefErro = _ref7.suppressRefError, suppressRefError = _ref7$suppressRefErro === void 0 ? false : _ref7$suppressRefErro;
    setGetterPropCallInfo("getInputProps", suppressRefError, refKey, inputRef);
    var latestState = latest.current.state;
    var inputHandleKeyDown = function inputHandleKeyDown2(event) {
      var key = normalizeArrowKey(event);
      if (key && inputKeyDownHandlers[key]) {
        inputKeyDownHandlers[key](event);
      }
    };
    var inputHandleChange = function inputHandleChange2(event) {
      dispatch({
        type: InputChange,
        inputValue: event.target.value
      });
    };
    var inputHandleBlur = function inputHandleBlur2(event) {
      if (environment != null && environment.document && latestState.isOpen && !mouseAndTouchTrackers.isMouseDown) {
        var isBlurByTabChange = event.relatedTarget === null && environment.document.activeElement !== environment.document.body;
        dispatch({
          type: InputBlur,
          selectItem: !isBlurByTabChange
        });
      }
    };
    var inputHandleClick = function inputHandleClick2() {
      dispatch({
        type: InputClick
      });
    };
    var onChangeKey = "onChange";
    var eventHandlers = {};
    if (!rest3.disabled) {
      var _eventHandlers;
      eventHandlers = (_eventHandlers = {}, _eventHandlers[onChangeKey] = callAllEventHandlers(onChange, onInput, inputHandleChange), _eventHandlers.onKeyDown = callAllEventHandlers(onKeyDown, inputHandleKeyDown), _eventHandlers.onBlur = callAllEventHandlers(onBlur, inputHandleBlur), _eventHandlers.onClick = callAllEventHandlers(onClick, inputHandleClick), _eventHandlers);
    }
    return _extends3((_extends5 = {}, _extends5[refKey] = handleRefs(ref, function(inputNode) {
      inputRef.current = inputNode;
    }), _extends5["aria-activedescendant"] = latestState.isOpen && latestState.highlightedIndex > -1 ? elementIds.getItemId(latestState.highlightedIndex) : "", _extends5["aria-autocomplete"] = "list", _extends5["aria-controls"] = elementIds.menuId, _extends5["aria-expanded"] = latestState.isOpen, _extends5["aria-labelledby"] = rest3 && rest3["aria-label"] ? void 0 : elementIds.labelId, _extends5.autoComplete = "off", _extends5.id = elementIds.inputId, _extends5.role = "combobox", _extends5.value = latestState.inputValue, _extends5), eventHandlers, rest3);
  }, [dispatch, elementIds, environment, inputKeyDownHandlers, latest, mouseAndTouchTrackers, setGetterPropCallInfo]);
  var toggleMenu = (0, import_react44.useCallback)(function() {
    dispatch({
      type: FunctionToggleMenu
    });
  }, [dispatch]);
  var closeMenu = (0, import_react44.useCallback)(function() {
    dispatch({
      type: FunctionCloseMenu
    });
  }, [dispatch]);
  var openMenu = (0, import_react44.useCallback)(function() {
    dispatch({
      type: FunctionOpenMenu
    });
  }, [dispatch]);
  var setHighlightedIndex = (0, import_react44.useCallback)(function(newHighlightedIndex) {
    dispatch({
      type: FunctionSetHighlightedIndex,
      highlightedIndex: newHighlightedIndex
    });
  }, [dispatch]);
  var selectItem = (0, import_react44.useCallback)(function(newSelectedItem) {
    dispatch({
      type: FunctionSelectItem,
      selectedItem: newSelectedItem
    });
  }, [dispatch]);
  var setInputValue = (0, import_react44.useCallback)(function(newInputValue) {
    dispatch({
      type: FunctionSetInputValue,
      inputValue: newInputValue
    });
  }, [dispatch]);
  var reset = (0, import_react44.useCallback)(function() {
    dispatch({
      type: FunctionReset$1
    });
  }, [dispatch]);
  return {
    // prop getters.
    getItemProps,
    getLabelProps,
    getMenuProps,
    getInputProps,
    getToggleButtonProps,
    // actions.
    toggleMenu,
    openMenu,
    closeMenu,
    setHighlightedIndex,
    setInputValue,
    selectItem,
    reset,
    // state.
    highlightedIndex,
    isOpen,
    selectedItem,
    inputValue
  };
}
var defaultStateValues = {
  activeIndex: -1,
  selectedItems: []
};
function getInitialValue(props, propKey) {
  return getInitialValue$1(props, propKey, defaultStateValues);
}
function getDefaultValue(props, propKey) {
  return getDefaultValue$1(props, propKey, defaultStateValues);
}
function getInitialState(props) {
  var activeIndex = getInitialValue(props, "activeIndex");
  var selectedItems = getInitialValue(props, "selectedItems");
  return {
    activeIndex,
    selectedItems
  };
}
function isKeyDownOperationPermitted(event) {
  if (event.shiftKey || event.metaKey || event.ctrlKey || event.altKey) {
    return false;
  }
  var element = event.target;
  if (element instanceof HTMLInputElement && // if element is a text input
  element.value !== "" && // and we have text in it
  // and cursor is either not at the start or is currently highlighting text.
  (element.selectionStart !== 0 || element.selectionEnd !== 0)) {
    return false;
  }
  return true;
}
function isStateEqual(prevState, newState) {
  return prevState.selectedItems === newState.selectedItems && prevState.activeIndex === newState.activeIndex;
}
var propTypes = {
  stateReducer: commonPropTypes.stateReducer,
  itemToKey: commonPropTypes.itemToKey,
  environment: commonPropTypes.environment,
  selectedItems: import_prop_types29.default.array,
  initialSelectedItems: import_prop_types29.default.array,
  defaultSelectedItems: import_prop_types29.default.array,
  getA11yStatusMessage: import_prop_types29.default.func,
  activeIndex: import_prop_types29.default.number,
  initialActiveIndex: import_prop_types29.default.number,
  defaultActiveIndex: import_prop_types29.default.number,
  onActiveIndexChange: import_prop_types29.default.func,
  onSelectedItemsChange: import_prop_types29.default.func,
  keyNavigationNext: import_prop_types29.default.string,
  keyNavigationPrevious: import_prop_types29.default.string
};
var defaultProps = {
  itemToKey: defaultProps$3.itemToKey,
  stateReducer: defaultProps$3.stateReducer,
  environment: defaultProps$3.environment,
  keyNavigationNext: "ArrowRight",
  keyNavigationPrevious: "ArrowLeft"
};
var validatePropTypes = noop2;
if (true) {
  validatePropTypes = function validatePropTypes2(options, caller) {
    import_prop_types29.default.checkPropTypes(propTypes, options, "prop", caller.name);
  };
}
var SelectedItemClick = true ? "__selected_item_click__" : 0;
var SelectedItemKeyDownDelete = true ? "__selected_item_keydown_delete__" : 1;
var SelectedItemKeyDownBackspace = true ? "__selected_item_keydown_backspace__" : 2;
var SelectedItemKeyDownNavigationNext = true ? "__selected_item_keydown_navigation_next__" : 3;
var SelectedItemKeyDownNavigationPrevious = true ? "__selected_item_keydown_navigation_previous__" : 4;
var DropdownKeyDownNavigationPrevious = true ? "__dropdown_keydown_navigation_previous__" : 5;
var DropdownKeyDownBackspace = true ? "__dropdown_keydown_backspace__" : 6;
var DropdownClick = true ? "__dropdown_click__" : 7;
var FunctionAddSelectedItem = true ? "__function_add_selected_item__" : 8;
var FunctionRemoveSelectedItem = true ? "__function_remove_selected_item__" : 9;
var FunctionSetSelectedItems = true ? "__function_set_selected_items__" : 10;
var FunctionSetActiveIndex = true ? "__function_set_active_index__" : 11;
var FunctionReset = true ? "__function_reset__" : 12;
var stateChangeTypes = Object.freeze({
  __proto__: null,
  DropdownClick,
  DropdownKeyDownBackspace,
  DropdownKeyDownNavigationPrevious,
  FunctionAddSelectedItem,
  FunctionRemoveSelectedItem,
  FunctionReset,
  FunctionSetActiveIndex,
  FunctionSetSelectedItems,
  SelectedItemClick,
  SelectedItemKeyDownBackspace,
  SelectedItemKeyDownDelete,
  SelectedItemKeyDownNavigationNext,
  SelectedItemKeyDownNavigationPrevious
});
function downshiftMultipleSelectionReducer(state, action) {
  var type = action.type, index4 = action.index, props = action.props, selectedItem = action.selectedItem;
  var activeIndex = state.activeIndex, selectedItems = state.selectedItems;
  var changes;
  switch (type) {
    case SelectedItemClick:
      changes = {
        activeIndex: index4
      };
      break;
    case SelectedItemKeyDownNavigationPrevious:
      changes = {
        activeIndex: activeIndex - 1 < 0 ? 0 : activeIndex - 1
      };
      break;
    case SelectedItemKeyDownNavigationNext:
      changes = {
        activeIndex: activeIndex + 1 >= selectedItems.length ? -1 : activeIndex + 1
      };
      break;
    case SelectedItemKeyDownBackspace:
    case SelectedItemKeyDownDelete: {
      if (activeIndex < 0) {
        break;
      }
      var newActiveIndex = activeIndex;
      if (selectedItems.length === 1) {
        newActiveIndex = -1;
      } else if (activeIndex === selectedItems.length - 1) {
        newActiveIndex = selectedItems.length - 2;
      }
      changes = _extends3({
        selectedItems: [].concat(selectedItems.slice(0, activeIndex), selectedItems.slice(activeIndex + 1))
      }, {
        activeIndex: newActiveIndex
      });
      break;
    }
    case DropdownKeyDownNavigationPrevious:
      changes = {
        activeIndex: selectedItems.length - 1
      };
      break;
    case DropdownKeyDownBackspace:
      changes = {
        selectedItems: selectedItems.slice(0, selectedItems.length - 1)
      };
      break;
    case FunctionAddSelectedItem:
      changes = {
        selectedItems: [].concat(selectedItems, [selectedItem])
      };
      break;
    case DropdownClick:
      changes = {
        activeIndex: -1
      };
      break;
    case FunctionRemoveSelectedItem: {
      var _newActiveIndex = activeIndex;
      var selectedItemIndex = selectedItems.findIndex(function(item) {
        return props.itemToKey(item) === props.itemToKey(selectedItem);
      });
      if (selectedItemIndex < 0) {
        break;
      }
      if (selectedItems.length === 1) {
        _newActiveIndex = -1;
      } else if (selectedItemIndex === selectedItems.length - 1) {
        _newActiveIndex = selectedItems.length - 2;
      }
      changes = {
        selectedItems: [].concat(selectedItems.slice(0, selectedItemIndex), selectedItems.slice(selectedItemIndex + 1)),
        activeIndex: _newActiveIndex
      };
      break;
    }
    case FunctionSetSelectedItems: {
      var newSelectedItems = action.selectedItems;
      changes = {
        selectedItems: newSelectedItems
      };
      break;
    }
    case FunctionSetActiveIndex: {
      var _newActiveIndex2 = action.activeIndex;
      changes = {
        activeIndex: _newActiveIndex2
      };
      break;
    }
    case FunctionReset:
      changes = {
        activeIndex: getDefaultValue(props, "activeIndex"),
        selectedItems: getDefaultValue(props, "selectedItems")
      };
      break;
    default:
      throw new Error("Reducer called without proper action type.");
  }
  return _extends3({}, state, changes);
}
var _excluded = ["refKey", "ref", "onClick", "onKeyDown", "selectedItem", "index"];
var _excluded2 = ["refKey", "ref", "onKeyDown", "onClick", "preventKeyAction"];
useMultipleSelection.stateChangeTypes = stateChangeTypes;
function useMultipleSelection(userProps) {
  if (userProps === void 0) {
    userProps = {};
  }
  validatePropTypes(userProps, useMultipleSelection);
  var props = _extends3({}, defaultProps, userProps);
  var getA11yStatusMessage2 = props.getA11yStatusMessage, environment = props.environment, keyNavigationNext = props.keyNavigationNext, keyNavigationPrevious = props.keyNavigationPrevious;
  var _useControlledReducer = useControlledReducer$1(downshiftMultipleSelectionReducer, props, getInitialState, isStateEqual), state = _useControlledReducer[0], dispatch = _useControlledReducer[1];
  var activeIndex = state.activeIndex, selectedItems = state.selectedItems;
  var isInitialMount = useIsInitialMount();
  var dropdownRef = (0, import_react44.useRef)(null);
  var selectedItemRefs = (0, import_react44.useRef)();
  selectedItemRefs.current = [];
  var latest = useLatestRef3({
    state,
    props
  });
  useA11yMessageStatus(getA11yStatusMessage2, state, [activeIndex, selectedItems], environment);
  (0, import_react44.useEffect)(function() {
    if (isInitialMount) {
      return;
    }
    if (activeIndex === -1 && dropdownRef.current) {
      dropdownRef.current.focus();
    } else if (selectedItemRefs.current[activeIndex]) {
      selectedItemRefs.current[activeIndex].focus();
    }
  }, [activeIndex]);
  useControlPropsValidator({
    props,
    state
  });
  var setGetterPropCallInfo = useGetterPropsCalledChecker("getDropdownProps");
  var selectedItemKeyDownHandlers = (0, import_react44.useMemo)(function() {
    var _ref;
    return _ref = {}, _ref[keyNavigationPrevious] = function() {
      dispatch({
        type: SelectedItemKeyDownNavigationPrevious
      });
    }, _ref[keyNavigationNext] = function() {
      dispatch({
        type: SelectedItemKeyDownNavigationNext
      });
    }, _ref.Delete = function Delete2() {
      dispatch({
        type: SelectedItemKeyDownDelete
      });
    }, _ref.Backspace = function Backspace() {
      dispatch({
        type: SelectedItemKeyDownBackspace
      });
    }, _ref;
  }, [dispatch, keyNavigationNext, keyNavigationPrevious]);
  var dropdownKeyDownHandlers = (0, import_react44.useMemo)(function() {
    var _ref2;
    return _ref2 = {}, _ref2[keyNavigationPrevious] = function(event) {
      if (isKeyDownOperationPermitted(event)) {
        dispatch({
          type: DropdownKeyDownNavigationPrevious
        });
      }
    }, _ref2.Backspace = function Backspace(event) {
      if (isKeyDownOperationPermitted(event)) {
        dispatch({
          type: DropdownKeyDownBackspace
        });
      }
    }, _ref2;
  }, [dispatch, keyNavigationPrevious]);
  var getSelectedItemProps = (0, import_react44.useCallback)(function(_temp) {
    var _extends22;
    var _ref3 = _temp === void 0 ? {} : _temp, _ref3$refKey = _ref3.refKey, refKey = _ref3$refKey === void 0 ? "ref" : _ref3$refKey, ref = _ref3.ref, onClick = _ref3.onClick, onKeyDown = _ref3.onKeyDown, selectedItemProp = _ref3.selectedItem, indexProp = _ref3.index, rest3 = _objectWithoutPropertiesLoose(_ref3, _excluded);
    var latestState = latest.current.state;
    var _getItemAndIndex = getItemAndIndex(selectedItemProp, indexProp, latestState.selectedItems, "Pass either item or index to getSelectedItemProps!"), index4 = _getItemAndIndex[1];
    var isFocusable2 = index4 > -1 && index4 === latestState.activeIndex;
    var selectedItemHandleClick = function selectedItemHandleClick2() {
      dispatch({
        type: SelectedItemClick,
        index: index4
      });
    };
    var selectedItemHandleKeyDown = function selectedItemHandleKeyDown2(event) {
      var key = normalizeArrowKey(event);
      if (key && selectedItemKeyDownHandlers[key]) {
        selectedItemKeyDownHandlers[key](event);
      }
    };
    return _extends3((_extends22 = {}, _extends22[refKey] = handleRefs(ref, function(selectedItemNode) {
      if (selectedItemNode) {
        selectedItemRefs.current.push(selectedItemNode);
      }
    }), _extends22.tabIndex = isFocusable2 ? 0 : -1, _extends22.onClick = callAllEventHandlers(onClick, selectedItemHandleClick), _extends22.onKeyDown = callAllEventHandlers(onKeyDown, selectedItemHandleKeyDown), _extends22), rest3);
  }, [dispatch, latest, selectedItemKeyDownHandlers]);
  var getDropdownProps = (0, import_react44.useCallback)(function(_temp2, _temp3) {
    var _extends32;
    var _ref4 = _temp2 === void 0 ? {} : _temp2, _ref4$refKey = _ref4.refKey, refKey = _ref4$refKey === void 0 ? "ref" : _ref4$refKey, ref = _ref4.ref, onKeyDown = _ref4.onKeyDown, onClick = _ref4.onClick, _ref4$preventKeyActio = _ref4.preventKeyAction, preventKeyAction = _ref4$preventKeyActio === void 0 ? false : _ref4$preventKeyActio, rest3 = _objectWithoutPropertiesLoose(_ref4, _excluded2);
    var _ref5 = _temp3 === void 0 ? {} : _temp3, _ref5$suppressRefErro = _ref5.suppressRefError, suppressRefError = _ref5$suppressRefErro === void 0 ? false : _ref5$suppressRefErro;
    setGetterPropCallInfo("getDropdownProps", suppressRefError, refKey, dropdownRef);
    var dropdownHandleKeyDown = function dropdownHandleKeyDown2(event) {
      var key = normalizeArrowKey(event);
      if (key && dropdownKeyDownHandlers[key]) {
        dropdownKeyDownHandlers[key](event);
      }
    };
    var dropdownHandleClick = function dropdownHandleClick2() {
      dispatch({
        type: DropdownClick
      });
    };
    return _extends3((_extends32 = {}, _extends32[refKey] = handleRefs(ref, function(dropdownNode) {
      if (dropdownNode) {
        dropdownRef.current = dropdownNode;
      }
    }), _extends32), !preventKeyAction && {
      onKeyDown: callAllEventHandlers(onKeyDown, dropdownHandleKeyDown),
      onClick: callAllEventHandlers(onClick, dropdownHandleClick)
    }, rest3);
  }, [dispatch, dropdownKeyDownHandlers, setGetterPropCallInfo]);
  var addSelectedItem = (0, import_react44.useCallback)(function(selectedItem) {
    dispatch({
      type: FunctionAddSelectedItem,
      selectedItem
    });
  }, [dispatch]);
  var removeSelectedItem = (0, import_react44.useCallback)(function(selectedItem) {
    dispatch({
      type: FunctionRemoveSelectedItem,
      selectedItem
    });
  }, [dispatch]);
  var setSelectedItems = (0, import_react44.useCallback)(function(newSelectedItems) {
    dispatch({
      type: FunctionSetSelectedItems,
      selectedItems: newSelectedItems
    });
  }, [dispatch]);
  var setActiveIndex = (0, import_react44.useCallback)(function(newActiveIndex) {
    dispatch({
      type: FunctionSetActiveIndex,
      activeIndex: newActiveIndex
    });
  }, [dispatch]);
  var reset = (0, import_react44.useCallback)(function() {
    dispatch({
      type: FunctionReset
    });
  }, [dispatch]);
  return {
    getSelectedItemProps,
    getDropdownProps,
    addSelectedItem,
    removeSelectedItem,
    setSelectedItems,
    setActiveIndex,
    reset,
    selectedItems,
    activeIndex
  };
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ComboBox/ComboBox.js
var import_prop_types41 = __toESM(require_prop_types());
var import_react56 = __toESM(require_react());
var import_react_fast_compare = __toESM(require_react_fast_compare());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ListBox/ListBoxPropTypes.js
var import_prop_types30 = __toESM(require_prop_types());
var listBoxTypes = ["default", "inline"];
var listBoxSizes = ["sm", "md", "lg"];
var ListBoxType = import_prop_types30.default.oneOf(listBoxTypes);
var ListBoxSize = import_prop_types30.default.oneOf(listBoxSizes);

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ListBox/ListBox.js
var import_classnames27 = __toESM(require_classnames());
var import_react48 = __toESM(require_react());
var import_prop_types33 = __toESM(require_prop_types());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FluidForm/FluidForm.js
var import_prop_types32 = __toESM(require_prop_types());
var import_react47 = __toESM(require_react());
var import_classnames26 = __toESM(require_classnames());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Form/Form.js
var import_prop_types31 = __toESM(require_prop_types());
var import_react45 = __toESM(require_react());
var import_classnames25 = __toESM(require_classnames());
function Form(_ref) {
  let {
    className,
    children,
    ...other
  } = _ref;
  const prefix = usePrefix();
  const classNames = (0, import_classnames25.default)(`${prefix}--form`, className);
  return import_react45.default.createElement("form", _extends({
    className: classNames
  }, other), children);
}
Form.propTypes = {
  /**
   * Provide children to be rendered inside of the <form> element
   */
  children: import_prop_types31.default.node,
  /**
   * Provide a custom className to be applied on the containing <form> node
   */
  className: import_prop_types31.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FluidForm/FormContext.js
var import_react46 = __toESM(require_react());
var FormContext = (0, import_react46.createContext)({
  isFluid: false
});

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FluidForm/FluidForm.js
var FluidForm = (_ref) => {
  let {
    className,
    children,
    ...other
  } = _ref;
  const prefix = usePrefix();
  const classNames = (0, import_classnames26.default)(`${prefix}--form--fluid`, className);
  return import_react47.default.createElement(FormContext.Provider, {
    value: {
      isFluid: true
    }
  }, import_react47.default.createElement(Form, _extends({
    className: classNames
  }, other), children));
};
FluidForm.propTypes = {
  /**
   * Provide children to be rendered inside of the <form> element
   */
  children: import_prop_types32.default.node,
  /**
   * Provide a custom className to be applied on the containing <form> node
   */
  className: import_prop_types32.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ListBox/ListBox.js
var handleOnKeyDown = (event) => {
  if (event.keyCode === 27) {
    event.stopPropagation();
  }
};
var handleClick = (event) => {
  event.preventDefault();
  event.stopPropagation();
};
var ListBox = import_react48.default.forwardRef(function ListBox2(_ref, ref) {
  let {
    children,
    className: containerClassName,
    disabled = false,
    type = "default",
    size: size6,
    invalid,
    invalidText,
    invalidTextId,
    warn: warn2,
    warnText,
    warnTextId,
    light,
    isOpen,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const {
    isFluid
  } = (0, import_react48.useContext)(FormContext);
  const showWarning = !invalid && warn2;
  const className = (0, import_classnames27.default)({
    ...containerClassName && {
      [containerClassName]: true
    },
    [`${prefix}--list-box`]: true,
    [`${prefix}--list-box--${size6}`]: size6,
    [`${prefix}--list-box--inline`]: type === "inline",
    [`${prefix}--list-box--disabled`]: disabled,
    [`${prefix}--list-box--light`]: light,
    [`${prefix}--list-box--expanded`]: isOpen,
    [`${prefix}--list-box--invalid`]: invalid,
    [`${prefix}--list-box--warning`]: showWarning
  });
  return import_react48.default.createElement(import_react48.default.Fragment, null, import_react48.default.createElement("div", _extends({}, rest3, {
    className,
    ref,
    onKeyDown: handleOnKeyDown,
    onClick: handleClick,
    "data-invalid": invalid || void 0
  }), children), isFluid && import_react48.default.createElement("hr", {
    className: `${prefix}--list-box__divider`
  }), invalid ? import_react48.default.createElement("div", {
    className: `${prefix}--form-requirement`,
    id: invalidTextId
  }, invalidText) : null, showWarning ? import_react48.default.createElement("div", {
    className: `${prefix}--form-requirement`,
    id: warnTextId
  }, warnText) : null);
});
ListBox.displayName = "ListBox";
ListBox.propTypes = {
  /**
   * Provide the contents of your ListBox
   */
  children: import_prop_types33.default.node,
  /**
   * Specify a class name to be applied on the containing list box node
   */
  className: import_prop_types33.default.string,
  /**
   * Specify whether the ListBox is currently disabled
   */
  disabled: import_prop_types33.default.bool,
  /**
   * Specify whether the control is currently invalid
   */
  invalid: import_prop_types33.default.bool,
  /**
   * Specify the text to be displayed when the control is invalid
   */
  invalidText: import_prop_types33.default.node,
  /**
   * Specify the id to be applied to the element containing the invalid text
   */
  invalidTextId: import_prop_types33.default.string,
  /**
   * Specify if the control should render open
   */
  isOpen: import_prop_types33.default.bool,
  /**
   * `true` to use the light version. For use on $ui-01 backgrounds only.
   * Don't use this to make tile background color same as container background color.
   */
  light: deprecate(import_prop_types33.default.bool, "The `light` prop for `ListBox` has been deprecated in favor of the new `Layer` component. It will be removed in the next major release."),
  /**
   * Specify the size of the ListBox. Currently supports either `sm`, `md` or `lg` as an option.
   */
  size: ListBoxSize,
  /**
   * Specify the "type" of the ListBox. Currently supports either `default` or
   * `inline` as an option.
   */
  type: ListBoxType,
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types33.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types33.default.string,
  /**
   * Specify the id to be applied to the element containing the warn text
   */
  warnTextId: import_prop_types33.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ListBox/ListBoxField.js
var import_react49 = __toESM(require_react());
var import_prop_types34 = __toESM(require_prop_types());
function ListBoxField(_ref) {
  let {
    children,
    disabled,
    tabIndex,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  return import_react49.default.createElement("div", _extends({
    className: `${prefix}--list-box__field`,
    tabIndex: !disabled && tabIndex || -1
  }, rest3), children);
}
ListBoxField.propTypes = {
  /**
   * Typically set by `getToggleButtonProps`, this should specify whether the
   * field has a popup.
   */
  "aria-haspopup": import_prop_types34.default.oneOfType([import_prop_types34.default.string, import_prop_types34.default.bool]),
  /**
   * Provide the contents of your ListBoxField
   */
  children: import_prop_types34.default.node,
  /**
   * Specify if the parent <ListBox> is disabled
   */
  disabled: import_prop_types34.default.bool,
  /**
   * The role for the component, should be set by `getToggleButtonProps` coming
   * from Downshift
   */
  role: import_prop_types34.default.string,
  /**
   * Optional prop to specify the tabIndex of the <ListBox> trigger button
   */
  tabIndex: import_prop_types34.default.oneOfType([import_prop_types34.default.number, import_prop_types34.default.string])
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ListBox/ListBoxMenu.js
var import_react51 = __toESM(require_react());
var import_prop_types36 = __toESM(require_prop_types());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ListBox/ListBoxMenuItem.js
var import_classnames28 = __toESM(require_classnames());
var import_react50 = __toESM(require_react());
var import_prop_types35 = __toESM(require_prop_types());
function useIsTruncated(ref) {
  const [isTruncated, setIsTruncated] = (0, import_react50.useState)(false);
  (0, import_react50.useEffect)(() => {
    const element = ref.current;
    const {
      offsetWidth,
      scrollWidth
    } = element;
    setIsTruncated(offsetWidth < scrollWidth);
  }, [ref, setIsTruncated]);
  return isTruncated;
}
var ListBoxMenuItem = import_react50.default.forwardRef(function ListBoxMenuItem2(_ref, forwardedRef) {
  let {
    children,
    isActive = false,
    isHighlighted = false,
    title,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const ref = (0, import_react50.useRef)(null);
  const isTruncated = useIsTruncated((forwardedRef == null ? void 0 : forwardedRef.menuItemOptionRef) || ref);
  const className = (0, import_classnames28.default)(`${prefix}--list-box__menu-item`, {
    [`${prefix}--list-box__menu-item--active`]: isActive,
    [`${prefix}--list-box__menu-item--highlighted`]: isHighlighted
  });
  return import_react50.default.createElement("li", _extends({}, rest3, {
    className,
    title: isTruncated ? title : void 0
  }), import_react50.default.createElement("div", {
    className: `${prefix}--list-box__menu-item__option`,
    ref: (forwardedRef == null ? void 0 : forwardedRef.menuItemOptionRef) || ref
  }, children));
});
ListBoxMenuItem.displayName = "ListBoxMenuItem";
ListBoxMenuItem.propTypes = {
  /**
   * Specify any children nodes that should be rendered inside of the ListBox
   * Menu Item
   */
  children: import_prop_types35.default.node,
  /**
   * Specify if the item should be disabled
   */
  disabled: import_prop_types35.default.bool,
  /**
   * Specify whether the current menu item is "active".
   */
  isActive: import_prop_types35.default.bool,
  /**
   * Specify whether the current menu item is "highlighted".
   */
  isHighlighted: import_prop_types35.default.bool,
  /**
   * Provide an optional tooltip for the ListBoxMenuItem
   */
  title: import_prop_types35.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ListBox/ListBoxMenu.js
var ListBoxMenu = import_react51.default.forwardRef(function ListBoxMenu2(_ref, ref) {
  let {
    children,
    id,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  return import_react51.default.createElement("ul", _extends({
    ref,
    id,
    className: `${prefix}--list-box__menu`,
    role: "listbox"
  }, rest3), children);
});
ListBoxMenu.displayName = "ListBoxMenu";
ListBoxMenu.propTypes = {
  /**
   * Provide the contents of your ListBoxMenu
   */
  children: import_prop_types36.default.oneOfType([
    import_prop_types36.default.node,
    import_prop_types36.default.arrayOf(import_prop_types36.default.oneOf([ListBoxMenuItem])),
    /**
     * allow single item using the workaround for functional components
     * https://github.com/facebook/react/issues/2979#issuecomment-222379916
     */
    import_prop_types36.default.shape({
      type: import_prop_types36.default.oneOf([ListBoxMenuItem])
    }),
    import_prop_types36.default.bool
    // used in Dropdown for closed state
  ]),
  /**
   * Specify a custom `id`
   */
  id: import_prop_types36.default.string.isRequired
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ListBox/ListBoxMenuIcon.js
var import_classnames29 = __toESM(require_classnames());
var import_react52 = __toESM(require_react());
var import_prop_types37 = __toESM(require_prop_types());
var defaultTranslations = {
  "close.menu": "Close menu",
  "open.menu": "Open menu"
};
var defaultTranslateWithId = (id) => defaultTranslations[id];
var ListBoxMenuIcon = (_ref) => {
  let {
    isOpen,
    translateWithId: t2 = defaultTranslateWithId
  } = _ref;
  const prefix = usePrefix();
  const className = (0, import_classnames29.default)(`${prefix}--list-box__menu-icon`, {
    [`${prefix}--list-box__menu-icon--open`]: isOpen
  });
  const description = isOpen ? t2("close.menu") : t2("open.menu");
  return import_react52.default.createElement("div", {
    className
  }, import_react52.default.createElement(ChevronDown, {
    name: "chevron--down",
    "aria-label": description
  }, import_react52.default.createElement("title", null, description)));
};
ListBoxMenuIcon.propTypes = {
  /**
   * Specify whether the menu is currently open, which will influence the
   * direction of the menu icon
   */
  isOpen: import_prop_types37.default.bool.isRequired,
  /**
   * i18n hook used to provide the appropriate description for the given menu
   * icon. This function takes a ListBoxMenuIconTranslationKey and should
   * return a string message for that given message id.
   */
  translateWithId: import_prop_types37.default.func
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ListBox/ListBoxSelection.js
var import_classnames30 = __toESM(require_classnames());
var import_react53 = __toESM(require_react());
var import_prop_types38 = __toESM(require_prop_types());
var _Close;
var _Close2;
var translationIds = {
  "clear.all": "clear.all",
  "clear.selection": "clear.selection"
};
var defaultTranslations2 = {
  [translationIds["clear.all"]]: "Clear all selected items",
  [translationIds["clear.selection"]]: "Clear selected item"
};
var defaultTranslateWithId2 = (id) => defaultTranslations2[id];
var ListBoxSelection = (_ref) => {
  let {
    clearSelection,
    selectionCount,
    translateWithId: t2 = defaultTranslateWithId2,
    disabled,
    onClearSelection,
    readOnly
  } = _ref;
  const prefix = usePrefix();
  const className = (0, import_classnames30.default)(`${prefix}--list-box__selection`, {
    [`${prefix}--tag--filter`]: selectionCount,
    [`${prefix}--list-box__selection--multi`]: selectionCount
  });
  const handleOnClick = (event) => {
    event.stopPropagation();
    if (disabled || readOnly) {
      return;
    }
    clearSelection(event);
    if (onClearSelection) {
      onClearSelection(event);
    }
  };
  const description = selectionCount ? t2("clear.all") : t2("clear.selection");
  const tagClasses = (0, import_classnames30.default)(`${prefix}--tag`, `${prefix}--tag--filter`, `${prefix}--tag--high-contrast`, {
    [`${prefix}--tag--disabled`]: disabled
  });
  return selectionCount ? import_react53.default.createElement("div", {
    className: tagClasses
  }, import_react53.default.createElement("span", {
    className: `${prefix}--tag__label`,
    title: `${selectionCount}`
  }, selectionCount), import_react53.default.createElement("div", {
    role: "button",
    tabIndex: -1,
    className: `${prefix}--tag__close-icon`,
    onClick: handleOnClick,
    "aria-label": t2("clear.all"),
    title: description,
    "aria-disabled": readOnly ? true : void 0
  }, _Close || (_Close = import_react53.default.createElement(Close, null)))) : import_react53.default.createElement("div", {
    role: "button",
    className,
    tabIndex: -1,
    onClick: handleOnClick,
    "aria-label": description,
    title: description
  }, selectionCount, _Close2 || (_Close2 = import_react53.default.createElement(Close, null)));
};
ListBoxSelection.propTypes = {
  /**
   * Specify a function to be invoked when a user interacts with the clear
   * selection element.
   */
  clearSelection: import_prop_types38.default.func.isRequired,
  /**
   * Specify whether or not the clear selection element should be disabled
   */
  disabled: import_prop_types38.default.bool,
  /**
   * Specify an optional `onClearSelection` handler that is called when the underlying
   * element is cleared
   */
  onClearSelection: import_prop_types38.default.func,
  /**
   * Whether or not the Dropdown is readonly
   */
  readOnly: import_prop_types38.default.bool,
  /**
   * Specify an optional `selectionCount` value that will be used to determine
   * whether the selection should display a badge or a single clear icon.
   */
  selectionCount: import_prop_types38.default.number,
  /**
   * i18n hook used to provide the appropriate description for the given menu
   * icon. This function takes in an id defined in `translationIds` and should
   * return a string message for that given message id.
   */
  translateWithId: import_prop_types38.default.func
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ListBox/index.js
var ListBox3 = Object.assign(ListBox, {
  Field: ListBoxField,
  Menu: ListBoxMenu,
  MenuIcon: ListBoxMenuIcon,
  MenuItem: ListBoxMenuItem,
  Selection: ListBoxSelection
});

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ListBox/next/ListBoxSelection.js
var import_classnames31 = __toESM(require_classnames());
var import_react54 = __toESM(require_react());
var import_prop_types39 = __toESM(require_prop_types());
var _Close3;
var _Close22;
var defaultTranslations3 = {
  "clear.all": "Clear all selected items",
  "clear.selection": "Clear selected item"
};
function defaultTranslateWithId3(id) {
  return defaultTranslations3[id];
}
function ListBoxSelection2(_ref) {
  let {
    clearSelection,
    selectionCount,
    translateWithId: t2 = defaultTranslateWithId3,
    disabled,
    readOnly,
    onClearSelection,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const className = (0, import_classnames31.default)(`${prefix}--list-box__selection`, {
    [`${prefix}--tag--filter`]: selectionCount,
    [`${prefix}--list-box__selection--multi`]: selectionCount
  });
  const description = selectionCount ? t2("clear.all") : t2("clear.selection");
  const tagClasses = (0, import_classnames31.default)(`${prefix}--tag`, `${prefix}--tag--filter`, `${prefix}--tag--high-contrast`, {
    [`${prefix}--tag--disabled`]: disabled
  });
  function onClick(event) {
    event.stopPropagation();
    if (disabled || readOnly) {
      return;
    }
    clearSelection(event);
    if (onClearSelection) {
      onClearSelection(event);
    }
  }
  if (selectionCount) {
    return import_react54.default.createElement("div", {
      className: tagClasses
    }, import_react54.default.createElement("span", {
      className: `${prefix}--tag__label`,
      title: selectionCount == null ? void 0 : selectionCount.toString()
    }, selectionCount), import_react54.default.createElement("button", {
      "aria-label": description,
      className: `${prefix}--tag__close-icon`,
      disabled: disabled || readOnly,
      onClick,
      tabIndex: -1,
      title: description,
      type: "button",
      "aria-disabled": readOnly ? true : void 0
    }, _Close3 || (_Close3 = import_react54.default.createElement(Close, null))));
  }
  return import_react54.default.createElement("button", _extends({}, rest3, {
    "aria-label": description,
    className,
    disabled: disabled || readOnly,
    onClick,
    tabIndex: -1,
    title: description,
    type: "button",
    "aria-disabled": readOnly ? true : void 0
  }), _Close22 || (_Close22 = import_react54.default.createElement(Close, null)));
}
ListBoxSelection2.propTypes = {
  /**
   * Specify a function to be invoked when a user interacts with the clear
   * selection element.
   */
  clearSelection: import_prop_types39.default.func.isRequired,
  /**
   * Specify whether or not the clear selection element should be disabled
   */
  disabled: import_prop_types39.default.bool,
  /**
   * Whether or not the listbox is readonly
   */
  readOnly: import_prop_types39.default.bool,
  /**
   * Specify an optional `onClearSelection` handler that is called when the underlying
   * element is cleared
   */
  onClearSelection: import_prop_types39.default.func,
  /**
   * Specify an optional `onClick` handler that is called when the underlying
   * clear selection element is clicked
   */
  onClick: import_prop_types39.default.func,
  /**
   * Specify an optional `onClick` handler that is called when the underlying
   * clear selection element is clicked
   */
  onMouseUp: import_prop_types39.default.func,
  /**
   * Specify an optional `onKeyDown` handler that is called when the underlying
   * clear selection element fires a keydown event
   */
  onKeyDown: import_prop_types39.default.func,
  /**
   * Specify an optional `selectionCount` value that will be used to determine
   * whether the selection should display a badge or a single clear icon.
   */
  selectionCount: import_prop_types39.default.number,
  /**
   * i18n hook used to provide the appropriate description for the given menu
   * icon. This function takes in an id defined in `translationIds` and should
   * return a string message for that given message id.
   */
  translateWithId: import_prop_types39.default.func
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ListBox/next/ListBoxTrigger.js
var import_classnames32 = __toESM(require_classnames());
var import_react55 = __toESM(require_react());
var import_prop_types40 = __toESM(require_prop_types());
var _ChevronDown;
var translationIds2 = {
  "close.menu": "close.menu",
  "open.menu": "open.menu"
};
var defaultTranslations4 = {
  [translationIds2["close.menu"]]: "Close",
  [translationIds2["open.menu"]]: "Open"
};
var defaultTranslateWithId4 = (id) => defaultTranslations4[id];
var ListBoxTrigger = import_react55.default.forwardRef(function ListBoxTrigger2(_ref, ref) {
  let {
    isOpen,
    translateWithId: t2 = defaultTranslateWithId4,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const className = (0, import_classnames32.default)({
    [`${prefix}--list-box__menu-icon`]: true,
    [`${prefix}--list-box__menu-icon--open`]: isOpen
  });
  const description = isOpen ? t2("close.menu") : t2("open.menu");
  return import_react55.default.createElement("button", _extends({}, rest3, {
    "aria-label": description,
    title: description,
    className,
    type: "button",
    tabIndex: -1,
    ref
  }), _ChevronDown || (_ChevronDown = import_react55.default.createElement(ChevronDown, null)));
});
ListBoxTrigger.propTypes = {
  /**
   * Specify whether the menu is currently open, which will influence the
   * direction of the menu icon
   */
  isOpen: import_prop_types40.default.bool.isRequired,
  /**
   * i18n hook used to provide the appropriate description for the given menu
   * icon. This function takes in an id defined in `translationIds` and should
   * return a string message for that given message id.
   */
  translateWithId: import_prop_types40.default.func
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/tools/mergeRefs.js
var mergeRefs = function() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }
  return (el) => {
    refs.forEach((ref) => {
      if (typeof ref === "function") {
        ref(el);
      } else if (Object(ref) === ref) {
        ref.current = el;
      }
    });
  };
};
var mergeRefs$1 = mergeRefs;

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ComboBox/ComboBox.js
var {
  InputBlur: InputBlur2,
  InputKeyDownEnter: InputKeyDownEnter2,
  FunctionToggleMenu: FunctionToggleMenu2,
  ToggleButtonClick: ToggleButtonClick2,
  ItemMouseMove: ItemMouseMove2,
  InputKeyDownArrowUp: InputKeyDownArrowUp2,
  InputKeyDownArrowDown: InputKeyDownArrowDown2,
  MenuMouseLeave: MenuMouseLeave2
} = useCombobox.stateChangeTypes;
var defaultItemToString = (item) => {
  if (typeof item === "string") {
    return item;
  }
  if (typeof item === "number") {
    return `${item}`;
  }
  if (item !== null && typeof item === "object" && "label" in item && typeof item["label"] === "string") {
    return item["label"];
  }
  return "";
};
var defaultShouldFilterItem = () => true;
var autocompleteCustomFilter = (_ref) => {
  let {
    item,
    inputValue
  } = _ref;
  if (inputValue === null || inputValue === "") {
    return true;
  }
  const lowercaseItem = item.toLowerCase();
  const lowercaseInput = inputValue.toLowerCase();
  return lowercaseItem.startsWith(lowercaseInput);
};
var getInputValue = (_ref2) => {
  let {
    initialSelectedItem,
    inputValue,
    itemToString: itemToString3,
    selectedItem,
    prevSelectedItem
  } = _ref2;
  if (selectedItem) {
    return itemToString3(selectedItem);
  }
  if (initialSelectedItem) {
    return itemToString3(initialSelectedItem);
  }
  if (!selectedItem && prevSelectedItem) {
    return "";
  }
  return inputValue || "";
};
var findHighlightedIndex = (_ref3, inputValue) => {
  let {
    items,
    itemToString: itemToString3 = defaultItemToString
  } = _ref3;
  if (!inputValue) {
    return -1;
  }
  const searchValue = inputValue.toLowerCase();
  for (let i = 0; i < items.length; i++) {
    const item = itemToString3(items[i]).toLowerCase();
    if (!items[i]["disabled"] && item.indexOf(searchValue) !== -1) {
      return i;
    }
  }
  return -1;
};
var ComboBox = (0, import_react56.forwardRef)((props, ref) => {
  var _a, _b, _c, _d;
  const prevInputLengthRef = (0, import_react56.useRef)(0);
  const inputRef = (0, import_react56.useRef)(null);
  const {
    ["aria-label"]: ariaLabel = "Choose an item",
    ariaLabel: deprecatedAriaLabel,
    autoAlign = false,
    className: containerClassName,
    decorator,
    direction = "bottom",
    disabled = false,
    downshiftActions,
    downshiftProps,
    helperText,
    id,
    initialSelectedItem,
    invalid,
    invalidText,
    items,
    itemToElement = null,
    itemToString: itemToString3 = defaultItemToString,
    light,
    onChange,
    onInputChange,
    onToggleClick,
    placeholder,
    readOnly,
    selectedItem: selectedItemProp,
    shouldFilterItem = defaultShouldFilterItem,
    size: size6,
    titleText,
    translateWithId: translateWithId8,
    typeahead = false,
    warn: warn2,
    warnText,
    allowCustomValue = false,
    slug,
    ...rest3
  } = props;
  const enableFloatingStyles = useFeatureFlag("enable-v12-dynamic-floating-styles") || autoAlign;
  const {
    refs,
    floatingStyles,
    middlewareData
  } = useFloating2(enableFloatingStyles ? {
    placement: direction,
    strategy: "fixed",
    middleware: autoAlign ? [flip3(), hide5()] : void 0,
    whileElementsMounted: autoUpdate
  } : {});
  const parentWidth = (_b = (_a = refs == null ? void 0 : refs.reference) == null ? void 0 : _a.current) == null ? void 0 : _b.clientWidth;
  (0, import_react56.useEffect)(() => {
    var _a2;
    if (enableFloatingStyles) {
      const updatedFloatingStyles = {
        ...floatingStyles,
        visibility: ((_a2 = middlewareData.hide) == null ? void 0 : _a2.referenceHidden) ? "hidden" : "visible"
      };
      Object.keys(updatedFloatingStyles).forEach((style) => {
        if (refs.floating.current) {
          refs.floating.current.style[style] = updatedFloatingStyles[style];
        }
      });
      if (parentWidth && refs.floating.current) {
        refs.floating.current.style.width = parentWidth + "px";
      }
    }
  }, [enableFloatingStyles, floatingStyles, refs.floating, parentWidth]);
  const [inputValue, setInputValue] = (0, import_react56.useState)(getInputValue({
    initialSelectedItem,
    inputValue: "",
    itemToString: itemToString3,
    selectedItem: selectedItemProp
  }));
  const [typeaheadText, setTypeaheadText] = (0, import_react56.useState)("");
  (0, import_react56.useEffect)(() => {
    if (typeahead) {
      if (inputValue.length >= prevInputLengthRef.current) {
        if (inputValue) {
          const filteredItems2 = items.filter((item) => autocompleteCustomFilter({
            item: itemToString3(item),
            inputValue
          }));
          if (filteredItems2.length > 0) {
            const suggestion = itemToString3(filteredItems2[0]);
            setTypeaheadText(suggestion.slice(inputValue.length));
          } else {
            setTypeaheadText("");
          }
        } else {
          setTypeaheadText("");
        }
      } else {
        setTypeaheadText("");
      }
      prevInputLengthRef.current = inputValue.length;
    }
  }, [typeahead, inputValue, items, itemToString3, autocompleteCustomFilter]);
  const prefix = usePrefix();
  const {
    isFluid
  } = (0, import_react56.useContext)(FormContext);
  const textInput = (0, import_react56.useRef)(null);
  const comboBoxInstanceId = useId();
  const [isFocused, setIsFocused] = (0, import_react56.useState)(false);
  const savedOnInputChange = (0, import_react56.useRef)(onInputChange);
  const prevSelectedItemProp = (0, import_react56.useRef)(selectedItemProp);
  (0, import_react56.useEffect)(() => {
    if (prevSelectedItemProp.current !== selectedItemProp) {
      const currentInputValue = getInputValue({
        initialSelectedItem,
        inputValue,
        itemToString: itemToString3,
        selectedItem: selectedItemProp,
        prevSelectedItem: prevSelectedItemProp.current
      });
      if (inputValue !== currentInputValue) {
        setInputValue(currentInputValue);
        onChange({
          selectedItem: selectedItemProp,
          inputValue: currentInputValue
        });
      }
      prevSelectedItemProp.current = selectedItemProp;
    }
  }, [selectedItemProp]);
  const filterItems = (items2, itemToString4, inputValue2) => items2.filter((item) => typeahead ? autocompleteCustomFilter({
    item: itemToString4(item),
    inputValue: inputValue2
  }) : shouldFilterItem ? shouldFilterItem({
    item,
    itemToString: itemToString4,
    inputValue: inputValue2
  }) : defaultShouldFilterItem());
  (0, import_react56.useEffect)(() => {
    savedOnInputChange.current = onInputChange;
  }, [onInputChange]);
  (0, import_react56.useEffect)(() => {
    if (savedOnInputChange.current) {
      savedOnInputChange.current(inputValue);
    }
  }, [inputValue]);
  const handleSelectionClear = () => {
    if (textInput == null ? void 0 : textInput.current) {
      textInput.current.focus();
    }
  };
  const filteredItems = (inputValue2) => filterItems(items, itemToString3, inputValue2 || null);
  const indexToHighlight = (inputValue2) => findHighlightedIndex({
    ...props,
    items: filteredItems(inputValue2)
  }, inputValue2);
  const stateReducer3 = (0, import_react56.useCallback)(
    (state, actionAndChanges) => {
      const {
        type,
        changes
      } = actionAndChanges;
      const {
        highlightedIndex: highlightedIndex2
      } = changes;
      switch (type) {
        case InputBlur2: {
          if (allowCustomValue && highlightedIndex2 == "-1") {
            const customValue = inputValue;
            changes.selectedItem = customValue;
            if (onChange) {
              onChange({
                selectedItem: inputValue,
                inputValue
              });
            }
            return changes;
          }
          if (state.inputValue && highlightedIndex2 == "-1" && changes.selectedItem) {
            return {
              ...changes,
              inputValue: itemToString3(changes.selectedItem)
            };
          }
          if (state.inputValue && highlightedIndex2 == "-1" && !allowCustomValue && !changes.selectedItem) {
            return {
              ...changes,
              inputValue: ""
            };
          }
          return changes;
        }
        case InputKeyDownEnter2:
          if (allowCustomValue) {
            setInputValue(inputValue);
            setHighlightedIndex(changes.selectedItem);
            if (onChange) {
              onChange({
                selectedItem: changes.selectedItem,
                inputValue
              });
            }
            return changes;
          } else if (changes.selectedItem && !allowCustomValue) {
            return changes;
          } else {
            return {
              ...changes,
              isOpen: true
            };
          }
        case FunctionToggleMenu2:
        case ToggleButtonClick2:
          if (changes.isOpen && !changes.selectedItem) {
            return {
              ...changes
            };
          }
          return changes;
        case MenuMouseLeave2:
          return {
            ...changes,
            highlightedIndex: state.highlightedIndex
          };
        case InputKeyDownArrowUp2:
        case InputKeyDownArrowDown2:
          if (highlightedIndex2 === -1) {
            return {
              ...changes,
              highlightedIndex: 0
            };
          }
          return changes;
        case ItemMouseMove2:
          return {
            ...changes,
            highlightedIndex: state.highlightedIndex
          };
        default:
          return changes;
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [allowCustomValue, inputValue, onChange]
  );
  const handleToggleClick = (isOpen2) => (event) => {
    var _a2, _b2;
    if (onToggleClick) {
      onToggleClick(event);
    }
    if (readOnly) {
      event.preventDownshiftDefault = true;
      (_a2 = event == null ? void 0 : event.persist) == null ? void 0 : _a2.call(event);
      return;
    }
    if (event.target === textInput.current && isOpen2) {
      event.preventDownshiftDefault = true;
      (_b2 = event == null ? void 0 : event.persist) == null ? void 0 : _b2.call(event);
    }
  };
  const showWarning = !invalid && warn2;
  const className = (0, import_classnames33.default)(`${prefix}--combo-box`, {
    [`${prefix}--combo-box--invalid--focused`]: invalid && isFocused,
    [`${prefix}--list-box--up`]: direction === "top",
    [`${prefix}--combo-box--warning`]: showWarning,
    [`${prefix}--combo-box--readonly`]: readOnly,
    [`${prefix}--autoalign`]: enableFloatingStyles
  });
  const titleClasses = (0, import_classnames33.default)(`${prefix}--label`, {
    [`${prefix}--label--disabled`]: disabled
  });
  const helperTextId = `combobox-helper-text-${comboBoxInstanceId}`;
  const warnTextId = `combobox-warn-text-${comboBoxInstanceId}`;
  const invalidTextId = `combobox-invalid-text-${comboBoxInstanceId}`;
  const helperClasses = (0, import_classnames33.default)(`${prefix}--form__helper-text`, {
    [`${prefix}--form__helper-text--disabled`]: disabled
  });
  const wrapperClasses = (0, import_classnames33.default)(`${prefix}--list-box__wrapper`, [containerClassName, {
    [`${prefix}--list-box__wrapper--fluid--invalid`]: isFluid && invalid,
    [`${prefix}--list-box__wrapper--slug`]: slug,
    [`${prefix}--list-box__wrapper--decorator`]: decorator
  }]);
  const inputClasses = (0, import_classnames33.default)(`${prefix}--text-input`, {
    [`${prefix}--text-input--empty`]: !inputValue,
    [`${prefix}--combo-box--input--focus`]: isFocused
  });
  const ItemToElement = itemToElement;
  let normalizedDecorator = import_react56.default.isValidElement(slug ?? decorator) ? slug ?? decorator : null;
  if (normalizedDecorator && ((_c = normalizedDecorator["type"]) == null ? void 0 : _c.displayName) === "AILabel") {
    normalizedDecorator = import_react56.default.cloneElement(normalizedDecorator, {
      size: "mini"
    });
  }
  const {
    // Prop getters
    getInputProps,
    getItemProps,
    getLabelProps,
    getMenuProps,
    getToggleButtonProps,
    // State
    isOpen,
    highlightedIndex,
    selectedItem,
    // Actions
    closeMenu,
    openMenu,
    reset,
    selectItem,
    setHighlightedIndex,
    setInputValue: downshiftSetInputValue,
    toggleMenu
  } = useCombobox({
    items: filterItems(items, itemToString3, inputValue),
    inputValue,
    itemToString: (item) => {
      return itemToString3(item);
    },
    onInputValueChange(_ref4) {
      let {
        inputValue: inputValue2
      } = _ref4;
      const normalizedInput = inputValue2 || "";
      setInputValue(normalizedInput);
      setHighlightedIndex(indexToHighlight(normalizedInput));
    },
    onHighlightedIndexChange: (_ref5) => {
      let {
        highlightedIndex: highlightedIndex2
      } = _ref5;
      if (highlightedIndex2 > -1 && typeof window !== void 0) {
        const itemArray = document.querySelectorAll(`li.${prefix}--list-box__menu-item[role="option"]`);
        const highlightedItem = itemArray[highlightedIndex2];
        if (highlightedItem) {
          highlightedItem.scrollIntoView({
            behavior: "smooth",
            block: "nearest"
          });
        }
      }
    },
    onStateChange: (_ref6) => {
      let {
        type,
        selectedItem: newSelectedItem
      } = _ref6;
      if (type === useCombobox.stateChangeTypes.ItemClick && !(0, import_react_fast_compare.default)(selectedItemProp, newSelectedItem)) {
        onChange({
          selectedItem: newSelectedItem
        });
      }
      if (type === useCombobox.stateChangeTypes.FunctionSelectItem || type === useCombobox.stateChangeTypes.InputKeyDownEnter) {
        onChange({
          selectedItem: newSelectedItem
        });
      }
    },
    initialSelectedItem,
    inputId: id,
    stateReducer: stateReducer3,
    isItemDisabled(item, _index) {
      return item == null ? void 0 : item.disabled;
    },
    ...downshiftProps
  });
  (0, import_react56.useEffect)(() => {
    if (downshiftActions) {
      downshiftActions.current = {
        closeMenu,
        openMenu,
        reset,
        selectItem,
        setHighlightedIndex,
        setInputValue: downshiftSetInputValue,
        toggleMenu
      };
    }
  }, [closeMenu, openMenu, reset, selectItem, setHighlightedIndex, downshiftSetInputValue, toggleMenu]);
  const buttonProps = getToggleButtonProps({
    disabled: disabled || readOnly,
    onClick: handleToggleClick(isOpen),
    // When we moved the "root node" of Downshift to the <input> for
    // ARIA 1.2 compliance, we unfortunately hit this branch for the
    // "mouseup" event that downshift listens to:
    // https://github.com/downshift-js/downshift/blob/v5.2.1/src/downshift.js#L1051-L1065
    //
    // As a result, it will reset the state of the component and so we
    // stop the event from propagating to prevent this if the menu is already open.
    // This allows the toggleMenu behavior for the toggleButton to correctly open and
    // close the menu.
    onMouseUp(event) {
      if (isOpen) {
        event.stopPropagation();
      }
    }
  });
  const handleFocus = (evt) => {
    setIsFocused(evt.type === "focus");
  };
  const readOnlyEventHandlers = readOnly ? {
    onKeyDown: (evt) => {
      if (evt.key !== "Tab") {
        evt.preventDefault();
      }
    },
    onClick: (evt) => {
      evt.preventDefault();
      evt.currentTarget.focus();
    }
  } : {};
  const ariaDescribedBy = invalid && invalidText && invalidTextId || warn2 && warnText && warnTextId || helperText && !isFluid && helperTextId || void 0;
  const menuProps = (0, import_react56.useMemo)(() => getMenuProps({
    ref: enableFloatingStyles ? refs.setFloating : null
  }), [enableFloatingStyles, deprecatedAriaLabel, ariaLabel, getMenuProps, refs.setFloating]);
  (0, import_react56.useEffect)(() => {
    if (textInput.current) {
      if (inputRef.current && typeaheadText) {
        const selectionStart = inputValue.length;
        const selectionEnd = selectionStart + typeaheadText.length;
        inputRef.current.value = inputValue + typeaheadText;
        inputRef.current.setSelectionRange(selectionStart, selectionEnd);
      }
    }
  }, [inputValue, typeaheadText]);
  return import_react56.default.createElement("div", {
    className: wrapperClasses
  }, titleText && import_react56.default.createElement(Text, _extends({
    as: "label",
    className: titleClasses
  }, getLabelProps()), titleText), import_react56.default.createElement(ListBox3, {
    onFocus: handleFocus,
    onBlur: handleFocus,
    className,
    disabled,
    invalid,
    invalidText,
    invalidTextId,
    isOpen,
    light,
    size: size6,
    warn: warn2,
    ref: enableFloatingStyles ? refs.setReference : null,
    warnText,
    warnTextId
  }, import_react56.default.createElement("div", {
    className: `${prefix}--list-box__field`
  }, import_react56.default.createElement("input", _extends({
    disabled,
    className: inputClasses,
    type: "text",
    tabIndex: 0,
    "aria-haspopup": "listbox",
    title: (_d = textInput == null ? void 0 : textInput.current) == null ? void 0 : _d.value
  }, getInputProps({
    "aria-label": titleText ? void 0 : deprecatedAriaLabel || ariaLabel,
    "aria-controls": isOpen ? void 0 : menuProps.id,
    placeholder,
    value: inputValue,
    onChange: (e2) => {
      const newValue = e2.target.value;
      setInputValue(newValue);
      downshiftSetInputValue(newValue);
    },
    ref: mergeRefs$1(textInput, ref, inputRef),
    onKeyDown: (event) => {
      var _a2, _b2;
      if (match(event, Space)) {
        event.stopPropagation();
      }
      if (match(event, Enter) && (!inputValue || allowCustomValue)) {
        toggleMenu();
        if (highlightedIndex !== -1) {
          selectItem(filterItems(items, itemToString3, inputValue)[highlightedIndex]);
        }
        if (allowCustomValue && isOpen && inputValue) {
          onChange({
            selectedItem,
            inputValue
          });
        }
        event.preventDownshiftDefault = true;
        (_a2 = event == null ? void 0 : event.persist) == null ? void 0 : _a2.call(event);
      }
      if (match(event, Escape) && inputValue) {
        if (event.target === textInput.current && isOpen) {
          toggleMenu();
          event.preventDownshiftDefault = true;
          (_b2 = event == null ? void 0 : event.persist) == null ? void 0 : _b2.call(event);
        }
      }
      if (match(event, Home) && event.code !== "Numpad7") {
        event.target.setSelectionRange(0, 0);
      }
      if (match(event, End) && event.code !== "Numpad1") {
        event.target.setSelectionRange(event.target.value.length, event.target.value.length);
      }
      if (event.altKey && event.key == "ArrowDown") {
        event.preventDownshiftDefault = true;
        if (!isOpen) {
          toggleMenu();
        }
      }
      if (event.altKey && event.key == "ArrowUp") {
        event.preventDownshiftDefault = true;
        if (isOpen) {
          toggleMenu();
        }
      }
      if (typeahead && event.key === "Tab") {
        const matchingItem = items.find((item) => itemToString3(item).toLowerCase().startsWith(inputValue.toLowerCase()));
        if (matchingItem) {
          const newValue = itemToString3(matchingItem);
          downshiftSetInputValue(newValue);
          selectItem(matchingItem);
        }
      }
    }
  }), rest3, readOnlyEventHandlers, {
    readOnly,
    "aria-describedby": ariaDescribedBy
  })), invalid && import_react56.default.createElement(WarningFilled, {
    className: `${prefix}--list-box__invalid-icon`
  }), showWarning && import_react56.default.createElement(WarningAltFilled, {
    className: `${prefix}--list-box__invalid-icon ${prefix}--list-box__invalid-icon--warning`
  }), inputValue && import_react56.default.createElement(ListBoxSelection2, {
    clearSelection: () => {
      selectItem(null);
    },
    translateWithId: translateWithId8,
    disabled: disabled || readOnly,
    onClearSelection: handleSelectionClear,
    selectionCount: 0
  }), import_react56.default.createElement(ListBoxTrigger, _extends({}, buttonProps, {
    isOpen,
    translateWithId: translateWithId8
  }))), slug ? normalizedDecorator : decorator ? import_react56.default.createElement("div", {
    className: `${prefix}--list-box__inner-wrapper--decorator`
  }, normalizedDecorator) : "", import_react56.default.createElement(ListBox3.Menu, menuProps, isOpen ? filterItems(items, itemToString3, inputValue).map((item, index4) => {
    var _a2;
    const isObject2 = item !== null && typeof item === "object";
    const title = isObject2 && "text" in item && itemToElement ? (_a2 = item.text) == null ? void 0 : _a2.toString() : itemToString3(item);
    const itemProps = getItemProps({
      item,
      index: index4
    });
    const disabled2 = itemProps["aria-disabled"];
    const {
      "aria-disabled": unusedAriaDisabled,
      // eslint-disable-line @typescript-eslint/no-unused-vars
      ...modifiedItemProps
    } = itemProps;
    return import_react56.default.createElement(ListBox3.MenuItem, _extends({
      key: itemProps.id,
      isActive: selectedItem === item,
      isHighlighted: highlightedIndex === index4,
      title,
      disabled: disabled2
    }, modifiedItemProps), ItemToElement ? import_react56.default.createElement(ItemToElement, _extends({
      key: itemProps.id
    }, item)) : itemToString3(item), selectedItem === item && import_react56.default.createElement(Checkmark, {
      className: `${prefix}--list-box__menu-item__selected-icon`
    }));
  }) : null)), helperText && !invalid && !warn2 && !isFluid && import_react56.default.createElement(Text, {
    as: "div",
    id: helperTextId,
    className: helperClasses
  }, helperText));
});
ComboBox.displayName = "ComboBox";
ComboBox.propTypes = {
  /**
   * Specify whether or not the ComboBox should allow a value that is
   * not in the list to be entered in the input
   */
  allowCustomValue: import_prop_types41.default.bool,
  /**
   * 'aria-label' of the ListBox component.
   * Specify a label to be read by screen readers on the container node
   */
  ["aria-label"]: import_prop_types41.default.string,
  /**
   * Deprecated, please use `aria-label` instead.
   * Specify a label to be read by screen readers on the container note.
   * 'aria-label' of the ListBox component.
   */
  ariaLabel: deprecate(import_prop_types41.default.string, "This prop syntax has been deprecated. Please use the new `aria-label`."),
  /**
   * **Experimental**: Will attempt to automatically align the floating
   * element to avoid collisions with the viewport and being clipped by
   * ancestor elements.
   */
  autoAlign: import_prop_types41.default.bool,
  /**
   * An optional className to add to the container node
   */
  className: import_prop_types41.default.string,
  /**
   * **Experimental**: Provide a decorator component to be rendered inside the `ComboBox` component
   */
  decorator: import_prop_types41.default.node,
  /**
   * Specify the direction of the combobox dropdown. Can be either top or bottom.
   */
  direction: import_prop_types41.default.oneOf(["top", "bottom"]),
  /**
   * Specify if the control should be disabled, or not
   */
  disabled: import_prop_types41.default.bool,
  /**
   * Additional props passed to Downshift.
   *
   * **Use with caution:** anything you define here overrides the components'
   * internal handling of that prop. Downshift APIs and internals are subject to
   * change, and in some cases they can not be shimmed by Carbon to shield you
   * from potentially breaking changes.
   */
  downshiftProps: import_prop_types41.default.object,
  /**
   * Provide a ref that will be mutated to contain an object of downshift
   * action functions. These can be called to change the internal state of the
   * downshift useCombobox hook.
   *
   * **Use with caution:** calling these actions modifies the internal state of
   * downshift. It may conflict with or override the state management used within
   * Combobox. Downshift APIs and internals are subject to change, and in some
   * cases they can not be shimmed by Carbon to shield you from potentially breaking
   * changes.
   */
  downshiftActions: import_prop_types41.default.exact({
    current: import_prop_types41.default.any
  }),
  /**
   * Provide helper text that is used alongside the control label for
   * additional help
   */
  helperText: import_prop_types41.default.node,
  /**
   * Specify a custom `id` for the input
   */
  id: import_prop_types41.default.string.isRequired,
  /**
   * Allow users to pass in an arbitrary item or a string (in case their items are an array of strings)
   * from their collection that are pre-selected
   */
  initialSelectedItem: import_prop_types41.default.oneOfType([import_prop_types41.default.object, import_prop_types41.default.string, import_prop_types41.default.number]),
  /**
   * Specify if the currently selected value is invalid.
   */
  invalid: import_prop_types41.default.bool,
  /**
   * Message which is displayed if the value is invalid.
   */
  invalidText: import_prop_types41.default.node,
  /**
   * Optional function to render items as custom components instead of strings.
   * Defaults to null and is overridden by a getter
   */
  itemToElement: import_prop_types41.default.func,
  /**
   * Helper function passed to downshift that allows the library to render a
   * given item to a string label. By default, it extracts the `label` field
   * from a given item to serve as the item label in the list
   */
  itemToString: import_prop_types41.default.func,
  /**
   * We try to stay as generic as possible here to allow individuals to pass
   * in a collection of whatever kind of data structure they prefer
   */
  items: import_prop_types41.default.array.isRequired,
  /**
   * should use "light theme" (white background)?
   */
  light: deprecate(import_prop_types41.default.bool, "The `light` prop for `Combobox` has been deprecated in favor of the new `Layer` component. It will be removed in the next major release."),
  /**
   * `onChange` is a utility for this controlled component to communicate to a
   * consuming component when a specific dropdown item is selected.
   * `({ selectedItem }) => void`
   * @param {{ selectedItem }}
   */
  onChange: import_prop_types41.default.func.isRequired,
  /**
   * Callback function to notify consumer when the text input changes.
   * This provides support to change available items based on the text.
   * `(inputText) => void`
   * @param {string} inputText
   */
  onInputChange: import_prop_types41.default.func,
  /**
   * Callback function that fires when the combobox menu toggle is clicked
   * `(evt) => void`
   * @param {MouseEvent} event
   */
  onToggleClick: import_prop_types41.default.func,
  /**
   * Used to provide a placeholder text node before a user enters any input.
   * This is only present if the control has no items selected
   */
  placeholder: import_prop_types41.default.string,
  /**
   * Is the ComboBox readonly?
   */
  readOnly: import_prop_types41.default.bool,
  /**
   * For full control of the selection
   */
  selectedItem: import_prop_types41.default.oneOfType([import_prop_types41.default.object, import_prop_types41.default.string, import_prop_types41.default.number]),
  /**
   * Specify your own filtering logic by passing in a `shouldFilterItem`
   * function that takes in the current input and an item and passes back
   * whether or not the item should be filtered.
   * this prop will be ignored if `typeahead` prop is enabled
   */
  shouldFilterItem: import_prop_types41.default.func,
  /**
   * Specify the size of the ListBox. Currently supports either `sm`, `md` or `lg` as an option.
   */
  size: ListBoxSize,
  slug: deprecate(import_prop_types41.default.node, "The `slug` prop has been deprecated and will be removed in the next major version. Use the decorator prop instead."),
  /**
   * Provide text to be used in a `<label>` element that is tied to the
   * combobox via ARIA attributes.
   */
  titleText: import_prop_types41.default.node,
  /**
   * Specify a custom translation function that takes in a message identifier
   * and returns the localized string for the message
   */
  translateWithId: import_prop_types41.default.func,
  /**
   * **Experimental**: will enable autcomplete and typeahead for the input field
   */
  typeahead: import_prop_types41.default.bool,
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types41.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types41.default.node
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ComboButton/index.js
var import_react66 = __toESM(require_react());
var import_prop_types44 = __toESM(require_prop_types());
var import_classnames36 = __toESM(require_classnames());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Menu/Menu.js
var import_classnames34 = __toESM(require_classnames());
var import_prop_types42 = __toESM(require_prop_types());
var import_react61 = __toESM(require_react());
var import_react_dom3 = __toESM(require_react_dom());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Menu/MenuContext.js
var import_react58 = __toESM(require_react());
var menuDefaultState = {
  isRoot: true,
  mode: "full",
  hasIcons: false,
  size: null,
  items: [],
  requestCloseRoot: () => {
  }
};
function menuReducer(state, action) {
  switch (action.type) {
    case "enableIcons":
      return {
        ...state,
        hasIcons: true
      };
    case "registerItem":
      return {
        ...state,
        items: [...state.items, action.payload].filter((item) => item.ref.current !== null)
      };
  }
}
var MenuContext = (0, import_react58.createContext)({
  state: menuDefaultState,
  // 'dispatch' is populated by the root menu
  dispatch: (_) => {
  }
});

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/LayoutDirection/useLayoutDirection.js
var import_react60 = __toESM(require_react());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/LayoutDirection/LayoutDirectionContext.js
var import_react59 = __toESM(require_react());
var LayoutDirectionContext = import_react59.default.createContext({
  direction: "ltr"
});

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/LayoutDirection/useLayoutDirection.js
function useLayoutDirection() {
  return (0, import_react60.useContext)(LayoutDirectionContext);
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Menu/Menu.js
var spacing = 8;
var Menu2 = (0, import_react61.forwardRef)(function Menu3(_ref, forwardRef13) {
  let {
    children,
    className,
    containerRef,
    label,
    menuAlignment,
    mode = "full",
    onClose,
    onOpen,
    open,
    size: size6 = "sm",
    legacyAutoalign = "true",
    // eslint-disable-next-line ssr-friendly/no-dom-globals-in-react-fc
    target = canUseDOM && document.body,
    x = 0,
    y = 0,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const focusReturn = (0, import_react61.useRef)(null);
  const context = (0, import_react61.useContext)(MenuContext);
  const isRoot = context.state.isRoot;
  if (context.state.mode === "basic" && !isRoot) {
    true ? warning(false, 'Nested menus are not supported when the menu is in "basic" mode.') : void 0;
  }
  const menuSize = isRoot ? size6 : context.state.size;
  const [childState, childDispatch] = (0, import_react61.useReducer)(menuReducer, {
    ...context.state,
    isRoot: false,
    mode,
    size: size6,
    requestCloseRoot: isRoot ? handleClose : context.state.requestCloseRoot
  });
  const childContext = (0, import_react61.useMemo)(() => {
    return {
      state: childState,
      dispatch: childDispatch
    };
  }, [childState, childDispatch]);
  const menu = (0, import_react61.useRef)(null);
  const ref = useMergedRefs([forwardRef13, menu]);
  const [position, setPosition] = (0, import_react61.useState)([-1, -1]);
  const focusableItems = childContext.state.items.filter((item) => !item.disabled && item.ref.current);
  let actionButtonWidth;
  if (containerRef == null ? void 0 : containerRef.current) {
    const {
      width: w
    } = containerRef.current.getBoundingClientRect();
    actionButtonWidth = w;
  }
  const {
    direction
  } = useLayoutDirection();
  function returnFocus() {
    if (focusReturn.current) {
      focusReturn.current.focus();
    }
  }
  function handleOpen() {
    var _a;
    if (menu.current) {
      focusReturn.current = document.activeElement;
      if (legacyAutoalign) {
        const pos = calculatePosition();
        if (((document == null ? void 0 : document.dir) === "rtl" || direction === "rtl") && !((_a = rest3 == null ? void 0 : rest3.id) == null ? void 0 : _a.includes("MenuButton"))) {
          menu.current.style.insetInlineStart = `initial`;
          menu.current.style.insetInlineEnd = `${pos[0]}px`;
        } else {
          menu.current.style.insetInlineStart = `${pos[0]}px`;
          menu.current.style.insetInlineEnd = `initial`;
        }
        menu.current.style.insetBlockStart = `${pos[1]}px`;
        setPosition(pos);
      }
      menu.current.focus();
      if (onOpen) {
        onOpen();
      }
    }
  }
  function handleClose(e2) {
    if (/^key/.test(e2.type)) {
      window.addEventListener("keyup", returnFocus, {
        once: true
      });
    } else if (e2.type === "click" && menu.current) {
      menu.current.addEventListener("focusout", returnFocus, {
        once: true
      });
    } else {
      returnFocus();
    }
    if (onClose) {
      onClose();
    }
  }
  function handleKeyDown(e2) {
    e2.stopPropagation();
    if ((match(e2, Escape) || !isRoot && match(e2, ArrowLeft)) && onClose) {
      handleClose(e2);
    } else {
      focusItem(e2);
    }
  }
  function focusItem(e2) {
    var _a, _b;
    const currentItem = focusableItems.findIndex((item) => {
      var _a2, _b2;
      return (_b2 = (_a2 = item.ref) == null ? void 0 : _a2.current) == null ? void 0 : _b2.contains(document.activeElement);
    });
    let indexToFocus = currentItem;
    if (currentItem === -1) {
      indexToFocus = 0;
    } else if (e2) {
      if (match(e2, ArrowUp2)) {
        indexToFocus = indexToFocus - 1;
      }
      if (match(e2, ArrowDown)) {
        indexToFocus = indexToFocus + 1;
      }
    }
    if (indexToFocus < 0) {
      indexToFocus = focusableItems.length - 1;
    }
    if (indexToFocus >= focusableItems.length) {
      indexToFocus = 0;
    }
    if (indexToFocus !== currentItem) {
      const nodeToFocus = focusableItems[indexToFocus];
      (_b = (_a = nodeToFocus.ref) == null ? void 0 : _a.current) == null ? void 0 : _b.focus();
      e2 == null ? void 0 : e2.preventDefault();
    }
  }
  function handleBlur(e2) {
    var _a;
    if (open && onClose && isRoot && !((_a = menu.current) == null ? void 0 : _a.contains(e2.relatedTarget))) {
      handleClose(e2);
    }
  }
  function fitValue(range3, axis) {
    if (!menu.current) {
      return;
    }
    const {
      width,
      height
    } = menu.current.getBoundingClientRect();
    const alignment = isRoot ? "vertical" : "horizontal";
    const axes = {
      x: {
        max: window.innerWidth,
        size: width,
        anchor: alignment === "horizontal" ? range3[1] : range3[0],
        reversedAnchor: alignment === "horizontal" ? range3[0] : range3[1],
        offset: 0
      },
      y: {
        max: window.innerHeight,
        size: height,
        anchor: alignment === "horizontal" ? range3[0] : range3[1],
        reversedAnchor: alignment === "horizontal" ? range3[1] : range3[0],
        offset: isRoot ? 0 : 4
        // top padding in menu, used to align the menu items
      }
    };
    if (actionButtonWidth && actionButtonWidth < axes.x.size && (menuAlignment === "bottom" || menuAlignment === "top")) {
      axes.x.size = actionButtonWidth;
    }
    if (actionButtonWidth && (menuAlignment === "bottom-end" || menuAlignment === "top-end") && axes.x.anchor >= 87 && actionButtonWidth < axes.x.size) {
      const diff = axes.x.anchor + axes.x.reversedAnchor;
      axes.x.anchor = axes.x.anchor + diff;
    }
    const {
      max: max4,
      size: size7,
      anchor,
      reversedAnchor,
      offset: offset5
    } = axes[axis];
    const options = [
      // towards max (preferred)
      max4 - spacing - size7 - anchor >= 0 ? anchor - offset5 : false,
      // towards min / reversed (first fallback)
      reversedAnchor - size7 >= 0 ? reversedAnchor - size7 + offset5 : false,
      // align at max (second fallback)
      max4 - spacing - size7
    ];
    const topAlignment = menuAlignment === "top" || menuAlignment === "top-end" || menuAlignment === "top-start";
    if (typeof options[0] === "number" && topAlignment && options[0] >= 0 && !options[1] && axis === "y") {
      menu.current.style.transform = "translate(0)";
    } else if (topAlignment && !options[0] && axis === "y") {
      options[0] = anchor - offset5;
    }
    const bestOption = options.find((option) => option !== false);
    return bestOption >= spacing ? bestOption : spacing;
  }
  function notEmpty(value) {
    return value !== null && value !== void 0;
  }
  function getPosition(x2) {
    if (Array.isArray(x2)) {
      const filtered = x2.filter(notEmpty);
      if (filtered.length === 2) {
        return filtered;
      } else {
        return;
      }
    } else {
      return [x2, x2];
    }
  }
  function calculatePosition() {
    const ranges = {
      x: getPosition(x),
      y: getPosition(y)
    };
    if (!ranges.x || !ranges.y) {
      return [-1, -1];
    }
    return [fitValue(ranges.x, "x") ?? -1, fitValue(ranges.y, "y") ?? -1];
  }
  (0, import_react61.useEffect)(() => {
    if (open && focusableItems.length > 0) {
      focusItem();
    }
  }, [open, focusableItems]);
  (0, import_react61.useEffect)(() => {
    if (open) {
      handleOpen();
    } else {
      setPosition([-1, -1]);
    }
  }, [open]);
  const classNames = (0, import_classnames34.default)(className, `${prefix}--menu`, `${prefix}--menu--${menuSize}`, {
    // --open sets visibility and --shown sets opacity.
    // visibility is needed for focusing elements.
    // opacity is only set once the position has been set correctly
    // to avoid a flicker effect when opening.
    [`${prefix}--menu--box-shadow-top`]: menuAlignment && menuAlignment.slice(0, 3) === "top",
    [`${prefix}--menu--open`]: open,
    [`${prefix}--menu--shown`]: open && !legacyAutoalign || position[0] >= 0 && position[1] >= 0,
    [`${prefix}--menu--with-icons`]: childContext.state.hasIcons,
    [`${prefix}--autoalign`]: !legacyAutoalign
  });
  const rendered = import_react61.default.createElement(MenuContext.Provider, {
    value: childContext
  }, import_react61.default.createElement("ul", _extends({}, rest3, {
    className: classNames,
    role: "menu",
    ref,
    "aria-label": label,
    tabIndex: -1,
    onKeyDown: handleKeyDown,
    onBlur: handleBlur
  }), children));
  if (!target) {
    return rendered;
  }
  return isRoot ? open && (0, import_react_dom3.createPortal)(rendered, target) || null : rendered;
});
Menu2.propTypes = {
  /**
   * A collection of MenuItems to be rendered within this Menu.
   */
  children: import_prop_types42.default.node,
  /**
   * Additional CSS class names.
   */
  className: import_prop_types42.default.string,
  /**
   * A label describing the Menu.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  label: import_prop_types42.default.string,
  /**
   * Specify how the menu should align with the button element
   */
  menuAlignment: import_prop_types42.default.string,
  /**
   * The mode of this menu. Defaults to full.
   * `full` supports nesting and selectable menu items, but no icons.
   * `basic` supports icons but no nesting or selectable menu items.
   *
   * **This prop is not intended for use and will be set by the respective implementation (like useContextMenu, MenuButton, and ComboButton).**
   */
  mode: import_prop_types42.default.oneOf(["full", "basic"]),
  /**
   * Provide an optional function to be called when the Menu should be closed.
   */
  onClose: import_prop_types42.default.func,
  /**
   * Provide an optional function to be called when the Menu is opened.
   */
  onOpen: import_prop_types42.default.func,
  /**
   * Whether the Menu is open or not.
   */
  open: import_prop_types42.default.bool,
  /**
   * Specify the size of the Menu.
   */
  size: import_prop_types42.default.oneOf(["xs", "sm", "md", "lg"]),
  /**
   * Specify a DOM node where the Menu should be rendered in. Defaults to document.body.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  target: import_prop_types42.default.object,
  /**
   * Specify the x position of the Menu. Either pass a single number or an array with two numbers describing your activator's boundaries ([x1, x2])
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  x: import_prop_types42.default.oneOfType([import_prop_types42.default.number, import_prop_types42.default.arrayOf(import_prop_types42.default.number)]),
  /**
   * Specify the y position of the Menu. Either pass a single number or an array with two numbers describing your activator's boundaries ([y1, y2])
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  y: import_prop_types42.default.oneOfType([import_prop_types42.default.number, import_prop_types42.default.arrayOf(import_prop_types42.default.number)])
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Menu/MenuItem.js
var import_classnames35 = __toESM(require_classnames());
var import_prop_types43 = __toESM(require_prop_types());
var import_react63 = __toESM(require_react());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/internal/useControllableState.js
var import_react62 = __toESM(require_react());
function useControllableState(_ref) {
  let {
    defaultValue,
    name = "custom",
    onChange,
    value
  } = _ref;
  const [state, internalSetState] = (0, import_react62.useState)(value ?? defaultValue);
  const controlled = (0, import_react62.useRef)(null);
  if (controlled.current === null) {
    controlled.current = value !== void 0;
  }
  function setState(stateOrUpdater) {
    const value2 = typeof stateOrUpdater === "function" ? stateOrUpdater(state) : stateOrUpdater;
    if (controlled.current === false) {
      internalSetState(value2);
    }
    if (onChange) {
      onChange(value2);
    }
  }
  (0, import_react62.useEffect)(() => {
    const controlledValue = value !== void 0;
    if (controlled.current === false && controlledValue) {
      true ? warning(false, "A component is changing an uncontrolled %s component to be controlled. This is likely caused by the value changing to a defined value from undefined. Decide between using a controlled or uncontrolled value for the lifetime of the component. More info: https://reactjs.org/link/controlled-components", name) : void 0;
    }
    if (controlled.current === true && !controlledValue) {
      true ? warning(false, "A component is changing a controlled %s component to be uncontrolled. This is likely caused by the value changing to an undefined value from a defined one. Decide between using a controlled or uncontrolled value for the lifetime of the component. More info: https://reactjs.org/link/controlled-components", name) : void 0;
    }
  }, [name, value]);
  if (controlled.current === true) {
    return [value, setState];
  }
  return [state, setState];
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Menu/MenuItem.js
var _CaretLeft;
var _CaretRight;
var MenuItem = (0, import_react63.forwardRef)(function MenuItem2(_ref, forwardRef13) {
  let {
    children,
    className,
    disabled,
    kind = "default",
    label,
    onClick,
    renderIcon: IconElement,
    shortcut,
    ...rest3
  } = _ref;
  const [submenuOpen, setSubmenuOpen] = (0, import_react63.useState)(false);
  const [rtl, setRtl] = (0, import_react63.useState)(false);
  const {
    refs,
    floatingStyles,
    context: floatingContext
  } = useFloating2({
    open: submenuOpen,
    onOpenChange: setSubmenuOpen,
    placement: rtl ? "left-start" : "right-start",
    whileElementsMounted: autoUpdate,
    middleware: [offset3({
      mainAxis: -6,
      crossAxis: -6
    })]
  });
  const {
    getReferenceProps,
    getFloatingProps
  } = useInteractions([useHover(floatingContext, {
    delay: 100,
    enabled: true,
    handleClose: safePolygon({
      requireIntent: false
    })
  })]);
  const prefix = usePrefix();
  const context = (0, import_react63.useContext)(MenuContext);
  const menuItem = (0, import_react63.useRef)(null);
  const ref = useMergedRefs([forwardRef13, menuItem, refs.setReference]);
  const hasChildren = Boolean(children);
  const isDisabled2 = disabled && !hasChildren;
  const isDanger = kind === "danger" && !hasChildren;
  function registerItem() {
    context.dispatch({
      type: "registerItem",
      payload: {
        ref: menuItem,
        disabled: Boolean(disabled)
      }
    });
  }
  function openSubmenu() {
    if (!menuItem.current) {
      return;
    }
    setSubmenuOpen(true);
  }
  function closeSubmenu() {
    setSubmenuOpen(false);
  }
  function handleClick2(e2) {
    if (!isDisabled2) {
      if (hasChildren) {
        openSubmenu();
      } else {
        context.state.requestCloseRoot(e2);
        if (onClick) {
          onClick(e2);
        }
      }
    }
  }
  function handleKeyDown(e2) {
    if (hasChildren && match(e2, ArrowRight2)) {
      openSubmenu();
      e2.stopPropagation();
    }
    if (match(e2, Enter) || match(e2, Space)) {
      handleClick2(e2);
    }
    if (rest3.onKeyDown) {
      rest3.onKeyDown(e2);
    }
  }
  const classNames = (0, import_classnames35.default)(className, `${prefix}--menu-item`, {
    [`${prefix}--menu-item--disabled`]: isDisabled2,
    [`${prefix}--menu-item--danger`]: isDanger
  });
  (0, import_react63.useEffect)(() => {
    registerItem();
  }, []);
  const {
    direction
  } = useLayoutDirection();
  (0, import_react63.useEffect)(() => {
    if ((document == null ? void 0 : document.dir) === "rtl" || direction === "rtl") {
      setRtl(true);
    } else {
      setRtl(false);
    }
  }, [direction]);
  const iconsAllowed = context.state.mode === "basic" || rest3.role === "menuitemcheckbox" || rest3.role === "menuitemradio";
  (0, import_react63.useEffect)(() => {
    if (iconsAllowed && IconElement && !context.state.hasIcons) {
      context.dispatch({
        type: "enableIcons"
      });
    }
  }, [iconsAllowed, IconElement, context.state.hasIcons, context]);
  (0, import_react63.useEffect)(() => {
    Object.keys(floatingStyles).forEach((style) => {
      if (refs.floating.current && style !== "position") {
        refs.floating.current.style[style] = floatingStyles[style];
      }
    });
  }, [floatingStyles, refs.floating]);
  return import_react63.default.createElement(FloatingFocusManager, {
    context: floatingContext,
    order: ["reference", "floating"],
    modal: false
  }, import_react63.default.createElement("li", _extends({
    role: "menuitem"
  }, rest3, {
    ref,
    className: classNames,
    tabIndex: -1,
    "aria-disabled": isDisabled2 ?? void 0,
    "aria-haspopup": hasChildren ?? void 0,
    "aria-expanded": hasChildren ? submenuOpen : void 0,
    onClick: handleClick2,
    onKeyDown: handleKeyDown
  }, getReferenceProps()), import_react63.default.createElement("div", {
    className: `${prefix}--menu-item__icon`
  }, iconsAllowed && IconElement && import_react63.default.createElement(IconElement, null)), import_react63.default.createElement(Text, {
    as: "div",
    className: `${prefix}--menu-item__label`,
    title: label
  }, label), shortcut && !hasChildren && import_react63.default.createElement("div", {
    className: `${prefix}--menu-item__shortcut`
  }, shortcut), hasChildren && import_react63.default.createElement(import_react63.default.Fragment, null, import_react63.default.createElement("div", {
    className: `${prefix}--menu-item__shortcut`
  }, rtl ? _CaretLeft || (_CaretLeft = import_react63.default.createElement(CaretLeft, null)) : _CaretRight || (_CaretRight = import_react63.default.createElement(CaretRight, null))), import_react63.default.createElement(Menu2, _extends({
    label,
    open: submenuOpen,
    onClose: () => {
      var _a;
      closeSubmenu();
      (_a = menuItem.current) == null ? void 0 : _a.focus();
    },
    ref: refs.setFloating
  }, getFloatingProps()), children))));
});
MenuItem.propTypes = {
  /**
   * Optionally provide another Menu to create a submenu. props.children can't be used to specify the content of the MenuItem itself. Use props.label instead.
   */
  children: import_prop_types43.default.node,
  /**
   * Additional CSS class names.
   */
  className: import_prop_types43.default.string,
  /**
   * Specify whether the MenuItem is disabled or not.
   */
  disabled: import_prop_types43.default.bool,
  /**
   * Specify the kind of the MenuItem.
   */
  kind: import_prop_types43.default.oneOf(["default", "danger"]),
  /**
   * A required label titling the MenuItem. Will be rendered as its text content.
   */
  label: import_prop_types43.default.string.isRequired,
  /**
   * Provide an optional function to be called when the MenuItem is clicked.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  onClick: import_prop_types43.default.func,
  /**
   * Only applicable if the parent menu is in `basic` mode. Sets the menu item's icon.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  renderIcon: import_prop_types43.default.oneOfType([import_prop_types43.default.func, import_prop_types43.default.object]),
  /**
   * Provide a shortcut for the action of this MenuItem. Note that the component will only render it as a hint but not actually register the shortcut.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  shortcut: import_prop_types43.default.string
};
var MenuItemSelectable = (0, import_react63.forwardRef)(function MenuItemSelectable2(_ref2, forwardRef13) {
  let {
    className,
    defaultSelected,
    label,
    onChange,
    selected,
    ...rest3
  } = _ref2;
  const prefix = usePrefix();
  const context = (0, import_react63.useContext)(MenuContext);
  if (context.state.mode === "basic") {
    true ? warning(false, 'MenuItemSelectable is not supported when the menu is in "basic" mode.') : void 0;
  }
  const [checked, setChecked] = useControllableState({
    value: selected,
    onChange,
    defaultValue: defaultSelected ?? false
  });
  function handleClick2(e2) {
    setChecked(!checked);
  }
  (0, import_react63.useEffect)(() => {
    if (!context.state.hasIcons) {
      context.dispatch({
        type: "enableIcons"
      });
    }
  }, [context.state.hasIcons, context]);
  const classNames = (0, import_classnames35.default)(className, `${prefix}--menu-item-selectable--selected`);
  return import_react63.default.createElement(MenuItem, _extends({}, rest3, {
    ref: forwardRef13,
    label,
    className: classNames,
    role: "menuitemcheckbox",
    "aria-checked": checked,
    renderIcon: checked ? Checkmark : void 0,
    onClick: handleClick2
  }));
});
MenuItemSelectable.propTypes = {
  /**
   * Additional CSS class names.
   */
  className: import_prop_types43.default.string,
  /**
   * Specify whether the option should be selected by default.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  defaultSelected: import_prop_types43.default.bool,
  /**
   * A required label titling this option.
   */
  label: import_prop_types43.default.string.isRequired,
  /**
   * Provide an optional function to be called when the selection state changes.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  onChange: import_prop_types43.default.func,
  /**
   * Pass a bool to props.selected to control the state of this option.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  selected: import_prop_types43.default.bool
};
var MenuItemGroup = (0, import_react63.forwardRef)(function MenuItemGroup2(_ref3, forwardRef13) {
  let {
    children,
    className,
    label,
    ...rest3
  } = _ref3;
  const prefix = usePrefix();
  const classNames = (0, import_classnames35.default)(className, `${prefix}--menu-item-group`);
  return import_react63.default.createElement("li", {
    className: classNames,
    role: "none",
    ref: forwardRef13
  }, import_react63.default.createElement("ul", _extends({}, rest3, {
    role: "group",
    "aria-label": label
  }), children));
});
MenuItemGroup.propTypes = {
  /**
   * A collection of MenuItems to be rendered within this group.
   */
  children: import_prop_types43.default.node,
  /**
   * Additional CSS class names.
   */
  className: import_prop_types43.default.string,
  /**
   * A required label titling this group.
   */
  label: import_prop_types43.default.string.isRequired
};
var defaultItemToString2 = (item) => item.toString();
var MenuItemRadioGroup = (0, import_react63.forwardRef)(function MenuItemRadioGroup2(_ref4, forwardRef13) {
  let {
    className,
    defaultSelectedItem,
    items,
    itemToString: itemToString3 = defaultItemToString2,
    label,
    onChange,
    selectedItem,
    ...rest3
  } = _ref4;
  const prefix = usePrefix();
  const context = (0, import_react63.useContext)(MenuContext);
  if (context.state.mode === "basic") {
    true ? warning(false, 'MenuItemRadioGroup is not supported when the menu is in "basic" mode.') : void 0;
  }
  const [selection, setSelection] = useControllableState({
    value: selectedItem,
    onChange,
    defaultValue: defaultSelectedItem
  });
  function handleClick2(item, e2) {
    setSelection(item);
  }
  (0, import_react63.useEffect)(() => {
    if (!context.state.hasIcons) {
      context.dispatch({
        type: "enableIcons"
      });
    }
  }, [context.state.hasIcons, context]);
  const classNames = (0, import_classnames35.default)(className, `${prefix}--menu-item-radio-group`);
  return import_react63.default.createElement("li", {
    className: classNames,
    role: "none",
    ref: forwardRef13
  }, import_react63.default.createElement("ul", _extends({}, rest3, {
    role: "group",
    "aria-label": label
  }), items.map((item, i) => import_react63.default.createElement(MenuItem, {
    key: i,
    label: itemToString3(item),
    role: "menuitemradio",
    "aria-checked": item === selection,
    renderIcon: item === selection ? Checkmark : void 0,
    onClick: (e2) => {
      handleClick2(item);
    }
  }))));
});
MenuItemRadioGroup.propTypes = {
  /**
   * Additional CSS class names.
   */
  className: import_prop_types43.default.string,
  /**
   * Specify the default selected item. Must match the type of props.items.
   */
  defaultSelectedItem: import_prop_types43.default.any,
  /**
   * Provide a function to convert an item to the string that will be rendered. Defaults to item.toString().
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  itemToString: import_prop_types43.default.func,
  /**
   * Provide the options for this radio group. Can be of any type, as long as you provide an appropriate props.itemToString function.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  items: import_prop_types43.default.array,
  /**
   * A required label titling this radio group.
   */
  label: import_prop_types43.default.string.isRequired,
  /**
   * Provide an optional function to be called when the selection changes.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  onChange: import_prop_types43.default.func,
  /**
   * Provide props.selectedItem to control the state of this radio group. Must match the type of props.items.
   */
  selectedItem: import_prop_types43.default.any
};
var MenuItemDivider = (0, import_react63.forwardRef)(function MenuItemDivider2(_ref5, forwardRef13) {
  let {
    className,
    ...rest3
  } = _ref5;
  const prefix = usePrefix();
  const classNames = (0, import_classnames35.default)(className, `${prefix}--menu-item-divider`);
  return import_react63.default.createElement("li", _extends({}, rest3, {
    className: classNames,
    role: "separator",
    ref: forwardRef13
  }));
});
MenuItemDivider.propTypes = {
  /**
   * Additional CSS class names.
   */
  className: import_prop_types43.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/internal/useAttachedMenu.js
var import_react65 = __toESM(require_react());
function useAttachedMenu(anchor) {
  const [open, setOpen] = (0, import_react65.useState)(false);
  const [position, setPosition] = (0, import_react65.useState)([[-1, -1], [-1, -1]]);
  function openMenu() {
    const anchorEl = (anchor == null ? void 0 : anchor.current) || anchor;
    if (anchorEl) {
      const {
        left,
        top,
        right,
        bottom
      } = anchorEl.getBoundingClientRect();
      setPosition([[left, right], [top, bottom]]);
    }
    setOpen(true);
  }
  function closeMenu() {
    setOpen(false);
  }
  function handleClick2() {
    if (open) {
      closeMenu();
    } else {
      openMenu();
    }
  }
  function handleMousedown(e2) {
    e2.preventDefault();
  }
  return {
    open,
    x: position[0],
    y: position[1],
    handleClick: handleClick2,
    handleMousedown,
    handleClose: closeMenu
  };
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ComboButton/index.js
var _ChevronDown2;
var defaultTranslations5 = {
  "carbon.combo-button.additional-actions": "Additional actions"
};
var propMappingFunction6 = (deprecatedValue) => {
  const mapping = {
    "top-left": "top-start",
    "top-right": "top-end",
    "bottom-left": "bottom-start",
    "bottom-right": "bottom-end",
    "left-bottom": "left-end",
    "left-top": "left-start",
    "right-bottom": "right-end",
    "right-top": "right-start"
  };
  return mapping[deprecatedValue];
};
function defaultTranslateWithId5(messageId) {
  return defaultTranslations5[messageId];
}
var ComboButton = import_react66.default.forwardRef(function ComboButton2(_ref, forwardRef13) {
  let {
    children,
    className,
    disabled,
    label,
    onClick,
    size: size$1 = "lg",
    menuAlignment = "bottom",
    tooltipAlignment,
    translateWithId: t2 = defaultTranslateWithId5,
    ...rest3
  } = _ref;
  const enableOnlyFloatingStyles = useFeatureFlag("enable-v12-dynamic-floating-styles");
  const id = useId("combobutton");
  const prefix = usePrefix();
  const containerRef = (0, import_react66.useRef)(null);
  let middlewares = [];
  if (!enableOnlyFloatingStyles) {
    middlewares = [flip3({
      crossAxis: false
    }), hide5()];
  }
  if (menuAlignment === "bottom" || menuAlignment === "top") {
    middlewares.push(size3({
      apply(_ref2) {
        let {
          rects,
          elements
        } = _ref2;
        Object.assign(elements.floating.style, {
          width: `${rects.reference.width}px`
        });
      }
    }));
  }
  const {
    refs,
    floatingStyles,
    placement,
    middlewareData
  } = useFloating2({
    placement: menuAlignment,
    // The floating element is positioned relative to its nearest
    // containing block (usually the viewport). It will in many cases also
    // “break” the floating element out of a clipping ancestor.
    // https://floating-ui.com/docs/misc#clipping
    strategy: "fixed",
    // Middleware order matters, arrow should be last
    middleware: middlewares,
    whileElementsMounted: autoUpdate
  });
  const ref = mergeRefs$1(forwardRef13, containerRef, refs.setReference);
  const {
    open,
    handleClick: hookOnClick,
    handleMousedown: handleTriggerMousedown,
    handleClose
  } = useAttachedMenu(containerRef);
  (0, import_react66.useLayoutEffect)(() => {
    var _a;
    const updatedFloatingStyles = {
      ...floatingStyles,
      visibility: ((_a = middlewareData.hide) == null ? void 0 : _a.referenceHidden) ? "hidden" : "visible"
    };
    Object.keys(updatedFloatingStyles).forEach((style) => {
      if (refs.floating.current) {
        refs.floating.current.style[style] = updatedFloatingStyles[style];
      }
    });
  }, [floatingStyles, refs.floating, middlewareData, placement, open]);
  function handleTriggerClick() {
    if (containerRef.current) {
      hookOnClick();
    }
  }
  function handlePrimaryActionClick(e2) {
    if (onClick) {
      onClick(e2);
    }
  }
  const containerClasses = (0, import_classnames36.default)(`${prefix}--combo-button__container`, `${prefix}--combo-button__container--${size$1}`, {
    [`${prefix}--combo-button__container--open`]: open
  }, className);
  const menuClasses = (0, import_classnames36.default)(`${prefix}--combo-button__${menuAlignment}`);
  const primaryActionClasses = (0, import_classnames36.default)(`${prefix}--combo-button__primary-action`);
  const triggerClasses = (0, import_classnames36.default)(`${prefix}--combo-button__trigger`);
  return import_react66.default.createElement("div", _extends({}, rest3, {
    className: containerClasses,
    ref,
    "aria-owns": open ? id : void 0
  }), import_react66.default.createElement("div", {
    className: primaryActionClasses
  }, import_react66.default.createElement(Button, {
    title: label,
    size: size$1,
    disabled,
    onClick: handlePrimaryActionClick
  }, label)), import_react66.default.createElement(IconButton, {
    ref: refs.setReference,
    className: triggerClasses,
    label: t2("carbon.combo-button.additional-actions"),
    size: size$1,
    disabled,
    align: tooltipAlignment,
    "aria-haspopup": true,
    "aria-expanded": open,
    onClick: handleTriggerClick,
    onMouseDown: handleTriggerMousedown,
    "aria-controls": open ? id : void 0
  }, _ChevronDown2 || (_ChevronDown2 = import_react66.default.createElement(ChevronDown, null))), import_react66.default.createElement(Menu2, {
    containerRef,
    menuAlignment,
    className: menuClasses,
    ref: refs.setFloating,
    id,
    label: t2("carbon.combo-button.additional-actions"),
    mode: "basic",
    size: size$1,
    open,
    onClose: handleClose
  }, children));
});
ComboButton.propTypes = {
  /**
   * A collection of MenuItems to be rendered as additional actions for this ComboButton.
   */
  children: import_prop_types44.default.node.isRequired,
  /**
   * Additional CSS class names.
   */
  className: import_prop_types44.default.string,
  /**
   * Specify whether the ComboButton should be disabled, or not.
   */
  disabled: import_prop_types44.default.bool,
  /**
   * Provide the label to be rendered on the primary action button.
   */
  label: import_prop_types44.default.string.isRequired,
  /**
   * Experimental property. Specify how the menu should align with the button element
   */
  menuAlignment: import_prop_types44.default.oneOf(["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end"]),
  /**
   * Provide an optional function to be called when the primary action element is clicked.
   */
  onClick: import_prop_types44.default.func,
  /**
   * Specify the size of the buttons and menu.
   */
  size: import_prop_types44.default.oneOf(["sm", "md", "lg"]),
  /**
   * Specify how the trigger tooltip should be aligned.
   */
  tooltipAlignment: deprecateValuesWithin(
    import_prop_types44.default.oneOf([
      "top",
      "top-left",
      // deprecated use top-start instead
      "top-right",
      // deprecated use top-end instead
      "bottom",
      "bottom-left",
      // deprecated use bottom-start instead
      "bottom-right",
      // deprecated use bottom-end instead
      "left",
      "left-bottom",
      // deprecated use left-end instead
      "left-top",
      // deprecated use left-start instead
      "right",
      "right-bottom",
      // deprecated use right-end instead
      "right-top",
      // deprecated use right-start instead
      // new values to match floating-ui
      "top-start",
      "top-end",
      "bottom-start",
      "bottom-end",
      "left-end",
      "left-start",
      "right-end",
      "right-start"
    ]),
    //allowed prop values
    ["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "left", "left-start", "left-end", "right", "right-start", "right-end"],
    //optional mapper function
    propMappingFunction6
  ),
  /**
   * Optional method that takes in a message id and returns an
   * internationalized string.
   */
  translateWithId: import_prop_types44.default.func
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ComposedModal/ComposedModal.js
var import_react75 = __toESM(require_react());
var import_react_is2 = __toESM(require_react_is2());
var import_prop_types50 = __toESM(require_prop_types());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Layer/index.js
var import_react69 = __toESM(require_react());
var import_prop_types45 = __toESM(require_prop_types());
var import_classnames37 = __toESM(require_classnames());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Layer/LayerContext.js
var import_react68 = __toESM(require_react());
var LayerContext = import_react68.default.createContext(1);

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Layer/LayerLevel.js
var levels = ["one", "two", "three"];
var MIN_LEVEL = 0;
var MAX_LEVEL = levels.length - 1;

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Layer/index.js
function useLayer() {
  const level = import_react69.default.useContext(LayerContext);
  return {
    level
  };
}
var LayerRenderFunction = import_react69.default.forwardRef(function Layer(_ref, ref) {
  let {
    as = "div",
    className: customClassName,
    children,
    level: overrideLevel,
    ...rest3
  } = _ref;
  const contextLevel = import_react69.default.useContext(LayerContext);
  const level = overrideLevel ?? contextLevel;
  const prefix = usePrefix();
  const className = (0, import_classnames37.default)(`${prefix}--layer-${levels[level]}`, customClassName);
  const value = Math.max(MIN_LEVEL, Math.min(level + 1, MAX_LEVEL));
  const BaseComponent = as;
  return import_react69.default.createElement(LayerContext.Provider, {
    value
  }, import_react69.default.createElement(BaseComponent, _extends({
    ref
  }, rest3, {
    className
  }), children));
});
LayerRenderFunction.displayName = "Layer";
LayerRenderFunction.propTypes = {
  /**
   * Specify a custom component or element to be rendered as the top-level
   * element in the component
   */
  as: import_prop_types45.default.oneOfType([import_prop_types45.default.func, import_prop_types45.default.string, import_prop_types45.default.elementType]),
  /**
   * Provide child elements to be rendered inside of `Theme`
   */
  children: import_prop_types45.default.node,
  /**
   * Provide a custom class name to be used on the outermost element rendered by
   * the component
   */
  className: import_prop_types45.default.string,
  /**
   * Specify the layer level and override any existing levels based on hierarchy
   */
  level: import_prop_types45.default.oneOf([0, 1, 2])
};
var Layer2 = LayerRenderFunction;

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ComposedModal/ModalHeader.js
var import_react70 = __toESM(require_react());
var import_prop_types46 = __toESM(require_prop_types());
var import_classnames38 = __toESM(require_classnames());
var ModalHeader = import_react70.default.forwardRef(function ModalHeader2(_ref, ref) {
  let {
    buttonOnClick,
    children,
    className: customClassName,
    closeClassName,
    closeIconClassName,
    closeModal,
    iconDescription = "Close",
    label,
    labelClassName,
    title,
    titleClassName,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  function handleCloseButtonClick(evt) {
    closeModal == null ? void 0 : closeModal(evt);
    buttonOnClick == null ? void 0 : buttonOnClick(evt);
  }
  const headerClass = (0, import_classnames38.default)(`${prefix}--modal-header`, customClassName);
  const labelClass = (0, import_classnames38.default)(`${prefix}--modal-header__label ${prefix}--type-delta`, labelClassName);
  const titleClass = (0, import_classnames38.default)(`${prefix}--modal-header__heading ${prefix}--type-beta`, titleClassName);
  const closeClass = (0, import_classnames38.default)(`${prefix}--modal-close`, closeClassName);
  const closeIconClass = (0, import_classnames38.default)(`${prefix}--modal-close__icon`, closeIconClassName);
  return import_react70.default.createElement("div", _extends({
    className: headerClass
  }, rest3, {
    ref
  }), label && import_react70.default.createElement("h2", {
    className: labelClass
  }, label), title && import_react70.default.createElement("h2", {
    className: titleClass
  }, title), children, import_react70.default.createElement("div", {
    className: `${prefix}--modal-close-button`
  }, import_react70.default.createElement(IconButton, {
    className: closeClass,
    label: iconDescription,
    onClick: handleCloseButtonClick,
    "aria-label": iconDescription,
    align: "left"
  }, import_react70.default.createElement(Close, {
    size: 20,
    "aria-hidden": "true",
    tabIndex: "-1",
    className: closeIconClass
  }))));
});
ModalHeader.propTypes = {
  /**
   * Provide an optional function to be called when the close button is
   * clicked
   */
  buttonOnClick: import_prop_types46.default.func,
  /**
   * Specify the content to be placed in the ModalHeader
   */
  children: import_prop_types46.default.node,
  /**
   * Specify an optional className to be applied to the modal header
   */
  className: import_prop_types46.default.string,
  /**
   * Specify an optional className to be applied to the modal close node
   */
  closeClassName: import_prop_types46.default.string,
  /**
   * Specify an optional className to be applied to the modal close icon node
   */
  closeIconClassName: import_prop_types46.default.string,
  /**
   * Provide an optional function to be called when the modal is closed
   */
  closeModal: import_prop_types46.default.func,
  /**
   * Specify a description for the close icon that can be read by screen
   * readers
   */
  iconDescription: import_prop_types46.default.string,
  /**
   * Specify an optional label to be displayed
   */
  label: import_prop_types46.default.node,
  /**
   * Specify an optional className to be applied to the modal header label
   */
  labelClassName: import_prop_types46.default.string,
  /**
   * Specify an optional title to be displayed
   */
  title: import_prop_types46.default.node,
  /**
   * Specify an optional className to be applied to the modal heading
   */
  titleClassName: import_prop_types46.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ComposedModal/ModalFooter.js
var import_react73 = __toESM(require_react());
var import_prop_types49 = __toESM(require_prop_types());
var import_classnames41 = __toESM(require_classnames());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/InlineLoading/InlineLoading.js
var import_react72 = __toESM(require_react());
var import_prop_types48 = __toESM(require_prop_types());
var import_classnames40 = __toESM(require_classnames());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Loading/Loading.js
var import_classnames39 = __toESM(require_classnames());
var import_prop_types47 = __toESM(require_prop_types());
var import_react71 = __toESM(require_react());
function Loading(_ref) {
  let {
    active = true,
    className: customClassName,
    withOverlay = true,
    small = false,
    description = "loading",
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const loadingClassName = (0, import_classnames39.default)(customClassName, {
    [`${prefix}--loading`]: true,
    [`${prefix}--loading--small`]: small,
    [`${prefix}--loading--stop`]: !active
  });
  const overlayClassName = (0, import_classnames39.default)({
    [`${prefix}--loading-overlay`]: true,
    [`${prefix}--loading-overlay--stop`]: !active
  });
  const loading = import_react71.default.createElement("div", _extends({}, rest3, {
    "aria-atomic": "true",
    "aria-live": active ? "assertive" : "off",
    className: loadingClassName
  }), import_react71.default.createElement("svg", {
    className: `${prefix}--loading__svg`,
    viewBox: "0 0 100 100"
  }, import_react71.default.createElement("title", null, description), small ? import_react71.default.createElement("circle", {
    className: `${prefix}--loading__background`,
    cx: "50%",
    cy: "50%",
    r: "42"
  }) : null, import_react71.default.createElement("circle", {
    className: `${prefix}--loading__stroke`,
    cx: "50%",
    cy: "50%",
    r: small ? "42" : "44"
  })));
  return withOverlay ? import_react71.default.createElement("div", {
    className: overlayClassName
  }, loading) : loading;
}
Loading.propTypes = {
  /**
   * Specify whether you want the loading indicator to be spinning or not
   */
  active: import_prop_types47.default.bool,
  /**
   * Provide an optional className to be applied to the containing node
   */
  className: import_prop_types47.default.string,
  /**
   * Specify a description that would be used to best describe the loading state
   */
  description: import_prop_types47.default.string,
  /**
   * Provide an `id` to uniquely identify the label
   */
  id: deprecate(import_prop_types47.default.string, `
The prop \`id\` is no longer needed.`),
  /**
   * Specify whether you would like the small variant of <Loading>
   */
  small: import_prop_types47.default.bool,
  /**
   * Specify whether you want the loader to be applied with an overlay
   */
  withOverlay: import_prop_types47.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/InlineLoading/InlineLoading.js
var InlineLoading = (_ref) => {
  let {
    className,
    status = "active",
    iconDescription,
    description,
    onSuccess,
    successDelay = 1500,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const loadingClasses = (0, import_classnames40.default)(`${prefix}--inline-loading`, className);
  const getLoading = () => {
    let iconLabel = iconDescription ? iconDescription : status;
    if (status === "error") {
      return import_react72.default.createElement(ErrorFilled, {
        className: `${prefix}--inline-loading--error`
      }, import_react72.default.createElement("title", null, iconLabel));
    }
    if (status === "finished") {
      setTimeout(() => {
        if (onSuccess) {
          onSuccess();
        }
      }, successDelay);
      return import_react72.default.createElement(CheckmarkFilled, {
        className: `${prefix}--inline-loading__checkmark-container`
      }, import_react72.default.createElement("title", null, iconLabel));
    }
    if (status === "inactive" || status === "active") {
      if (!iconDescription) {
        iconLabel = status === "active" ? "loading" : "not loading";
      }
      return import_react72.default.createElement(Loading, {
        small: true,
        description: iconLabel,
        withOverlay: false,
        active: status === "active"
      });
    }
    return void 0;
  };
  const loadingText = import_react72.default.createElement("div", {
    className: `${prefix}--inline-loading__text`
  }, description);
  const loading = getLoading();
  const loadingAnimation = loading && import_react72.default.createElement("div", {
    className: `${prefix}--inline-loading__animation`
  }, loading);
  return import_react72.default.createElement("div", _extends({
    className: loadingClasses
  }, rest3, {
    "aria-live": "assertive"
  }), loadingAnimation, description && loadingText);
};
InlineLoading.propTypes = {
  /**
   * Specify a custom className to be applied to the container node
   */
  className: import_prop_types48.default.string,
  /**
   * Specify the description for the inline loading text
   */
  description: import_prop_types48.default.node,
  /**
   * Specify the description for the inline loading text
   */
  iconDescription: import_prop_types48.default.string,
  /**
   * Provide an optional handler to be invoked when <InlineLoading> is
   * successful
   */
  onSuccess: import_prop_types48.default.func,
  /**
   * Specify the loading status
   */
  status: import_prop_types48.default.oneOf(["inactive", "active", "finished", "error"]),
  /**
   * Provide a delay for the `setTimeout` for success
   */
  successDelay: import_prop_types48.default.number
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ComposedModal/ModalFooter.js
function SecondaryButtonSet(_ref) {
  let {
    secondaryButtons,
    secondaryButtonText,
    secondaryClassName,
    closeModal,
    onRequestClose,
    disabled
  } = _ref;
  function handleRequestClose(evt) {
    closeModal(evt);
    onRequestClose(evt);
  }
  if (Array.isArray(secondaryButtons) && secondaryButtons.length <= 2) {
    return import_react73.default.createElement(import_react73.default.Fragment, null, secondaryButtons.map((_ref2, i) => {
      let {
        buttonText,
        onClick: onButtonClick
      } = _ref2;
      return import_react73.default.createElement(Button, {
        key: `${buttonText}-${i}`,
        className: secondaryClassName,
        kind: "secondary",
        onClick: onButtonClick || handleRequestClose
      }, buttonText);
    }));
  }
  if (secondaryButtonText) {
    return import_react73.default.createElement(Button, {
      disabled,
      className: secondaryClassName,
      onClick: handleRequestClose,
      kind: "secondary"
    }, secondaryButtonText);
  }
  return null;
}
SecondaryButtonSet.propTypes = {
  closeModal: import_prop_types49.default.func,
  disabled: import_prop_types49.default.bool,
  onRequestClose: import_prop_types49.default.func,
  secondaryButtonText: import_prop_types49.default.string,
  secondaryButtons: (props, propName, componentName) => {
    if (props.secondaryButtons) {
      if (!Array.isArray(props.secondaryButtons) || props.secondaryButtons.length !== 2) {
        return new Error(`${propName} needs to be an array of two button config objects`);
      }
      const shape = {
        buttonText: import_prop_types49.default.node,
        onClick: import_prop_types49.default.func
      };
      props[propName].forEach((secondaryButton) => {
        import_prop_types49.default.checkPropTypes(shape, secondaryButton, propName, componentName);
      });
    }
    return null;
  },
  secondaryClassName: import_prop_types49.default.string
};
var ModalFooter = import_react73.default.forwardRef(function ModalFooter2(_ref3, ref) {
  let {
    children,
    className: customClassName,
    closeModal = noopFn,
    danger,
    inputref,
    onRequestClose = noopFn,
    onRequestSubmit = noopFn,
    primaryButtonDisabled,
    primaryButtonText,
    primaryClassName,
    secondaryButtonText,
    secondaryButtons,
    secondaryClassName,
    loadingStatus = "inactive",
    loadingDescription,
    loadingIconDescription,
    onLoadingSuccess = noopFn,
    ...rest3
  } = _ref3;
  const prefix = usePrefix();
  const footerClass = (0, import_classnames41.default)(`${prefix}--modal-footer`, customClassName, Array.isArray(secondaryButtons) && secondaryButtons.length === 2 ? `${prefix}--modal-footer--three-button` : null);
  const primaryButtonClass = (0, import_classnames41.default)(primaryClassName, loadingStatus !== "inactive" ? `${prefix}--btn--loading` : null);
  const loadingActive = loadingStatus !== "inactive";
  const secondaryButtonProps = {
    closeModal,
    secondaryButtons,
    secondaryButtonText,
    secondaryClassName,
    onRequestClose,
    disabled: loadingActive
  };
  return import_react73.default.createElement(ButtonSet, _extends({
    className: footerClass
  }, rest3, {
    // @ts-expect-error: Invalid derived types, will be fine once explicit types are added
    ref,
    "aria-busy": loadingActive
  }), import_react73.default.createElement(SecondaryButtonSet, secondaryButtonProps), primaryButtonText && import_react73.default.createElement(Button, {
    onClick: onRequestSubmit,
    className: primaryButtonClass,
    disabled: loadingActive || primaryButtonDisabled,
    kind: danger ? "danger" : "primary",
    ref: inputref
  }, loadingStatus === "inactive" ? primaryButtonText : import_react73.default.createElement(InlineLoading, {
    status: loadingStatus,
    description: loadingDescription,
    iconDescription: loadingIconDescription,
    className: `${prefix}--inline-loading--btn`,
    onSuccess: onLoadingSuccess
  })), children);
});
ModalFooter.propTypes = {
  /**
   * Pass in content that will be rendered in the Modal Footer
   */
  children: import_prop_types49.default.node,
  /**
   * Specify a custom className to be applied to the Modal Footer container
   */
  className: import_prop_types49.default.string,
  /**
   * Specify an optional function that is called whenever the modal is closed
   */
  closeModal: import_prop_types49.default.func,
  /**
   * Specify whether the primary button should be replaced with danger button.
   * Note that this prop is not applied if you render primary/danger button by yourself
   */
  danger: import_prop_types49.default.bool,
  /**
   * The `ref` callback for the primary button.
   */
  // @ts-expect-error: Invalid derived type
  inputref: import_prop_types49.default.oneOfType([import_prop_types49.default.func, import_prop_types49.default.shape({
    current: import_prop_types49.default.any
  })]),
  /**
   * Specify the description for the loading text
   */
  loadingDescription: import_prop_types49.default.string,
  /**
   * Specify the description for the loading text
   */
  loadingIconDescription: import_prop_types49.default.string,
  /**
   * loading status
   */
  loadingStatus: import_prop_types49.default.oneOf(["inactive", "active", "finished", "error"]),
  /**
   * Provide an optional handler to be invoked when loading is
   * successful
   */
  onLoadingSuccess: import_prop_types49.default.func,
  /**
   * Specify an optional function for when the modal is requesting to be
   * closed
   */
  onRequestClose: import_prop_types49.default.func,
  /**
   * Specify an optional function for when the modal is requesting to be
   * submitted
   */
  onRequestSubmit: import_prop_types49.default.func,
  /**
   * Specify whether the primary button should be disabled
   */
  primaryButtonDisabled: import_prop_types49.default.bool,
  /**
   * Specify the text for the primary button
   */
  primaryButtonText: import_prop_types49.default.string,
  /**
   * Specify a custom className to be applied to the primary button
   */
  primaryClassName: import_prop_types49.default.string,
  /**
   * Specify the text for the secondary button
   */
  secondaryButtonText: import_prop_types49.default.string,
  /**
   * Specify an array of config objects for secondary buttons
   * (`Array<{
   *   buttonText: string,
   *   onClick: function,
   * }>`).
   */
  secondaryButtons: (props, propName, componentName) => {
    if (props.secondaryButtons) {
      if (!Array.isArray(props.secondaryButtons) || props.secondaryButtons.length !== 2) {
        return new Error(`${propName} needs to be an array of two button config objects`);
      }
      const shape = {
        buttonText: import_prop_types49.default.node,
        onClick: import_prop_types49.default.func
      };
      props[propName].forEach((secondaryButton) => {
        import_prop_types49.default.checkPropTypes(shape, secondaryButton, propName, componentName);
      });
    }
    return null;
  },
  /**
   * Specify a custom className to be applied to the secondary button
   */
  secondaryClassName: import_prop_types49.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ComposedModal/ComposedModal.js
var import_classnames42 = __toESM(require_classnames());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/tools/toggleClass.js
function toggleClass(element, name, add2) {
  if (element.classList.contains(name) === !add2) {
    element.classList[add2 ? "add" : "remove"](name);
  }
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/prop-types/requiredIfGivenPropIsTruthy.js
function requiredIfGivenPropIsTruthy(name, propType) {
  return function check(props, propName, componentName) {
    if (props[name] == true && props[propName] == null) {
      return new Error(`You must provide a value for \`${propName}\` in \`${componentName}\` if \`${name}\` exists.`);
    }
    for (var _len = arguments.length, rest3 = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      rest3[_key - 3] = arguments[_key];
    }
    return propType(props, propName, componentName, ...rest3);
  };
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/internal/wrapFocus.js
var import_react74 = __toESM(require_react());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/internal/keyboard/navigation.js
var getNextIndex = (key, index4, arrayLength) => {
  if (match(key, ArrowRight2)) {
    return (index4 + 1) % arrayLength;
  }
  if (match(key, ArrowLeft)) {
    return (index4 + arrayLength - 1) % arrayLength;
  }
};
var DOCUMENT_POSITION_BROAD_PRECEDING = (
  // Checks `typeof Node` for `react-docgen`
  typeof Node !== "undefined" && // eslint-disable-next-line ssr-friendly/no-dom-globals-in-module-scope
  Node.DOCUMENT_POSITION_PRECEDING | Node.DOCUMENT_POSITION_CONTAINS
);
var DOCUMENT_POSITION_BROAD_FOLLOWING = (
  // Checks `typeof Node` for `react-docgen`
  typeof Node !== "undefined" && // eslint-disable-next-line ssr-friendly/no-dom-globals-in-module-scope
  Node.DOCUMENT_POSITION_FOLLOWING | Node.DOCUMENT_POSITION_CONTAINED_BY
);
var selectorTabbable = `
  a[href], area[href], input:not([disabled]):not([tabindex='-1']),
  button:not([disabled]):not([tabindex='-1']),select:not([disabled]):not([tabindex='-1']),
  textarea:not([disabled]):not([tabindex='-1']),
  iframe, object, embed, *[tabindex]:not([tabindex='-1']):not([disabled]), *[contenteditable=true]
`;
var selectorFocusable = `
  a[href], area[href], input:not([disabled]),
  button:not([disabled]),select:not([disabled]),
  textarea:not([disabled]),
  iframe, object, embed, *[tabindex]:not([disabled]), *[contenteditable=true]
`;

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/internal/wrapFocus.js
function elementOrParentIsFloatingMenu(node) {
  let selectorsFloatingMenus = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  if (node && typeof node.closest === "function") {
    const allSelectorsFloatingMenus = [`.cds--overflow-menu-options`, `.cds--tooltip`, ".flatpickr-calendar", ...selectorsFloatingMenus];
    return allSelectorsFloatingMenus.some((selector) => node.closest(selector));
  }
}
function wrapFocus(_ref) {
  let {
    bodyNode,
    startTrapNode,
    endTrapNode,
    currentActiveNode,
    oldActiveNode,
    selectorsFloatingMenus
  } = _ref;
  if (bodyNode && currentActiveNode && oldActiveNode && !bodyNode.contains(currentActiveNode) && !elementOrParentIsFloatingMenu(currentActiveNode, selectorsFloatingMenus)) {
    const comparisonResult = oldActiveNode.compareDocumentPosition(currentActiveNode);
    if (currentActiveNode === startTrapNode || comparisonResult & DOCUMENT_POSITION_BROAD_PRECEDING) {
      const tabbable3 = [...bodyNode.querySelectorAll(selectorTabbable)].reverse().find((elem) => Boolean(elem.offsetParent));
      if (tabbable3) {
        tabbable3.focus();
      } else if (bodyNode !== oldActiveNode) {
        bodyNode.focus();
      }
    } else if (currentActiveNode === endTrapNode || comparisonResult & DOCUMENT_POSITION_BROAD_FOLLOWING) {
      const tabbable3 = Array.prototype.find.call(bodyNode.querySelectorAll(selectorTabbable), (elem) => Boolean(elem.offsetParent));
      if (tabbable3) {
        tabbable3.focus();
      } else if (bodyNode !== oldActiveNode) {
        bodyNode.focus();
      }
    }
  }
}
function wrapFocusWithoutSentinels(_ref2) {
  let {
    containerNode,
    currentActiveNode,
    event
  } = _ref2;
  if (["blur", "focusout", "focusin", "focus"].includes(event.type) && true) {
    (0, import_react74.useEffect)(() => {
      throw new Error(`Error: wrapFocusWithoutSentinels(...) called in unsupported ${event.type} event.

Call wrapFocusWithoutSentinels(...) from onKeyDown instead.`);
    });
  }
  const tabbables = tabbable(containerNode);
  const firstTabbable = tabbables[0];
  const lastTabbable = tabbables[tabbables.length - 1];
  if (currentActiveNode === lastTabbable && !event.shiftKey) {
    event.preventDefault();
    firstTabbable.focus();
  }
  if (currentActiveNode === firstTabbable && event.shiftKey) {
    event.preventDefault();
    lastTabbable.focus();
  }
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ComposedModal/ComposedModal.js
var ModalBody = import_react75.default.forwardRef(function ModalBody2(_ref, ref) {
  let {
    className: customClassName,
    children,
    hasForm,
    hasScrollingContent,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const contentRef = (0, import_react75.useRef)(null);
  const [isScrollable, setIsScrollable] = (0, import_react75.useState)(false);
  const contentClass = (0, import_classnames42.default)({
    [`${prefix}--modal-content`]: true,
    [`${prefix}--modal-content--with-form`]: hasForm,
    [`${prefix}--modal-scroll-content`]: hasScrollingContent || isScrollable
  }, customClassName);
  useIsomorphicEffect$1(() => {
    if (contentRef.current) {
      setIsScrollable(contentRef.current.scrollHeight > contentRef.current.clientHeight);
    }
    function handler() {
      if (contentRef.current) {
        setIsScrollable(contentRef.current.scrollHeight > contentRef.current.clientHeight);
      }
    }
    const debouncedHandler = debounce2(handler, 200);
    window.addEventListener("resize", debouncedHandler);
    return () => {
      debouncedHandler.cancel();
      window.removeEventListener("resize", debouncedHandler);
    };
  }, []);
  const hasScrollingContentProps = hasScrollingContent || isScrollable ? {
    tabIndex: 0,
    role: "region"
  } : {};
  return import_react75.default.createElement(Layer2, _extends({
    className: contentClass
  }, hasScrollingContentProps, rest3, {
    ref: mergeRefs$1(contentRef, ref)
  }), children);
});
ModalBody.propTypes = {
  /**
   * Required props for the accessibility label of the header
   */
  ["aria-label"]: requiredIfGivenPropIsTruthy("hasScrollingContent", import_prop_types50.default.string),
  /**
   * Specify the content to be placed in the ModalBody
   */
  children: import_prop_types50.default.node,
  /**
   * Specify an optional className to be added to the Modal Body node
   */
  className: import_prop_types50.default.string,
  /**
   * Provide whether the modal content has a form element.
   * If `true` is used here, non-form child content should have `cds--modal-content__regular-content` class.
   */
  hasForm: import_prop_types50.default.bool,
  /**
   * Specify whether the modal contains scrolling content
   */
  hasScrollingContent: import_prop_types50.default.bool
};
var ComposedModal = import_react75.default.forwardRef(function ComposedModal2(_ref2, ref) {
  var _a;
  let {
    ["aria-labelledby"]: ariaLabelledBy,
    ["aria-label"]: ariaLabel,
    children,
    className: customClassName,
    containerClassName,
    danger,
    decorator,
    isFullWidth,
    onClose,
    onKeyDown,
    open,
    preventCloseOnClickOutside,
    selectorPrimaryFocus = "[data-modal-primary-focus]",
    selectorsFloatingMenus,
    size: size6,
    launcherButtonRef,
    slug,
    ...rest3
  } = _ref2;
  const prefix = usePrefix();
  const [isOpen, setIsOpen] = (0, import_react75.useState)(!!open);
  const [wasOpen, setWasOpen] = (0, import_react75.useState)(!!open);
  const innerModal = (0, import_react75.useRef)(null);
  const button = (0, import_react75.useRef)(null);
  const startSentinel = (0, import_react75.useRef)(null);
  const endSentinel = (0, import_react75.useRef)(null);
  const onMouseDownTarget = (0, import_react75.useRef)(null);
  const focusTrapWithoutSentinels = useFeatureFlag("enable-experimental-focus-wrap-without-sentinels");
  (0, import_react75.useEffect)(() => {
    if (open !== wasOpen) {
      setIsOpen(!!open);
      setWasOpen(!!open);
      toggleClass(document.body, `${prefix}--body--with-modal-open`, !!open);
    }
  }, [open, wasOpen, prefix]);
  (0, import_react75.useEffect)(() => {
    return () => {
      toggleClass(document.body, `${prefix}--body--with-modal-open`, false);
    };
  }, []);
  function handleKeyDown(event) {
    event.stopPropagation();
    if (match(event, Escape)) {
      closeModal(event);
    }
    if (focusTrapWithoutSentinels && open && match(event, Tab) && innerModal.current) {
      wrapFocusWithoutSentinels({
        containerNode: innerModal.current,
        currentActiveNode: event.target,
        event
      });
    }
    onKeyDown == null ? void 0 : onKeyDown(event);
  }
  function handleOnMouseDown(evt) {
    const target = evt.target;
    onMouseDownTarget.current = target;
  }
  function handleOnClick(evt) {
    const target = evt.target;
    const mouseDownTarget = onMouseDownTarget.current;
    evt.stopPropagation();
    if (!preventCloseOnClickOutside && !elementOrParentIsFloatingMenu(target, selectorsFloatingMenus) && innerModal.current && !innerModal.current.contains(target) && !innerModal.current.contains(mouseDownTarget)) {
      closeModal(evt);
    }
  }
  function handleBlur(_ref3) {
    let {
      target: oldActiveNode,
      relatedTarget: currentActiveNode
    } = _ref3;
    if (open && currentActiveNode && oldActiveNode && innerModal.current) {
      const {
        current: bodyNode
      } = innerModal;
      const {
        current: startSentinelNode
      } = startSentinel;
      const {
        current: endSentinelNode
      } = endSentinel;
      wrapFocus({
        bodyNode,
        startTrapNode: startSentinelNode,
        endTrapNode: endSentinelNode,
        currentActiveNode,
        oldActiveNode,
        selectorsFloatingMenus: selectorsFloatingMenus == null ? void 0 : selectorsFloatingMenus.filter(Boolean)
      });
    }
  }
  function closeModal(evt) {
    if (!onClose || onClose(evt) !== false) {
      setIsOpen(false);
    }
  }
  const modalClass = (0, import_classnames42.default)(`${prefix}--modal`, {
    "is-visible": isOpen,
    [`${prefix}--modal--danger`]: danger,
    [`${prefix}--modal--slug`]: slug,
    [`${prefix}--modal--decorator`]: decorator
  }, customClassName);
  const containerClass = (0, import_classnames42.default)(`${prefix}--modal-container`, size6 && `${prefix}--modal-container--${size6}`, isFullWidth && `${prefix}--modal-container--full-width`, containerClassName);
  let generatedAriaLabel;
  const childrenWithProps = import_react75.default.Children.toArray(children).map((child) => {
    switch (true) {
      case ((0, import_react_is2.isElement)(child) && child.type === import_react75.default.createElement(ModalHeader).type): {
        const el = child;
        generatedAriaLabel = el.props.label;
        return import_react75.default.cloneElement(el, {
          closeModal
        });
      }
      case ((0, import_react_is2.isElement)(child) && child.type === import_react75.default.createElement(ModalFooter).type): {
        const el = child;
        return import_react75.default.cloneElement(el, {
          closeModal,
          inputref: button,
          danger
        });
      }
      default:
        return child;
    }
  });
  (0, import_react75.useEffect)(() => {
    if (!open && launcherButtonRef) {
      setTimeout(() => {
        var _a2;
        (_a2 = launcherButtonRef == null ? void 0 : launcherButtonRef.current) == null ? void 0 : _a2.focus();
      });
    }
  }, [open, launcherButtonRef]);
  (0, import_react75.useEffect)(() => {
    const initialFocus = (focusContainerElement) => {
      const containerElement = focusContainerElement || innerModal.current;
      const primaryFocusElement = containerElement ? containerElement.querySelector(danger ? `.${prefix}--btn--secondary` : selectorPrimaryFocus) : null;
      if (primaryFocusElement) {
        return primaryFocusElement;
      }
      return button && button.current;
    };
    const focusButton = (focusContainerElement) => {
      const target = initialFocus(focusContainerElement);
      const closeButton = focusContainerElement.querySelector(`.${prefix}--modal-close`);
      if (target) {
        target.focus();
      } else if (!target && closeButton) {
        closeButton == null ? void 0 : closeButton.focus();
      }
    };
    if (open && isOpen) {
      focusButton(innerModal.current);
    }
  }, [open, selectorPrimaryFocus, isOpen]);
  let normalizedDecorator = import_react75.default.isValidElement(slug ?? decorator) ? slug ?? decorator : null;
  if (normalizedDecorator && ((_a = normalizedDecorator["type"]) == null ? void 0 : _a.displayName) === "AILabel") {
    normalizedDecorator = import_react75.default.cloneElement(normalizedDecorator, {
      size: "sm"
    });
  }
  return import_react75.default.createElement(Layer2, _extends({}, rest3, {
    level: 0,
    role: "presentation",
    ref,
    "aria-hidden": !open,
    onBlur: !focusTrapWithoutSentinels ? handleBlur : () => {
    },
    onClick: composeEventHandlers([rest3 == null ? void 0 : rest3.onClick, handleOnClick]),
    onMouseDown: composeEventHandlers([rest3 == null ? void 0 : rest3.onMouseDown, handleOnMouseDown]),
    onKeyDown: handleKeyDown,
    className: modalClass
  }), import_react75.default.createElement("div", {
    className: containerClass,
    role: "dialog",
    "aria-modal": "true",
    "aria-label": ariaLabel ? ariaLabel : generatedAriaLabel,
    "aria-labelledby": ariaLabelledBy
  }, !focusTrapWithoutSentinels && import_react75.default.createElement("button", {
    type: "button",
    ref: startSentinel,
    className: `${prefix}--visually-hidden`
  }, "Focus sentinel"), import_react75.default.createElement("div", {
    ref: innerModal,
    className: `${prefix}--modal-container-body`
  }, slug ? normalizedDecorator : decorator ? import_react75.default.createElement("div", {
    className: `${prefix}--modal--inner__decorator`
  }, normalizedDecorator) : "", childrenWithProps), !focusTrapWithoutSentinels && import_react75.default.createElement("button", {
    type: "button",
    ref: endSentinel,
    className: `${prefix}--visually-hidden`
  }, "Focus sentinel")));
});
ComposedModal.propTypes = {
  /**
   * Specify the aria-label for cds--modal-container
   */
  ["aria-label"]: import_prop_types50.default.string,
  /**
   * Specify the aria-labelledby for cds--modal-container
   */
  ["aria-labelledby"]: import_prop_types50.default.string,
  /**
   * Specify the content to be placed in the ComposedModal
   */
  children: import_prop_types50.default.node,
  /**
   * Specify an optional className to be applied to the modal root node
   */
  className: import_prop_types50.default.string,
  /**
   * Specify an optional className to be applied to the modal node
   */
  containerClassName: import_prop_types50.default.string,
  /**
   * Specify whether the primary button should be replaced with danger button.
   * Note that this prop is not applied if you render primary/danger button by yourself
   */
  danger: import_prop_types50.default.bool,
  /**
   * **Experimental**: Provide a `decorator` component to be rendered inside the `ComposedModal` component
   */
  decorator: import_prop_types50.default.node,
  /**
   * Specify whether the Modal content should have any inner padding.
   */
  isFullWidth: import_prop_types50.default.bool,
  /**
   * Provide a ref to return focus to once the modal is closed.
   */
  // @ts-expect-error: Invalid derived type
  launcherButtonRef: import_prop_types50.default.oneOfType([import_prop_types50.default.func, import_prop_types50.default.shape({
    current: import_prop_types50.default.any
  })]),
  /**
   * Specify an optional handler for closing modal.
   * Returning `false` here prevents closing modal.
   */
  onClose: import_prop_types50.default.func,
  /**
   * Specify an optional handler for the `onKeyDown` event. Called for all
   * `onKeyDown` events that do not close the modal
   */
  onKeyDown: import_prop_types50.default.func,
  /**
   * Specify whether the Modal is currently open
   */
  open: import_prop_types50.default.bool,
  preventCloseOnClickOutside: import_prop_types50.default.bool,
  /**
   * Specify a CSS selector that matches the DOM element that should be
   * focused when the Modal opens
   */
  selectorPrimaryFocus: import_prop_types50.default.string,
  /**
   * Specify the CSS selectors that match the floating menus
   */
  selectorsFloatingMenus: import_prop_types50.default.arrayOf(import_prop_types50.default.string.isRequired),
  /**
   * Specify the size variant.
   */
  size: import_prop_types50.default.oneOf(["xs", "sm", "md", "lg"]),
  slug: deprecate(import_prop_types50.default.node, "The `slug` prop for `ComposedModal` has been deprecated in favor of the new `decorator` prop. It will be removed in the next major release.")
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/internal/deprecateFieldOnObject.js
var didWarnAboutDeprecation3 = {};
function deprecateFieldOnObject(object, field, Component2, message) {
  Object.defineProperty(object, field, {
    enumerable: true,
    get() {
      if (!didWarnAboutDeprecation3[field]) {
        true ? warning(false, message || `The ${field} field has been deprecated on the ${object.displayName} object. Please import and use ${Component2.displayName || Component2.name || "the field"} directly.`) : void 0;
        didWarnAboutDeprecation3[field] = true;
      }
      return Component2;
    }
  });
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ContainedList/ContainedList.js
var import_react77 = __toESM(require_react());
var import_prop_types52 = __toESM(require_prop_types());
var import_classnames44 = __toESM(require_classnames());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ContainedList/ContainedListItem/ContainedListItem.js
var import_react76 = __toESM(require_react());
var import_prop_types51 = __toESM(require_prop_types());
var import_classnames43 = __toESM(require_classnames());
var ContainedListItem = (_ref) => {
  let {
    action,
    children,
    className,
    disabled = false,
    onClick,
    renderIcon: IconElement,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const isClickable = onClick !== void 0;
  const classes = (0, import_classnames43.default)(`${prefix}--contained-list-item`, className, {
    [`${prefix}--contained-list-item--clickable`]: isClickable,
    [`${prefix}--contained-list-item--with-icon`]: IconElement,
    [`${prefix}--contained-list-item--with-action`]: action
  });
  const content = import_react76.default.createElement(import_react76.default.Fragment, null, IconElement && import_react76.default.createElement("div", {
    className: `${prefix}--contained-list-item__icon`
  }, import_react76.default.createElement(IconElement, null)), import_react76.default.createElement("div", null, children));
  return import_react76.default.createElement("li", _extends({
    className: classes
  }, rest3), isClickable ? import_react76.default.createElement("button", {
    className: `${prefix}--contained-list-item__content`,
    type: "button",
    disabled,
    onClick
  }, content) : import_react76.default.createElement("div", {
    className: `${prefix}--contained-list-item__content`
  }, content), action && import_react76.default.createElement(LayoutConstraint, {
    size: {
      min: "sm",
      max: "lg"
    },
    className: `${prefix}--contained-list-item__action`
  }, action));
};
ContainedListItem.propTypes = {
  /**
   * A slot for a possible interactive element to render within the item.
   */
  action: import_prop_types51.default.node,
  /**
   * The content of this item. Must not contain any interactive elements. Use props.action to include those.
   */
  children: import_prop_types51.default.node,
  /**
   * Additional CSS class names.
   */
  className: import_prop_types51.default.string,
  /**
   * Whether this item is disabled.
   */
  disabled: import_prop_types51.default.bool,
  /**
   * Provide an optional function to be called when the item is clicked.
   */
  onClick: import_prop_types51.default.func,
  /**
   * Provide an optional icon to render in front of the item's content.
   */
  // @ts-expect-error: PropTypes are not expressive enough to cover this case
  renderIcon: import_prop_types51.default.oneOfType([import_prop_types51.default.func, import_prop_types51.default.object])
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ContainedList/ContainedList.js
var variants = ["on-page", "disclosed"];
function filterChildren(children) {
  var _a;
  if (Array.isArray(children)) {
    return children == null ? void 0 : children.filter((child) => {
      var _a2;
      return !["Search", "ExpandableSearch"].includes((_a2 = child == null ? void 0 : child.type) == null ? void 0 : _a2.displayName);
    });
  }
  if (children && !["Search", "ExpandableSearch"].includes((_a = children == null ? void 0 : children.type) == null ? void 0 : _a.displayName)) {
    return children;
  }
  return null;
}
function renderChildren(children) {
  var _a;
  if (Array.isArray(children)) {
    children.map((child, index4) => {
      var _a2;
      if (index4 === 0 && ((_a2 = child.type) == null ? void 0 : _a2.displayName) === "Search") {
        return child;
      }
      return child;
    });
  }
  if (children && ((_a = children.type) == null ? void 0 : _a.displayName) === "Search") {
    return children;
  }
  return children;
}
var ContainedList = (_ref) => {
  let {
    action,
    children,
    className,
    isInset,
    kind = variants[0],
    label,
    size: size6,
    ...rest3
  } = _ref;
  const labelId = `${useId("contained-list")}-header`;
  const prefix = usePrefix();
  const classes = (0, import_classnames44.default)(`${prefix}--contained-list`, {
    [`${prefix}--contained-list--inset-rulers`]: isInset,
    [`${prefix}--contained-list--${size6}`]: size6,
    // TODO: V12 - Remove this class
    [`${prefix}--layout--size-${size6}`]: size6
  }, `${prefix}--contained-list--${kind}`, className);
  const filteredChildren = filterChildren(children);
  function isSearchAction(action2) {
    if (!import_react77.default.isValidElement(action2)) {
      return false;
    }
    const actionTypes = ["Search", "ExpandableSearch"];
    let actionType = "";
    if (typeof action2.type === "string") {
      actionType = action2.type;
    } else {
      actionType = action2.type.displayName || "";
    }
    return actionTypes.includes(actionType);
  }
  const isActionSearch = isSearchAction(action);
  const renderedChildren = renderChildren(children);
  return import_react77.default.createElement("div", _extends({
    className: classes
  }, rest3), import_react77.default.createElement("div", {
    className: `${prefix}--contained-list__header`
  }, import_react77.default.createElement("div", {
    id: labelId,
    className: `${prefix}--contained-list__label`
  }, label), import_react77.default.createElement(LayoutConstraint, {
    size: {
      min: "sm",
      max: "xl"
    },
    className: `${prefix}--contained-list__action`
  }, action)), children && /**
   * Webkit removes implicit "list" semantics when "list-style-type: none" is set.
   * Explicitly setting the "list" role ensures assistive technology in webkit
   * browsers correctly announce the semantics.
   *
   * Ref https://bugs.webkit.org/show_bug.cgi?id=170179#c1
   */
  // eslint-disable-next-line jsx-a11y/no-redundant-roles
  import_react77.default.createElement("ul", {
    role: "list",
    "aria-labelledby": labelId
  }, isActionSearch ? filteredChildren : renderedChildren));
};
ContainedList.propTypes = {
  /**
   * A slot for a possible interactive element to render.
   */
  action: import_prop_types52.default.node,
  /**
   * A collection of ContainedListItems to be rendered in the ContainedList
   */
  children: import_prop_types52.default.node,
  /**
   * Additional CSS class names.
   */
  className: import_prop_types52.default.string,
  /**
   * Specify whether the dividing lines in between list items should be inset.
   */
  isInset: import_prop_types52.default.bool,
  /**
   * The kind of ContainedList you want to display
   */
  kind: import_prop_types52.default.oneOf(variants),
  /**
   * A label describing the contained list.
   */
  label: import_prop_types52.default.oneOfType([import_prop_types52.default.string, import_prop_types52.default.node]).isRequired,
  /**
   * Specify the size of the contained list.
   */
  size: import_prop_types52.default.oneOf(["sm", "md", "lg", "xl"])
};
ContainedList.ContainedListItem = ContainedListItem;

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ContainedList/index.js
ContainedList.ContainedListItem = ContainedListItem;
if (true) {
  deprecateFieldOnObject(ContainedList, "ContainedListItem", ContainedListItem);
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/internal/createClassWrapper.js
var import_react78 = __toESM(require_react());
function createClassWrapper(Component2) {
  function ClassWrapper(props) {
    return import_react78.default.createElement(Component2, props);
  }
  const name = Component2.displayName || Component2.name;
  ClassWrapper.displayName = `ClassWrapper(${name})`;
  return ClassWrapper;
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ContentSwitcher/ContentSwitcher.js
var import_prop_types53 = __toESM(require_prop_types());
var import_react79 = __toESM(require_react());
var import_classnames45 = __toESM(require_classnames());
var ContentSwitcher = class extends import_react79.default.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "_switchRefs", []);
    _defineProperty(this, "state", {
      selectedIndex: void 0
    });
    _defineProperty(this, "handleItemRef", (index4) => (ref) => {
      this._switchRefs[index4] = ref;
    });
    _defineProperty(this, "handleChildChange", (data) => {
      var _a;
      const {
        selectionMode = "automatic"
      } = this.props;
      const {
        selectedIndex
      } = this.state;
      const {
        index: index4
      } = data;
      const {
        key
      } = data;
      if (matches(data, [ArrowRight2, ArrowLeft])) {
        const nextIndex = getNextIndex(key, index4, (_a = this.props.children) == null ? void 0 : _a.length);
        const children = import_react79.default.Children.toArray(this.props.children);
        if (selectionMode === "manual") {
          const switchRef = this._switchRefs[nextIndex];
          switchRef && switchRef.focus();
        } else {
          this.setState({
            selectedIndex: nextIndex
          }, () => {
            if (typeof this.state.selectedIndex !== "number") {
              return;
            }
            const child = children[this.state.selectedIndex];
            const switchRef = this._switchRefs[this.state.selectedIndex];
            switchRef && switchRef.focus();
            this.props.onChange({
              ...data,
              index: this.state.selectedIndex,
              name: child.props.name,
              text: child.props.text
            });
          });
        }
      } else if (selectedIndex !== index4) {
        this.setState({
          selectedIndex: index4
        }, () => {
          const switchRef = this._switchRefs[index4];
          switchRef && switchRef.focus();
          this.props.onChange(data);
        });
      }
    });
  }
  static getDerivedStateFromProps(_ref, state) {
    let {
      selectedIndex = 0
    } = _ref;
    const {
      prevSelectedIndex
    } = state;
    return prevSelectedIndex === selectedIndex ? null : {
      selectedIndex,
      prevSelectedIndex: selectedIndex
    };
  }
  render() {
    var _a, _b;
    const prefix = this.context;
    const {
      children,
      className,
      light,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      selectedIndex = 0,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      selectionMode = "automatic",
      size: size6,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onChange = noopFn,
      ...other
    } = this.props;
    const isIconOnly = (_b = (_a = import_react79.default.Children) == null ? void 0 : _a.map(children, (child) => {
      return child.type.displayName === "IconSwitch";
    })) == null ? void 0 : _b.every((val) => val === true);
    const classes = (0, import_classnames45.default)(`${prefix}--content-switcher`, className, {
      [`${prefix}--content-switcher--light`]: light,
      [`${prefix}--content-switcher--${size6}`]: size6,
      // TODO: V12 - Remove this class
      [`${prefix}--layout--size-${size6}`]: size6,
      [`${prefix}--content-switcher--icon-only`]: isIconOnly
    });
    return import_react79.default.createElement(LayoutConstraint, _extends({
      size: {
        default: "md",
        min: "sm",
        max: "lg"
      }
    }, other, {
      className: classes,
      role: "tablist",
      onChange: void 0
    }), children && import_react79.default.Children.toArray(children).map((child, index4) => import_react79.default.cloneElement(child, {
      index: index4,
      onClick: composeEventHandlers([this.handleChildChange, child.props.onClick]),
      onKeyDown: this.handleChildChange,
      selected: index4 === this.state.selectedIndex,
      ref: this.handleItemRef(index4),
      size: size6
    })));
  }
};
_defineProperty(ContentSwitcher, "propTypes", {
  /**
   * Pass in Switch components to be rendered in the ContentSwitcher
   */
  children: import_prop_types53.default.node,
  /**
   * Specify an optional className to be added to the container node
   */
  className: import_prop_types53.default.string,
  /**
   * `true` to use the light variant.
   */
  light: deprecate(import_prop_types53.default.bool, "The `light` prop for `ContentSwitcher` is no longer needed and has been deprecated. It will be removed in the next major release."),
  /**
   * Specify an `onChange` handler that is called whenever the ContentSwitcher
   * changes which item is selected
   */
  onChange: import_prop_types53.default.func.isRequired,
  /**
   * Specify a selected index for the initially selected content
   */
  selectedIndex: import_prop_types53.default.number,
  /**
   * Choose whether or not to automatically change selection on focus when left/right arrow pressed. Defaults to 'automatic'
   */
  selectionMode: import_prop_types53.default.oneOf(["automatic", "manual"]),
  /**
   * Specify the size of the Content Switcher. Currently supports either `sm`, 'md' (default) or 'lg` as an option.
   */
  size: import_prop_types53.default.oneOf(["sm", "md", "lg"])
});
_defineProperty(ContentSwitcher, "contextType", PrefixContext);

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ContentSwitcher/index.js
var ContentSwitcher2 = createClassWrapper(ContentSwitcher);

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ContextMenu/useContextMenu.js
var import_react80 = __toESM(require_react());
function useContextMenu() {
  let trigger = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : document;
  const [open, setOpen] = (0, import_react80.useState)(false);
  const [position, setPosition] = (0, import_react80.useState)([0, 0]);
  function openContextMenu(e2) {
    e2.preventDefault();
    const {
      clientX: x,
      clientY: y
    } = e2;
    setPosition([x, y]);
    setOpen(true);
  }
  function onClose() {
    setOpen(false);
  }
  (0, import_react80.useEffect)(() => {
    const el = trigger instanceof Element || trigger instanceof Document || trigger instanceof Window ? trigger : trigger.current;
    if (el) {
      const eventListener = (e2) => openContextMenu(e2);
      el.addEventListener("contextmenu", eventListener);
      return () => {
        el.removeEventListener("contextmenu", eventListener);
      };
    }
  }, [trigger]);
  return {
    open,
    x: position[0],
    y: position[1],
    onClose,
    mode: "full"
  };
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DangerButton/DangerButton.js
var import_react81 = __toESM(require_react());
var DangerButton = (props) => import_react81.default.createElement(Button, _extends({}, props, {
  kind: "danger"
}));

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/DataTable.js
var import_prop_types82 = __toESM(require_prop_types());
var import_react114 = __toESM(require_react());
var import_react_fast_compare2 = __toESM(require_react_fast_compare());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/state/sortStates.js
var sortStates = {
  NONE: "NONE",
  DESC: "DESC",
  ASC: "ASC"
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/tools/cells.js
var getCellId = (rowId, header) => `${rowId}:${header}`;

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/tools/sorting.js
var compare = function(a, b) {
  var _a, _b;
  let locale = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "en";
  a === null ? a = "" : null;
  b === null ? b = "" : null;
  if (typeof a === "number" && typeof b === "number") {
    return a - b;
  }
  if (typeof a === "string" && typeof b === "string") {
    return compareStrings(a, b, locale);
  }
  if (typeof a === "object" && typeof b === "object") {
    if (typeof ((_a = a.props) == null ? void 0 : _a.children) === "string" && typeof ((_b = b.props) == null ? void 0 : _b.children) === "string") {
      return compareStrings(a.props.children, b.props.children, locale);
    }
  }
  return compareStrings("" + a, "" + b, locale);
};
var compareStrings = function(a, b) {
  let locale = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "en";
  if (!isNaN(a) && !isNaN(parseFloat(a)) && !isNaN(b) && !isNaN(parseFloat(b))) {
    return a.localeCompare(b, locale, {
      numeric: true
    });
  }
  return a.localeCompare(b, locale);
};
var sortRows = (_ref) => {
  let {
    rowIds,
    cellsById,
    sortDirection,
    key,
    locale = "en",
    sortRow = defaultSortRow
  } = _ref;
  return rowIds.slice().sort((a, b) => {
    const cellA = cellsById[getCellId(a, key)];
    const cellB = cellsById[getCellId(b, key)];
    return sortRow(cellA && cellA.value, cellB && cellB.value, {
      key,
      sortDirection,
      locale,
      sortStates,
      compare,
      rowIds: [a, b]
    });
  });
};
var defaultSortRow = (cellA, cellB, _ref2) => {
  let {
    sortDirection,
    sortStates: sortStates2,
    locale
  } = _ref2;
  if (sortDirection === sortStates2.ASC) {
    return compare(cellA, cellB, locale);
  }
  return compare(cellB, cellA, locale);
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/state/sorting.js
var initialSortState = sortStates.NONE;
var getNextSortDirection = (prevHeader, header, prevState) => {
  if (prevHeader === header) {
    if (prevState === "NONE") {
      return sortStates.ASC;
    }
    if (prevState === "ASC") {
      return sortStates.DESC;
    }
    return sortStates.NONE;
  }
  return sortStates.ASC;
};
var getNextSortState = (props, state, _ref) => {
  let {
    key
  } = _ref;
  const {
    sortDirection,
    sortHeaderKey
  } = state;
  const nextSortDirection = getNextSortDirection(key, sortHeaderKey, sortDirection);
  return getSortedState(props, state, key, nextSortDirection);
};
var getSortedState = (props, state, key, sortDirection) => {
  const {
    rowIds,
    cellsById,
    initialRowOrder
  } = state;
  const {
    locale,
    sortRow
  } = props;
  const nextRowIds = sortDirection !== sortStates.NONE ? sortRows({
    rowIds,
    cellsById,
    sortDirection,
    key,
    locale,
    sortRow
  }) : initialRowOrder;
  return {
    sortHeaderKey: key,
    sortDirection,
    rowIds: nextRowIds
  };
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/tools/normalize.js
var normalize = function(rows, headers) {
  let prevState = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const {
    rowsById: prevRowsByIds
  } = prevState;
  const rowIds = new Array(rows.length);
  const rowsById = {};
  const cellsById = {};
  rows.forEach((row, i) => {
    rowIds[i] = row.id;
    const {
      id,
      isSelected = false,
      isExpanded = false,
      disabled = false
    } = row;
    rowsById[id] = {
      id,
      isSelected,
      isExpanded,
      disabled,
      cells: new Array(headers.length)
    };
    if (prevRowsByIds && prevRowsByIds[row.id] !== void 0) {
      rowsById[row.id].isSelected = prevRowsByIds[row.id].isSelected;
      rowsById[row.id].isExpanded = prevRowsByIds[row.id].isExpanded;
    }
    headers.forEach((_ref, i2) => {
      var _a;
      let {
        key,
        slug,
        decorator
      } = _ref;
      const id2 = getCellId(row.id, key);
      cellsById[id2] = {
        id: id2,
        value: row[key],
        isEditable: false,
        isEditing: false,
        isValid: true,
        errors: null,
        hasAILabelHeader: !!(slug || ((_a = decorator == null ? void 0 : decorator.type) == null ? void 0 : _a.displayName) === "AILabel"),
        info: {
          header: key
        }
      };
      rowsById[row.id].cells[i2] = id2;
    });
  });
  return {
    rowIds,
    rowsById,
    cellsById
  };
};
var normalize$1 = normalize;

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/state/getDerivedStateFromProps.js
var getDerivedStateFromProps = (props, prevState) => {
  const {
    rowIds,
    rowsById,
    cellsById
  } = normalize$1(props.rows, props.headers, prevState);
  const state = {
    rowIds,
    rowsById,
    cellsById,
    sortDirection: prevState.sortDirection || initialSortState,
    sortHeaderKey: prevState.sortHeaderKey || null,
    // Copy over rowIds so the reference doesn't mutate the stored
    // `initialRowOrder`
    initialRowOrder: rowIds.slice(),
    filterInputValue: prevState.filterInputValue || null,
    // Optional state field to indicate whether a consumer should show a
    // batch actions menu
    shouldShowBatchActions: prevState.shouldShowBatchActions || false
  };
  if (prevState.sortDirection && prevState.sortHeaderKey) {
    const {
      rowIds: rowIds2
    } = getSortedState(props, state, prevState.sortHeaderKey, prevState.sortDirection);
    state.rowIds = rowIds2;
  }
  state.isExpandedAll = state.rowIds.every((id) => {
    return state.rowsById[id].isExpanded === true;
  });
  return state;
};
var getDerivedStateFromProps$1 = getDerivedStateFromProps;

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/tools/denormalize.js
var denormalize = (rowIds, rowsById, cellsById) => {
  return rowIds.map((id) => ({
    ...rowsById[id],
    cells: rowsById[id].cells.map((cellId) => cellsById[cellId])
  }));
};
var denormalize$1 = denormalize;

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/tools/filter.js
var defaultFilterRows = (_ref) => {
  let {
    rowIds,
    headers,
    cellsById,
    inputValue,
    getCellId: getCellId2
  } = _ref;
  return rowIds.filter((rowId) => headers.some((_ref2) => {
    let {
      key
    } = _ref2;
    const id = getCellId2(rowId, key);
    if (typeof cellsById[id].value === "boolean") {
      return false;
    }
    return ("" + cellsById[id].value).toLowerCase().includes(inputValue.toLowerCase());
  }));
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/Table.js
var import_react83 = __toESM(require_react());
var import_prop_types54 = __toESM(require_prop_types());
var import_classnames46 = __toESM(require_classnames());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/TableContext.js
var import_react82 = __toESM(require_react());
var TableContext = (0, import_react82.createContext)({
  titleId: void 0,
  descriptionId: void 0
});

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/Table.js
var isElementWrappingContent = (element, context) => {
  var _a, _b, _c, _d;
  if (element.children.length > 0) {
    return false;
  }
  const computedStyles = window.getComputedStyle(element);
  context.font = computedStyles.font ? computedStyles.font : `${computedStyles.fontSize}" "${computedStyles.fontFamily}`;
  const measuredText = context == null ? void 0 : context.measureText(element.textContent ?? "");
  let textWidth = measuredText.width ?? 0;
  const letterSpacing = (_a = computedStyles.letterSpacing) == null ? void 0 : _a.split("px");
  if (letterSpacing && letterSpacing.length && !isNaN(Number(letterSpacing[0]))) {
    textWidth += Number(letterSpacing[0]) * (((_b = element.textContent) == null ? void 0 : _b.length) ?? 0);
  }
  const paddingLeft = (_c = computedStyles.paddingLeft) == null ? void 0 : _c.split("px");
  if (paddingLeft && paddingLeft.length && !isNaN(Number(paddingLeft[0]))) {
    textWidth += Number(paddingLeft[0]);
  }
  const paddingRight = (_d = computedStyles.paddingLeft) == null ? void 0 : _d.split("px");
  if (paddingRight && paddingRight.length && !isNaN(Number(paddingRight[0]))) {
    textWidth += Number(paddingRight[0]);
  }
  if (textWidth > element.getBoundingClientRect().width) {
    return true;
  }
  return false;
};
var Table = (_ref) => {
  var _a;
  let {
    className,
    children,
    useZebraStyles,
    size: size6 = "lg",
    isSortable = false,
    useStaticWidth,
    stickyHeader,
    overflowMenuOnHover = true,
    experimentalAutoAlign = false,
    tabIndex,
    ...other
  } = _ref;
  const {
    titleId,
    descriptionId
  } = (0, import_react83.useContext)(TableContext);
  const prefix = usePrefix();
  const [isScrollable, setIsScrollable] = (0, import_react83.useState)(false);
  const tableRef = (0, import_react83.useRef)(null);
  const componentClass = (0, import_classnames46.default)(`${prefix}--data-table`, className, {
    [`${prefix}--data-table--${size6}`]: size6,
    [`${prefix}--data-table--sort`]: isSortable,
    [`${prefix}--data-table--zebra`]: useZebraStyles,
    [`${prefix}--data-table--static`]: useStaticWidth,
    [`${prefix}--data-table--sticky-header`]: stickyHeader,
    [`${prefix}--data-table--visible-overflow-menu`]: !overflowMenuOnHover
  });
  const toggleTableBodyAlignmentClass = (0, import_react83.useCallback)(function() {
    var _a2, _b;
    let alignTop = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    alignTop ? (_a2 = tableRef.current) == null ? void 0 : _a2.classList.add(`${prefix}--data-table--top-aligned-body`) : (_b = tableRef.current) == null ? void 0 : _b.classList.remove(`${prefix}--data-table--top-aligned-body`);
  }, [prefix]);
  const toggleTableHeaderAlignmentClass = (0, import_react83.useCallback)(function() {
    var _a2, _b;
    let alignTop = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    alignTop ? (_a2 = tableRef.current) == null ? void 0 : _a2.classList.add(`${prefix}--data-table--top-aligned-header`) : (_b = tableRef.current) == null ? void 0 : _b.classList.remove(`${prefix}--data-table--top-aligned-header`);
  }, [prefix]);
  const setTableAlignment = (0, import_react83.useCallback)(() => {
    if (experimentalAutoAlign) {
      const canvas = document.createElement("canvas");
      const context = canvas.getContext("2d");
      if (tableRef.current && context) {
        const isBodyMultiline = Array.from(tableRef.current.querySelectorAll("td")).some((td) => isElementWrappingContent(td, context));
        const isHeaderMultiline = Array.from(tableRef.current.querySelectorAll("th")).some((th) => {
          const label = th.querySelector(`.${prefix}--table-header-label`);
          return label && isElementWrappingContent(label, context);
        });
        toggleTableBodyAlignmentClass(isBodyMultiline);
        toggleTableHeaderAlignmentClass(isHeaderMultiline);
      }
    } else {
      toggleTableBodyAlignmentClass(false);
      toggleTableHeaderAlignmentClass(false);
    }
  }, [experimentalAutoAlign, toggleTableBodyAlignmentClass, toggleTableHeaderAlignmentClass, prefix]);
  const debouncedSetTableAlignment = debounce2(setTableAlignment, 100);
  useWindowEvent("resize", debouncedSetTableAlignment);
  const setTabIndex = (0, import_react83.useCallback)(() => {
    var _a2, _b;
    const tableContainer = (_a2 = tableRef == null ? void 0 : tableRef.current) == null ? void 0 : _a2.parentNode;
    const tableHeader = (_b = tableRef == null ? void 0 : tableRef.current) == null ? void 0 : _b.firstChild;
    if ((tableHeader == null ? void 0 : tableHeader.scrollWidth) > (tableContainer == null ? void 0 : tableContainer.clientWidth)) {
      setIsScrollable(true);
    } else {
      setIsScrollable(false);
    }
  }, []);
  const debouncedSetTabIndex = debounce2(setTabIndex, 100);
  useWindowEvent("resize", debouncedSetTabIndex);
  useIsomorphicEffect$1(() => {
    setTabIndex();
  }, [setTabIndex]);
  if (typeof document !== "undefined" && ((_a = document == null ? void 0 : document.fonts) == null ? void 0 : _a.status) && document.fonts.status !== "loaded") {
    document.fonts.ready.then(() => {
      setTableAlignment();
    });
  }
  useIsomorphicEffect$1(() => {
    setTableAlignment();
  }, [setTableAlignment, size6]);
  const table = import_react83.default.createElement("div", {
    className: `${prefix}--data-table-content`,
    tabIndex: tabIndex ?? (isScrollable ? 0 : void 0)
  }, import_react83.default.createElement("table", _extends({
    "aria-labelledby": titleId,
    "aria-describedby": descriptionId
  }, other, {
    className: componentClass,
    ref: tableRef
  }), children));
  return stickyHeader ? import_react83.default.createElement("section", {
    className: `${prefix}--data-table_inner-container`
  }, table) : table;
};
Table.propTypes = {
  /**
   * Pass in the children that will be rendered within the Table
   */
  children: import_prop_types54.default.node,
  className: import_prop_types54.default.string,
  /**
   * Experimental property. Allows table to align cell contents to the top if there is text wrapping in the content. Might have performance issues, intended for smaller tables
   */
  experimentalAutoAlign: import_prop_types54.default.bool,
  /**
   * `false` If true, will apply sorting styles
   */
  isSortable: import_prop_types54.default.bool,
  /**
   * Specify whether the overflow menu (if it exists) should be shown always, or only on hover
   */
  overflowMenuOnHover: import_prop_types54.default.bool,
  /**
   *  Change the row height of table. Currently supports `xs`, `sm`, `md`, `lg`, and `xl`.
   */
  size: import_prop_types54.default.oneOf(["xs", "sm", "md", "lg", "xl"]),
  /**
   * `false` If true, will keep the header sticky (only data rows will scroll)
   */
  stickyHeader: import_prop_types54.default.bool,
  /**
   * `false` If true, will use a width of 'auto' instead of 100%
   */
  useStaticWidth: import_prop_types54.default.bool,
  /**
   * `true` to add useZebraStyles striping.
   */
  useZebraStyles: import_prop_types54.default.bool,
  /**
   * Specify the table tabIndex
   */
  tabIndex: import_prop_types54.default.number
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/tools/wrapComponent.js
var import_classnames47 = __toESM(require_classnames());
var import_prop_types55 = __toESM(require_prop_types());
var import_react84 = __toESM(require_react());
var wrapComponent = (_ref) => {
  let {
    name,
    className: getClassName,
    type
  } = _ref;
  function Component2(_ref2) {
    let {
      className: baseClassName,
      ...other
    } = _ref2;
    const prefix = usePrefix();
    const componentClass = (0, import_classnames47.default)(typeof getClassName === "function" ? getClassName(prefix) : getClassName, baseClassName);
    return import_react84.default.createElement(type, {
      ...other,
      // Prevent Weird quirk where `cx` will evaluate to an empty string, '',
      // and so we have empty `class` attributes in the resulting markup
      // eslint-disable-next-line no-extra-boolean-cast
      className: !!componentClass ? componentClass : void 0
    });
  }
  Component2.displayName = name;
  Component2.propTypes = {
    className: import_prop_types55.default.string
  };
  return Component2;
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/TableActionList.js
var TableActionList = wrapComponent({
  name: "TableActionList",
  type: "div",
  className: (prefix) => `${prefix}--action-list`
});

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/TableBatchAction.js
var import_prop_types56 = __toESM(require_prop_types());
var import_react85 = __toESM(require_react());
var TableBatchAction = (_ref) => {
  let {
    renderIcon = AddFilled,
    iconDescription = "Add",
    ...props
  } = _ref;
  return import_react85.default.createElement(Button, _extends({
    renderIcon,
    iconDescription
  }, props));
};
TableBatchAction.propTypes = {
  /**
   * Specify if the button is an icon-only button
   */
  hasIconOnly: import_prop_types56.default.bool,
  /**
   * If specifying the `renderIcon` prop, provide a description for that icon that can
   * be read by screen readers
   */
  iconDescription: (props) => {
    if (props.renderIcon && !props.children && !props.iconDescription) {
      return new Error("renderIcon property specified without also providing an iconDescription property.");
    }
    return void 0;
  },
  /**
   * Optional function to render your own icon in the underlying button
   */
  renderIcon: import_prop_types56.default.oneOfType([import_prop_types56.default.func, import_prop_types56.default.object])
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/TableBatchActions.js
var import_classnames48 = __toESM(require_classnames());
var import_prop_types57 = __toESM(require_prop_types());
var import_react86 = __toESM(require_react());
var TableBatchActionsTranslationKeys = ["carbon.table.batch.cancel", "carbon.table.batch.items.selected", "carbon.table.batch.item.selected", "carbon.table.batch.selectAll"];
var translationKeys = {
  "carbon.table.batch.cancel": "Cancel",
  "carbon.table.batch.items.selected": "items selected",
  "carbon.table.batch.item.selected": "item selected",
  "carbon.table.batch.selectAll": "Select all"
};
var translateWithId = function(id) {
  let {
    totalSelected,
    totalCount
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    totalSelected: 0,
    totalCount: 0
  };
  if (id === "carbon.table.batch.cancel") {
    return translationKeys[id];
  }
  if (id === "carbon.table.batch.selectAll") {
    return `${translationKeys[id]} (${totalCount})`;
  }
  return `${totalSelected} ${translationKeys[id]}`;
};
var TableBatchActions = (_ref) => {
  let {
    className,
    children,
    shouldShowBatchActions,
    totalSelected,
    totalCount,
    onCancel,
    onSelectAll,
    translateWithId: t2 = translateWithId,
    ...rest3
  } = _ref;
  const [isScrolling, setIsScrolling] = import_react86.default.useState(false);
  const prefix = usePrefix();
  const batchActionsClasses = (0, import_classnames48.default)({
    [`${prefix}--batch-actions`]: true,
    [`${prefix}--batch-actions--active`]: shouldShowBatchActions
  }, className);
  const batchSummaryClasses = (0, import_classnames48.default)(`${prefix}--batch-summary`, {
    [`${prefix}--batch-summary__scroll`]: isScrolling
  });
  return import_react86.default.createElement("div", _extends({
    onScroll: () => {
      setIsScrolling(!isScrolling);
    },
    "aria-hidden": !shouldShowBatchActions,
    className: batchActionsClasses
  }, rest3), import_react86.default.createElement("div", {
    className: batchSummaryClasses
  }, import_react86.default.createElement("p", {
    className: `${prefix}--batch-summary__para`
  }, import_react86.default.createElement(Text, null, totalSelected > 1 || totalSelected === 0 ? t2("carbon.table.batch.items.selected", {
    totalSelected
  }) : t2("carbon.table.batch.item.selected", {
    totalSelected
  }))), onSelectAll && import_react86.default.createElement(import_react86.default.Fragment, null, import_react86.default.createElement("span", {
    className: `${prefix}--batch-summary__divider`
  }, "|"), import_react86.default.createElement(Button, {
    onClick: onSelectAll,
    tabIndex: shouldShowBatchActions ? 0 : -1
  }, t2("carbon.table.batch.selectAll", {
    totalCount
  })))), import_react86.default.createElement(TableActionList, null, children, import_react86.default.createElement(Button, {
    className: `${prefix}--batch-summary__cancel`,
    tabIndex: shouldShowBatchActions ? 0 : -1,
    onClick: onCancel
  }, t2("carbon.table.batch.cancel"))));
};
TableBatchActions.translationKeys = TableBatchActionsTranslationKeys;
TableBatchActions.propTypes = {
  children: import_prop_types57.default.node,
  className: import_prop_types57.default.string,
  /**
   * Hook required to listen for when the user initiates a cancel request
   * through this component
   */
  onCancel: import_prop_types57.default.func.isRequired,
  /**
   * Hook to listen for when the user initiates a select all
   * request through this component. This _only_ controls the rendering
   * of the `Select All` button and does not include built in functionality
   */
  onSelectAll: import_prop_types57.default.func,
  /**
   * Boolean specifier for whether or not the batch action bar should be
   * displayed
   */
  shouldShowBatchActions: import_prop_types57.default.bool,
  /**
   * Numeric representation of the total number of items in a table.
   * This number is used in the select all button text
   */
  totalCount: import_prop_types57.default.number,
  /**
   * Numeric representation of the total number of items selected in a table.
   * This number is used to derive the selection message
   */
  totalSelected: import_prop_types57.default.number.isRequired,
  /**
   * Supply a method to translate internal strings with your i18n tool of
   * choice. Translation keys are available on the `translationKeys` field for
   * this component.
   */
  translateWithId: import_prop_types57.default.func
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/TableBody.js
var import_prop_types58 = __toESM(require_prop_types());
var import_react87 = __toESM(require_react());
var TableBody = (_ref) => {
  let {
    children,
    className,
    ...rest3
  } = _ref;
  return import_react87.default.createElement("tbody", _extends({
    "aria-live": "polite",
    className
  }, rest3), children);
};
TableBody.propTypes = {
  /**
   * `polite` Adjust the notification behavior of screen readers
   */
  "aria-live": import_prop_types58.default.oneOf(["polite", "assertive", "off"]),
  children: import_prop_types58.default.node,
  className: import_prop_types58.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/TableCell.js
var import_react88 = __toESM(require_react());
var import_classnames49 = __toESM(require_classnames());
var TableCell = import_react88.default.forwardRef((_ref, ref) => {
  let {
    children,
    className,
    hasAILabelHeader,
    colSpan,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const tableCellClassNames = (0, import_classnames49.default)(className, {
    [`${prefix}--table-cell--column-slug`]: hasAILabelHeader
  });
  return import_react88.default.createElement("td", _extends({
    className: tableCellClassNames ? tableCellClassNames : void 0,
    ref,
    colSpan
  }, rest3), children);
});
TableCell.displayName = "TableCell";

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/TableContainer.js
var import_classnames50 = __toESM(require_classnames());
var import_prop_types59 = __toESM(require_prop_types());
var import_react89 = __toESM(require_react());
var TableContainer = (_ref) => {
  let {
    className,
    children,
    title,
    description,
    stickyHeader,
    useStaticWidth,
    ...rest3
  } = _ref;
  const baseId = useId("tc");
  const titleId = `${baseId}-title`;
  const descriptionId = `${baseId}-description`;
  const prefix = usePrefix();
  const tableContainerClasses = (0, import_classnames50.default)(className, `${prefix}--data-table-container`, {
    [`${prefix}--data-table--max-width`]: stickyHeader,
    [`${prefix}--data-table-container--static`]: useStaticWidth
  });
  const value = (0, import_react89.useMemo)(() => {
    return {
      titleId: title ? titleId : void 0,
      descriptionId: description ? descriptionId : void 0
    };
  }, [title, description, titleId, descriptionId]);
  return import_react89.default.createElement(TableContext.Provider, {
    value
  }, import_react89.default.createElement("div", _extends({}, rest3, {
    className: tableContainerClasses
  }), title && import_react89.default.createElement("div", {
    className: `${prefix}--data-table-header`
  }, import_react89.default.createElement("h4", {
    className: `${prefix}--data-table-header__title`,
    id: titleId
  }, title), import_react89.default.createElement("p", {
    className: `${prefix}--data-table-header__description`,
    id: descriptionId
  }, description)), children));
};
TableContainer.propTypes = {
  children: import_prop_types59.default.node,
  className: import_prop_types59.default.string,
  /**
   * Optional description text for the Table
   */
  description: import_prop_types59.default.node,
  /**
   * Specify whether the table should have a sticky header
   */
  stickyHeader: import_prop_types59.default.bool,
  /**
   * Provide a title for the Table
   */
  title: import_prop_types59.default.node,
  /**
   * If true, will use a width of 'fit-content' to match the inner table width
   */
  useStaticWidth: import_prop_types59.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/TableDecoratorRow.js
var import_prop_types60 = __toESM(require_prop_types());
var import_react90 = __toESM(require_react());
var import_classnames51 = __toESM(require_classnames());
var TableDecoratorRow = (_ref) => {
  var _a;
  let {
    className,
    decorator
  } = _ref;
  const prefix = usePrefix();
  const TableDecoratorRowClasses = (0, import_classnames51.default)({
    ...className && {
      [className]: true
    },
    [`${prefix}--table-column-decorator`]: true,
    [`${prefix}--table-column-decorator--active`]: decorator
  });
  let normalizedDecorator = import_react90.default.isValidElement(decorator) ? decorator : null;
  if (normalizedDecorator && ((_a = normalizedDecorator["type"]) == null ? void 0 : _a.displayName) === "AILabel") {
    normalizedDecorator = import_react90.default.cloneElement(normalizedDecorator, {
      size: "mini"
    });
  }
  return import_react90.default.createElement("td", {
    className: TableDecoratorRowClasses
  }, normalizedDecorator);
};
TableDecoratorRow.displayName = "TableDecoratorRow";
TableDecoratorRow.propTypes = {
  /**
   * The CSS class names of the cell that wraps the underlying input control
   */
  className: import_prop_types60.default.string,
  /**
   * **Experimental**: Provide a `decorator` component to be rendered inside the `TableDecoratorRow` component
   */
  decorator: import_prop_types60.default.node
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/TableExpandHeader.js
var import_classnames52 = __toESM(require_classnames());
var import_prop_types61 = __toESM(require_prop_types());
var import_react91 = __toESM(require_react());
var TableExpandHeader = (_ref) => {
  let {
    ["aria-controls"]: ariaControls,
    ["aria-label"]: ariaLabel,
    ariaLabel: deprecatedAriaLabel,
    className: headerClassName,
    enableExpando,
    enableToggle,
    id = "expand",
    isExpanded,
    onExpand,
    expandIconDescription,
    children,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const className = (0, import_classnames52.default)(`${prefix}--table-expand`, headerClassName);
  const previousValue = isExpanded ? "collapsed" : void 0;
  return import_react91.default.createElement("th", _extends({
    scope: "col",
    className,
    "data-previous-value": previousValue,
    id
  }, rest3), enableExpando || enableToggle ? import_react91.default.createElement("button", {
    type: "button",
    className: `${prefix}--table-expand__button`,
    onClick: onExpand,
    title: expandIconDescription,
    "aria-label": deprecatedAriaLabel || ariaLabel,
    "aria-expanded": isExpanded,
    "aria-controls": ariaControls
  }, import_react91.default.createElement(ChevronRight, {
    className: `${prefix}--table-expand__svg`,
    "aria-label": expandIconDescription
  })) : null, children);
};
TableExpandHeader.propTypes = {
  /**
   * Space separated list of one or more ID values referencing the TableExpandedRow(s) being controlled by the TableExpandHeader
   */
  ["aria-controls"]: import_prop_types61.default.string,
  /**
   * Specify the string read by a voice reader when the expand trigger is
   * focused
   */
  ["aria-label"]: import_prop_types61.default.string,
  /**
   * Deprecated, please use `aria-label` instead.
   * Specify the string read by a voice reader when the expand trigger is
   * focused
   */
  ariaLabel: import_prop_types61.default.string,
  children: import_prop_types61.default.node,
  className: import_prop_types61.default.string,
  /**
   * The enableExpando prop is being replaced by TableExpandHeader
   */
  enableExpando: deprecate(import_prop_types61.default.bool, "The `enableExpando` prop has been deprecated in favor of `enableToggle`. This prop will be removed in the next major release."),
  /**
   * Specify whether an expand all button should be displayed
   */
  enableToggle: import_prop_types61.default.bool,
  /**
   * The description of the chevron right icon, to be put in its SVG `<title>` element.
   */
  expandIconDescription: import_prop_types61.default.string,
  /**
   * Supply an id to the th element.
   */
  id: import_prop_types61.default.string,
  /**
   * Specify whether this row is expanded or not. This helps coordinate data
   * attributes so that `TableExpandRow` and `TableExpandedRow` work together
   */
  isExpanded: requiredIfGivenPropIsTruthy("enableToggle", import_prop_types61.default.bool),
  /**
   * Hook for when a listener initiates a request to expand the given row
   */
  onExpand: import_prop_types61.default.oneOfType([requiredIfGivenPropIsTruthy("enableExpando", import_prop_types61.default.func), requiredIfGivenPropIsTruthy("enableToggle", import_prop_types61.default.func)])
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/TableExpandRow.js
var import_classnames53 = __toESM(require_classnames());
var import_prop_types62 = __toESM(require_prop_types());
var import_react92 = __toESM(require_react());
var TableExpandRow = import_react92.default.forwardRef((_ref, ref) => {
  let {
    ["aria-controls"]: ariaControls,
    ["aria-label"]: ariaLabel,
    ariaLabel: deprecatedAriaLabel,
    className: rowClassName,
    children,
    isExpanded,
    onExpand,
    expandIconDescription,
    isSelected,
    expandHeader = "expand",
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  let rowHasAILabel;
  const decorator = import_react92.default.Children.toArray(children).map((child) => {
    var _a, _b, _c;
    if (((_a = child.type) == null ? void 0 : _a.displayName) === "TableSlugRow" || ((_b = child.type) == null ? void 0 : _b.displayName) === "TableDecoratorRow") {
      if (child.props.slug || ((_c = child.props.decorator) == null ? void 0 : _c.type.displayName) === "AILabel") {
        rowHasAILabel = true;
      }
      return child;
    }
  });
  const normalizedChildren = import_react92.default.Children.toArray(children).map((child) => {
    var _a, _b;
    if (((_a = child.type) == null ? void 0 : _a.displayName) !== "TableSlugRow" && ((_b = child.type) == null ? void 0 : _b.displayName) !== "TableDecoratorRow") {
      return child;
    }
  });
  const className = (0, import_classnames53.default)({
    [`${prefix}--parent-row`]: true,
    [`${prefix}--expandable-row`]: isExpanded,
    [`${prefix}--data-table--selected`]: isSelected,
    [`${prefix}--data-table--slug-row ${prefix}--data-table--ai-label-row`]: rowHasAILabel
  }, rowClassName);
  const previousValue = isExpanded ? "collapsed" : void 0;
  return import_react92.default.createElement("tr", _extends({}, rest3, {
    ref,
    className,
    "data-parent-row": true
  }), decorator, import_react92.default.createElement(TableCell, {
    className: `${prefix}--table-expand`,
    "data-previous-value": previousValue,
    headers: expandHeader
  }, import_react92.default.createElement("button", {
    type: "button",
    className: `${prefix}--table-expand__button`,
    onClick: onExpand,
    title: expandIconDescription,
    "aria-label": deprecatedAriaLabel || ariaLabel,
    "aria-expanded": isExpanded,
    "aria-controls": ariaControls
  }, import_react92.default.createElement(ChevronRight, {
    className: `${prefix}--table-expand__svg`,
    "aria-label": expandIconDescription
  }))), normalizedChildren);
});
TableExpandRow.propTypes = {
  /**
   * Space separated list of one or more ID values referencing the TableExpandedRow(s) being controlled by the TableExpandRow
   * TODO: make this required in v12
   */
  ["aria-controls"]: import_prop_types62.default.string,
  /**
   * Specify the string read by a voice reader when the expand trigger is
   * focused
   */
  /**@ts-ignore*/
  ["aria-label"]: import_prop_types62.default.string,
  /**
   * Deprecated, please use `aria-label` instead.
   * Specify the string read by a voice reader when the expand trigger is
   * focused
   */
  ariaLabel: import_prop_types62.default.string,
  children: import_prop_types62.default.node,
  className: import_prop_types62.default.string,
  /**
   * The id of the matching th node in the table head. Addresses a11y concerns outlined here: https://www.ibm.com/able/guidelines/ci162/info_and_relationships.html and https://www.w3.org/TR/WCAG20-TECHS/H43
   */
  expandHeader: import_prop_types62.default.string,
  /**
   * The description of the chevron right icon, to be put in its SVG `<title>` element.
   */
  expandIconDescription: import_prop_types62.default.string,
  /**
   * Specify whether this row is expanded or not. This helps coordinate data
   * attributes so that `TableExpandRow` and `TableExpandedRow` work together
   */
  isExpanded: import_prop_types62.default.bool,
  /**
   * Specify if the row is selected
   */
  isSelected: import_prop_types62.default.bool,
  /**
   * Hook for when a listener initiates a request to expand the given row
   */
  onExpand: import_prop_types62.default.func.isRequired
};
TableExpandRow.displayName = "TableExpandRow";

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/TableExpandedRow.js
var import_classnames54 = __toESM(require_classnames());
var import_prop_types63 = __toESM(require_prop_types());
var import_react93 = __toESM(require_react());
var TableExpandedRow = (_ref) => {
  let {
    className: customClassName,
    children,
    colSpan,
    ...rest3
  } = _ref;
  const rowRef = (0, import_react93.useRef)(null);
  const prefix = usePrefix();
  const className = (0, import_classnames54.default)(`${prefix}--expandable-row`, customClassName);
  const toggleParentHoverClass = (eventType) => {
    if (rowRef && rowRef.current && rowRef.current.previousElementSibling) {
      const parentNode = rowRef.current.previousElementSibling;
      if (eventType === "enter") {
        parentNode.classList.add(`${prefix}--expandable-row--hover`);
      } else {
        parentNode.classList.remove(`${prefix}--expandable-row--hover`);
      }
    }
  };
  return import_react93.default.createElement("tr", _extends({
    ref: rowRef,
    onMouseEnter: () => toggleParentHoverClass("enter"),
    onMouseLeave: () => toggleParentHoverClass("leave")
  }, rest3, {
    className,
    "data-child-row": true
  }), import_react93.default.createElement(TableCell, {
    colSpan
  }, import_react93.default.createElement("div", {
    className: `${prefix}--child-row-inner-container`
  }, children)));
};
TableExpandedRow.propTypes = {
  /**
   * Pass in the contents for your TableExpandedRow
   */
  children: import_prop_types63.default.node,
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types63.default.string,
  /**
   * The width of the expanded row's internal cell
   */
  colSpan: import_prop_types63.default.number.isRequired
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/TableHead.js
var TableHead = wrapComponent({
  name: "TableHead",
  type: "thead"
});

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/TableHeader.js
var import_classnames55 = __toESM(require_classnames());
var import_prop_types64 = __toESM(require_prop_types());
var import_react94 = __toESM(require_react());
var defaultScope = "col";
var translationKeys2 = {
  buttonDescription: "carbon.table.header.icon.description"
};
var translateWithId2 = (key, args) => {
  if (args && key === translationKeys2.buttonDescription) {
    if (args.isSortHeader && sortStates) {
      if (args.sortDirection === sortStates.NONE) {
        return `Click to sort rows by ${args.header} header in ascending order`;
      }
      if (args.sortDirection === sortStates.ASC) {
        return `Click to sort rows by ${args.header} header in descending order`;
      }
      return `Click to unsort rows by ${args.header} header`;
    }
    return `Click to sort rows by ${args.header} header in ascending order`;
  }
  return "";
};
var sortDirections = {
  [sortStates.NONE]: "none",
  [sortStates.ASC]: "ascending",
  [sortStates.DESC]: "descending"
};
var TableHeader = import_react94.default.forwardRef(function TableHeader2(_ref, ref) {
  var _a;
  let {
    className: headerClassName,
    children,
    colSpan,
    decorator,
    isSortable = false,
    isSortHeader,
    onClick,
    scope = defaultScope,
    sortDirection,
    translateWithId: t2 = translateWithId2,
    slug,
    id,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const uniqueId3 = useId("table-sort");
  const AILableRef = (0, import_react94.useRef)(null);
  let colHasAILabel;
  let normalizedDecorator = import_react94.default.isValidElement(slug ?? decorator) ? slug ?? decorator : null;
  if (normalizedDecorator && ((_a = normalizedDecorator["type"]) == null ? void 0 : _a.displayName) === "AILabel") {
    colHasAILabel = true;
    normalizedDecorator = import_react94.default.cloneElement(normalizedDecorator, {
      size: "mini",
      ref: AILableRef
    });
  }
  const headerLabelClassNames = (0, import_classnames55.default)({
    [`${prefix}--table-header-label`]: true,
    [`${prefix}--table-header-label--slug ${prefix}--table-header-label--ai-label`]: colHasAILabel,
    [`${prefix}--table-header-label--decorator`]: decorator
  });
  if (!isSortable) {
    return import_react94.default.createElement("th", _extends({}, rest3, {
      id,
      className: headerClassName,
      scope,
      colSpan,
      ref
    }), children ? import_react94.default.createElement("div", {
      className: headerLabelClassNames
    }, children, import_react94.default.createElement("div", {
      className: `${prefix}--table-header-label--decorator-inner`
    }, normalizedDecorator)) : null);
  }
  const className = (0, import_classnames55.default)(headerClassName, {
    [`${prefix}--table-sort`]: true,
    [`${prefix}--table-sort--active`]: isSortHeader && sortDirection !== sortStates.NONE,
    [`${prefix}--table-sort--descending`]: isSortHeader && sortDirection === sortStates.DESC
  });
  const ariaSort = !isSortHeader || !sortDirection ? "none" : sortDirections[sortDirection];
  const sortDescription = t2 && t2("carbon.table.header.icon.description", {
    header: children,
    sortDirection,
    isSortHeader,
    sortStates
  });
  const headerClasses = (0, import_classnames55.default)(headerClassName, `${prefix}--table-sort__header`, {
    [`${prefix}--table-sort__header--ai-label`]: colHasAILabel,
    [`${prefix}--table-sort__header--decorator`]: decorator
  });
  const handleClick2 = (evt) => {
    if (colHasAILabel && AILableRef.current && AILableRef.current.contains(evt.target)) {
      return;
    } else if (onClick) {
      return onClick(evt);
    }
  };
  return import_react94.default.createElement("th", {
    id,
    "aria-sort": ariaSort,
    className: headerClasses,
    colSpan,
    ref,
    scope
  }, import_react94.default.createElement("div", {
    className: `${prefix}--table-sort__description`,
    id: uniqueId3
  }, sortDescription), import_react94.default.createElement("button", _extends({
    type: "button",
    "aria-describedby": uniqueId3,
    className,
    onClick: handleClick2
  }, rest3), import_react94.default.createElement("span", {
    className: `${prefix}--table-sort__flex`
  }, import_react94.default.createElement("div", {
    className: `${prefix}--table-header-label`
  }, children), import_react94.default.createElement(ArrowUp, {
    size: 20,
    className: `${prefix}--table-sort__icon`
  }), import_react94.default.createElement(ArrowsVertical, {
    size: 20,
    className: `${prefix}--table-sort__icon-unsorted`
  }), import_react94.default.createElement("div", {
    className: `${prefix}--table-header-label--decorator-inner`
  }, normalizedDecorator))));
});
TableHeader.propTypes = {
  /**
   * Pass in children that will be embedded in the table header label
   */
  children: import_prop_types64.default.node,
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types64.default.string,
  /**
   * Specify `colSpan` as a non-negative integer value to indicate how
   * many columns the TableHeader cell extends in a table
   */
  colSpan: import_prop_types64.default.number,
  /**
   * Supply an id to the th element.
   */
  id: import_prop_types64.default.string,
  /**
   * Specify whether this header is the header by which a table is being sorted
   * by
   */
  isSortHeader: import_prop_types64.default.bool,
  /**
   * Specify whether this header is one through which a user can sort the table
   */
  isSortable: import_prop_types64.default.bool,
  /**
   * Hook that is invoked when the header is clicked
   */
  onClick: import_prop_types64.default.func,
  /**
   * Specify the scope of this table header. You can find more info about this
   * attribute at the following URL:
   * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/th#attr-scope
   */
  scope: import_prop_types64.default.string,
  /**
   * Specify which direction we are currently sorting by, should be one of DESC,
   * NONE, or ASC.
   */
  sortDirection: import_prop_types64.default.oneOf(Object.values(sortStates)),
  /**
   * Supply a method to translate internal strings with your i18n tool of
   * choice. Translation keys are available on the `translationKeys` field for
   * this component.
   */
  translateWithId: import_prop_types64.default.func
};
TableHeader.translationKeys = Object.values(translationKeys2);
TableHeader.displayName = "TableHeader";

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/TableRow.js
var import_react95 = __toESM(require_react());
var import_prop_types65 = __toESM(require_prop_types());
var import_classnames56 = __toESM(require_classnames());
var TableRow = (props) => {
  const prefix = usePrefix();
  let rowHasAILabel;
  if (props == null ? void 0 : props.children) {
    import_react95.default.Children.toArray(props.children).map((child) => {
      var _a, _b, _c;
      if (((_a = child.type) == null ? void 0 : _a.displayName) === "TableSlugRow" || ((_b = child.type) == null ? void 0 : _b.displayName) === "TableDecoratorRow") {
        if (child.props.slug || ((_c = child.props.decorator) == null ? void 0 : _c.type.displayName) === "AILabel") {
          rowHasAILabel = true;
        }
      }
    });
  }
  const className = (0, import_classnames56.default)(props.className, {
    [`${prefix}--data-table--selected`]: props.isSelected,
    [`${prefix}--data-table--slug-row ${prefix}--data-table--ai-label-row`]: rowHasAILabel
  });
  const {
    ariaLabel,
    "aria-label": ariaLabelAlt,
    "aria-controls": ariaControls,
    onExpand,
    isExpanded,
    isSelected,
    ...cleanProps
  } = props;
  if (className) {
    cleanProps.className = className;
  }
  return import_react95.default.createElement("tr", cleanProps);
};
TableRow.propTypes = {
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types65.default.string,
  /**
   * Specify if the row is selected
   */
  isSelected: import_prop_types65.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/TableSelectAll.js
var import_prop_types67 = __toESM(require_prop_types());
var import_react97 = __toESM(require_react());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/InlineCheckbox/InlineCheckbox.js
var import_prop_types66 = __toESM(require_prop_types());
var import_react96 = __toESM(require_react());
var InlineCheckbox = import_react96.default.forwardRef(function InlineCheckbox2(props, forwardRef13) {
  const {
    ["aria-label"]: ariaLabel,
    ariaLabel: deprecatedAriaLabel,
    checked = false,
    disabled,
    id,
    indeterminate,
    name,
    onChange = () => {
    },
    onClick,
    onKeyDown,
    title
  } = props;
  const prefix = usePrefix();
  const inputRef = (0, import_react96.useRef)(null);
  const ref = useMergedRefs([inputRef, forwardRef13]);
  const inputProps = {
    checked,
    className: `${prefix}--checkbox`,
    disabled,
    id,
    name,
    onClick: onClick ? onClickCheckBoxInput : onClick,
    onChange: (evt) => {
      onChange(evt.target.checked, id, evt);
    },
    onKeyDown,
    ref,
    type: "checkbox"
  };
  if (indeterminate) {
    inputProps.checked = false;
  }
  (0, import_react96.useEffect)(() => {
    if (inputRef == null ? void 0 : inputRef.current) {
      inputRef.current.indeterminate = indeterminate || false;
    }
  }, [indeterminate]);
  function onClickCheckBoxInput(evt) {
    if (indeterminate) {
      evt.target.checked = false;
    }
    onClick == null ? void 0 : onClick(evt);
  }
  return import_react96.default.createElement(
    "div",
    {
      className: `${prefix}--checkbox--inline`
    },
    import_react96.default.createElement("input", inputProps),
    /* eslint-disable jsx-a11y/label-has-for,jsx-a11y/label-has-associated-control,jsx-a11y/click-events-have-key-events,jsx-a11y/no-noninteractive-element-interactions */
    import_react96.default.createElement("label", {
      htmlFor: id,
      className: `${prefix}--checkbox-label`,
      title,
      onClick: (evt) => {
        evt.stopPropagation();
      }
    }, import_react96.default.createElement("span", {
      className: `${prefix}--visually-hidden`
    }, deprecatedAriaLabel || ariaLabel))
  );
});
InlineCheckbox.propTypes = {
  /**
   * Specify the label for the control
   */
  ["aria-label"]: import_prop_types66.default.string.isRequired,
  /**
   * Deprecated, please use `aria-label` instead.
   * Specify the label for the control
   */
  ariaLabel: deprecate(import_prop_types66.default.string.isRequired, "The `ariaLabel` prop has been deprecated in favor of `aria-label`. This prop will be removed in the next major release."),
  /**
   * Specify whether the underlying control is checked, or not
   */
  checked: import_prop_types66.default.bool,
  /**
   * Specify whether the underlying input control should be disabled
   */
  disabled: import_prop_types66.default.bool,
  /**
   * Provide an `id` for the underlying input control
   */
  id: import_prop_types66.default.string.isRequired,
  /**
   * Specify whether the control is in an indterminate state
   */
  indeterminate: import_prop_types66.default.bool,
  /**
   * Provide a `name` for the underlying input control
   */
  name: import_prop_types66.default.string.isRequired,
  /**
   * Provide an optional hook that is called each time the input is updated
   */
  onChange: import_prop_types66.default.func,
  /**
   * Provide a handler that is invoked when a user clicks on the control
   */
  onClick: import_prop_types66.default.func,
  /**
   * Provide a handler that is invoked on the key down event for the control
   */
  onKeyDown: import_prop_types66.default.func,
  /**
   * Provide an optional tooltip for the InlineCheckbox
   */
  title: import_prop_types66.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/TableSelectAll.js
var import_classnames57 = __toESM(require_classnames());
var TableSelectAll = (_ref) => {
  let {
    ariaLabel: deprecatedAriaLabel = "Select all rows in the table",
    ["aria-label"]: ariaLabel,
    checked,
    id,
    indeterminate,
    name,
    onSelect,
    disabled,
    className
  } = _ref;
  const prefix = usePrefix();
  return import_react97.default.createElement("th", {
    "aria-live": "off",
    scope: "col",
    className: (0, import_classnames57.default)(`${prefix}--table-column-checkbox`, className)
  }, import_react97.default.createElement(InlineCheckbox, {
    "aria-label": ariaLabel || deprecatedAriaLabel,
    checked,
    id,
    indeterminate,
    name,
    onClick: onSelect,
    disabled
  }));
};
TableSelectAll.propTypes = {
  /**
   * Specify the aria label for the underlying input control
   */
  ["aria-label"]: import_prop_types67.default.string,
  /**
   * Deprecated, please use `aria-label` instead.
   * Specify the aria label for the underlying input control
   */
  ariaLabel: deprecate(import_prop_types67.default.string, "This prop syntax has been deprecated. Please use the new `aria-label`."),
  /**
   * Specify whether all items are selected, or not
   */
  checked: import_prop_types67.default.bool,
  /**
   * The CSS class names of the cell that wraps the underlying input control
   */
  className: import_prop_types67.default.string,
  /**
   * Specify whether the checkbox input should be disabled
   */
  disabled: import_prop_types67.default.bool,
  /**
   * Provide an `id` for the underlying input control
   */
  id: import_prop_types67.default.string.isRequired,
  /**
   * Specify whether the selection only has a subset of all items
   */
  indeterminate: import_prop_types67.default.bool,
  /**
   * Provide a `name` for the underlying input control
   */
  name: import_prop_types67.default.string.isRequired,
  /**
   * Provide a handler to listen to when a user initiates a selection request
   */
  onSelect: import_prop_types67.default.func.isRequired
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/TableSelectRow.js
var import_prop_types69 = __toESM(require_prop_types());
var import_react99 = __toESM(require_react());
var import_classnames59 = __toESM(require_classnames());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/RadioButton/RadioButton.js
var import_prop_types68 = __toESM(require_prop_types());
var import_react98 = __toESM(require_react());
var import_classnames58 = __toESM(require_classnames());
var RadioButton2 = import_react98.default.forwardRef((props, ref) => {
  var _a, _b;
  const {
    className,
    decorator,
    disabled,
    hideLabel,
    id,
    labelPosition = "right",
    labelText = "",
    name,
    onChange = () => {
    },
    value = "",
    slug,
    required,
    ...rest3
  } = props;
  const prefix = usePrefix();
  const uid = useId("radio-button");
  const uniqueId3 = id || uid;
  function handleOnChange(event) {
    onChange(value, name, event);
  }
  const innerLabelClasses = (0, import_classnames58.default)(`${prefix}--radio-button__label-text`, {
    [`${prefix}--visually-hidden`]: hideLabel
  });
  const wrapperClasses = (0, import_classnames58.default)(className, `${prefix}--radio-button-wrapper`, {
    [`${prefix}--radio-button-wrapper--label-${labelPosition}`]: labelPosition !== "right",
    [`${prefix}--radio-button-wrapper--slug`]: slug,
    [`${prefix}--radio-button-wrapper--decorator`]: decorator
  });
  const inputRef = (0, import_react98.useRef)(null);
  let normalizedDecorator = import_react98.default.isValidElement(slug ?? decorator) ? slug ?? decorator : null;
  if (normalizedDecorator && ((_a = normalizedDecorator["type"]) == null ? void 0 : _a.displayName) === "AILabel") {
    const size6 = ((_b = normalizedDecorator.props) == null ? void 0 : _b["kind"]) === "inline" ? "md" : "mini";
    normalizedDecorator = import_react98.default.cloneElement(normalizedDecorator, {
      size: size6
    });
  }
  return import_react98.default.createElement("div", {
    className: wrapperClasses
  }, import_react98.default.createElement("input", _extends({}, rest3, {
    type: "radio",
    className: `${prefix}--radio-button`,
    onChange: handleOnChange,
    id: uniqueId3,
    ref: mergeRefs$1(inputRef, ref),
    disabled,
    value,
    name,
    required
  })), import_react98.default.createElement("label", {
    htmlFor: uniqueId3,
    className: `${prefix}--radio-button__label`
  }, import_react98.default.createElement("span", {
    className: `${prefix}--radio-button__appearance`
  }), labelText && import_react98.default.createElement(Text, {
    className: innerLabelClasses
  }, labelText, slug ? normalizedDecorator : decorator ? import_react98.default.createElement("div", {
    className: `${prefix}--radio-button-wrapper-inner--decorator`
  }, normalizedDecorator) : "")));
});
RadioButton2.displayName = "RadioButton";
RadioButton2.propTypes = {
  /**
   * Specify whether the `<RadioButton>` is currently checked
   */
  checked: import_prop_types68.default.bool,
  /**
   * Provide an optional className to be applied to the containing node
   */
  className: import_prop_types68.default.string,
  /**
   * **Experimental**: Provide a decorator component to be rendered inside the `RadioButton` component
   */
  decorator: import_prop_types68.default.node,
  /**
   * Specify whether the `<RadioButton>` should be checked by default
   */
  defaultChecked: import_prop_types68.default.bool,
  /**
   * Specify whether the control is disabled
   */
  disabled: import_prop_types68.default.bool,
  /**
   * Specify whether the label should be hidden, or not
   */
  hideLabel: import_prop_types68.default.bool,
  /**
   * Provide a unique id for the underlying `<input>` node
   */
  id: import_prop_types68.default.string,
  /**
   * Provide where label text should be placed
   * NOTE: `top`/`bottom` are deprecated
   */
  labelPosition: import_prop_types68.default.oneOf(["right", "left"]),
  /**
   * Provide label text to be read by screen readers when interacting with the
   * control
   */
  labelText: import_prop_types68.default.node.isRequired,
  /**
   * Provide a name for the underlying `<input>` node
   */
  name: import_prop_types68.default.string,
  /**
   * Provide an optional `onChange` hook that is called each time the value of
   * the underlying `<input>` changes
   */
  onChange: import_prop_types68.default.func,
  /**
   * Provide a handler that is invoked when a user clicks on the control
   */
  onClick: import_prop_types68.default.func,
  /**
   * `true` to specify if the control is required.
   */
  required: import_prop_types68.default.bool,
  /**
   * **Experimental**: Provide a `Slug` component to be rendered inside the `RadioButton` component
   */
  slug: deprecate(import_prop_types68.default.node, "The `slug` prop has been deprecated and will be removed in the next major version. Use the decorator prop instead."),
  /**
   * Specify the value of the `<RadioButton>`
   */
  value: import_prop_types68.default.oneOfType([import_prop_types68.default.string, import_prop_types68.default.number])
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/TableSelectRow.js
var TableSelectRow = (_ref) => {
  let {
    ariaLabel: deprecatedAriaLabel,
    ["aria-label"]: ariaLabel,
    checked,
    id,
    name,
    onSelect,
    onChange,
    disabled,
    radio,
    className
  } = _ref;
  const prefix = usePrefix();
  const uniqueNameId = useId();
  const handleRadioChange = onChange ? (value, name2, event) => {
    onChange(!!value, name2 || "", event);
  } : void 0;
  const handleCheckboxChange = onChange ? (checked2, name2, event) => {
    onChange(checked2, name2, event);
  } : void 0;
  const selectionInputProps = {
    id,
    name: name ? name : uniqueNameId,
    onClick: onSelect,
    checked,
    disabled
  };
  const labelValue = ariaLabel || deprecatedAriaLabel || "";
  const tableSelectRowClasses = (0, import_classnames59.default)(`${prefix}--table-column-checkbox`, {
    ...className && {
      [className]: true
    },
    [`${prefix}--table-column-radio`]: radio
  });
  return import_react99.default.createElement("td", {
    className: tableSelectRowClasses,
    "aria-live": "off"
  }, radio ? import_react99.default.createElement(RadioButton2, _extends({}, selectionInputProps, {
    labelText: labelValue,
    onChange: handleRadioChange,
    hideLabel: true
  })) : import_react99.default.createElement(InlineCheckbox, _extends({}, selectionInputProps, {
    "aria-label": labelValue,
    onChange: handleCheckboxChange
  })));
};
TableSelectRow.propTypes = {
  /**
   * Specify the aria label for the underlying input control
   */
  ["aria-label"]: import_prop_types69.default.string,
  /**
   * Deprecated, please use `aria-label` instead.
   * Specify the aria label for the underlying input control
   */
  ariaLabel: deprecate(import_prop_types69.default.string, "This prop syntax has been deprecated. Please use the new `aria-label`."),
  /**
   * Specify whether this row is selected, or not
   */
  checked: import_prop_types69.default.bool,
  /**
   * The CSS class names of the cell that wraps the underlying input control
   */
  className: import_prop_types69.default.string,
  /**
   * Specify whether the control is disabled
   */
  disabled: import_prop_types69.default.bool,
  /**
   * Provide an `id` for the underlying input control
   */
  id: import_prop_types69.default.string.isRequired,
  /**
   * Provide a `name` for the underlying input control
   */
  name: import_prop_types69.default.string.isRequired,
  /**
   * Provide an optional hook that is called each time the input is updated
   */
  onChange: import_prop_types69.default.func,
  /**
   * Provide a handler to listen to when a user initiates a selection request
   */
  onSelect: import_prop_types69.default.func.isRequired,
  /**
   * Specify whether the control should be a radio button or inline checkbox
   */
  radio: import_prop_types69.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/TableSlugRow.js
var import_prop_types70 = __toESM(require_prop_types());
var import_react100 = __toESM(require_react());
var import_classnames60 = __toESM(require_classnames());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/prop-types/deprecateComponent.js
var didWarnAboutDeprecation4 = {};
function deprecateComponent(componentName, message) {
  if (!componentName) {
    return;
  }
  if (!didWarnAboutDeprecation4[componentName]) {
    didWarnAboutDeprecation4[componentName] = true;
    true ? warning(false, message || `The ${componentName} component has been deprecated and will be removed in the next major release.`) : void 0;
  }
  return componentName;
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/TableSlugRow.js
var TableSlugRow = (_ref) => {
  let {
    className,
    slug
  } = _ref;
  (0, import_react100.useEffect)(() => {
    deprecateComponent("TableSlugRow", "The `TableSlugRow` component has been deprecated and will be removed in the next major version. Use the TableDecoratorRow component instead.");
  }, []);
  const prefix = usePrefix();
  const TableSlugRowClasses = (0, import_classnames60.default)({
    ...className && {
      [className]: true
    },
    [`${prefix}--table-column-slug`]: true,
    [`${prefix}--table-column-slug--active`]: slug
  });
  let normalizedSlug;
  if (slug) {
    normalizedSlug = import_react100.default.cloneElement(slug, {
      size: "mini"
    });
  }
  return import_react100.default.createElement("td", {
    className: TableSlugRowClasses
  }, normalizedSlug);
};
TableSlugRow.displayName = "TableSlugRow";
TableSlugRow.propTypes = {
  /**
   * The CSS class names of the cell that wraps the underlying input control
   */
  className: import_prop_types70.default.string,
  /**
   * Provide a `Slug` component to be rendered inside the `TableSlugRow` component
   */
  slug: import_prop_types70.default.node
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/TableToolbar.js
var import_classnames61 = __toESM(require_classnames());
var import_prop_types71 = __toESM(require_prop_types());
var import_react101 = __toESM(require_react());
var TableToolbar = (_ref) => {
  let {
    ["aria-label"]: ariaLabel = "data table toolbar",
    ariaLabel: deprecatedAriaLabel,
    children,
    size: size6,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const className = (0, import_classnames61.default)({
    [`${prefix}--table-toolbar`]: true,
    [`${prefix}--table-toolbar--${size6}`]: size6
  });
  return import_react101.default.createElement("section", _extends({
    "aria-label": deprecatedAriaLabel || ariaLabel
  }, rest3, {
    className
  }), children);
};
TableToolbar.propTypes = {
  /**
   * 'aria-label' of the TableToolbar component.
   * Specify a label to be read by screen readers on the container node
   */
  ["aria-label"]: import_prop_types71.default.string,
  /**
   * Deprecated, please use `aria-label` instead.
   * Specify a label to be read by screen readers on the container node.
   * 'aria-label' of the TableToolbar component.
   */
  ariaLabel: deprecate(import_prop_types71.default.string, "This prop syntax has been deprecated. Please use the new `aria-label`."),
  /**
   * Pass in the children that will be rendered inside the TableToolbar
   */
  children: import_prop_types71.default.node,
  /**
   * `lg` Change the row height of table
   */
  size: import_prop_types71.default.oneOf(["sm", "lg"])
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/TableToolbarAction.js
var import_prop_types73 = __toESM(require_prop_types());
var import_react103 = __toESM(require_react());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/OverflowMenuItem/OverflowMenuItem.js
var import_classnames62 = __toESM(require_classnames());
var import_prop_types72 = __toESM(require_prop_types());
var import_react102 = __toESM(require_react());
var OverflowMenuItem = import_react102.default.forwardRef(function OverflowMenuItem2(_ref, ref) {
  let {
    className,
    closeMenu,
    disabled = false,
    handleOverflowMenuItemFocus,
    hasDivider = false,
    href,
    isDelete = false,
    index: index4,
    itemText = "Provide itemText",
    onClick = () => {
    },
    onKeyDown = () => {
    },
    requireTitle,
    title,
    wrapperClassName,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  function setTabFocus(evt) {
    if (match(evt, ArrowDown)) {
      handleOverflowMenuItemFocus == null ? void 0 : handleOverflowMenuItemFocus({
        currentIndex: index4,
        direction: 1
      });
    }
    if (match(evt, ArrowUp2)) {
      handleOverflowMenuItemFocus == null ? void 0 : handleOverflowMenuItemFocus({
        currentIndex: index4,
        direction: -1
      });
    }
  }
  function handleClick2(evt) {
    onClick(evt);
    if (closeMenu) {
      closeMenu();
    }
  }
  if (true) {
    true ? warning(closeMenu, "`<OverflowMenuItem>` detected missing `closeMenu` prop. `closeMenu` is required to let `<OverflowMenu>` close the menu upon actions on `<OverflowMenuItem>`. Please make sure `<OverflowMenuItem>` is a direct child of `<OverflowMenu>.") : void 0;
  }
  const overflowMenuBtnClasses = (0, import_classnames62.default)(`${prefix}--overflow-menu-options__btn`, className);
  const overflowMenuItemClasses = (0, import_classnames62.default)(`${prefix}--overflow-menu-options__option`, {
    [`${prefix}--overflow-menu--divider`]: hasDivider,
    [`${prefix}--overflow-menu-options__option--danger`]: isDelete,
    [`${prefix}--overflow-menu-options__option--disabled`]: disabled
  }, wrapperClassName);
  const TagToUse = href ? "a" : "button";
  const OverflowMenuItemContent = (() => {
    if (typeof itemText !== "string") {
      return itemText;
    }
    return import_react102.default.createElement("div", {
      className: `${prefix}--overflow-menu-options__option-content`
    }, itemText);
  })();
  return import_react102.default.createElement(Text, {
    as: "li",
    className: overflowMenuItemClasses,
    role: "none"
  }, import_react102.default.createElement(TagToUse, _extends({
    className: overflowMenuBtnClasses,
    disabled,
    href,
    onClick: handleClick2,
    onKeyDown: (evt) => {
      setTabFocus(evt);
      onKeyDown(evt);
    },
    role: "menuitem",
    ref,
    tabIndex: -1,
    title: requireTitle ? title || itemText : void 0
  }, rest3), OverflowMenuItemContent));
});
OverflowMenuItem.propTypes = {
  /**
   * The CSS class name to be placed on the button element
   */
  className: import_prop_types72.default.string,
  /**
   * A callback to tell the parent menu component that the menu should be closed.
   */
  closeMenu: import_prop_types72.default.func,
  /**
   * `true` to make this menu item disabled.
   */
  disabled: import_prop_types72.default.bool,
  handleOverflowMenuItemFocus: import_prop_types72.default.func,
  /**
   * `true` to make this menu item a divider.
   */
  hasDivider: import_prop_types72.default.bool,
  /**
   * If given, overflow item will render as a link with the given href
   */
  href: import_prop_types72.default.string,
  index: import_prop_types72.default.number,
  /**
   * `true` to make this menu item a "danger button".
   */
  isDelete: import_prop_types72.default.bool,
  /**
   * The text in the menu item.
   */
  itemText: import_prop_types72.default.node.isRequired,
  /**
   * event handlers
   */
  onBlur: import_prop_types72.default.func,
  onClick: import_prop_types72.default.func,
  onFocus: import_prop_types72.default.func,
  onKeyDown: import_prop_types72.default.func,
  onKeyUp: import_prop_types72.default.func,
  onMouseDown: import_prop_types72.default.func,
  onMouseEnter: import_prop_types72.default.func,
  onMouseLeave: import_prop_types72.default.func,
  onMouseUp: import_prop_types72.default.func,
  /**
   * `true` if this menu item has long text and requires a browser tooltip
   */
  requireTitle: import_prop_types72.default.bool,
  /**
   * Specify a title for the OverflowMenuItem
   */
  title: import_prop_types72.default.string,
  /**
   * The CSS class name to be placed on the wrapper list item element
   */
  wrapperClassName: import_prop_types72.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/TableToolbarAction.js
var TableToolbarAction = import_react103.default.forwardRef((_ref, ref) => {
  let {
    children,
    ...rest3
  } = _ref;
  return import_react103.default.createElement(OverflowMenuItem, _extends({
    ref,
    itemText: children
  }, rest3));
});
TableToolbarAction.displayName = "TableToolbarAction";
TableToolbarAction.propTypes = {
  children: import_prop_types73.default.node,
  className: import_prop_types73.default.string,
  onClick: import_prop_types73.default.func.isRequired
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/TableToolbarContent.js
var TableToolbarContent = wrapComponent({
  name: "TableToolbarContent",
  type: "div",
  className: (prefix) => `${prefix}--toolbar-content`
});

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/TableToolbarSearch.js
var import_classnames65 = __toESM(require_classnames());
var import_prop_types76 = __toESM(require_prop_types());
var import_react106 = __toESM(require_react());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Search/Search.js
var import_classnames63 = __toESM(require_classnames());
var import_prop_types74 = __toESM(require_prop_types());
var import_react104 = __toESM(require_react());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/internal/focus/index.js
function focus(elementOrRef) {
  const element = elementOrRef.current || elementOrRef;
  if (element && element.focus && document.activeElement !== element) {
    element.focus();
  }
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Search/Search.js
var _Close4;
var Search2 = import_react104.default.forwardRef(function Search3(_ref, forwardRef13) {
  let {
    autoComplete = "off",
    className,
    closeButtonLabelText = "Clear search input",
    defaultValue,
    disabled,
    isExpanded = true,
    id,
    labelText,
    // @ts-expect-error: deprecated prop
    light,
    onChange = () => {
    },
    onClear = () => {
    },
    onKeyDown,
    onExpand,
    placeholder = "Search",
    renderIcon,
    role = "searchbox",
    size: size6 = "md",
    type = "text",
    value,
    ...rest3
  } = _ref;
  const hasPropValue = value || defaultValue ? true : false;
  const prefix = usePrefix();
  const {
    isFluid
  } = (0, import_react104.useContext)(FormContext);
  const inputRef = (0, import_react104.useRef)(null);
  const ref = useMergedRefs([forwardRef13, inputRef]);
  const expandButtonRef = (0, import_react104.useRef)(null);
  const inputId = useId("search-input");
  const uniqueId3 = id || inputId;
  const searchId = `${uniqueId3}-search`;
  const [hasContent, setHasContent] = (0, import_react104.useState)(hasPropValue || false);
  const [prevValue, setPrevValue] = (0, import_react104.useState)(value);
  const searchClasses = (0, import_classnames63.default)({
    [`${prefix}--search`]: true,
    [`${prefix}--search--sm`]: size6 === "sm",
    [`${prefix}--search--md`]: size6 === "md",
    [`${prefix}--search--lg`]: size6 === "lg",
    [`${prefix}--search--light`]: light,
    [`${prefix}--search--disabled`]: disabled,
    [`${prefix}--search--fluid`]: isFluid
  }, className);
  const clearClasses = (0, import_classnames63.default)({
    [`${prefix}--search-close`]: true,
    [`${prefix}--search-close--hidden`]: !hasContent || !isExpanded
  });
  if (value !== prevValue) {
    setHasContent(!!value);
    setPrevValue(value);
  }
  function clearInput() {
    if (!value && inputRef.current) {
      inputRef.current.value = "";
    }
    const inputTarget = Object.assign({}, inputRef.current, {
      value: ""
    });
    const clearedEvt = {
      target: inputTarget,
      type: "change"
    };
    onChange(clearedEvt);
    onClear();
    setHasContent(false);
    focus(inputRef);
  }
  function handleChange(event) {
    setHasContent(event.target.value !== "");
  }
  function handleKeyDown(event) {
    var _a, _b;
    if (match(event, Escape)) {
      event.stopPropagation();
      if ((_a = inputRef.current) == null ? void 0 : _a.value) {
        clearInput();
      } else if (onExpand && isExpanded) {
        (_b = expandButtonRef.current) == null ? void 0 : _b.focus();
      }
    }
  }
  function handleExpandButtonKeyDown(event) {
    if (match(event, Enter) || match(event, Space)) {
      event.stopPropagation();
      if (onExpand) {
        onExpand(event);
      }
    }
  }
  return import_react104.default.createElement("div", {
    role: "search",
    "aria-label": placeholder,
    className: searchClasses
  }, import_react104.default.createElement("div", {
    "aria-label": onExpand ? "button" : void 0,
    "aria-labelledby": onExpand ? searchId : void 0,
    role: onExpand ? "button" : void 0,
    className: `${prefix}--search-magnifier`,
    onClick: onExpand,
    onKeyDown: handleExpandButtonKeyDown,
    tabIndex: onExpand && !isExpanded ? 0 : -1,
    ref: expandButtonRef,
    "aria-expanded": onExpand && isExpanded ? true : onExpand && !isExpanded ? false : void 0,
    "aria-controls": onExpand ? uniqueId3 : void 0
  }, import_react104.default.createElement(CustomSearchIcon, {
    icon: renderIcon
  })), import_react104.default.createElement("label", {
    id: searchId,
    htmlFor: uniqueId3,
    className: `${prefix}--label`
  }, labelText), import_react104.default.createElement("input", _extends({
    autoComplete,
    className: `${prefix}--search-input`,
    defaultValue,
    disabled,
    role,
    ref,
    id: uniqueId3,
    onChange: composeEventHandlers([onChange, handleChange]),
    onKeyDown: composeEventHandlers([onKeyDown, handleKeyDown]),
    placeholder,
    type,
    value,
    tabIndex: onExpand && !isExpanded ? -1 : void 0
  }, rest3)), import_react104.default.createElement("button", {
    "aria-label": closeButtonLabelText,
    className: clearClasses,
    disabled,
    onClick: clearInput,
    title: closeButtonLabelText,
    type: "button"
  }, _Close4 || (_Close4 = import_react104.default.createElement(Close, null))));
});
Search2.displayName = "Search";
Search2.propTypes = {
  /**
   * Specify an optional value for the `autocomplete` property on the underlying
   * `<input>`, defaults to "off"
   */
  autoComplete: import_prop_types74.default.string,
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types74.default.string,
  /**
   * Specify a label to be read by screen readers on the "close" button
   */
  closeButtonLabelText: import_prop_types74.default.string,
  /**
   * Optionally provide the default value of the `<input>`
   */
  defaultValue: import_prop_types74.default.oneOfType([import_prop_types74.default.string, import_prop_types74.default.number]),
  /**
   * Specify whether the `<input>` should be disabled
   */
  disabled: import_prop_types74.default.bool,
  /**
   * Specify a custom `id` for the input
   */
  id: import_prop_types74.default.string,
  /**
   * Specify whether or not ExpandableSearch should render expanded or not
   */
  isExpanded: import_prop_types74.default.bool,
  /**
   * Provide the label text for the Search icon
   */
  labelText: import_prop_types74.default.node.isRequired,
  /**
   * Specify light version or default version of this control
   */
  light: deprecate(import_prop_types74.default.bool, "The `light` prop for `Search` is no longer needed and has been deprecated in v11 in favor of the new `Layer` component. It will be moved in the next major release."),
  /**
   * Optional callback called when the search value changes.
   */
  onChange: import_prop_types74.default.func,
  /**
   * Optional callback called when the search value is cleared.
   */
  onClear: import_prop_types74.default.func,
  /**
   * Optional callback called when the magnifier icon is clicked in ExpandableSearch.
   */
  onExpand: import_prop_types74.default.func,
  /**
   * Provide a handler that is invoked on the key down event for the input
   */
  onKeyDown: import_prop_types74.default.func,
  /**
   * Provide an optional placeholder text for the Search.
   * Note: if the label and placeholder differ,
   * VoiceOver on Mac will read both
   */
  placeholder: import_prop_types74.default.string,
  /**
   * Rendered icon for the Search.
   * Can be a React component class
   */
  // @ts-expect-error: PropTypes are not expressive enough to cover this case
  renderIcon: import_prop_types74.default.oneOfType([import_prop_types74.default.func, import_prop_types74.default.object]),
  /**
   * Specify the role for the underlying `<input>`, defaults to `searchbox`
   */
  role: import_prop_types74.default.string,
  /**
   * Specify the size of the Search
   */
  size: import_prop_types74.default.oneOf(["sm", "md", "lg"]),
  /**
   * Optional prop to specify the type of the `<input>`
   */
  type: import_prop_types74.default.string,
  /**
   * Specify the value of the `<input>`
   */
  value: import_prop_types74.default.oneOfType([import_prop_types74.default.string, import_prop_types74.default.number])
};
function CustomSearchIcon(_ref2) {
  let {
    icon: Icon
  } = _ref2;
  const prefix = usePrefix();
  if (Icon) {
    return import_react104.default.createElement(Icon, {
      className: `${prefix}--search-magnifier-icon`
    });
  }
  return import_react104.default.createElement(Search, {
    className: `${prefix}--search-magnifier-icon`
  });
}
CustomSearchIcon.propTypes = {
  /**
   * Rendered icon for the Search. Can be a React component class
   */
  icon: import_prop_types74.default.oneOfType([import_prop_types74.default.func, import_prop_types74.default.object])
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Search/Search.Skeleton.js
var import_prop_types75 = __toESM(require_prop_types());
var import_react105 = __toESM(require_react());
var import_classnames64 = __toESM(require_classnames());
var SearchSkeleton = (_ref) => {
  let {
    small = false,
    className,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const searchClasses = (0, import_classnames64.default)(className, {
    [`${prefix}--skeleton`]: true,
    [`${prefix}--search--xl`]: !small,
    [`${prefix}--search--sm`]: small
  });
  return import_react105.default.createElement("div", _extends({
    className: searchClasses
  }, rest3), import_react105.default.createElement("span", {
    className: `${prefix}--label`
  }), import_react105.default.createElement("div", {
    className: `${prefix}--search-input`
  }));
};
SearchSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types75.default.string,
  /**
   * Specify whether the Search should be a small variant
   */
  small: import_prop_types75.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/TableToolbarSearch.js
var translationKeys3 = {
  "carbon.table.toolbar.search.label": "Filter table",
  "carbon.table.toolbar.search.placeholder": "Filter table"
};
var translateWithId3 = (id) => {
  return translationKeys3[id];
};
var TableToolbarSearch = (_ref) => {
  let {
    className,
    searchContainerClass,
    onChange: onChangeProp,
    onClear = noopFn,
    translateWithId: t2 = translateWithId3,
    placeholder,
    labelText,
    expanded: expandedProp,
    defaultExpanded,
    defaultValue,
    disabled,
    onExpand,
    persistent = false,
    id,
    onBlur,
    onFocus,
    size: size6 = "lg",
    tabIndex = "0",
    ...rest3
  } = _ref;
  const {
    current: controlled
  } = (0, import_react106.useRef)(expandedProp !== void 0);
  const [expandedState, setExpandedState] = (0, import_react106.useState)(Boolean(defaultExpanded || defaultValue));
  const expanded = controlled ? expandedProp : expandedState;
  const [value, setValue] = (0, import_react106.useState)(defaultValue || "");
  const uniqueId3 = useId("table-toolbar-search");
  const [focusTarget, setFocusTarget] = (0, import_react106.useState)(null);
  const prefix = usePrefix();
  (0, import_react106.useEffect)(() => {
    var _a, _b, _c;
    if (focusTarget) {
      (_c = (_b = (_a = focusTarget.current) == null ? void 0 : _a.querySelector) == null ? void 0 : _b.call(_a, "input")) == null ? void 0 : _c.focus();
      setFocusTarget(null);
    }
  }, [focusTarget]);
  (0, import_react106.useEffect)(
    () => {
      if (defaultValue) {
        onChangeProp == null ? void 0 : onChangeProp("", defaultValue);
      }
    },
    //eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  const searchClasses = (0, import_classnames65.default)(className, {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    [searchContainerClass]: searchContainerClass,
    [`${prefix}--toolbar-search-container-active`]: expanded,
    [`${prefix}--toolbar-search-container-disabled`]: disabled,
    [`${prefix}--toolbar-search-container-expandable`]: !persistent,
    [`${prefix}--toolbar-search-container-persistent`]: persistent
  });
  const handleExpand = function(event) {
    let value2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !expanded;
    if (!disabled) {
      if (!controlled && !persistent) {
        setExpandedState(value2);
      }
      if (onExpand) {
        onExpand(event, value2);
      }
    }
  };
  const onChange = (e2) => {
    setValue(e2.target.value);
    if (onChangeProp) {
      onChangeProp(e2, e2.target.value);
    }
  };
  const handleOnFocus = (event) => handleExpand(event, true);
  const handleOnBlur = (event) => !value && handleExpand(event, false);
  return import_react106.default.createElement(Search2, _extends({
    disabled,
    className: searchClasses,
    value,
    id: typeof id !== "undefined" ? id : uniqueId3,
    labelText: labelText || t2("carbon.table.toolbar.search.label"),
    placeholder: placeholder || t2("carbon.table.toolbar.search.placeholder"),
    onChange,
    onClear,
    onFocus: onFocus ? (event) => onFocus(event, handleExpand) : handleOnFocus,
    onBlur: onBlur ? (event) => onBlur(event, handleExpand) : handleOnBlur,
    size: size6,
    tabIndex
  }, rest3));
};
TableToolbarSearch.propTypes = {
  children: import_prop_types76.default.node,
  /**
   * Provide an optional class name for the search container
   */
  className: import_prop_types76.default.string,
  /**
   * Specifies if the search should initially render in an expanded state
   */
  defaultExpanded: import_prop_types76.default.bool,
  /**
   * Provide an optional default value for the Search component
   */
  defaultValue: import_prop_types76.default.string,
  /**
   * Specifies if the search should be disabled
   */
  disabled: import_prop_types76.default.bool,
  /**
   * Specifies if the search should expand
   */
  expanded: import_prop_types76.default.bool,
  /**
   * Provide an optional id for the search container
   */
  id: import_prop_types76.default.string,
  /**
   * Provide an optional label text for the Search component icon
   */
  labelText: import_prop_types76.default.string,
  /**
   * Provide an optional function to be called when the search input loses focus, this will be
   * passed the event as the first parameter and a function to handle the expanding of the search
   * input as the second
   */
  onBlur: import_prop_types76.default.func,
  /**
   * Provide an optional hook that is called each time the input is updated
   */
  onChange: import_prop_types76.default.func,
  /**
   * Optional callback called when the search value is cleared.
   */
  onClear: import_prop_types76.default.func,
  /**
   * Provide an optional hook that is called each time the input is expanded
   */
  onExpand: import_prop_types76.default.func,
  /**
   * Provide an optional function to be called when the search input gains focus, this will be
   * passed the event as the first parameter and a function to handle the expanding of the search
   * input as the second.
   */
  onFocus: import_prop_types76.default.func,
  /**
   * Whether the search should be allowed to expand
   */
  persistent: import_prop_types76.default.bool,
  /**
   * Provide an optional placeholder text for the Search component
   */
  placeholder: import_prop_types76.default.string,
  /**
   * Provide an optional className for the overall container of the Search
   */
  searchContainerClass: import_prop_types76.default.string,
  /**
   * Specify the size of the Search
   */
  size: import_prop_types76.default.oneOf(["sm", "md", "lg"]),
  /**
   * Optional prop to specify the tabIndex of the <Search> (in expanded state) or the container (in collapsed state)
   */
  tabIndex: import_prop_types76.default.oneOfType([import_prop_types76.default.number, import_prop_types76.default.string]),
  /**
   * Provide custom text for the component for each translation id
   */
  translateWithId: import_prop_types76.default.func
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/TableToolbarMenu.js
var import_classnames68 = __toESM(require_classnames());
var import_prop_types81 = __toESM(require_prop_types());
var import_react113 = __toESM(require_react());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/OverflowMenu/index.js
var import_react112 = __toESM(require_react());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/OverflowMenu/next/index.js
var import_react107 = __toESM(require_react());
var import_prop_types77 = __toESM(require_prop_types());
var import_classnames66 = __toESM(require_classnames());
var defaultSize = "md";
var propMappingFunction7 = (deprecatedValue) => {
  const mapping = {
    "top-left": "top-start",
    "top-right": "top-end",
    "bottom-left": "bottom-start",
    "bottom-right": "bottom-end",
    "left-bottom": "left-end",
    "left-top": "left-start",
    "right-bottom": "right-end",
    "right-top": "right-start"
  };
  return mapping[deprecatedValue];
};
var OverflowMenu = import_react107.default.forwardRef(function OverflowMenu2(_ref, forwardRef13) {
  let {
    autoAlign = false,
    children,
    className,
    label = "Options",
    renderIcon: IconElement = OverflowMenuVertical,
    size: size6 = defaultSize,
    menuAlignment = "bottom-start",
    tooltipAlignment,
    menuTarget,
    ...rest3
  } = _ref;
  const enableFloatingStyles = useFeatureFlag("enable-v12-dynamic-floating-styles") || autoAlign;
  const {
    refs,
    floatingStyles,
    placement,
    middlewareData
  } = useFloating2(
    enableFloatingStyles ? {
      // Computing the position starts with initial positioning
      // via `placement`.
      placement: menuAlignment,
      // The floating element is positioned relative to its nearest
      // containing block (usually the viewport). It will in many cases
      // also “break” the floating element out of a clipping ancestor.
      // https://floating-ui.com/docs/misc#clipping
      strategy: "fixed",
      // Middleware are executed as an in-between “middle” step of the
      // initial `placement` computation and eventual return of data for
      // rendering. Each middleware is executed in order.
      middleware: [autoAlign && flip3({
        // An explicit array of placements to try if the initial
        // `placement` doesn’t fit on the axes in which overflow
        // is checked.
        fallbackPlacements: menuAlignment.includes("bottom") ? ["bottom-start", "bottom-end", "top-start", "top-end"] : ["top-start", "top-end", "bottom-start", "bottom-end"]
      })],
      whileElementsMounted: autoUpdate
    } : {}
    // When autoAlign is turned off & the `enable-v12-dynamic-floating-styles` feature flag is not
    // enabled, floating-ui will not be used
  );
  const id = useId("overflowmenu");
  const prefix = usePrefix();
  const triggerRef = (0, import_react107.useRef)(null);
  const {
    open,
    x,
    y,
    handleClick: hookOnClick,
    handleMousedown,
    handleClose
  } = useAttachedMenu(triggerRef);
  (0, import_react107.useEffect)(() => {
    if (enableFloatingStyles) {
      Object.keys(floatingStyles).forEach((style) => {
        if (refs.floating.current) {
          refs.floating.current.style[style] = floatingStyles[style];
        }
      });
    }
  }, [floatingStyles, enableFloatingStyles, refs.floating, open, placement, middlewareData]);
  function handleTriggerClick() {
    if (triggerRef.current) {
      hookOnClick();
    }
  }
  const containerClasses = (0, import_classnames66.default)(className, `${prefix}--overflow-menu__container`, {
    [`${prefix}--autoalign`]: enableFloatingStyles
  });
  const menuClasses = (0, import_classnames66.default)(`${prefix}--overflow-menu__${menuAlignment}`);
  const triggerClasses = (0, import_classnames66.default)(`${prefix}--overflow-menu`, {
    [`${prefix}--overflow-menu--open`]: open
  }, size6 !== defaultSize && `${prefix}--overflow-menu--${size6}`);
  const floatingRef = mergeRefs$1(triggerRef, refs.setReference);
  return import_react107.default.createElement("div", _extends({}, rest3, {
    className: containerClasses,
    "aria-owns": open ? id : void 0,
    ref: forwardRef13
  }), import_react107.default.createElement(IconButton, {
    "aria-controls": open ? id : void 0,
    "aria-haspopup": true,
    "aria-expanded": open,
    className: triggerClasses,
    onClick: handleTriggerClick,
    onMouseDown: handleMousedown,
    ref: floatingRef,
    label,
    align: tooltipAlignment,
    kind: "ghost"
  }, import_react107.default.createElement(IconElement, {
    className: `${prefix}--overflow-menu__icon`
  })), import_react107.default.createElement(Menu2, {
    containerRef: triggerRef,
    ref: refs.setFloating,
    menuAlignment,
    className: menuClasses,
    id,
    size: size6,
    legacyAutoalign: !enableFloatingStyles,
    open,
    onClose: handleClose,
    x,
    y,
    label,
    target: menuTarget
  }, children));
});
OverflowMenu.propTypes = {
  /**
   * **Experimental**: Will attempt to automatically align the floating element to avoid collisions with the viewport and being clipped by ancestor elements.
   */
  autoAlign: import_prop_types77.default.bool,
  /**
   * A collection of MenuItems to be rendered within this OverflowMenu.
   */
  children: import_prop_types77.default.node,
  /**
   * Additional CSS class names for the trigger button.
   */
  className: import_prop_types77.default.string,
  /**
   * A label describing the options available. Is used in the trigger tooltip and as the menu's accessible label.
   */
  label: import_prop_types77.default.string,
  /**
   * Experimental property. Specify how the menu should align with the button element
   */
  menuAlignment: import_prop_types77.default.oneOf(["top-start", "top-end", "bottom-start", "bottom-end"]),
  /**
   * Optionally provide a custom icon to be rendered on the trigger button.
   */
  // @ts-expect-error: PropTypes are not expressive enough to cover this case
  renderIcon: import_prop_types77.default.oneOfType([import_prop_types77.default.func, import_prop_types77.default.object]),
  /**
   * Specify the size of the menu, from a list of available sizes.
   */
  size: import_prop_types77.default.oneOf(["sm", "md", "lg"]),
  /**
   * Specify how the trigger tooltip should be aligned.
   */
  tooltipAlignment: deprecateValuesWithin(
    import_prop_types77.default.oneOf([
      "top",
      "top-left",
      // deprecated use top-start instead
      "top-right",
      // deprecated use top-end instead
      "bottom",
      "bottom-left",
      // deprecated use bottom-start instead
      "bottom-right",
      // deprecated use bottom-end instead
      "left",
      "left-bottom",
      // deprecated use left-end instead
      "left-top",
      // deprecated use left-start instead
      "right",
      "right-bottom",
      // deprecated use right-end instead
      "right-top",
      // deprecated use right-start instead
      // new values to match floating-ui
      "top-start",
      "top-end",
      "bottom-start",
      "bottom-end",
      "left-end",
      "left-start",
      "right-end",
      "right-start"
    ]),
    //allowed prop values
    ["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "left", "left-start", "left-end", "right", "right-start", "right-end"],
    //optional mapper function
    propMappingFunction7
  ),
  /**
   * Specify a DOM node where the Menu should be rendered in. Defaults to document.body.
   */
  menuTarget: import_prop_types77.default.instanceOf(typeof Element !== "undefined" ? Element : Object)
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/internal/FloatingMenu.js
var import_prop_types78 = __toESM(require_prop_types());
var import_react109 = __toESM(require_react());
var import_react_dom4 = __toESM(require_react_dom());
var import_window_or_global2 = __toESM(require_lib());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/internal/OptimizedResize.js
var import_window_or_global = __toESM(require_lib());
var OptimizedResize = /* @__PURE__ */ function optimizedResize() {
  const callbacks = [];
  let running = false;
  function runCallbacks() {
    callbacks.forEach((callback) => {
      callback();
    });
    running = false;
  }
  function resize() {
    if (!running) {
      running = true;
      import_window_or_global.default.requestAnimationFrame(runCallbacks);
    }
  }
  function addCallback(callback) {
    if (callback) {
      const index4 = callbacks.indexOf(callback);
      if (index4 < 0) {
        callbacks.push(callback);
      }
    }
  }
  return {
    // public method to add additional callback
    add: (callback) => {
      if (!callbacks.length) {
        import_window_or_global.default.addEventListener("resize", resize);
      }
      addCallback(callback);
      return {
        release() {
          const index4 = callbacks.indexOf(callback);
          if (index4 >= 0) {
            callbacks.splice(index4, 1);
          }
        }
      };
    }
  };
}();
var OptimizedResize$1 = OptimizedResize;

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/internal/FloatingMenu.js
var DIRECTION_LEFT = "left";
var DIRECTION_TOP = "top";
var DIRECTION_RIGHT = "right";
var DIRECTION_BOTTOM = "bottom";
var hasChangeInOffset = function() {
  let oldMenuOffset = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  let menuOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (typeof oldMenuOffset !== typeof menuOffset) {
    return true;
  }
  if (Object(menuOffset) === menuOffset && typeof menuOffset !== "function") {
    return oldMenuOffset.top !== menuOffset.top || oldMenuOffset.left !== menuOffset.left;
  }
  return oldMenuOffset !== menuOffset;
};
var getFloatingPosition = (_ref) => {
  let {
    menuSize,
    refPosition = {},
    offset: offset5 = {},
    direction = DIRECTION_BOTTOM,
    scrollX: pageXOffset = 0,
    scrollY: pageYOffset = 0,
    container
  } = _ref;
  const {
    left: refLeft = 0,
    top: refTop = 0,
    right: refRight = 0,
    bottom: refBottom = 0
  } = refPosition;
  const scrollX = container.position !== "static" ? 0 : pageXOffset;
  const scrollY = container.position !== "static" ? 0 : pageYOffset;
  const relativeDiff = {
    top: container.position !== "static" ? container.rect.top : 0,
    left: container.position !== "static" ? container.rect.left : 0
  };
  const {
    width,
    height
  } = menuSize;
  const {
    top = 0,
    left = 0
  } = offset5;
  const refCenterHorizontal = (refLeft + refRight) / 2;
  const refCenterVertical = (refTop + refBottom) / 2;
  return {
    [DIRECTION_LEFT]: () => ({
      left: refLeft - width + scrollX - left - relativeDiff.left,
      top: refCenterVertical - height / 2 + scrollY + top - 9 - relativeDiff.top
    }),
    [DIRECTION_TOP]: () => ({
      left: refCenterHorizontal - width / 2 + scrollX + left - relativeDiff.left,
      top: refTop - height + scrollY - top - relativeDiff.top
    }),
    [DIRECTION_RIGHT]: () => ({
      left: refRight + scrollX + left - relativeDiff.left,
      top: refCenterVertical - height / 2 + scrollY + top + 3 - relativeDiff.top
    }),
    [DIRECTION_BOTTOM]: () => ({
      left: refCenterHorizontal - width / 2 + scrollX + left - relativeDiff.left,
      top: refBottom + scrollY + top - relativeDiff.top
    })
  }[direction]();
};
var FloatingMenu = class extends import_react109.default.Component {
  constructor() {
    var _this;
    super(...arguments);
    _this = this;
    _defineProperty(this, "_placeInProgress", false);
    _defineProperty(this, "state", {
      /**
       * The position of the menu, relative to the top-left corner of the viewport.
       * @type {FloatingMenu~offset}
       */
      floatingPosition: void 0
    });
    _defineProperty(this, "_menuContainer", null);
    _defineProperty(this, "_menuBody", null);
    _defineProperty(this, "startSentinel", import_react109.default.createRef());
    _defineProperty(this, "endSentinel", import_react109.default.createRef());
    _defineProperty(this, "_updateMenuSize", function() {
      let prevProps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let isAdjustment = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      const menuBody = _this._menuBody;
      true ? warning(menuBody, "The DOM node for menu body for calculating its position is not available. Skipping...") : void 0;
      if (!menuBody) {
        return;
      }
      const {
        menuOffset: oldMenuOffset = {},
        menuDirection: oldMenuDirection
      } = prevProps;
      const {
        menuOffset = {},
        menuDirection = DIRECTION_BOTTOM
      } = _this.props;
      if (hasChangeInOffset(oldMenuOffset, menuOffset) || oldMenuDirection !== menuDirection || isAdjustment) {
        const {
          flipped,
          triggerRef,
          updateOrientation = null
        } = _this.props;
        const {
          current: triggerEl
        } = triggerRef;
        const menuSize = menuBody.getBoundingClientRect();
        const refPosition = triggerEl && triggerEl.getBoundingClientRect();
        const offset5 = typeof menuOffset !== "function" ? menuOffset : menuOffset(menuBody, menuDirection, triggerEl, flipped);
        if (updateOrientation) {
          updateOrientation({
            menuSize,
            refPosition,
            direction: menuDirection,
            offset: offset5,
            scrollX: import_window_or_global2.default.pageXOffset,
            scrollY: import_window_or_global2.default.pageYOffset,
            container: {
              rect: _this.props.target().getBoundingClientRect(),
              position: getComputedStyle(_this.props.target()).position
            }
          });
        }
        if (menuSize.width > 0 && menuSize.height > 0 || !offset5) {
          _this.setState({
            floatingPosition: getFloatingPosition({
              menuSize,
              refPosition,
              direction: menuDirection,
              offset: offset5,
              scrollX: import_window_or_global2.default.pageXOffset,
              scrollY: import_window_or_global2.default.pageYOffset,
              container: {
                rect: _this.props.target().getBoundingClientRect(),
                position: getComputedStyle(_this.props.target()).position
              }
            })
          }, () => {
            if (!isAdjustment) {
              const newMenuSize = menuBody.getBoundingClientRect();
              if (newMenuSize !== menuSize) {
                _this._updateMenuSize(_this.props, true);
              }
            }
          });
        }
      }
    });
    _defineProperty(this, "_focusMenuContent", (menuBody) => {
      const primaryFocusNode = menuBody.querySelector(this.props.selectorPrimaryFocus || null);
      const tabbableNode = menuBody.querySelector(selectorTabbable);
      const focusableNode = menuBody.querySelector(selectorFocusable);
      const focusTarget = primaryFocusNode || // User defined focusable node
      tabbableNode || // First sequentially focusable node
      focusableNode || // First programmatic focusable node
      menuBody;
      focusTarget.focus();
      if (focusTarget === menuBody && true) {
        true ? warning(focusableNode === null, 'Floating Menus must have at least a programmatically focusable child. This can be accomplished by adding tabIndex="-1" to the content element.') : void 0;
      }
    });
    _defineProperty(this, "_menuRef", (menuBody) => {
      const {
        menuRef
      } = this.props;
      this._placeInProgress = !!menuBody;
      menuRef && menuRef(this._menuBody = menuBody);
      if (menuBody) {
        this._updateMenuSize();
      }
    });
    _defineProperty(this, "_getChildrenWithProps", () => {
      const {
        styles,
        children
      } = this.props;
      const {
        floatingPosition: pos
      } = this.state;
      const positioningStyle = pos ? {
        left: `${pos.left}px`,
        top: `${pos.top}px`,
        right: "auto"
      } : {
        visibility: "hidden",
        top: "0px"
      };
      return import_react109.default.cloneElement(children, {
        ref: this._menuRef,
        style: {
          ...styles,
          ...positioningStyle,
          position: "absolute",
          opacity: 1
        }
      });
    });
    _defineProperty(this, "handleBlur", (_ref2) => {
      let {
        target: oldActiveNode,
        relatedTarget: currentActiveNode
      } = _ref2;
      if (currentActiveNode && oldActiveNode) {
        const {
          current: startSentinelNode
        } = this.startSentinel;
        const {
          current: endSentinelNode
        } = this.endSentinel;
        wrapFocus({
          bodyNode: this._menuBody,
          startSentinelNode,
          endSentinelNode,
          currentActiveNode,
          oldActiveNode
        });
      }
    });
    _defineProperty(this, "handleKeyDown", (event) => {
      if (match(event, Tab) && this._menuBody) {
        wrapFocusWithoutSentinels({
          containerNode: this._menuBody,
          currentActiveNode: event.target,
          event
        });
      }
    });
  }
  componentWillUnmount() {
    this.hResize.release();
  }
  componentDidMount() {
    this.hResize = OptimizedResize$1.add(() => {
      this._updateMenuSize();
    });
  }
  componentDidUpdate(prevProps) {
    this._updateMenuSize(prevProps);
    const {
      onPlace
    } = this.props;
    if (this._placeInProgress && this.state.floatingPosition) {
      if (this._menuBody && !this._menuBody.contains(document.activeElement)) {
        this._focusMenuContent(this._menuBody);
      }
      if (typeof onPlace === "function") {
        onPlace(this._menuBody);
        this._placeInProgress = false;
      }
    }
  }
  render() {
    const {
      context: prefix
    } = this;
    const focusTrapWithoutSentinels = enabled("enable-experimental-focus-wrap-without-sentinels");
    if (typeof document !== "undefined") {
      const {
        focusTrap,
        target
      } = this.props;
      return import_react_dom4.default.createPortal(
        //eslint-disable-next-line jsx-a11y/no-static-element-interactions
        import_react109.default.createElement("div", {
          onBlur: focusTrap && !focusTrapWithoutSentinels ? this.handleBlur : () => {
          },
          onKeyDown: focusTrapWithoutSentinels ? this.handleKeyDown : () => {
          }
        }, !focusTrapWithoutSentinels && import_react109.default.createElement("span", {
          ref: this.startSentinel,
          tabIndex: "0",
          role: "link",
          className: `${prefix}--visually-hidden`
        }, "Focus sentinel"), this._getChildrenWithProps(), !focusTrapWithoutSentinels && import_react109.default.createElement("span", {
          ref: this.endSentinel,
          tabIndex: "0",
          role: "link",
          className: `${prefix}--visually-hidden`
        }, "Focus sentinel")),
        !target ? document.body : target()
      );
    }
    return null;
  }
};
_defineProperty(FloatingMenu, "contextType", PrefixContext);
_defineProperty(FloatingMenu, "propTypes", {
  /**
   * Contents to put into the floating menu.
   */
  children: import_prop_types78.default.object,
  /**
   * `true` if the menu alignment should be flipped.
   */
  flipped: import_prop_types78.default.bool,
  /**
   * Enable or disable focus trap behavior
   */
  focusTrap: import_prop_types78.default.bool,
  /**
   * Where to put the tooltip, relative to the trigger button.
   */
  menuDirection: import_prop_types78.default.oneOf([DIRECTION_LEFT, DIRECTION_TOP, DIRECTION_RIGHT, DIRECTION_BOTTOM]),
  /**
   * The adjustment of the floating menu position, considering the position of dropdown arrow, etc.
   */
  menuOffset: import_prop_types78.default.oneOfType([import_prop_types78.default.shape({
    top: import_prop_types78.default.number,
    left: import_prop_types78.default.number
  }), import_prop_types78.default.func]),
  /**
   * The callback called when the menu body has been mounted to/will be unmounted from the DOM.
   */
  menuRef: import_prop_types78.default.func,
  /**
   * The callback called when the menu body has been mounted and positioned.
   */
  onPlace: import_prop_types78.default.func,
  /**
   * Specify a CSS selector that matches the DOM element that should
   * be focused when the Modal opens
   */
  selectorPrimaryFocus: import_prop_types78.default.string,
  /**
   * The additional styles to put to the floating menu.
   */
  styles: import_prop_types78.default.object,
  /**
   * The query selector indicating where the floating menu body should be placed.
   */
  target: import_prop_types78.default.func,
  /**
   * The element ref of the tooltip's trigger button.
   */
  triggerRef: import_prop_types78.default.oneOfType([import_prop_types78.default.func, import_prop_types78.default.shape({
    current: import_prop_types78.default.any
  })]),
  /**
   * Optional function to change orientation of tooltip based on parent
   */
  updateOrientation: import_prop_types78.default.func
});
var FloatingMenu$1 = FloatingMenu;

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/OverflowMenu/OverflowMenu.js
var import_react111 = __toESM(require_react());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/internal/ClickListener.js
var import_prop_types79 = __toESM(require_prop_types());
var import_react110 = __toESM(require_react());
var ClickListener = class _ClickListener extends import_react110.default.Component {
  static getEventTarget(evt) {
    if (evt.composed && typeof evt.composedPath === "function") {
      return evt.composedPath()[0];
    }
    return evt.target;
  }
  constructor(props) {
    super(props);
    this.handleRef = this.handleRef.bind(this);
    this.handleDocumentClick = this.handleDocumentClick.bind(this);
  }
  componentDidMount() {
    document.addEventListener("click", this.handleDocumentClick);
  }
  componentWillUnmount() {
    document.removeEventListener("click", this.handleDocumentClick);
  }
  handleDocumentClick(evt) {
    if (this.element) {
      if (this.element.contains && !this.element.contains(_ClickListener.getEventTarget(evt))) {
        this.props.onClickOutside(evt);
      }
    }
  }
  handleRef(el) {
    const {
      children
    } = this.props;
    this.element = el;
    if (children.ref && typeof children.ref === "function") {
      children.ref(el);
    }
  }
  render() {
    return import_react110.default.cloneElement(this.props.children, {
      ref: this.handleRef
    });
  }
};
_defineProperty(ClickListener, "propTypes", {
  children: import_prop_types79.default.element.isRequired,
  onClickOutside: import_prop_types79.default.func.isRequired
});

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/OverflowMenu/OverflowMenu.js
var import_prop_types80 = __toESM(require_prop_types());
var import_classnames67 = __toESM(require_classnames());
var import_invariant2 = __toESM(require_browser());
var getInstanceId = setupGetInstanceId();
var on = function(element) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  element.addEventListener(...args);
  return {
    release() {
      element.removeEventListener(...args);
      return null;
    }
  };
};
var triggerButtonPositionProps = {
  [DIRECTION_TOP]: "bottom",
  [DIRECTION_BOTTOM]: "top"
};
var triggerButtonPositionFactors = {
  [DIRECTION_TOP]: -2,
  [DIRECTION_BOTTOM]: -1
};
var getMenuOffset = (menuBody, direction, trigger, flip6) => {
  const triggerButtonPositionProp = triggerButtonPositionProps[direction];
  const triggerButtonPositionFactor = triggerButtonPositionFactors[direction];
  if (true) {
    !(triggerButtonPositionProp && triggerButtonPositionFactor) ? true ? (0, import_invariant2.default)(false, "[OverflowMenu] wrong floating menu direction: `%s`", direction) : (0, import_invariant2.default)(false) : void 0;
  }
  const {
    offsetWidth: menuWidth,
    offsetHeight: menuHeight
  } = menuBody;
  switch (triggerButtonPositionProp) {
    case "top":
    case "bottom": {
      const triggerWidth = !trigger ? 0 : trigger.offsetWidth;
      return {
        left: (!flip6 ? 1 : -1) * (menuWidth / 2 - triggerWidth / 2),
        top: 0
      };
    }
  }
};
var OverflowMenu3 = class extends import_react111.default.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "state", {
      open: false,
      // Set a default value for 'open'
      hasMountedTrigger: false,
      // Set a default value for 'hasMountedTrigger'
      click: false
      // Set a default value for 'click'
    });
    _defineProperty(this, "instanceId", getInstanceId());
    _defineProperty(this, "_hFocusIn", null);
    _defineProperty(this, "_hBlurTimeout", void 0);
    _defineProperty(this, "_triggerRef", import_react111.default.createRef());
    _defineProperty(this, "handleClick", (evt) => {
      const {
        onClick = noopFn
      } = this.props;
      this.setState({
        click: true
      });
      if (!this._menuBody || !this._menuBody.contains(evt.target)) {
        this.setState({
          open: !this.state.open
        });
        onClick(evt);
      }
    });
    _defineProperty(this, "closeMenuAndFocus", () => {
      const wasClicked = this.state.click;
      const wasOpen = this.state.open;
      this.closeMenu(() => {
        if (wasOpen && !wasClicked) {
          this.focusMenuEl();
        }
      });
    });
    _defineProperty(this, "closeMenuOnEscape", () => {
      const wasOpen = this.state.open;
      this.closeMenu(() => {
        if (wasOpen) {
          this.focusMenuEl();
        }
      });
    });
    _defineProperty(this, "handleKeyPress", (evt) => {
      if (this.state.open && matches(evt, [ArrowUp2, ArrowRight2, ArrowDown, ArrowLeft])) {
        evt.preventDefault();
      }
      if (matches(evt, [Escape])) {
        this.closeMenuOnEscape();
        evt.stopPropagation();
      }
    });
    _defineProperty(this, "handleClickOutside", (evt) => {
      if (this.state.open && (!this._menuBody || !this._menuBody.contains(evt.target))) {
        this.closeMenu();
      }
    });
    _defineProperty(this, "closeMenu", (onCloseMenu) => {
      const {
        onClose = noopFn
      } = this.props;
      this.setState({
        open: false
      }, () => {
        if (onCloseMenu) {
          onCloseMenu();
        }
        onClose();
      });
    });
    _defineProperty(this, "focusMenuEl", () => {
      const {
        current: triggerEl
      } = this._triggerRef;
      if (triggerEl) {
        triggerEl.focus();
      }
    });
    _defineProperty(this, "handleOverflowMenuItemFocus", (_ref) => {
      let {
        currentIndex,
        direction
      } = _ref;
      const enabledIndices = import_react111.default.Children.toArray(this.props.children).reduce((acc, curr, i) => {
        if (import_react111.default.isValidElement(curr) && !curr.props.disabled) {
          acc.push(i);
        }
        return acc;
      }, []);
      const nextValidIndex = (() => {
        const nextIndex = enabledIndices.indexOf(currentIndex) + direction;
        switch (nextIndex) {
          case -1:
            return enabledIndices.length - 1;
          case enabledIndices.length:
            return 0;
          default:
            return nextIndex;
        }
      })();
      const overflowMenuItem = this[`overflowMenuItem${enabledIndices[nextValidIndex]}`];
      overflowMenuItem == null ? void 0 : overflowMenuItem.focus();
    });
    _defineProperty(this, "_menuBody", null);
    _defineProperty(this, "_bindMenuBody", (menuBody) => {
      if (!menuBody) {
        this._menuBody = menuBody;
      }
      if (!menuBody && this._hFocusIn) {
        this._hFocusIn = this._hFocusIn.release();
      }
    });
    _defineProperty(this, "_handlePlace", (menuBody) => {
      const {
        onOpen = noopFn
      } = this.props;
      if (menuBody) {
        this._menuBody = menuBody;
        const hasFocusin = "onfocusin" in window;
        const focusinEventName = hasFocusin ? "focusin" : "focus";
        this._hFocusIn = on(menuBody.ownerDocument, focusinEventName, (event) => {
          const target = ClickListener.getEventTarget(event);
          const {
            current: triggerEl
          } = this._triggerRef;
          if (typeof target.matches === "function") {
            if (!menuBody.contains(target) && triggerEl && !target.matches(`.${this.context}--overflow-menu:first-child,.${this.context}--overflow-menu-options:first-child`)) {
              this.closeMenuAndFocus();
            }
          }
        }, !hasFocusin);
        onOpen();
      }
    });
    _defineProperty(this, "_getTarget", () => {
      const {
        current: triggerEl
      } = this._triggerRef;
      return triggerEl instanceof Element && triggerEl.closest("[data-floating-menu-container]") || document.body;
    });
  }
  componentDidUpdate(_, prevState) {
    const {
      onClose = noopFn
    } = this.props;
    if (!this.state.open && prevState.open) {
      onClose();
    }
  }
  componentDidMount() {
    if (this._triggerRef.current) {
      this.setState({
        hasMountedTrigger: true
      });
    }
  }
  static getDerivedStateFromProps(_ref2, state) {
    let {
      open
    } = _ref2;
    const {
      prevOpen
    } = state;
    return prevOpen === open ? null : {
      open,
      prevOpen: open
    };
  }
  componentWillUnmount() {
    if (typeof this._hBlurTimeout === "number") {
      clearTimeout(this._hBlurTimeout);
      this._hBlurTimeout = void 0;
    }
  }
  render() {
    const prefix = this.context;
    const {
      id,
      ["aria-label"]: ariaLabel = null,
      ariaLabel: deprecatedAriaLabel,
      children,
      iconDescription = "Options",
      direction = DIRECTION_BOTTOM,
      flipped = false,
      focusTrap = true,
      menuOffset = getMenuOffset,
      menuOffsetFlip = getMenuOffset,
      iconClass,
      onClick = noopFn,
      // eslint-disable-line
      onOpen = noopFn,
      // eslint-disable-line
      selectorPrimaryFocus = "[data-floating-menu-primary-focus]",
      // eslint-disable-line
      renderIcon: IconElement = OverflowMenuVertical,
      // eslint-disable-next-line react/prop-types
      innerRef: ref,
      menuOptionsClass,
      light,
      size: size6 = "md",
      ...other
    } = this.props;
    const {
      open = false
    } = this.state;
    const overflowMenuClasses = (0, import_classnames67.default)(this.props.className, `${prefix}--overflow-menu`, {
      [`${prefix}--overflow-menu--open`]: open,
      [`${prefix}--overflow-menu--light`]: light,
      [`${prefix}--overflow-menu--${size6}`]: size6
    });
    const overflowMenuOptionsClasses = (0, import_classnames67.default)(menuOptionsClass, `${prefix}--overflow-menu-options`, {
      [`${prefix}--overflow-menu--flip`]: this.props.flipped,
      [`${prefix}--overflow-menu-options--open`]: open,
      [`${prefix}--overflow-menu-options--light`]: light,
      [`${prefix}--overflow-menu-options--${size6}`]: size6
    });
    const overflowMenuIconClasses = (0, import_classnames67.default)(`${prefix}--overflow-menu__icon`, iconClass);
    const childrenWithProps = import_react111.default.Children.toArray(children).map((child, index4) => import_react111.default.isValidElement(child) ? import_react111.default.cloneElement(child, {
      // @ts-expect-error: PropTypes are not expressive enough to cover this case
      closeMenu: child.props.closeMenu || this.closeMenuAndFocus,
      handleOverflowMenuItemFocus: this.handleOverflowMenuItemFocus,
      ref: (e2) => {
        this[`overflowMenuItem${index4}`] = e2;
      },
      index: index4
    }) : null);
    const menuBodyId = `overflow-menu-${this.instanceId}__menu-body`;
    const menuBody = import_react111.default.createElement("ul", {
      className: overflowMenuOptionsClasses,
      tabIndex: -1,
      role: "menu",
      "aria-label": ariaLabel || deprecatedAriaLabel,
      onKeyDown: this.handleKeyPress,
      id: menuBodyId
    }, childrenWithProps);
    const wrappedMenuBody = import_react111.default.createElement(FloatingMenu$1, {
      focusTrap,
      triggerRef: this._triggerRef,
      menuDirection: direction,
      menuOffset: flipped ? menuOffsetFlip : menuOffset,
      menuRef: this._bindMenuBody,
      flipped: this.props.flipped,
      target: this._getTarget,
      onPlace: this._handlePlace,
      selectorPrimaryFocus: this.props.selectorPrimaryFocus
    }, import_react111.default.cloneElement(menuBody, {
      "data-floating-menu-direction": direction
    }));
    const iconProps = {
      className: overflowMenuIconClasses,
      "aria-label": iconDescription
    };
    return import_react111.default.createElement(ClickListener, {
      onClickOutside: this.handleClickOutside
    }, import_react111.default.createElement("span", {
      className: `${prefix}--overflow-menu__wrapper`,
      "aria-owns": open ? menuBodyId : void 0
    }, import_react111.default.createElement(IconButton, _extends({}, other, {
      type: "button",
      "aria-haspopup": true,
      "aria-expanded": open,
      "aria-controls": open ? menuBodyId : void 0,
      className: overflowMenuClasses,
      onClick: this.handleClick,
      id,
      ref: mergeRefs$1(this._triggerRef, ref),
      size: size6,
      label: iconDescription,
      kind: "ghost"
    }), import_react111.default.createElement(IconElement, iconProps)), open && this.state.hasMountedTrigger && wrappedMenuBody));
  }
};
_defineProperty(OverflowMenu3, "propTypes", {
  /**
   * Specify a label to be read by screen readers on the container node
   */
  ["aria-label"]: import_prop_types80.default.string,
  /**
   * Deprecated, please use `aria-label` instead.
   * Specify a label to be read by screen readers on the container note.
   */
  ariaLabel: deprecate(import_prop_types80.default.string, "This prop syntax has been deprecated. Please use the new `aria-label`."),
  /**
   * The child nodes.
   */
  children: import_prop_types80.default.node,
  /**
   * The CSS class names.
   */
  className: import_prop_types80.default.string,
  /**
   * The menu direction.
   */
  direction: import_prop_types80.default.oneOf([DIRECTION_TOP, DIRECTION_BOTTOM]),
  /**
   * `true` if the menu alignment should be flipped.
   */
  flipped: import_prop_types80.default.bool,
  /**
   * Enable or disable focus trap behavior
   */
  focusTrap: import_prop_types80.default.bool,
  /**
   * The CSS class for the icon.
   */
  iconClass: import_prop_types80.default.string,
  /**
   * The icon description.
   */
  iconDescription: import_prop_types80.default.string,
  /**
   * The element ID.
   */
  id: import_prop_types80.default.string,
  /**
   * `true` to use the light version. For use on $ui-01 backgrounds only.
   * Don't use this to make OverflowMenu background color same as container background color.
   */
  light: deprecate(import_prop_types80.default.bool, "The `light` prop for `OverflowMenu` is no longer needed and has been deprecated. It will be removed in the next major release. Use the Layer component instead."),
  /**
   * The adjustment in position applied to the floating menu.
   */
  menuOffset: import_prop_types80.default.oneOfType([import_prop_types80.default.shape({
    top: import_prop_types80.default.number,
    left: import_prop_types80.default.number
  }), import_prop_types80.default.func]),
  /**
   * The adjustment in position applied to the floating menu.
   */
  menuOffsetFlip: import_prop_types80.default.oneOfType([import_prop_types80.default.shape({
    top: import_prop_types80.default.number,
    left: import_prop_types80.default.number
  }), import_prop_types80.default.func]),
  /**
   * The class to apply to the menu options
   */
  menuOptionsClass: import_prop_types80.default.string,
  /**
   * The event handler for the `click` event.
   */
  onClick: import_prop_types80.default.func,
  /**
   * Function called when menu is closed
   */
  onClose: import_prop_types80.default.func,
  /**
   * The event handler for the `focus` event.
   */
  onFocus: import_prop_types80.default.func,
  /**
   * The event handler for the `keydown` event.
   */
  onKeyDown: import_prop_types80.default.func,
  /**
   * Function called when menu is opened
   */
  onOpen: import_prop_types80.default.func,
  /**
   * `true` if the menu should be open.
   */
  open: import_prop_types80.default.bool,
  /**
   * Function called to override icon rendering.
   */
  renderIcon: import_prop_types80.default.oneOfType([import_prop_types80.default.func, import_prop_types80.default.object]),
  /**
   * Specify a CSS selector that matches the DOM element that should
   * be focused when the OverflowMenu opens
   */
  selectorPrimaryFocus: import_prop_types80.default.string,
  /**
   * Specify the size of the OverflowMenu. Currently supports either `sm`, 'md' (default) or 'lg` as an option.
   */
  size: import_prop_types80.default.oneOf(["sm", "md", "lg"])
});
_defineProperty(OverflowMenu3, "contextType", PrefixContext);
(() => {
  const forwardRef13 = (props, ref) => import_react111.default.createElement(OverflowMenu3, _extends({}, props, {
    innerRef: ref
  }));
  forwardRef13.displayName = "OverflowMenu";
  return import_react111.default.forwardRef(forwardRef13);
})();

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/OverflowMenu/index.js
var OverflowMenuV11 = createClassWrapper(OverflowMenu3);
function OverflowMenu4(props) {
  const enableV12OverflowMenu = useFeatureFlag("enable-v12-overflowmenu");
  return enableV12OverflowMenu ? import_react112.default.createElement(OverflowMenu, props) : import_react112.default.createElement(OverflowMenuV11, props);
}
OverflowMenu4.displayName = "OverflowMenu";

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/TableToolbarMenu.js
var defaultIconDescription = "Settings";
var TableToolbarMenu = (_ref) => {
  let {
    className,
    renderIcon = Settings,
    iconDescription = defaultIconDescription,
    children,
    menuOptionsClass,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const toolbarActionClasses = (0, import_classnames68.default)(className, `${prefix}--toolbar-action ${prefix}--overflow-menu`);
  const menuOptionsClasses = (0, import_classnames68.default)(menuOptionsClass, `${prefix}--toolbar-action__menu`);
  return import_react113.default.createElement(OverflowMenu4, _extends({
    "aria-label": iconDescription,
    renderIcon,
    className: toolbarActionClasses,
    title: iconDescription,
    iconDescription,
    menuOptionsClass: menuOptionsClasses,
    flipped: true
  }, rest3), children);
};
TableToolbarMenu.propTypes = {
  children: import_prop_types81.default.node.isRequired,
  /**
   * Provide an optional class name for the toolbar menu
   */
  className: import_prop_types81.default.string,
  /**
   * The description of the menu icon.
   */
  iconDescription: import_prop_types81.default.string,
  /**
   * Provide an optional class name for the toolbar menu
   */
  menuOptionsClass: import_prop_types81.default.string,
  /**
   * Optional prop to allow overriding the default menu icon
   */
  renderIcon: import_prop_types81.default.oneOfType([import_prop_types81.default.func, import_prop_types81.default.object])
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/DataTable.js
var getInstanceId2 = setupGetInstanceId();
var translationKeys4 = {
  expandRow: "carbon.table.row.expand",
  collapseRow: "carbon.table.row.collapse",
  expandAll: "carbon.table.all.expand",
  collapseAll: "carbon.table.all.collapse",
  selectAll: "carbon.table.all.select",
  unselectAll: "carbon.table.all.unselect",
  selectRow: "carbon.table.row.select",
  unselectRow: "carbon.table.row.unselect"
};
var defaultTranslations6 = {
  [translationKeys4.expandAll]: "Expand all rows",
  [translationKeys4.collapseAll]: "Collapse all rows",
  [translationKeys4.expandRow]: "Expand current row",
  [translationKeys4.collapseRow]: "Collapse current row",
  [translationKeys4.selectAll]: "Select all rows",
  [translationKeys4.unselectAll]: "Unselect all rows",
  [translationKeys4.selectRow]: "Select row",
  [translationKeys4.unselectRow]: "Unselect row"
};
var translateWithId4 = (id) => defaultTranslations6[id];
var DataTable = class extends import_react114.default.Component {
  constructor(_props) {
    var _this;
    super(_props);
    _this = this;
    _defineProperty(this, "instanceId", void 0);
    _defineProperty(this, "getHeaderProps", (_ref) => {
      let {
        header,
        onClick,
        isSortable = this.props.isSortable,
        ...rest3
      } = _ref;
      const {
        sortDirection,
        sortHeaderKey
      } = this.state;
      return {
        ...rest3,
        key: header.key,
        sortDirection,
        isSortable,
        isSortHeader: sortHeaderKey === header.key,
        slug: header.slug,
        decorator: header.decorator,
        onClick: (event) => {
          const nextSortState = getNextSortState(this.props, this.state, {
            key: header.key
          });
          this.setState(nextSortState, () => {
            onClick && this.handleOnHeaderClick(onClick, {
              sortHeaderKey: header.key,
              sortDirection: nextSortState.sortDirection
            })(event);
          });
        }
      };
    });
    _defineProperty(this, "getExpandHeaderProps", function() {
      let {
        onClick,
        onExpand,
        ...rest3
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        translateWithId: t2 = translateWithId4
      } = _this.props;
      const {
        isExpandedAll,
        rowIds,
        rowsById
      } = _this.state;
      const isExpanded = isExpandedAll || rowIds.every((id) => rowsById[id].isExpanded);
      const translationKey = isExpanded ? translationKeys4.collapseAll : translationKeys4.expandAll;
      return {
        ...rest3,
        ariaLabel: t2(translationKey),
        // TODO: remove in v12
        "aria-label": t2(translationKey),
        // Provide a string of all the expanded row id's, separated by a space.
        "aria-controls": rowIds.map((id) => `expanded-row-${id}`).join(" "),
        isExpanded,
        // Compose the event handlers so we don't overwrite a consumer's `onClick`
        // handler
        onExpand: composeEventHandlers([_this.handleOnExpandAll, onExpand, onClick && _this.handleOnExpandHeaderClick(onClick, {
          isExpanded
        })])
      };
    });
    _defineProperty(this, "handleOnHeaderClick", (onClick, sortParams) => {
      return (e2) => onClick(e2, sortParams);
    });
    _defineProperty(this, "handleOnExpandHeaderClick", (onClick, expandParams) => {
      return (e2) => onClick(e2, expandParams);
    });
    _defineProperty(this, "getRowProps", (_ref2) => {
      let {
        row,
        onClick,
        ...rest3
      } = _ref2;
      const {
        translateWithId: t2 = translateWithId4
      } = this.props;
      const translationKey = row.isExpanded ? translationKeys4.collapseRow : translationKeys4.expandRow;
      return {
        ...rest3,
        key: row.id,
        // Compose the event handlers so we don't overwrite a consumer's `onClick`
        // handler
        onExpand: composeEventHandlers([this.handleOnExpandRow(row.id), onClick]),
        isExpanded: row.isExpanded,
        ariaLabel: t2(translationKey),
        // TODO remove in v12
        "aria-label": t2(translationKey),
        "aria-controls": `expanded-row-${row.id}`,
        isSelected: row.isSelected,
        disabled: row.disabled
      };
    });
    _defineProperty(this, "getExpandedRowProps", (_ref3) => {
      let {
        row,
        ...rest3
      } = _ref3;
      return {
        ...rest3,
        id: `expanded-row-${row.id}`
      };
    });
    _defineProperty(this, "getSelectionProps", function() {
      let {
        onClick,
        row,
        ...rest3
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        translateWithId: t2 = translateWithId4
      } = _this.props;
      if (row) {
        const translationKey2 = row.isSelected ? translationKeys4.unselectRow : translationKeys4.selectRow;
        return {
          ...rest3,
          checked: row.isSelected,
          onSelect: composeEventHandlers([_this.handleOnSelectRow(row.id), onClick]),
          id: `${_this.getTablePrefix()}__select-row-${row.id}`,
          name: `select-row-${_this.instanceId}`,
          ariaLabel: t2(translationKey2),
          // TODO remove in v12
          "aria-label": t2(translationKey2),
          disabled: row.disabled,
          radio: _this.props.radio
        };
      }
      const rowCount = _this.state.rowIds.length;
      const selectedRowCount = _this.getSelectedRows().length;
      const checked = rowCount > 0 && selectedRowCount === rowCount;
      const indeterminate = rowCount > 0 && selectedRowCount > 0 && selectedRowCount !== rowCount;
      const translationKey = checked || indeterminate ? translationKeys4.unselectAll : translationKeys4.selectAll;
      return {
        ...rest3,
        ariaLabel: t2(translationKey),
        // TODO remove in v12
        "aria-label": t2(translationKey),
        checked,
        id: `${_this.getTablePrefix()}__select-all`,
        indeterminate,
        name: "select-all",
        onSelect: composeEventHandlers([_this.handleSelectAll, onClick])
      };
    });
    _defineProperty(this, "getToolbarProps", function() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        size: size6
      } = _this.props;
      const isSmall = size6 === "xs" || size6 === "sm";
      return {
        ...props,
        size: isSmall ? "sm" : void 0
      };
    });
    _defineProperty(this, "getBatchActionProps", function() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        shouldShowBatchActions
      } = _this.state;
      const totalSelected = _this.getSelectedRows().length;
      return {
        onSelectAll: void 0,
        totalCount: _this.state.rowIds.length || 0,
        ...props,
        shouldShowBatchActions: shouldShowBatchActions && totalSelected > 0,
        totalSelected,
        onCancel: _this.handleOnCancel
      };
    });
    _defineProperty(this, "getTableProps", () => {
      const {
        useZebraStyles,
        size: size6 = "lg",
        isSortable,
        useStaticWidth,
        stickyHeader,
        overflowMenuOnHover = false,
        experimentalAutoAlign
      } = this.props;
      return {
        useZebraStyles,
        size: size6,
        isSortable,
        useStaticWidth,
        stickyHeader,
        overflowMenuOnHover,
        experimentalAutoAlign
      };
    });
    _defineProperty(this, "getTableContainerProps", () => {
      const {
        stickyHeader,
        useStaticWidth
      } = this.props;
      return {
        stickyHeader,
        useStaticWidth
      };
    });
    _defineProperty(this, "getCellProps", (_ref4) => {
      let {
        cell,
        ...rest3
      } = _ref4;
      return {
        ...rest3,
        hasAILabelHeader: cell.hasAILabelHeader,
        hasDecoratorHeader: cell.hasDecoratorHeader
      };
    });
    _defineProperty(this, "getSelectedRows", () => this.state.rowIds.filter((id) => {
      const row = this.state.rowsById[id];
      return row.isSelected && !row.disabled;
    }));
    _defineProperty(this, "getFilteredRowIds", () => {
      const {
        filterRows = defaultFilterRows
      } = this.props;
      const filteredRowIds = typeof this.state.filterInputValue === "string" ? filterRows({
        rowIds: this.state.rowIds,
        headers: this.props.headers,
        cellsById: this.state.cellsById,
        inputValue: this.state.filterInputValue,
        getCellId
      }) : this.state.rowIds;
      if (filteredRowIds.length == 0) {
        return [];
      }
      return filteredRowIds;
    });
    _defineProperty(this, "getTablePrefix", () => `data-table-${this.instanceId}`);
    _defineProperty(this, "setAllSelectedState", (initialState, isSelected, filteredRowIds) => {
      const {
        rowIds
      } = initialState;
      const isFiltered = rowIds.length != filteredRowIds.length;
      return {
        rowsById: rowIds.reduce((acc, id) => {
          const row = {
            ...initialState.rowsById[id]
          };
          if (!row.disabled && (!isFiltered || filteredRowIds.includes(id))) {
            row.isSelected = isSelected;
          }
          acc[id] = row;
          return acc;
        }, {})
      };
    });
    _defineProperty(this, "handleOnCancel", () => {
      this.setState((state) => {
        return {
          shouldShowBatchActions: false,
          ...this.setAllSelectedState(state, false, this.getFilteredRowIds())
        };
      });
    });
    _defineProperty(this, "handleSelectAll", () => {
      this.setState((state) => {
        const filteredRowIds = this.getFilteredRowIds();
        const {
          rowsById
        } = state;
        const isSelected = !(Object.values(rowsById).filter((row) => row.isSelected && !row.disabled).length > 0);
        return {
          shouldShowBatchActions: isSelected,
          ...this.setAllSelectedState(state, isSelected, filteredRowIds)
        };
      });
    });
    _defineProperty(this, "handleOnSelectRow", (rowId) => () => {
      this.setState((state) => {
        const row = state.rowsById[rowId];
        if (this.props.radio) {
          const rowsById = Object.entries(state.rowsById).reduce((p, c) => {
            const [key, val] = c;
            val.isSelected = false;
            p[key] = val;
            return p;
          }, {});
          return {
            shouldShowBatchActions: false,
            rowsById: {
              ...rowsById,
              [rowId]: {
                ...row,
                isSelected: !row.isSelected
              }
            }
          };
        }
        const selectedRows = state.rowIds.filter((id) => state.rowsById[id].isSelected).length;
        const selectedRowsCount = !row.isSelected ? selectedRows + 1 : selectedRows - 1;
        return {
          // Basic assumption here is that we want to show the batch action bar if
          // the row is being selected. If it's being unselected, then see if we
          // have a non-zero number of selected rows that batch actions could
          // still apply to
          shouldShowBatchActions: !row.isSelected || selectedRowsCount > 0,
          rowsById: {
            ...state.rowsById,
            [rowId]: {
              ...row,
              isSelected: !row.isSelected
            }
          }
        };
      });
    });
    _defineProperty(this, "handleOnExpandRow", (rowId) => () => {
      this.setState((state) => {
        const row = state.rowsById[rowId];
        const {
          isExpandedAll
        } = state;
        return {
          isExpandedAll: row.isExpanded ? false : isExpandedAll,
          rowsById: {
            ...state.rowsById,
            [rowId]: {
              ...row,
              isExpanded: !row.isExpanded
            }
          }
        };
      });
    });
    _defineProperty(this, "handleOnExpandAll", () => {
      this.setState((state) => {
        const {
          rowIds,
          isExpandedAll
        } = state;
        return {
          isExpandedAll: !isExpandedAll,
          rowsById: rowIds.reduce((acc, id) => ({
            ...acc,
            [id]: {
              ...state.rowsById[id],
              isExpanded: !isExpandedAll
            }
          }), {})
        };
      });
    });
    _defineProperty(this, "handleSortBy", (headerKey) => () => {
      this.setState((state) => getNextSortState(this.props, state, {
        key: headerKey
      }));
    });
    _defineProperty(this, "handleOnInputValueChange", (event, defaultValue) => {
      if (event.target) {
        this.setState({
          filterInputValue: event.target.value
        });
      }
      if (defaultValue) {
        this.setState({
          filterInputValue: defaultValue
        });
      }
    });
    this.state = {
      ...getDerivedStateFromProps$1(_props, {}),
      isExpandedAll: false
      // Start with collapsed state, treat `undefined` as neutral state
    };
    this.instanceId = getInstanceId2();
  }
  // if state needs to be updated then wait for only update after state is finished
  shouldComponentUpdate(nextProps) {
    if (this.props !== nextProps) {
      const nextRowIds = nextProps.rows.map((row) => row.id);
      const rowIds = this.props.rows.map((row) => row.id);
      if (!(0, import_react_fast_compare2.default)(nextRowIds, rowIds)) {
        this.setState((state) => getDerivedStateFromProps$1(this.props, state));
        return false;
      }
      const nextHeaders = nextProps.headers.map((header) => header.key);
      const headers = this.props.headers.map((header) => header.key);
      if (!(0, import_react_fast_compare2.default)(nextHeaders, headers)) {
        this.setState((state) => getDerivedStateFromProps$1(this.props, state));
        return false;
      }
      if (!(0, import_react_fast_compare2.default)(nextProps.rows, this.props.rows)) {
        this.setState((state) => getDerivedStateFromProps$1(this.props, state));
        return false;
      }
    }
    return true;
  }
  render() {
    const {
      children,
      filterRows = defaultFilterRows,
      headers,
      render
    } = this.props;
    const {
      filterInputValue,
      rowIds,
      rowsById,
      cellsById
    } = this.state;
    const filteredRowIds = typeof filterInputValue === "string" ? filterRows({
      rowIds,
      headers,
      cellsById,
      inputValue: filterInputValue,
      getCellId
    }) : rowIds;
    const renderProps = {
      // Data derived from state
      rows: denormalize$1(filteredRowIds, rowsById, cellsById),
      headers: this.props.headers,
      selectedRows: denormalize$1(this.getSelectedRows(), rowsById, cellsById),
      // Prop accessors/getters
      getHeaderProps: this.getHeaderProps,
      getExpandHeaderProps: this.getExpandHeaderProps,
      getRowProps: this.getRowProps,
      getExpandedRowProps: this.getExpandedRowProps,
      getSelectionProps: this.getSelectionProps,
      getToolbarProps: this.getToolbarProps,
      getBatchActionProps: this.getBatchActionProps,
      getTableProps: this.getTableProps,
      getTableContainerProps: this.getTableContainerProps,
      getCellProps: this.getCellProps,
      // Custom event handlers
      onInputChange: this.handleOnInputValueChange,
      // Expose internal state change actions
      sortBy: (headerKey) => this.handleSortBy(headerKey)(),
      selectAll: this.handleSelectAll,
      selectRow: (rowId) => this.handleOnSelectRow(rowId)(),
      expandRow: (rowId) => this.handleOnExpandRow(rowId)(),
      expandAll: this.handleOnExpandAll,
      radio: this.props.radio
    };
    if (render !== void 0) {
      return render(renderProps);
    }
    if (children !== void 0) {
      return children(renderProps);
    }
    return null;
  }
};
_defineProperty(DataTable, "propTypes", {
  /**
   * Experimental property. Allows table to align cell contents to the top if there is text wrapping in the content. Might have performance issues, intended for smaller tables
   */
  experimentalAutoAlign: import_prop_types82.default.bool,
  /**
   * Optional hook to manually control filtering of the rows from the
   * TableToolbarSearch component
   */
  filterRows: import_prop_types82.default.func,
  /**
   * The `headers` prop represents the order in which the headers should
   * appear in the table. We expect an array of objects to be passed in, where
   * `key` is the name of the key in a row object, and `header` is the name of
   * the header.
   */
  headers: import_prop_types82.default.arrayOf(import_prop_types82.default.shape({
    key: import_prop_types82.default.string.isRequired,
    header: import_prop_types82.default.node.isRequired
  })).isRequired,
  /**
   * Specify whether the table should be able to be sorted by its headers
   */
  isSortable: import_prop_types82.default.bool,
  /**
   * Provide a string for the current locale
   */
  locale: import_prop_types82.default.string,
  /**
   * Specify whether the overflow menu (if it exists) should be shown always, or only on hover
   */
  overflowMenuOnHover: import_prop_types82.default.bool,
  /**
   * Specify whether the control should be a radio button or inline checkbox
   */
  radio: import_prop_types82.default.bool,
  /**
   * The `rows` prop is where you provide us with a list of all the rows that
   * you want to render in the table. The only hard requirement is that this
   * is an array of objects, and that each object has a unique `id` field
   * available on it.
   */
  rows: import_prop_types82.default.arrayOf(import_prop_types82.default.shape({
    id: import_prop_types82.default.string.isRequired,
    disabled: import_prop_types82.default.bool,
    isSelected: import_prop_types82.default.bool,
    isExpanded: import_prop_types82.default.bool
  })).isRequired,
  /**
   *  Change the row height of table. Currently supports `xs`, `sm`, `md`, `lg`, and `xl`.
   */
  size: import_prop_types82.default.oneOf(["xs", "sm", "md", "lg", "xl"]),
  /**
   * Optional hook to manually control sorting of the rows.
   */
  sortRow: import_prop_types82.default.func,
  /**
   * Specify whether the header should be sticky.
   * Still experimental: may not work with every combination of table props
   */
  stickyHeader: import_prop_types82.default.bool,
  /**
   * Optional method that takes in a message id and returns an
   * internationalized string. See `DataTable.translationKeys` for all
   * available message ids.
   */
  translateWithId: import_prop_types82.default.func,
  /**
   * `false` If true, will use a width of 'auto' instead of 100%
   */
  useStaticWidth: import_prop_types82.default.bool,
  /**
   * `true` to add useZebraStyles striping.
   */
  useZebraStyles: import_prop_types82.default.bool
});
_defineProperty(DataTable, "translationKeys", Object.values(translationKeys4));
_defineProperty(DataTable, "Table", void 0);
_defineProperty(DataTable, "TableActionList", void 0);
_defineProperty(DataTable, "TableBatchAction", void 0);
_defineProperty(DataTable, "TableBatchActions", void 0);
_defineProperty(DataTable, "TableBody", void 0);
_defineProperty(DataTable, "TableCell", void 0);
_defineProperty(DataTable, "TableContainer", void 0);
_defineProperty(DataTable, "TableDecoratorRow", void 0);
_defineProperty(DataTable, "TableExpandHeader", void 0);
_defineProperty(DataTable, "TableExpandRow", void 0);
_defineProperty(DataTable, "TableExpandedRow", void 0);
_defineProperty(DataTable, "TableHead", void 0);
_defineProperty(DataTable, "TableHeader", void 0);
_defineProperty(DataTable, "TableRow", void 0);
_defineProperty(DataTable, "TableSelectAll", void 0);
_defineProperty(DataTable, "TableSelectRow", void 0);
_defineProperty(DataTable, "TableSlugRow", void 0);
_defineProperty(DataTable, "TableToolbar", void 0);
_defineProperty(DataTable, "TableToolbarAction", void 0);
_defineProperty(DataTable, "TableToolbarContent", void 0);
_defineProperty(DataTable, "TableToolbarSearch", void 0);
_defineProperty(DataTable, "TableToolbarMenu", void 0);
DataTable.Table = Table;
DataTable.TableActionList = TableActionList;
DataTable.TableBatchAction = TableBatchAction;
DataTable.TableBatchActions = TableBatchActions;
DataTable.TableBody = TableBody;
DataTable.TableCell = TableCell;
DataTable.TableContainer = TableContainer;
DataTable.TableDecoratorRow = TableDecoratorRow;
DataTable.TableExpandHeader = TableExpandHeader;
DataTable.TableExpandRow = TableExpandRow;
DataTable.TableExpandedRow = TableExpandedRow;
DataTable.TableHead = TableHead;
DataTable.TableHeader = TableHeader;
DataTable.TableRow = TableRow;
DataTable.TableSelectAll = TableSelectAll;
DataTable.TableSelectRow = TableSelectRow;
DataTable.TableSlugRow = TableSlugRow;
DataTable.TableToolbar = TableToolbar;
DataTable.TableToolbarAction = TableToolbarAction;
DataTable.TableToolbarContent = TableToolbarContent;
DataTable.TableToolbarSearch = TableToolbarSearch;
DataTable.TableToolbarMenu = TableToolbarMenu;

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTable/index.js
DataTable.Table = Table;
DataTable.TableActionList = TableActionList;
DataTable.TableBatchAction = TableBatchAction;
DataTable.TableBatchActions = TableBatchActions;
DataTable.TableBody = TableBody;
DataTable.TableCell = TableCell;
DataTable.TableContainer = TableContainer;
DataTable.TableDecoratorRow = TableDecoratorRow;
DataTable.TableExpandHeader = TableExpandHeader;
DataTable.TableExpandRow = TableExpandRow;
DataTable.TableExpandedRow = TableExpandedRow;
DataTable.TableHead = TableHead;
DataTable.TableHeader = TableHeader;
DataTable.TableRow = TableRow;
DataTable.TableSelectAll = TableSelectAll;
DataTable.TableSelectRow = TableSelectRow;
DataTable.TableSlugRow = TableSlugRow;
DataTable.TableToolbar = TableToolbar;
DataTable.TableToolbarAction = TableToolbarAction;
DataTable.TableToolbarContent = TableToolbarContent;
DataTable.TableToolbarSearch = TableToolbarSearch;
DataTable.TableToolbarMenu = TableToolbarMenu;

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DataTableSkeleton/DataTableSkeleton.js
var import_prop_types83 = __toESM(require_prop_types());
var import_react115 = __toESM(require_react());
var import_classnames69 = __toESM(require_classnames());
var _span5;
var _span22;
var DataTableSkeleton = (_ref) => {
  let {
    headers,
    rowCount = 5,
    columnCount = 5,
    zebra = false,
    compact: compact3 = false,
    className,
    showHeader = true,
    showToolbar = true,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const dataTableSkeletonClasses = (0, import_classnames69.default)(className, {
    [`${prefix}--skeleton`]: true,
    [`${prefix}--data-table`]: true,
    [`${prefix}--data-table--zebra`]: zebra,
    [`${prefix}--data-table--compact`]: compact3
  });
  const rowRepeat = rowCount;
  const rows = Array(rowRepeat);
  const columnsArray = Array.from({
    length: columnCount
  }, (_, index4) => index4);
  for (let i = 0; i < rowRepeat; i++) {
    rows[i] = import_react115.default.createElement("tr", {
      key: i
    }, columnsArray.map((j) => import_react115.default.createElement("td", {
      key: j
    }, _span5 || (_span5 = import_react115.default.createElement("span", null)))));
  }
  return import_react115.default.createElement("div", {
    className: `${prefix}--skeleton ${prefix}--data-table-container`
  }, showHeader ? import_react115.default.createElement("div", {
    className: `${prefix}--data-table-header`
  }, import_react115.default.createElement("div", {
    className: `${prefix}--data-table-header__title`
  }), import_react115.default.createElement("div", {
    className: `${prefix}--data-table-header__description`
  })) : null, showToolbar ? import_react115.default.createElement("section", {
    "aria-label": "data table toolbar",
    className: `${prefix}--table-toolbar`
  }, import_react115.default.createElement("div", {
    className: `${prefix}--toolbar-content`
  }, import_react115.default.createElement("span", {
    className: `${prefix}--skeleton ${prefix}--btn ${prefix}--btn--sm`
  }))) : null, import_react115.default.createElement("table", _extends({
    className: dataTableSkeletonClasses
  }, rest3), import_react115.default.createElement("thead", null, import_react115.default.createElement("tr", null, columnsArray.map((i) => {
    var _a;
    return import_react115.default.createElement("th", {
      key: i
    }, headers ? import_react115.default.createElement("div", {
      className: "cds--table-header-label"
    }, (_a = headers[i]) == null ? void 0 : _a.header) : _span22 || (_span22 = import_react115.default.createElement("span", null)));
  }))), import_react115.default.createElement("tbody", null, rows)));
};
DataTableSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types83.default.string,
  /**
   * Specify the number of columns that you want to render in the skeleton state
   */
  columnCount: import_prop_types83.default.number,
  /**
   * Optionally specify whether you want the Skeleton to be rendered as a
   * compact DataTable
   */
  compact: import_prop_types83.default.bool,
  /**
   * Optionally specify the displayed headers
   */
  headers: import_prop_types83.default.arrayOf(import_prop_types83.default.shape({
    header: import_prop_types83.default.node.isRequired
  }).isRequired),
  /**
   * Specify the number of rows that you want to render in the skeleton state
   */
  rowCount: import_prop_types83.default.number,
  /**
   * Specify if the table header should be rendered as part of the skeleton.
   */
  showHeader: import_prop_types83.default.bool,
  /**
   * Specify if the table toolbar should be rendered as part of the skeleton.
   */
  showToolbar: import_prop_types83.default.bool,
  /**
   * Optionally specify whether you want the DataTable to be zebra striped
   */
  zebra: import_prop_types83.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DatePicker/DatePicker.js
var import_prop_types85 = __toESM(require_prop_types());
var import_react118 = __toESM(require_react());
var import_classnames71 = __toESM(require_classnames());

// ../node_modules/.pnpm/flatpickr@4.6.13/node_modules/flatpickr/dist/esm/types/options.js
var HOOKS = [
  "onChange",
  "onClose",
  "onDayCreate",
  "onDestroy",
  "onKeyDown",
  "onMonthChange",
  "onOpen",
  "onParseConfig",
  "onReady",
  "onValueUpdate",
  "onYearChange",
  "onPreCalendarPosition"
];
var defaults2 = {
  _disable: [],
  allowInput: false,
  allowInvalidPreload: false,
  altFormat: "F j, Y",
  altInput: false,
  altInputClass: "form-control input",
  animate: typeof window === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
  ariaDateFormat: "F j, Y",
  autoFillDefaultTime: true,
  clickOpens: true,
  closeOnSelect: true,
  conjunction: ", ",
  dateFormat: "Y-m-d",
  defaultHour: 12,
  defaultMinute: 0,
  defaultSeconds: 0,
  disable: [],
  disableMobile: false,
  enableSeconds: false,
  enableTime: false,
  errorHandler: function(err) {
    return typeof console !== "undefined" && console.warn(err);
  },
  getWeek: function(givenDate) {
    var date = new Date(givenDate.getTime());
    date.setHours(0, 0, 0, 0);
    date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
    var week1 = new Date(date.getFullYear(), 0, 4);
    return 1 + Math.round(((date.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7);
  },
  hourIncrement: 1,
  ignoredFocusElements: [],
  inline: false,
  locale: "default",
  minuteIncrement: 5,
  mode: "single",
  monthSelectorType: "dropdown",
  nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
  noCalendar: false,
  now: /* @__PURE__ */ new Date(),
  onChange: [],
  onClose: [],
  onDayCreate: [],
  onDestroy: [],
  onKeyDown: [],
  onMonthChange: [],
  onOpen: [],
  onParseConfig: [],
  onReady: [],
  onValueUpdate: [],
  onYearChange: [],
  onPreCalendarPosition: [],
  plugins: [],
  position: "auto",
  positionElement: void 0,
  prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
  shorthandCurrentMonth: false,
  showMonths: 1,
  static: false,
  time_24hr: false,
  weekNumbers: false,
  wrap: false
};

// ../node_modules/.pnpm/flatpickr@4.6.13/node_modules/flatpickr/dist/esm/l10n/default.js
var english = {
  weekdays: {
    shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    longhand: [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ]
  },
  months: {
    shorthand: [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ],
    longhand: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ]
  },
  daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
  firstDayOfWeek: 0,
  ordinal: function(nth2) {
    var s = nth2 % 100;
    if (s > 3 && s < 21)
      return "th";
    switch (s % 10) {
      case 1:
        return "st";
      case 2:
        return "nd";
      case 3:
        return "rd";
      default:
        return "th";
    }
  },
  rangeSeparator: " to ",
  weekAbbreviation: "Wk",
  scrollTitle: "Scroll to increment",
  toggleTitle: "Click to toggle",
  amPM: ["AM", "PM"],
  yearAriaLabel: "Year",
  monthAriaLabel: "Month",
  hourAriaLabel: "Hour",
  minuteAriaLabel: "Minute",
  time_24hr: false
};
var default_default = english;

// ../node_modules/.pnpm/flatpickr@4.6.13/node_modules/flatpickr/dist/esm/utils/index.js
var pad3 = function(number, length) {
  if (length === void 0) {
    length = 2;
  }
  return ("000" + number).slice(length * -1);
};
var int = function(bool) {
  return bool === true ? 1 : 0;
};
function debounce4(fn, wait) {
  var t2;
  return function() {
    var _this = this;
    var args = arguments;
    clearTimeout(t2);
    t2 = setTimeout(function() {
      return fn.apply(_this, args);
    }, wait);
  };
}
var arrayify = function(obj) {
  return obj instanceof Array ? obj : [obj];
};

// ../node_modules/.pnpm/flatpickr@4.6.13/node_modules/flatpickr/dist/esm/utils/dom.js
function toggleClass2(elem, className, bool) {
  if (bool === true)
    return elem.classList.add(className);
  elem.classList.remove(className);
}
function createElement2(tag, className, content) {
  var e2 = window.document.createElement(tag);
  className = className || "";
  content = content || "";
  e2.className = className;
  if (content !== void 0)
    e2.textContent = content;
  return e2;
}
function clearNode(node) {
  while (node.firstChild)
    node.removeChild(node.firstChild);
}
function findParent(node, condition) {
  if (condition(node))
    return node;
  else if (node.parentNode)
    return findParent(node.parentNode, condition);
  return void 0;
}
function createNumberInput(inputClassName, opts) {
  var wrapper = createElement2("div", "numInputWrapper"), numInput = createElement2("input", "numInput " + inputClassName), arrowUp = createElement2("span", "arrowUp"), arrowDown = createElement2("span", "arrowDown");
  if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
    numInput.type = "number";
  } else {
    numInput.type = "text";
    numInput.pattern = "\\d*";
  }
  if (opts !== void 0)
    for (var key in opts)
      numInput.setAttribute(key, opts[key]);
  wrapper.appendChild(numInput);
  wrapper.appendChild(arrowUp);
  wrapper.appendChild(arrowDown);
  return wrapper;
}
function getEventTarget(event) {
  try {
    if (typeof event.composedPath === "function") {
      var path = event.composedPath();
      return path[0];
    }
    return event.target;
  } catch (error2) {
    return event.target;
  }
}

// ../node_modules/.pnpm/flatpickr@4.6.13/node_modules/flatpickr/dist/esm/utils/formatting.js
var doNothing = function() {
  return void 0;
};
var monthToStr = function(monthNumber, shorthand, locale) {
  return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
};
var revFormat = {
  D: doNothing,
  F: function(dateObj, monthName, locale) {
    dateObj.setMonth(locale.months.longhand.indexOf(monthName));
  },
  G: function(dateObj, hour) {
    dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
  },
  H: function(dateObj, hour) {
    dateObj.setHours(parseFloat(hour));
  },
  J: function(dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  K: function(dateObj, amPM, locale) {
    dateObj.setHours(dateObj.getHours() % 12 + 12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));
  },
  M: function(dateObj, shortMonth, locale) {
    dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
  },
  S: function(dateObj, seconds) {
    dateObj.setSeconds(parseFloat(seconds));
  },
  U: function(_, unixSeconds) {
    return new Date(parseFloat(unixSeconds) * 1e3);
  },
  W: function(dateObj, weekNum, locale) {
    var weekNumber = parseInt(weekNum);
    var date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
    date.setDate(date.getDate() - date.getDay() + locale.firstDayOfWeek);
    return date;
  },
  Y: function(dateObj, year) {
    dateObj.setFullYear(parseFloat(year));
  },
  Z: function(_, ISODate) {
    return new Date(ISODate);
  },
  d: function(dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  h: function(dateObj, hour) {
    dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
  },
  i: function(dateObj, minutes) {
    dateObj.setMinutes(parseFloat(minutes));
  },
  j: function(dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  l: doNothing,
  m: function(dateObj, month) {
    dateObj.setMonth(parseFloat(month) - 1);
  },
  n: function(dateObj, month) {
    dateObj.setMonth(parseFloat(month) - 1);
  },
  s: function(dateObj, seconds) {
    dateObj.setSeconds(parseFloat(seconds));
  },
  u: function(_, unixMillSeconds) {
    return new Date(parseFloat(unixMillSeconds));
  },
  w: doNothing,
  y: function(dateObj, year) {
    dateObj.setFullYear(2e3 + parseFloat(year));
  }
};
var tokenRegex = {
  D: "",
  F: "",
  G: "(\\d\\d|\\d)",
  H: "(\\d\\d|\\d)",
  J: "(\\d\\d|\\d)\\w+",
  K: "",
  M: "",
  S: "(\\d\\d|\\d)",
  U: "(.+)",
  W: "(\\d\\d|\\d)",
  Y: "(\\d{4})",
  Z: "(.+)",
  d: "(\\d\\d|\\d)",
  h: "(\\d\\d|\\d)",
  i: "(\\d\\d|\\d)",
  j: "(\\d\\d|\\d)",
  l: "",
  m: "(\\d\\d|\\d)",
  n: "(\\d\\d|\\d)",
  s: "(\\d\\d|\\d)",
  u: "(.+)",
  w: "(\\d\\d|\\d)",
  y: "(\\d{2})"
};
var formats = {
  Z: function(date) {
    return date.toISOString();
  },
  D: function(date, locale, options) {
    return locale.weekdays.shorthand[formats.w(date, locale, options)];
  },
  F: function(date, locale, options) {
    return monthToStr(formats.n(date, locale, options) - 1, false, locale);
  },
  G: function(date, locale, options) {
    return pad3(formats.h(date, locale, options));
  },
  H: function(date) {
    return pad3(date.getHours());
  },
  J: function(date, locale) {
    return locale.ordinal !== void 0 ? date.getDate() + locale.ordinal(date.getDate()) : date.getDate();
  },
  K: function(date, locale) {
    return locale.amPM[int(date.getHours() > 11)];
  },
  M: function(date, locale) {
    return monthToStr(date.getMonth(), true, locale);
  },
  S: function(date) {
    return pad3(date.getSeconds());
  },
  U: function(date) {
    return date.getTime() / 1e3;
  },
  W: function(date, _, options) {
    return options.getWeek(date);
  },
  Y: function(date) {
    return pad3(date.getFullYear(), 4);
  },
  d: function(date) {
    return pad3(date.getDate());
  },
  h: function(date) {
    return date.getHours() % 12 ? date.getHours() % 12 : 12;
  },
  i: function(date) {
    return pad3(date.getMinutes());
  },
  j: function(date) {
    return date.getDate();
  },
  l: function(date, locale) {
    return locale.weekdays.longhand[date.getDay()];
  },
  m: function(date) {
    return pad3(date.getMonth() + 1);
  },
  n: function(date) {
    return date.getMonth() + 1;
  },
  s: function(date) {
    return date.getSeconds();
  },
  u: function(date) {
    return date.getTime();
  },
  w: function(date) {
    return date.getDay();
  },
  y: function(date) {
    return String(date.getFullYear()).substring(2);
  }
};

// ../node_modules/.pnpm/flatpickr@4.6.13/node_modules/flatpickr/dist/esm/utils/dates.js
var createDateFormatter = function(_a) {
  var _b = _a.config, config = _b === void 0 ? defaults2 : _b, _c = _a.l10n, l10n2 = _c === void 0 ? english : _c, _d = _a.isMobile, isMobile = _d === void 0 ? false : _d;
  return function(dateObj, frmt, overrideLocale) {
    var locale = overrideLocale || l10n2;
    if (config.formatDate !== void 0 && !isMobile) {
      return config.formatDate(dateObj, frmt, locale);
    }
    return frmt.split("").map(function(c, i, arr) {
      return formats[c] && arr[i - 1] !== "\\" ? formats[c](dateObj, locale, config) : c !== "\\" ? c : "";
    }).join("");
  };
};
var createDateParser = function(_a) {
  var _b = _a.config, config = _b === void 0 ? defaults2 : _b, _c = _a.l10n, l10n2 = _c === void 0 ? english : _c;
  return function(date, givenFormat, timeless, customLocale) {
    if (date !== 0 && !date)
      return void 0;
    var locale = customLocale || l10n2;
    var parsedDate;
    var dateOrig = date;
    if (date instanceof Date)
      parsedDate = new Date(date.getTime());
    else if (typeof date !== "string" && date.toFixed !== void 0)
      parsedDate = new Date(date);
    else if (typeof date === "string") {
      var format = givenFormat || (config || defaults2).dateFormat;
      var datestr = String(date).trim();
      if (datestr === "today") {
        parsedDate = /* @__PURE__ */ new Date();
        timeless = true;
      } else if (config && config.parseDate) {
        parsedDate = config.parseDate(date, format);
      } else if (/Z$/.test(datestr) || /GMT$/.test(datestr)) {
        parsedDate = new Date(date);
      } else {
        var matched = void 0, ops = [];
        for (var i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
          var token = format[i];
          var isBackSlash = token === "\\";
          var escaped = format[i - 1] === "\\" || isBackSlash;
          if (tokenRegex[token] && !escaped) {
            regexStr += tokenRegex[token];
            var match2 = new RegExp(regexStr).exec(date);
            if (match2 && (matched = true)) {
              ops[token !== "Y" ? "push" : "unshift"]({
                fn: revFormat[token],
                val: match2[++matchIndex]
              });
            }
          } else if (!isBackSlash)
            regexStr += ".";
        }
        parsedDate = !config || !config.noCalendar ? new Date((/* @__PURE__ */ new Date()).getFullYear(), 0, 1, 0, 0, 0, 0) : new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
        ops.forEach(function(_a2) {
          var fn = _a2.fn, val = _a2.val;
          return parsedDate = fn(parsedDate, val, locale) || parsedDate;
        });
        parsedDate = matched ? parsedDate : void 0;
      }
    }
    if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
      config.errorHandler(new Error("Invalid date provided: " + dateOrig));
      return void 0;
    }
    if (timeless === true)
      parsedDate.setHours(0, 0, 0, 0);
    return parsedDate;
  };
};
function compareDates(date1, date2, timeless) {
  if (timeless === void 0) {
    timeless = true;
  }
  if (timeless !== false) {
    return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
  }
  return date1.getTime() - date2.getTime();
}
var isBetween = function(ts, ts1, ts2) {
  return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
};
var calculateSecondsSinceMidnight = function(hours, minutes, seconds) {
  return hours * 3600 + minutes * 60 + seconds;
};
var parseSeconds = function(secondsSinceMidnight) {
  var hours = Math.floor(secondsSinceMidnight / 3600), minutes = (secondsSinceMidnight - hours * 3600) / 60;
  return [hours, minutes, secondsSinceMidnight - hours * 3600 - minutes * 60];
};
var duration = {
  DAY: 864e5
};
function getDefaultHours(config) {
  var hours = config.defaultHour;
  var minutes = config.defaultMinute;
  var seconds = config.defaultSeconds;
  if (config.minDate !== void 0) {
    var minHour = config.minDate.getHours();
    var minMinutes = config.minDate.getMinutes();
    var minSeconds = config.minDate.getSeconds();
    if (hours < minHour) {
      hours = minHour;
    }
    if (hours === minHour && minutes < minMinutes) {
      minutes = minMinutes;
    }
    if (hours === minHour && minutes === minMinutes && seconds < minSeconds)
      seconds = config.minDate.getSeconds();
  }
  if (config.maxDate !== void 0) {
    var maxHr = config.maxDate.getHours();
    var maxMinutes = config.maxDate.getMinutes();
    hours = Math.min(hours, maxHr);
    if (hours === maxHr)
      minutes = Math.min(maxMinutes, minutes);
    if (hours === maxHr && minutes === maxMinutes)
      seconds = config.maxDate.getSeconds();
  }
  return { hours, minutes, seconds };
}

// ../node_modules/.pnpm/flatpickr@4.6.13/node_modules/flatpickr/dist/esm/utils/polyfills.js
if (typeof Object.assign !== "function") {
  Object.assign = function(target) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (!target) {
      throw TypeError("Cannot convert undefined or null to object");
    }
    var _loop_1 = function(source2) {
      if (source2) {
        Object.keys(source2).forEach(function(key) {
          return target[key] = source2[key];
        });
      }
    };
    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
      var source = args_1[_a];
      _loop_1(source);
    }
    return target;
  };
}

// ../node_modules/.pnpm/flatpickr@4.6.13/node_modules/flatpickr/dist/esm/index.js
var __assign2 = function() {
  __assign2 = Object.assign || function(t2) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t2[p] = s[p];
    }
    return t2;
  };
  return __assign2.apply(this, arguments);
};
var __spreadArrays = function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r2 = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r2[k] = a[j];
  return r2;
};
var DEBOUNCED_CHANGE_MS = 300;
function FlatpickrInstance(element, instanceConfig) {
  var self2 = {
    config: __assign2(__assign2({}, defaults2), flatpickr.defaultConfig),
    l10n: default_default
  };
  self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
  self2._handlers = [];
  self2.pluginElements = [];
  self2.loadedPlugins = [];
  self2._bind = bind2;
  self2._setHoursFromDate = setHoursFromDate;
  self2._positionCalendar = positionCalendar;
  self2.changeMonth = changeMonth;
  self2.changeYear = changeYear;
  self2.clear = clear;
  self2.close = close;
  self2.onMouseOver = onMouseOver;
  self2._createElement = createElement2;
  self2.createDay = createDay;
  self2.destroy = destroy;
  self2.isEnabled = isEnabled;
  self2.jumpToDate = jumpToDate;
  self2.updateValue = updateValue;
  self2.open = open;
  self2.redraw = redraw;
  self2.set = set2;
  self2.setDate = setDate;
  self2.toggle = toggle;
  function setupHelperFunctions() {
    self2.utils = {
      getDaysInMonth: function(month, yr) {
        if (month === void 0) {
          month = self2.currentMonth;
        }
        if (yr === void 0) {
          yr = self2.currentYear;
        }
        if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0))
          return 29;
        return self2.l10n.daysInMonth[month];
      }
    };
  }
  function init() {
    self2.element = self2.input = element;
    self2.isOpen = false;
    parseConfig();
    setupLocale();
    setupInputs();
    setupDates();
    setupHelperFunctions();
    if (!self2.isMobile)
      build();
    bindEvents();
    if (self2.selectedDates.length || self2.config.noCalendar) {
      if (self2.config.enableTime) {
        setHoursFromDate(self2.config.noCalendar ? self2.latestSelectedDateObj : void 0);
      }
      updateValue(false);
    }
    setCalendarWidth();
    var isSafari2 = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    if (!self2.isMobile && isSafari2) {
      positionCalendar();
    }
    triggerEvent("onReady");
  }
  function getClosestActiveElement() {
    var _a;
    return ((_a = self2.calendarContainer) === null || _a === void 0 ? void 0 : _a.getRootNode()).activeElement || document.activeElement;
  }
  function bindToInstance(fn) {
    return fn.bind(self2);
  }
  function setCalendarWidth() {
    var config = self2.config;
    if (config.weekNumbers === false && config.showMonths === 1) {
      return;
    } else if (config.noCalendar !== true) {
      window.requestAnimationFrame(function() {
        if (self2.calendarContainer !== void 0) {
          self2.calendarContainer.style.visibility = "hidden";
          self2.calendarContainer.style.display = "block";
        }
        if (self2.daysContainer !== void 0) {
          var daysWidth = (self2.days.offsetWidth + 1) * config.showMonths;
          self2.daysContainer.style.width = daysWidth + "px";
          self2.calendarContainer.style.width = daysWidth + (self2.weekWrapper !== void 0 ? self2.weekWrapper.offsetWidth : 0) + "px";
          self2.calendarContainer.style.removeProperty("visibility");
          self2.calendarContainer.style.removeProperty("display");
        }
      });
    }
  }
  function updateTime(e2) {
    if (self2.selectedDates.length === 0) {
      var defaultDate = self2.config.minDate === void 0 || compareDates(/* @__PURE__ */ new Date(), self2.config.minDate) >= 0 ? /* @__PURE__ */ new Date() : new Date(self2.config.minDate.getTime());
      var defaults3 = getDefaultHours(self2.config);
      defaultDate.setHours(defaults3.hours, defaults3.minutes, defaults3.seconds, defaultDate.getMilliseconds());
      self2.selectedDates = [defaultDate];
      self2.latestSelectedDateObj = defaultDate;
    }
    if (e2 !== void 0 && e2.type !== "blur") {
      timeWrapper(e2);
    }
    var prevValue = self2._input.value;
    setHoursFromInputs();
    updateValue();
    if (self2._input.value !== prevValue) {
      self2._debouncedChange();
    }
  }
  function ampm2military(hour, amPM) {
    return hour % 12 + 12 * int(amPM === self2.l10n.amPM[1]);
  }
  function military2ampm(hour) {
    switch (hour % 24) {
      case 0:
      case 12:
        return 12;
      default:
        return hour % 12;
    }
  }
  function setHoursFromInputs() {
    if (self2.hourElement === void 0 || self2.minuteElement === void 0)
      return;
    var hours = (parseInt(self2.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self2.minuteElement.value, 10) || 0) % 60, seconds = self2.secondElement !== void 0 ? (parseInt(self2.secondElement.value, 10) || 0) % 60 : 0;
    if (self2.amPM !== void 0) {
      hours = ampm2military(hours, self2.amPM.textContent);
    }
    var limitMinHours = self2.config.minTime !== void 0 || self2.config.minDate && self2.minDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.minDate, true) === 0;
    var limitMaxHours = self2.config.maxTime !== void 0 || self2.config.maxDate && self2.maxDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.maxDate, true) === 0;
    if (self2.config.maxTime !== void 0 && self2.config.minTime !== void 0 && self2.config.minTime > self2.config.maxTime) {
      var minBound = calculateSecondsSinceMidnight(self2.config.minTime.getHours(), self2.config.minTime.getMinutes(), self2.config.minTime.getSeconds());
      var maxBound = calculateSecondsSinceMidnight(self2.config.maxTime.getHours(), self2.config.maxTime.getMinutes(), self2.config.maxTime.getSeconds());
      var currentTime = calculateSecondsSinceMidnight(hours, minutes, seconds);
      if (currentTime > maxBound && currentTime < minBound) {
        var result = parseSeconds(minBound);
        hours = result[0];
        minutes = result[1];
        seconds = result[2];
      }
    } else {
      if (limitMaxHours) {
        var maxTime = self2.config.maxTime !== void 0 ? self2.config.maxTime : self2.config.maxDate;
        hours = Math.min(hours, maxTime.getHours());
        if (hours === maxTime.getHours())
          minutes = Math.min(minutes, maxTime.getMinutes());
        if (minutes === maxTime.getMinutes())
          seconds = Math.min(seconds, maxTime.getSeconds());
      }
      if (limitMinHours) {
        var minTime = self2.config.minTime !== void 0 ? self2.config.minTime : self2.config.minDate;
        hours = Math.max(hours, minTime.getHours());
        if (hours === minTime.getHours() && minutes < minTime.getMinutes())
          minutes = minTime.getMinutes();
        if (minutes === minTime.getMinutes())
          seconds = Math.max(seconds, minTime.getSeconds());
      }
    }
    setHours(hours, minutes, seconds);
  }
  function setHoursFromDate(dateObj) {
    var date = dateObj || self2.latestSelectedDateObj;
    if (date && date instanceof Date) {
      setHours(date.getHours(), date.getMinutes(), date.getSeconds());
    }
  }
  function setHours(hours, minutes, seconds) {
    if (self2.latestSelectedDateObj !== void 0) {
      self2.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
    }
    if (!self2.hourElement || !self2.minuteElement || self2.isMobile)
      return;
    self2.hourElement.value = pad3(!self2.config.time_24hr ? (12 + hours) % 12 + 12 * int(hours % 12 === 0) : hours);
    self2.minuteElement.value = pad3(minutes);
    if (self2.amPM !== void 0)
      self2.amPM.textContent = self2.l10n.amPM[int(hours >= 12)];
    if (self2.secondElement !== void 0)
      self2.secondElement.value = pad3(seconds);
  }
  function onYearInput(event) {
    var eventTarget = getEventTarget(event);
    var year = parseInt(eventTarget.value) + (event.delta || 0);
    if (year / 1e3 > 1 || event.key === "Enter" && !/[^\d]/.test(year.toString())) {
      changeYear(year);
    }
  }
  function bind2(element2, event, handler, options) {
    if (event instanceof Array)
      return event.forEach(function(ev) {
        return bind2(element2, ev, handler, options);
      });
    if (element2 instanceof Array)
      return element2.forEach(function(el) {
        return bind2(el, event, handler, options);
      });
    element2.addEventListener(event, handler, options);
    self2._handlers.push({
      remove: function() {
        return element2.removeEventListener(event, handler, options);
      }
    });
  }
  function triggerChange() {
    triggerEvent("onChange");
  }
  function bindEvents() {
    if (self2.config.wrap) {
      ["open", "close", "toggle", "clear"].forEach(function(evt) {
        Array.prototype.forEach.call(self2.element.querySelectorAll("[data-" + evt + "]"), function(el) {
          return bind2(el, "click", self2[evt]);
        });
      });
    }
    if (self2.isMobile) {
      setupMobile();
      return;
    }
    var debouncedResize = debounce4(onResize, 50);
    self2._debouncedChange = debounce4(triggerChange, DEBOUNCED_CHANGE_MS);
    if (self2.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
      bind2(self2.daysContainer, "mouseover", function(e2) {
        if (self2.config.mode === "range")
          onMouseOver(getEventTarget(e2));
      });
    bind2(self2._input, "keydown", onKeyDown);
    if (self2.calendarContainer !== void 0) {
      bind2(self2.calendarContainer, "keydown", onKeyDown);
    }
    if (!self2.config.inline && !self2.config.static)
      bind2(window, "resize", debouncedResize);
    if (window.ontouchstart !== void 0)
      bind2(window.document, "touchstart", documentClick);
    else
      bind2(window.document, "mousedown", documentClick);
    bind2(window.document, "focus", documentClick, { capture: true });
    if (self2.config.clickOpens === true) {
      bind2(self2._input, "focus", self2.open);
      bind2(self2._input, "click", self2.open);
    }
    if (self2.daysContainer !== void 0) {
      bind2(self2.monthNav, "click", onMonthNavClick);
      bind2(self2.monthNav, ["keyup", "increment"], onYearInput);
      bind2(self2.daysContainer, "click", selectDate);
    }
    if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0) {
      var selText = function(e2) {
        return getEventTarget(e2).select();
      };
      bind2(self2.timeContainer, ["increment"], updateTime);
      bind2(self2.timeContainer, "blur", updateTime, { capture: true });
      bind2(self2.timeContainer, "click", timeIncrement);
      bind2([self2.hourElement, self2.minuteElement], ["focus", "click"], selText);
      if (self2.secondElement !== void 0)
        bind2(self2.secondElement, "focus", function() {
          return self2.secondElement && self2.secondElement.select();
        });
      if (self2.amPM !== void 0) {
        bind2(self2.amPM, "click", function(e2) {
          updateTime(e2);
        });
      }
    }
    if (self2.config.allowInput) {
      bind2(self2._input, "blur", onBlur);
    }
  }
  function jumpToDate(jumpDate, triggerChange2) {
    var jumpTo = jumpDate !== void 0 ? self2.parseDate(jumpDate) : self2.latestSelectedDateObj || (self2.config.minDate && self2.config.minDate > self2.now ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate < self2.now ? self2.config.maxDate : self2.now);
    var oldYear = self2.currentYear;
    var oldMonth = self2.currentMonth;
    try {
      if (jumpTo !== void 0) {
        self2.currentYear = jumpTo.getFullYear();
        self2.currentMonth = jumpTo.getMonth();
      }
    } catch (e2) {
      e2.message = "Invalid date supplied: " + jumpTo;
      self2.config.errorHandler(e2);
    }
    if (triggerChange2 && self2.currentYear !== oldYear) {
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
    if (triggerChange2 && (self2.currentYear !== oldYear || self2.currentMonth !== oldMonth)) {
      triggerEvent("onMonthChange");
    }
    self2.redraw();
  }
  function timeIncrement(e2) {
    var eventTarget = getEventTarget(e2);
    if (~eventTarget.className.indexOf("arrow"))
      incrementNumInput(e2, eventTarget.classList.contains("arrowUp") ? 1 : -1);
  }
  function incrementNumInput(e2, delta, inputElem) {
    var target = e2 && getEventTarget(e2);
    var input = inputElem || target && target.parentNode && target.parentNode.firstChild;
    var event = createEvent("increment");
    event.delta = delta;
    input && input.dispatchEvent(event);
  }
  function build() {
    var fragment = window.document.createDocumentFragment();
    self2.calendarContainer = createElement2("div", "flatpickr-calendar");
    self2.calendarContainer.tabIndex = -1;
    if (!self2.config.noCalendar) {
      fragment.appendChild(buildMonthNav());
      self2.innerContainer = createElement2("div", "flatpickr-innerContainer");
      if (self2.config.weekNumbers) {
        var _a = buildWeeks(), weekWrapper = _a.weekWrapper, weekNumbers = _a.weekNumbers;
        self2.innerContainer.appendChild(weekWrapper);
        self2.weekNumbers = weekNumbers;
        self2.weekWrapper = weekWrapper;
      }
      self2.rContainer = createElement2("div", "flatpickr-rContainer");
      self2.rContainer.appendChild(buildWeekdays());
      if (!self2.daysContainer) {
        self2.daysContainer = createElement2("div", "flatpickr-days");
        self2.daysContainer.tabIndex = -1;
      }
      buildDays();
      self2.rContainer.appendChild(self2.daysContainer);
      self2.innerContainer.appendChild(self2.rContainer);
      fragment.appendChild(self2.innerContainer);
    }
    if (self2.config.enableTime) {
      fragment.appendChild(buildTime());
    }
    toggleClass2(self2.calendarContainer, "rangeMode", self2.config.mode === "range");
    toggleClass2(self2.calendarContainer, "animate", self2.config.animate === true);
    toggleClass2(self2.calendarContainer, "multiMonth", self2.config.showMonths > 1);
    self2.calendarContainer.appendChild(fragment);
    var customAppend = self2.config.appendTo !== void 0 && self2.config.appendTo.nodeType !== void 0;
    if (self2.config.inline || self2.config.static) {
      self2.calendarContainer.classList.add(self2.config.inline ? "inline" : "static");
      if (self2.config.inline) {
        if (!customAppend && self2.element.parentNode)
          self2.element.parentNode.insertBefore(self2.calendarContainer, self2._input.nextSibling);
        else if (self2.config.appendTo !== void 0)
          self2.config.appendTo.appendChild(self2.calendarContainer);
      }
      if (self2.config.static) {
        var wrapper = createElement2("div", "flatpickr-wrapper");
        if (self2.element.parentNode)
          self2.element.parentNode.insertBefore(wrapper, self2.element);
        wrapper.appendChild(self2.element);
        if (self2.altInput)
          wrapper.appendChild(self2.altInput);
        wrapper.appendChild(self2.calendarContainer);
      }
    }
    if (!self2.config.static && !self2.config.inline)
      (self2.config.appendTo !== void 0 ? self2.config.appendTo : window.document.body).appendChild(self2.calendarContainer);
  }
  function createDay(className, date, _dayNumber, i) {
    var dateIsEnabled = isEnabled(date, true), dayElement = createElement2("span", className, date.getDate().toString());
    dayElement.dateObj = date;
    dayElement.$i = i;
    dayElement.setAttribute("aria-label", self2.formatDate(date, self2.config.ariaDateFormat));
    if (className.indexOf("hidden") === -1 && compareDates(date, self2.now) === 0) {
      self2.todayDateElem = dayElement;
      dayElement.classList.add("today");
      dayElement.setAttribute("aria-current", "date");
    }
    if (dateIsEnabled) {
      dayElement.tabIndex = -1;
      if (isDateSelected(date)) {
        dayElement.classList.add("selected");
        self2.selectedDateElem = dayElement;
        if (self2.config.mode === "range") {
          toggleClass2(dayElement, "startRange", self2.selectedDates[0] && compareDates(date, self2.selectedDates[0], true) === 0);
          toggleClass2(dayElement, "endRange", self2.selectedDates[1] && compareDates(date, self2.selectedDates[1], true) === 0);
          if (className === "nextMonthDay")
            dayElement.classList.add("inRange");
        }
      }
    } else {
      dayElement.classList.add("flatpickr-disabled");
    }
    if (self2.config.mode === "range") {
      if (isDateInRange(date) && !isDateSelected(date))
        dayElement.classList.add("inRange");
    }
    if (self2.weekNumbers && self2.config.showMonths === 1 && className !== "prevMonthDay" && i % 7 === 6) {
      self2.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self2.config.getWeek(date) + "</span>");
    }
    triggerEvent("onDayCreate", dayElement);
    return dayElement;
  }
  function focusOnDayElem(targetNode) {
    targetNode.focus();
    if (self2.config.mode === "range")
      onMouseOver(targetNode);
  }
  function getFirstAvailableDay(delta) {
    var startMonth = delta > 0 ? 0 : self2.config.showMonths - 1;
    var endMonth = delta > 0 ? self2.config.showMonths : -1;
    for (var m = startMonth; m != endMonth; m += delta) {
      var month = self2.daysContainer.children[m];
      var startIndex = delta > 0 ? 0 : month.children.length - 1;
      var endIndex = delta > 0 ? month.children.length : -1;
      for (var i = startIndex; i != endIndex; i += delta) {
        var c = month.children[i];
        if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj))
          return c;
      }
    }
    return void 0;
  }
  function getNextAvailableDay(current, delta) {
    var givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self2.currentMonth;
    var endMonth = delta > 0 ? self2.config.showMonths : -1;
    var loopDelta = delta > 0 ? 1 : -1;
    for (var m = givenMonth - self2.currentMonth; m != endMonth; m += loopDelta) {
      var month = self2.daysContainer.children[m];
      var startIndex = givenMonth - self2.currentMonth === m ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
      var numMonthDays = month.children.length;
      for (var i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {
        var c = month.children[i];
        if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj) && Math.abs(current.$i - i) >= Math.abs(delta))
          return focusOnDayElem(c);
      }
    }
    self2.changeMonth(loopDelta);
    focusOnDay(getFirstAvailableDay(loopDelta), 0);
    return void 0;
  }
  function focusOnDay(current, offset5) {
    var activeElement2 = getClosestActiveElement();
    var dayFocused = isInView(activeElement2 || document.body);
    var startElem = current !== void 0 ? current : dayFocused ? activeElement2 : self2.selectedDateElem !== void 0 && isInView(self2.selectedDateElem) ? self2.selectedDateElem : self2.todayDateElem !== void 0 && isInView(self2.todayDateElem) ? self2.todayDateElem : getFirstAvailableDay(offset5 > 0 ? 1 : -1);
    if (startElem === void 0) {
      self2._input.focus();
    } else if (!dayFocused) {
      focusOnDayElem(startElem);
    } else {
      getNextAvailableDay(startElem, offset5);
    }
  }
  function buildMonthDays(year, month) {
    var firstOfMonth = (new Date(year, month, 1).getDay() - self2.l10n.firstDayOfWeek + 7) % 7;
    var prevMonthDays = self2.utils.getDaysInMonth((month - 1 + 12) % 12, year);
    var daysInMonth = self2.utils.getDaysInMonth(month, year), days = window.document.createDocumentFragment(), isMultiMonth = self2.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
    var dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
    for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day " + prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
    }
    for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day", new Date(year, month, dayNumber), dayNumber, dayIndex));
    }
    for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth && (self2.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day " + nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
    }
    var dayContainer = createElement2("div", "dayContainer");
    dayContainer.appendChild(days);
    return dayContainer;
  }
  function buildDays() {
    if (self2.daysContainer === void 0) {
      return;
    }
    clearNode(self2.daysContainer);
    if (self2.weekNumbers)
      clearNode(self2.weekNumbers);
    var frag = document.createDocumentFragment();
    for (var i = 0; i < self2.config.showMonths; i++) {
      var d = new Date(self2.currentYear, self2.currentMonth, 1);
      d.setMonth(self2.currentMonth + i);
      frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
    }
    self2.daysContainer.appendChild(frag);
    self2.days = self2.daysContainer.firstChild;
    if (self2.config.mode === "range" && self2.selectedDates.length === 1) {
      onMouseOver();
    }
  }
  function buildMonthSwitch() {
    if (self2.config.showMonths > 1 || self2.config.monthSelectorType !== "dropdown")
      return;
    var shouldBuildMonth = function(month2) {
      if (self2.config.minDate !== void 0 && self2.currentYear === self2.config.minDate.getFullYear() && month2 < self2.config.minDate.getMonth()) {
        return false;
      }
      return !(self2.config.maxDate !== void 0 && self2.currentYear === self2.config.maxDate.getFullYear() && month2 > self2.config.maxDate.getMonth());
    };
    self2.monthsDropdownContainer.tabIndex = -1;
    self2.monthsDropdownContainer.innerHTML = "";
    for (var i = 0; i < 12; i++) {
      if (!shouldBuildMonth(i))
        continue;
      var month = createElement2("option", "flatpickr-monthDropdown-month");
      month.value = new Date(self2.currentYear, i).getMonth().toString();
      month.textContent = monthToStr(i, self2.config.shorthandCurrentMonth, self2.l10n);
      month.tabIndex = -1;
      if (self2.currentMonth === i) {
        month.selected = true;
      }
      self2.monthsDropdownContainer.appendChild(month);
    }
  }
  function buildMonth() {
    var container = createElement2("div", "flatpickr-month");
    var monthNavFragment = window.document.createDocumentFragment();
    var monthElement;
    if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
      monthElement = createElement2("span", "cur-month");
    } else {
      self2.monthsDropdownContainer = createElement2("select", "flatpickr-monthDropdown-months");
      self2.monthsDropdownContainer.setAttribute("aria-label", self2.l10n.monthAriaLabel);
      bind2(self2.monthsDropdownContainer, "change", function(e2) {
        var target = getEventTarget(e2);
        var selectedMonth = parseInt(target.value, 10);
        self2.changeMonth(selectedMonth - self2.currentMonth);
        triggerEvent("onMonthChange");
      });
      buildMonthSwitch();
      monthElement = self2.monthsDropdownContainer;
    }
    var yearInput = createNumberInput("cur-year", { tabindex: "-1" });
    var yearElement = yearInput.getElementsByTagName("input")[0];
    yearElement.setAttribute("aria-label", self2.l10n.yearAriaLabel);
    if (self2.config.minDate) {
      yearElement.setAttribute("min", self2.config.minDate.getFullYear().toString());
    }
    if (self2.config.maxDate) {
      yearElement.setAttribute("max", self2.config.maxDate.getFullYear().toString());
      yearElement.disabled = !!self2.config.minDate && self2.config.minDate.getFullYear() === self2.config.maxDate.getFullYear();
    }
    var currentMonth = createElement2("div", "flatpickr-current-month");
    currentMonth.appendChild(monthElement);
    currentMonth.appendChild(yearInput);
    monthNavFragment.appendChild(currentMonth);
    container.appendChild(monthNavFragment);
    return {
      container,
      yearElement,
      monthElement
    };
  }
  function buildMonths() {
    clearNode(self2.monthNav);
    self2.monthNav.appendChild(self2.prevMonthNav);
    if (self2.config.showMonths) {
      self2.yearElements = [];
      self2.monthElements = [];
    }
    for (var m = self2.config.showMonths; m--; ) {
      var month = buildMonth();
      self2.yearElements.push(month.yearElement);
      self2.monthElements.push(month.monthElement);
      self2.monthNav.appendChild(month.container);
    }
    self2.monthNav.appendChild(self2.nextMonthNav);
  }
  function buildMonthNav() {
    self2.monthNav = createElement2("div", "flatpickr-months");
    self2.yearElements = [];
    self2.monthElements = [];
    self2.prevMonthNav = createElement2("span", "flatpickr-prev-month");
    self2.prevMonthNav.innerHTML = self2.config.prevArrow;
    self2.nextMonthNav = createElement2("span", "flatpickr-next-month");
    self2.nextMonthNav.innerHTML = self2.config.nextArrow;
    buildMonths();
    Object.defineProperty(self2, "_hidePrevMonthArrow", {
      get: function() {
        return self2.__hidePrevMonthArrow;
      },
      set: function(bool) {
        if (self2.__hidePrevMonthArrow !== bool) {
          toggleClass2(self2.prevMonthNav, "flatpickr-disabled", bool);
          self2.__hidePrevMonthArrow = bool;
        }
      }
    });
    Object.defineProperty(self2, "_hideNextMonthArrow", {
      get: function() {
        return self2.__hideNextMonthArrow;
      },
      set: function(bool) {
        if (self2.__hideNextMonthArrow !== bool) {
          toggleClass2(self2.nextMonthNav, "flatpickr-disabled", bool);
          self2.__hideNextMonthArrow = bool;
        }
      }
    });
    self2.currentYearElement = self2.yearElements[0];
    updateNavigationCurrentMonth();
    return self2.monthNav;
  }
  function buildTime() {
    self2.calendarContainer.classList.add("hasTime");
    if (self2.config.noCalendar)
      self2.calendarContainer.classList.add("noCalendar");
    var defaults3 = getDefaultHours(self2.config);
    self2.timeContainer = createElement2("div", "flatpickr-time");
    self2.timeContainer.tabIndex = -1;
    var separator = createElement2("span", "flatpickr-time-separator", ":");
    var hourInput = createNumberInput("flatpickr-hour", {
      "aria-label": self2.l10n.hourAriaLabel
    });
    self2.hourElement = hourInput.getElementsByTagName("input")[0];
    var minuteInput = createNumberInput("flatpickr-minute", {
      "aria-label": self2.l10n.minuteAriaLabel
    });
    self2.minuteElement = minuteInput.getElementsByTagName("input")[0];
    self2.hourElement.tabIndex = self2.minuteElement.tabIndex = -1;
    self2.hourElement.value = pad3(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getHours() : self2.config.time_24hr ? defaults3.hours : military2ampm(defaults3.hours));
    self2.minuteElement.value = pad3(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getMinutes() : defaults3.minutes);
    self2.hourElement.setAttribute("step", self2.config.hourIncrement.toString());
    self2.minuteElement.setAttribute("step", self2.config.minuteIncrement.toString());
    self2.hourElement.setAttribute("min", self2.config.time_24hr ? "0" : "1");
    self2.hourElement.setAttribute("max", self2.config.time_24hr ? "23" : "12");
    self2.hourElement.setAttribute("maxlength", "2");
    self2.minuteElement.setAttribute("min", "0");
    self2.minuteElement.setAttribute("max", "59");
    self2.minuteElement.setAttribute("maxlength", "2");
    self2.timeContainer.appendChild(hourInput);
    self2.timeContainer.appendChild(separator);
    self2.timeContainer.appendChild(minuteInput);
    if (self2.config.time_24hr)
      self2.timeContainer.classList.add("time24hr");
    if (self2.config.enableSeconds) {
      self2.timeContainer.classList.add("hasSeconds");
      var secondInput = createNumberInput("flatpickr-second");
      self2.secondElement = secondInput.getElementsByTagName("input")[0];
      self2.secondElement.value = pad3(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getSeconds() : defaults3.seconds);
      self2.secondElement.setAttribute("step", self2.minuteElement.getAttribute("step"));
      self2.secondElement.setAttribute("min", "0");
      self2.secondElement.setAttribute("max", "59");
      self2.secondElement.setAttribute("maxlength", "2");
      self2.timeContainer.appendChild(createElement2("span", "flatpickr-time-separator", ":"));
      self2.timeContainer.appendChild(secondInput);
    }
    if (!self2.config.time_24hr) {
      self2.amPM = createElement2("span", "flatpickr-am-pm", self2.l10n.amPM[int((self2.latestSelectedDateObj ? self2.hourElement.value : self2.config.defaultHour) > 11)]);
      self2.amPM.title = self2.l10n.toggleTitle;
      self2.amPM.tabIndex = -1;
      self2.timeContainer.appendChild(self2.amPM);
    }
    return self2.timeContainer;
  }
  function buildWeekdays() {
    if (!self2.weekdayContainer)
      self2.weekdayContainer = createElement2("div", "flatpickr-weekdays");
    else
      clearNode(self2.weekdayContainer);
    for (var i = self2.config.showMonths; i--; ) {
      var container = createElement2("div", "flatpickr-weekdaycontainer");
      self2.weekdayContainer.appendChild(container);
    }
    updateWeekdays();
    return self2.weekdayContainer;
  }
  function updateWeekdays() {
    if (!self2.weekdayContainer) {
      return;
    }
    var firstDayOfWeek = self2.l10n.firstDayOfWeek;
    var weekdays = __spreadArrays(self2.l10n.weekdays.shorthand);
    if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
      weekdays = __spreadArrays(weekdays.splice(firstDayOfWeek, weekdays.length), weekdays.splice(0, firstDayOfWeek));
    }
    for (var i = self2.config.showMonths; i--; ) {
      self2.weekdayContainer.children[i].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
    }
  }
  function buildWeeks() {
    self2.calendarContainer.classList.add("hasWeeks");
    var weekWrapper = createElement2("div", "flatpickr-weekwrapper");
    weekWrapper.appendChild(createElement2("span", "flatpickr-weekday", self2.l10n.weekAbbreviation));
    var weekNumbers = createElement2("div", "flatpickr-weeks");
    weekWrapper.appendChild(weekNumbers);
    return {
      weekWrapper,
      weekNumbers
    };
  }
  function changeMonth(value, isOffset) {
    if (isOffset === void 0) {
      isOffset = true;
    }
    var delta = isOffset ? value : value - self2.currentMonth;
    if (delta < 0 && self2._hidePrevMonthArrow === true || delta > 0 && self2._hideNextMonthArrow === true)
      return;
    self2.currentMonth += delta;
    if (self2.currentMonth < 0 || self2.currentMonth > 11) {
      self2.currentYear += self2.currentMonth > 11 ? 1 : -1;
      self2.currentMonth = (self2.currentMonth + 12) % 12;
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
    buildDays();
    triggerEvent("onMonthChange");
    updateNavigationCurrentMonth();
  }
  function clear(triggerChangeEvent, toInitial) {
    if (triggerChangeEvent === void 0) {
      triggerChangeEvent = true;
    }
    if (toInitial === void 0) {
      toInitial = true;
    }
    self2.input.value = "";
    if (self2.altInput !== void 0)
      self2.altInput.value = "";
    if (self2.mobileInput !== void 0)
      self2.mobileInput.value = "";
    self2.selectedDates = [];
    self2.latestSelectedDateObj = void 0;
    if (toInitial === true) {
      self2.currentYear = self2._initialDate.getFullYear();
      self2.currentMonth = self2._initialDate.getMonth();
    }
    if (self2.config.enableTime === true) {
      var _a = getDefaultHours(self2.config), hours = _a.hours, minutes = _a.minutes, seconds = _a.seconds;
      setHours(hours, minutes, seconds);
    }
    self2.redraw();
    if (triggerChangeEvent)
      triggerEvent("onChange");
  }
  function close() {
    self2.isOpen = false;
    if (!self2.isMobile) {
      if (self2.calendarContainer !== void 0) {
        self2.calendarContainer.classList.remove("open");
      }
      if (self2._input !== void 0) {
        self2._input.classList.remove("active");
      }
    }
    triggerEvent("onClose");
  }
  function destroy() {
    if (self2.config !== void 0)
      triggerEvent("onDestroy");
    for (var i = self2._handlers.length; i--; ) {
      self2._handlers[i].remove();
    }
    self2._handlers = [];
    if (self2.mobileInput) {
      if (self2.mobileInput.parentNode)
        self2.mobileInput.parentNode.removeChild(self2.mobileInput);
      self2.mobileInput = void 0;
    } else if (self2.calendarContainer && self2.calendarContainer.parentNode) {
      if (self2.config.static && self2.calendarContainer.parentNode) {
        var wrapper = self2.calendarContainer.parentNode;
        wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
        if (wrapper.parentNode) {
          while (wrapper.firstChild)
            wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
          wrapper.parentNode.removeChild(wrapper);
        }
      } else
        self2.calendarContainer.parentNode.removeChild(self2.calendarContainer);
    }
    if (self2.altInput) {
      self2.input.type = "text";
      if (self2.altInput.parentNode)
        self2.altInput.parentNode.removeChild(self2.altInput);
      delete self2.altInput;
    }
    if (self2.input) {
      self2.input.type = self2.input._type;
      self2.input.classList.remove("flatpickr-input");
      self2.input.removeAttribute("readonly");
    }
    [
      "_showTimeInput",
      "latestSelectedDateObj",
      "_hideNextMonthArrow",
      "_hidePrevMonthArrow",
      "__hideNextMonthArrow",
      "__hidePrevMonthArrow",
      "isMobile",
      "isOpen",
      "selectedDateElem",
      "minDateHasTime",
      "maxDateHasTime",
      "days",
      "daysContainer",
      "_input",
      "_positionElement",
      "innerContainer",
      "rContainer",
      "monthNav",
      "todayDateElem",
      "calendarContainer",
      "weekdayContainer",
      "prevMonthNav",
      "nextMonthNav",
      "monthsDropdownContainer",
      "currentMonthElement",
      "currentYearElement",
      "navigationCurrentMonth",
      "selectedDateElem",
      "config"
    ].forEach(function(k) {
      try {
        delete self2[k];
      } catch (_) {
      }
    });
  }
  function isCalendarElem(elem) {
    return self2.calendarContainer.contains(elem);
  }
  function documentClick(e2) {
    if (self2.isOpen && !self2.config.inline) {
      var eventTarget_1 = getEventTarget(e2);
      var isCalendarElement = isCalendarElem(eventTarget_1);
      var isInput3 = eventTarget_1 === self2.input || eventTarget_1 === self2.altInput || self2.element.contains(eventTarget_1) || e2.path && e2.path.indexOf && (~e2.path.indexOf(self2.input) || ~e2.path.indexOf(self2.altInput));
      var lostFocus = !isInput3 && !isCalendarElement && !isCalendarElem(e2.relatedTarget);
      var isIgnored = !self2.config.ignoredFocusElements.some(function(elem) {
        return elem.contains(eventTarget_1);
      });
      if (lostFocus && isIgnored) {
        if (self2.config.allowInput) {
          self2.setDate(self2._input.value, false, self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
        }
        if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0 && self2.input.value !== "" && self2.input.value !== void 0) {
          updateTime();
        }
        self2.close();
        if (self2.config && self2.config.mode === "range" && self2.selectedDates.length === 1)
          self2.clear(false);
      }
    }
  }
  function changeYear(newYear) {
    if (!newYear || self2.config.minDate && newYear < self2.config.minDate.getFullYear() || self2.config.maxDate && newYear > self2.config.maxDate.getFullYear())
      return;
    var newYearNum = newYear, isNewYear = self2.currentYear !== newYearNum;
    self2.currentYear = newYearNum || self2.currentYear;
    if (self2.config.maxDate && self2.currentYear === self2.config.maxDate.getFullYear()) {
      self2.currentMonth = Math.min(self2.config.maxDate.getMonth(), self2.currentMonth);
    } else if (self2.config.minDate && self2.currentYear === self2.config.minDate.getFullYear()) {
      self2.currentMonth = Math.max(self2.config.minDate.getMonth(), self2.currentMonth);
    }
    if (isNewYear) {
      self2.redraw();
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
  }
  function isEnabled(date, timeless) {
    var _a;
    if (timeless === void 0) {
      timeless = true;
    }
    var dateToCheck = self2.parseDate(date, void 0, timeless);
    if (self2.config.minDate && dateToCheck && compareDates(dateToCheck, self2.config.minDate, timeless !== void 0 ? timeless : !self2.minDateHasTime) < 0 || self2.config.maxDate && dateToCheck && compareDates(dateToCheck, self2.config.maxDate, timeless !== void 0 ? timeless : !self2.maxDateHasTime) > 0)
      return false;
    if (!self2.config.enable && self2.config.disable.length === 0)
      return true;
    if (dateToCheck === void 0)
      return false;
    var bool = !!self2.config.enable, array = (_a = self2.config.enable) !== null && _a !== void 0 ? _a : self2.config.disable;
    for (var i = 0, d = void 0; i < array.length; i++) {
      d = array[i];
      if (typeof d === "function" && d(dateToCheck))
        return bool;
      else if (d instanceof Date && dateToCheck !== void 0 && d.getTime() === dateToCheck.getTime())
        return bool;
      else if (typeof d === "string") {
        var parsed = self2.parseDate(d, void 0, true);
        return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
      } else if (typeof d === "object" && dateToCheck !== void 0 && d.from && d.to && dateToCheck.getTime() >= d.from.getTime() && dateToCheck.getTime() <= d.to.getTime())
        return bool;
    }
    return !bool;
  }
  function isInView(elem) {
    if (self2.daysContainer !== void 0)
      return elem.className.indexOf("hidden") === -1 && elem.className.indexOf("flatpickr-disabled") === -1 && self2.daysContainer.contains(elem);
    return false;
  }
  function onBlur(e2) {
    var isInput3 = e2.target === self2._input;
    var valueChanged = self2._input.value.trimEnd() !== getDateStr();
    if (isInput3 && valueChanged && !(e2.relatedTarget && isCalendarElem(e2.relatedTarget))) {
      self2.setDate(self2._input.value, true, e2.target === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
    }
  }
  function onKeyDown(e2) {
    var eventTarget = getEventTarget(e2);
    var isInput3 = self2.config.wrap ? element.contains(eventTarget) : eventTarget === self2._input;
    var allowInput = self2.config.allowInput;
    var allowKeydown = self2.isOpen && (!allowInput || !isInput3);
    var allowInlineKeydown = self2.config.inline && isInput3 && !allowInput;
    if (e2.keyCode === 13 && isInput3) {
      if (allowInput) {
        self2.setDate(self2._input.value, true, eventTarget === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
        self2.close();
        return eventTarget.blur();
      } else {
        self2.open();
      }
    } else if (isCalendarElem(eventTarget) || allowKeydown || allowInlineKeydown) {
      var isTimeObj = !!self2.timeContainer && self2.timeContainer.contains(eventTarget);
      switch (e2.keyCode) {
        case 13:
          if (isTimeObj) {
            e2.preventDefault();
            updateTime();
            focusAndClose();
          } else
            selectDate(e2);
          break;
        case 27:
          e2.preventDefault();
          focusAndClose();
          break;
        case 8:
        case 46:
          if (isInput3 && !self2.config.allowInput) {
            e2.preventDefault();
            self2.clear();
          }
          break;
        case 37:
        case 39:
          if (!isTimeObj && !isInput3) {
            e2.preventDefault();
            var activeElement2 = getClosestActiveElement();
            if (self2.daysContainer !== void 0 && (allowInput === false || activeElement2 && isInView(activeElement2))) {
              var delta_1 = e2.keyCode === 39 ? 1 : -1;
              if (!e2.ctrlKey)
                focusOnDay(void 0, delta_1);
              else {
                e2.stopPropagation();
                changeMonth(delta_1);
                focusOnDay(getFirstAvailableDay(1), 0);
              }
            }
          } else if (self2.hourElement)
            self2.hourElement.focus();
          break;
        case 38:
        case 40:
          e2.preventDefault();
          var delta = e2.keyCode === 40 ? 1 : -1;
          if (self2.daysContainer && eventTarget.$i !== void 0 || eventTarget === self2.input || eventTarget === self2.altInput) {
            if (e2.ctrlKey) {
              e2.stopPropagation();
              changeYear(self2.currentYear - delta);
              focusOnDay(getFirstAvailableDay(1), 0);
            } else if (!isTimeObj)
              focusOnDay(void 0, delta * 7);
          } else if (eventTarget === self2.currentYearElement) {
            changeYear(self2.currentYear - delta);
          } else if (self2.config.enableTime) {
            if (!isTimeObj && self2.hourElement)
              self2.hourElement.focus();
            updateTime(e2);
            self2._debouncedChange();
          }
          break;
        case 9:
          if (isTimeObj) {
            var elems = [
              self2.hourElement,
              self2.minuteElement,
              self2.secondElement,
              self2.amPM
            ].concat(self2.pluginElements).filter(function(x) {
              return x;
            });
            var i = elems.indexOf(eventTarget);
            if (i !== -1) {
              var target = elems[i + (e2.shiftKey ? -1 : 1)];
              e2.preventDefault();
              (target || self2._input).focus();
            }
          } else if (!self2.config.noCalendar && self2.daysContainer && self2.daysContainer.contains(eventTarget) && e2.shiftKey) {
            e2.preventDefault();
            self2._input.focus();
          }
          break;
        default:
          break;
      }
    }
    if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
      switch (e2.key) {
        case self2.l10n.amPM[0].charAt(0):
        case self2.l10n.amPM[0].charAt(0).toLowerCase():
          self2.amPM.textContent = self2.l10n.amPM[0];
          setHoursFromInputs();
          updateValue();
          break;
        case self2.l10n.amPM[1].charAt(0):
        case self2.l10n.amPM[1].charAt(0).toLowerCase():
          self2.amPM.textContent = self2.l10n.amPM[1];
          setHoursFromInputs();
          updateValue();
          break;
      }
    }
    if (isInput3 || isCalendarElem(eventTarget)) {
      triggerEvent("onKeyDown", e2);
    }
  }
  function onMouseOver(elem, cellClass) {
    if (cellClass === void 0) {
      cellClass = "flatpickr-day";
    }
    if (self2.selectedDates.length !== 1 || elem && (!elem.classList.contains(cellClass) || elem.classList.contains("flatpickr-disabled")))
      return;
    var hoverDate = elem ? elem.dateObj.getTime() : self2.days.firstElementChild.dateObj.getTime(), initialDate = self2.parseDate(self2.selectedDates[0], void 0, true).getTime(), rangeStartDate = Math.min(hoverDate, self2.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self2.selectedDates[0].getTime());
    var containsDisabled = false;
    var minRange = 0, maxRange = 0;
    for (var t2 = rangeStartDate; t2 < rangeEndDate; t2 += duration.DAY) {
      if (!isEnabled(new Date(t2), true)) {
        containsDisabled = containsDisabled || t2 > rangeStartDate && t2 < rangeEndDate;
        if (t2 < initialDate && (!minRange || t2 > minRange))
          minRange = t2;
        else if (t2 > initialDate && (!maxRange || t2 < maxRange))
          maxRange = t2;
      }
    }
    var hoverableCells = Array.from(self2.rContainer.querySelectorAll("*:nth-child(-n+" + self2.config.showMonths + ") > ." + cellClass));
    hoverableCells.forEach(function(dayElem) {
      var date = dayElem.dateObj;
      var timestamp = date.getTime();
      var outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;
      if (outOfRange) {
        dayElem.classList.add("notAllowed");
        ["inRange", "startRange", "endRange"].forEach(function(c) {
          dayElem.classList.remove(c);
        });
        return;
      } else if (containsDisabled && !outOfRange)
        return;
      ["startRange", "inRange", "endRange", "notAllowed"].forEach(function(c) {
        dayElem.classList.remove(c);
      });
      if (elem !== void 0) {
        elem.classList.add(hoverDate <= self2.selectedDates[0].getTime() ? "startRange" : "endRange");
        if (initialDate < hoverDate && timestamp === initialDate)
          dayElem.classList.add("startRange");
        else if (initialDate > hoverDate && timestamp === initialDate)
          dayElem.classList.add("endRange");
        if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && isBetween(timestamp, initialDate, hoverDate))
          dayElem.classList.add("inRange");
      }
    });
  }
  function onResize() {
    if (self2.isOpen && !self2.config.static && !self2.config.inline)
      positionCalendar();
  }
  function open(e2, positionElement) {
    if (positionElement === void 0) {
      positionElement = self2._positionElement;
    }
    if (self2.isMobile === true) {
      if (e2) {
        e2.preventDefault();
        var eventTarget = getEventTarget(e2);
        if (eventTarget) {
          eventTarget.blur();
        }
      }
      if (self2.mobileInput !== void 0) {
        self2.mobileInput.focus();
        self2.mobileInput.click();
      }
      triggerEvent("onOpen");
      return;
    } else if (self2._input.disabled || self2.config.inline) {
      return;
    }
    var wasOpen = self2.isOpen;
    self2.isOpen = true;
    if (!wasOpen) {
      self2.calendarContainer.classList.add("open");
      self2._input.classList.add("active");
      triggerEvent("onOpen");
      positionCalendar(positionElement);
    }
    if (self2.config.enableTime === true && self2.config.noCalendar === true) {
      if (self2.config.allowInput === false && (e2 === void 0 || !self2.timeContainer.contains(e2.relatedTarget))) {
        setTimeout(function() {
          return self2.hourElement.select();
        }, 50);
      }
    }
  }
  function minMaxDateSetter(type) {
    return function(date) {
      var dateObj = self2.config["_" + type + "Date"] = self2.parseDate(date, self2.config.dateFormat);
      var inverseDateObj = self2.config["_" + (type === "min" ? "max" : "min") + "Date"];
      if (dateObj !== void 0) {
        self2[type === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
      }
      if (self2.selectedDates) {
        self2.selectedDates = self2.selectedDates.filter(function(d) {
          return isEnabled(d);
        });
        if (!self2.selectedDates.length && type === "min")
          setHoursFromDate(dateObj);
        updateValue();
      }
      if (self2.daysContainer) {
        redraw();
        if (dateObj !== void 0)
          self2.currentYearElement[type] = dateObj.getFullYear().toString();
        else
          self2.currentYearElement.removeAttribute(type);
        self2.currentYearElement.disabled = !!inverseDateObj && dateObj !== void 0 && inverseDateObj.getFullYear() === dateObj.getFullYear();
      }
    };
  }
  function parseConfig() {
    var boolOpts = [
      "wrap",
      "weekNumbers",
      "allowInput",
      "allowInvalidPreload",
      "clickOpens",
      "time_24hr",
      "enableTime",
      "noCalendar",
      "altInput",
      "shorthandCurrentMonth",
      "inline",
      "static",
      "enableSeconds",
      "disableMobile"
    ];
    var userConfig = __assign2(__assign2({}, JSON.parse(JSON.stringify(element.dataset || {}))), instanceConfig);
    var formats2 = {};
    self2.config.parseDate = userConfig.parseDate;
    self2.config.formatDate = userConfig.formatDate;
    Object.defineProperty(self2.config, "enable", {
      get: function() {
        return self2.config._enable;
      },
      set: function(dates) {
        self2.config._enable = parseDateRules(dates);
      }
    });
    Object.defineProperty(self2.config, "disable", {
      get: function() {
        return self2.config._disable;
      },
      set: function(dates) {
        self2.config._disable = parseDateRules(dates);
      }
    });
    var timeMode = userConfig.mode === "time";
    if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
      var defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults2.dateFormat;
      formats2.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
    }
    if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
      var defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults2.altFormat;
      formats2.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
    }
    Object.defineProperty(self2.config, "minDate", {
      get: function() {
        return self2.config._minDate;
      },
      set: minMaxDateSetter("min")
    });
    Object.defineProperty(self2.config, "maxDate", {
      get: function() {
        return self2.config._maxDate;
      },
      set: minMaxDateSetter("max")
    });
    var minMaxTimeSetter = function(type) {
      return function(val) {
        self2.config[type === "min" ? "_minTime" : "_maxTime"] = self2.parseDate(val, "H:i:S");
      };
    };
    Object.defineProperty(self2.config, "minTime", {
      get: function() {
        return self2.config._minTime;
      },
      set: minMaxTimeSetter("min")
    });
    Object.defineProperty(self2.config, "maxTime", {
      get: function() {
        return self2.config._maxTime;
      },
      set: minMaxTimeSetter("max")
    });
    if (userConfig.mode === "time") {
      self2.config.noCalendar = true;
      self2.config.enableTime = true;
    }
    Object.assign(self2.config, formats2, userConfig);
    for (var i = 0; i < boolOpts.length; i++)
      self2.config[boolOpts[i]] = self2.config[boolOpts[i]] === true || self2.config[boolOpts[i]] === "true";
    HOOKS.filter(function(hook) {
      return self2.config[hook] !== void 0;
    }).forEach(function(hook) {
      self2.config[hook] = arrayify(self2.config[hook] || []).map(bindToInstance);
    });
    self2.isMobile = !self2.config.disableMobile && !self2.config.inline && self2.config.mode === "single" && !self2.config.disable.length && !self2.config.enable && !self2.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    for (var i = 0; i < self2.config.plugins.length; i++) {
      var pluginConf = self2.config.plugins[i](self2) || {};
      for (var key in pluginConf) {
        if (HOOKS.indexOf(key) > -1) {
          self2.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self2.config[key]);
        } else if (typeof userConfig[key] === "undefined")
          self2.config[key] = pluginConf[key];
      }
    }
    if (!userConfig.altInputClass) {
      self2.config.altInputClass = getInputElem().className + " " + self2.config.altInputClass;
    }
    triggerEvent("onParseConfig");
  }
  function getInputElem() {
    return self2.config.wrap ? element.querySelector("[data-input]") : element;
  }
  function setupLocale() {
    if (typeof self2.config.locale !== "object" && typeof flatpickr.l10ns[self2.config.locale] === "undefined")
      self2.config.errorHandler(new Error("flatpickr: invalid locale " + self2.config.locale));
    self2.l10n = __assign2(__assign2({}, flatpickr.l10ns.default), typeof self2.config.locale === "object" ? self2.config.locale : self2.config.locale !== "default" ? flatpickr.l10ns[self2.config.locale] : void 0);
    tokenRegex.D = "(" + self2.l10n.weekdays.shorthand.join("|") + ")";
    tokenRegex.l = "(" + self2.l10n.weekdays.longhand.join("|") + ")";
    tokenRegex.M = "(" + self2.l10n.months.shorthand.join("|") + ")";
    tokenRegex.F = "(" + self2.l10n.months.longhand.join("|") + ")";
    tokenRegex.K = "(" + self2.l10n.amPM[0] + "|" + self2.l10n.amPM[1] + "|" + self2.l10n.amPM[0].toLowerCase() + "|" + self2.l10n.amPM[1].toLowerCase() + ")";
    var userConfig = __assign2(__assign2({}, instanceConfig), JSON.parse(JSON.stringify(element.dataset || {})));
    if (userConfig.time_24hr === void 0 && flatpickr.defaultConfig.time_24hr === void 0) {
      self2.config.time_24hr = self2.l10n.time_24hr;
    }
    self2.formatDate = createDateFormatter(self2);
    self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
  }
  function positionCalendar(customPositionElement) {
    if (typeof self2.config.position === "function") {
      return void self2.config.position(self2, customPositionElement);
    }
    if (self2.calendarContainer === void 0)
      return;
    triggerEvent("onPreCalendarPosition");
    var positionElement = customPositionElement || self2._positionElement;
    var calendarHeight = Array.prototype.reduce.call(self2.calendarContainer.children, function(acc, child) {
      return acc + child.offsetHeight;
    }, 0), calendarWidth = self2.calendarContainer.offsetWidth, configPos = self2.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
    var top = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
    toggleClass2(self2.calendarContainer, "arrowTop", !showOnTop);
    toggleClass2(self2.calendarContainer, "arrowBottom", showOnTop);
    if (self2.config.inline)
      return;
    var left = window.pageXOffset + inputBounds.left;
    var isCenter = false;
    var isRight = false;
    if (configPosHorizontal === "center") {
      left -= (calendarWidth - inputBounds.width) / 2;
      isCenter = true;
    } else if (configPosHorizontal === "right") {
      left -= calendarWidth - inputBounds.width;
      isRight = true;
    }
    toggleClass2(self2.calendarContainer, "arrowLeft", !isCenter && !isRight);
    toggleClass2(self2.calendarContainer, "arrowCenter", isCenter);
    toggleClass2(self2.calendarContainer, "arrowRight", isRight);
    var right = window.document.body.offsetWidth - (window.pageXOffset + inputBounds.right);
    var rightMost = left + calendarWidth > window.document.body.offsetWidth;
    var centerMost = right + calendarWidth > window.document.body.offsetWidth;
    toggleClass2(self2.calendarContainer, "rightMost", rightMost);
    if (self2.config.static)
      return;
    self2.calendarContainer.style.top = top + "px";
    if (!rightMost) {
      self2.calendarContainer.style.left = left + "px";
      self2.calendarContainer.style.right = "auto";
    } else if (!centerMost) {
      self2.calendarContainer.style.left = "auto";
      self2.calendarContainer.style.right = right + "px";
    } else {
      var doc = getDocumentStyleSheet();
      if (doc === void 0)
        return;
      var bodyWidth = window.document.body.offsetWidth;
      var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
      var centerBefore = ".flatpickr-calendar.centerMost:before";
      var centerAfter = ".flatpickr-calendar.centerMost:after";
      var centerIndex = doc.cssRules.length;
      var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
      toggleClass2(self2.calendarContainer, "rightMost", false);
      toggleClass2(self2.calendarContainer, "centerMost", true);
      doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
      self2.calendarContainer.style.left = centerLeft + "px";
      self2.calendarContainer.style.right = "auto";
    }
  }
  function getDocumentStyleSheet() {
    var editableSheet = null;
    for (var i = 0; i < document.styleSheets.length; i++) {
      var sheet = document.styleSheets[i];
      if (!sheet.cssRules)
        continue;
      try {
        sheet.cssRules;
      } catch (err) {
        continue;
      }
      editableSheet = sheet;
      break;
    }
    return editableSheet != null ? editableSheet : createStyleSheet();
  }
  function createStyleSheet() {
    var style = document.createElement("style");
    document.head.appendChild(style);
    return style.sheet;
  }
  function redraw() {
    if (self2.config.noCalendar || self2.isMobile)
      return;
    buildMonthSwitch();
    updateNavigationCurrentMonth();
    buildDays();
  }
  function focusAndClose() {
    self2._input.focus();
    if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== void 0) {
      setTimeout(self2.close, 0);
    } else {
      self2.close();
    }
  }
  function selectDate(e2) {
    e2.preventDefault();
    e2.stopPropagation();
    var isSelectable = function(day) {
      return day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
    };
    var t2 = findParent(getEventTarget(e2), isSelectable);
    if (t2 === void 0)
      return;
    var target = t2;
    var selectedDate = self2.latestSelectedDateObj = new Date(target.dateObj.getTime());
    var shouldChangeMonth = (selectedDate.getMonth() < self2.currentMonth || selectedDate.getMonth() > self2.currentMonth + self2.config.showMonths - 1) && self2.config.mode !== "range";
    self2.selectedDateElem = target;
    if (self2.config.mode === "single")
      self2.selectedDates = [selectedDate];
    else if (self2.config.mode === "multiple") {
      var selectedIndex = isDateSelected(selectedDate);
      if (selectedIndex)
        self2.selectedDates.splice(parseInt(selectedIndex), 1);
      else
        self2.selectedDates.push(selectedDate);
    } else if (self2.config.mode === "range") {
      if (self2.selectedDates.length === 2) {
        self2.clear(false, false);
      }
      self2.latestSelectedDateObj = selectedDate;
      self2.selectedDates.push(selectedDate);
      if (compareDates(selectedDate, self2.selectedDates[0], true) !== 0)
        self2.selectedDates.sort(function(a, b) {
          return a.getTime() - b.getTime();
        });
    }
    setHoursFromInputs();
    if (shouldChangeMonth) {
      var isNewYear = self2.currentYear !== selectedDate.getFullYear();
      self2.currentYear = selectedDate.getFullYear();
      self2.currentMonth = selectedDate.getMonth();
      if (isNewYear) {
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
      triggerEvent("onMonthChange");
    }
    updateNavigationCurrentMonth();
    buildDays();
    updateValue();
    if (!shouldChangeMonth && self2.config.mode !== "range" && self2.config.showMonths === 1)
      focusOnDayElem(target);
    else if (self2.selectedDateElem !== void 0 && self2.hourElement === void 0) {
      self2.selectedDateElem && self2.selectedDateElem.focus();
    }
    if (self2.hourElement !== void 0)
      self2.hourElement !== void 0 && self2.hourElement.focus();
    if (self2.config.closeOnSelect) {
      var single = self2.config.mode === "single" && !self2.config.enableTime;
      var range3 = self2.config.mode === "range" && self2.selectedDates.length === 2 && !self2.config.enableTime;
      if (single || range3) {
        focusAndClose();
      }
    }
    triggerChange();
  }
  var CALLBACKS = {
    locale: [setupLocale, updateWeekdays],
    showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
    minDate: [jumpToDate],
    maxDate: [jumpToDate],
    positionElement: [updatePositionElement],
    clickOpens: [
      function() {
        if (self2.config.clickOpens === true) {
          bind2(self2._input, "focus", self2.open);
          bind2(self2._input, "click", self2.open);
        } else {
          self2._input.removeEventListener("focus", self2.open);
          self2._input.removeEventListener("click", self2.open);
        }
      }
    ]
  };
  function set2(option, value) {
    if (option !== null && typeof option === "object") {
      Object.assign(self2.config, option);
      for (var key in option) {
        if (CALLBACKS[key] !== void 0)
          CALLBACKS[key].forEach(function(x) {
            return x();
          });
      }
    } else {
      self2.config[option] = value;
      if (CALLBACKS[option] !== void 0)
        CALLBACKS[option].forEach(function(x) {
          return x();
        });
      else if (HOOKS.indexOf(option) > -1)
        self2.config[option] = arrayify(value);
    }
    self2.redraw();
    updateValue(true);
  }
  function setSelectedDate(inputDate, format) {
    var dates = [];
    if (inputDate instanceof Array)
      dates = inputDate.map(function(d) {
        return self2.parseDate(d, format);
      });
    else if (inputDate instanceof Date || typeof inputDate === "number")
      dates = [self2.parseDate(inputDate, format)];
    else if (typeof inputDate === "string") {
      switch (self2.config.mode) {
        case "single":
        case "time":
          dates = [self2.parseDate(inputDate, format)];
          break;
        case "multiple":
          dates = inputDate.split(self2.config.conjunction).map(function(date) {
            return self2.parseDate(date, format);
          });
          break;
        case "range":
          dates = inputDate.split(self2.l10n.rangeSeparator).map(function(date) {
            return self2.parseDate(date, format);
          });
          break;
        default:
          break;
      }
    } else
      self2.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
    self2.selectedDates = self2.config.allowInvalidPreload ? dates : dates.filter(function(d) {
      return d instanceof Date && isEnabled(d, false);
    });
    if (self2.config.mode === "range")
      self2.selectedDates.sort(function(a, b) {
        return a.getTime() - b.getTime();
      });
  }
  function setDate(date, triggerChange2, format) {
    if (triggerChange2 === void 0) {
      triggerChange2 = false;
    }
    if (format === void 0) {
      format = self2.config.dateFormat;
    }
    if (date !== 0 && !date || date instanceof Array && date.length === 0)
      return self2.clear(triggerChange2);
    setSelectedDate(date, format);
    self2.latestSelectedDateObj = self2.selectedDates[self2.selectedDates.length - 1];
    self2.redraw();
    jumpToDate(void 0, triggerChange2);
    setHoursFromDate();
    if (self2.selectedDates.length === 0) {
      self2.clear(false);
    }
    updateValue(triggerChange2);
    if (triggerChange2)
      triggerEvent("onChange");
  }
  function parseDateRules(arr) {
    return arr.slice().map(function(rule) {
      if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) {
        return self2.parseDate(rule, void 0, true);
      } else if (rule && typeof rule === "object" && rule.from && rule.to)
        return {
          from: self2.parseDate(rule.from, void 0),
          to: self2.parseDate(rule.to, void 0)
        };
      return rule;
    }).filter(function(x) {
      return x;
    });
  }
  function setupDates() {
    self2.selectedDates = [];
    self2.now = self2.parseDate(self2.config.now) || /* @__PURE__ */ new Date();
    var preloadedDate = self2.config.defaultDate || ((self2.input.nodeName === "INPUT" || self2.input.nodeName === "TEXTAREA") && self2.input.placeholder && self2.input.value === self2.input.placeholder ? null : self2.input.value);
    if (preloadedDate)
      setSelectedDate(preloadedDate, self2.config.dateFormat);
    self2._initialDate = self2.selectedDates.length > 0 ? self2.selectedDates[0] : self2.config.minDate && self2.config.minDate.getTime() > self2.now.getTime() ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate.getTime() < self2.now.getTime() ? self2.config.maxDate : self2.now;
    self2.currentYear = self2._initialDate.getFullYear();
    self2.currentMonth = self2._initialDate.getMonth();
    if (self2.selectedDates.length > 0)
      self2.latestSelectedDateObj = self2.selectedDates[0];
    if (self2.config.minTime !== void 0)
      self2.config.minTime = self2.parseDate(self2.config.minTime, "H:i");
    if (self2.config.maxTime !== void 0)
      self2.config.maxTime = self2.parseDate(self2.config.maxTime, "H:i");
    self2.minDateHasTime = !!self2.config.minDate && (self2.config.minDate.getHours() > 0 || self2.config.minDate.getMinutes() > 0 || self2.config.minDate.getSeconds() > 0);
    self2.maxDateHasTime = !!self2.config.maxDate && (self2.config.maxDate.getHours() > 0 || self2.config.maxDate.getMinutes() > 0 || self2.config.maxDate.getSeconds() > 0);
  }
  function setupInputs() {
    self2.input = getInputElem();
    if (!self2.input) {
      self2.config.errorHandler(new Error("Invalid input element specified"));
      return;
    }
    self2.input._type = self2.input.type;
    self2.input.type = "text";
    self2.input.classList.add("flatpickr-input");
    self2._input = self2.input;
    if (self2.config.altInput) {
      self2.altInput = createElement2(self2.input.nodeName, self2.config.altInputClass);
      self2._input = self2.altInput;
      self2.altInput.placeholder = self2.input.placeholder;
      self2.altInput.disabled = self2.input.disabled;
      self2.altInput.required = self2.input.required;
      self2.altInput.tabIndex = self2.input.tabIndex;
      self2.altInput.type = "text";
      self2.input.setAttribute("type", "hidden");
      if (!self2.config.static && self2.input.parentNode)
        self2.input.parentNode.insertBefore(self2.altInput, self2.input.nextSibling);
    }
    if (!self2.config.allowInput)
      self2._input.setAttribute("readonly", "readonly");
    updatePositionElement();
  }
  function updatePositionElement() {
    self2._positionElement = self2.config.positionElement || self2._input;
  }
  function setupMobile() {
    var inputType = self2.config.enableTime ? self2.config.noCalendar ? "time" : "datetime-local" : "date";
    self2.mobileInput = createElement2("input", self2.input.className + " flatpickr-mobile");
    self2.mobileInput.tabIndex = 1;
    self2.mobileInput.type = inputType;
    self2.mobileInput.disabled = self2.input.disabled;
    self2.mobileInput.required = self2.input.required;
    self2.mobileInput.placeholder = self2.input.placeholder;
    self2.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";
    if (self2.selectedDates.length > 0) {
      self2.mobileInput.defaultValue = self2.mobileInput.value = self2.formatDate(self2.selectedDates[0], self2.mobileFormatStr);
    }
    if (self2.config.minDate)
      self2.mobileInput.min = self2.formatDate(self2.config.minDate, "Y-m-d");
    if (self2.config.maxDate)
      self2.mobileInput.max = self2.formatDate(self2.config.maxDate, "Y-m-d");
    if (self2.input.getAttribute("step"))
      self2.mobileInput.step = String(self2.input.getAttribute("step"));
    self2.input.type = "hidden";
    if (self2.altInput !== void 0)
      self2.altInput.type = "hidden";
    try {
      if (self2.input.parentNode)
        self2.input.parentNode.insertBefore(self2.mobileInput, self2.input.nextSibling);
    } catch (_a) {
    }
    bind2(self2.mobileInput, "change", function(e2) {
      self2.setDate(getEventTarget(e2).value, false, self2.mobileFormatStr);
      triggerEvent("onChange");
      triggerEvent("onClose");
    });
  }
  function toggle(e2) {
    if (self2.isOpen === true)
      return self2.close();
    self2.open(e2);
  }
  function triggerEvent(event, data) {
    if (self2.config === void 0)
      return;
    var hooks = self2.config[event];
    if (hooks !== void 0 && hooks.length > 0) {
      for (var i = 0; hooks[i] && i < hooks.length; i++)
        hooks[i](self2.selectedDates, self2.input.value, self2, data);
    }
    if (event === "onChange") {
      self2.input.dispatchEvent(createEvent("change"));
      self2.input.dispatchEvent(createEvent("input"));
    }
  }
  function createEvent(name) {
    var e2 = document.createEvent("Event");
    e2.initEvent(name, true, true);
    return e2;
  }
  function isDateSelected(date) {
    for (var i = 0; i < self2.selectedDates.length; i++) {
      var selectedDate = self2.selectedDates[i];
      if (selectedDate instanceof Date && compareDates(selectedDate, date) === 0)
        return "" + i;
    }
    return false;
  }
  function isDateInRange(date) {
    if (self2.config.mode !== "range" || self2.selectedDates.length < 2)
      return false;
    return compareDates(date, self2.selectedDates[0]) >= 0 && compareDates(date, self2.selectedDates[1]) <= 0;
  }
  function updateNavigationCurrentMonth() {
    if (self2.config.noCalendar || self2.isMobile || !self2.monthNav)
      return;
    self2.yearElements.forEach(function(yearElement, i) {
      var d = new Date(self2.currentYear, self2.currentMonth, 1);
      d.setMonth(self2.currentMonth + i);
      if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
        self2.monthElements[i].textContent = monthToStr(d.getMonth(), self2.config.shorthandCurrentMonth, self2.l10n) + " ";
      } else {
        self2.monthsDropdownContainer.value = d.getMonth().toString();
      }
      yearElement.value = d.getFullYear().toString();
    });
    self2._hidePrevMonthArrow = self2.config.minDate !== void 0 && (self2.currentYear === self2.config.minDate.getFullYear() ? self2.currentMonth <= self2.config.minDate.getMonth() : self2.currentYear < self2.config.minDate.getFullYear());
    self2._hideNextMonthArrow = self2.config.maxDate !== void 0 && (self2.currentYear === self2.config.maxDate.getFullYear() ? self2.currentMonth + 1 > self2.config.maxDate.getMonth() : self2.currentYear > self2.config.maxDate.getFullYear());
  }
  function getDateStr(specificFormat) {
    var format = specificFormat || (self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
    return self2.selectedDates.map(function(dObj) {
      return self2.formatDate(dObj, format);
    }).filter(function(d, i, arr) {
      return self2.config.mode !== "range" || self2.config.enableTime || arr.indexOf(d) === i;
    }).join(self2.config.mode !== "range" ? self2.config.conjunction : self2.l10n.rangeSeparator);
  }
  function updateValue(triggerChange2) {
    if (triggerChange2 === void 0) {
      triggerChange2 = true;
    }
    if (self2.mobileInput !== void 0 && self2.mobileFormatStr) {
      self2.mobileInput.value = self2.latestSelectedDateObj !== void 0 ? self2.formatDate(self2.latestSelectedDateObj, self2.mobileFormatStr) : "";
    }
    self2.input.value = getDateStr(self2.config.dateFormat);
    if (self2.altInput !== void 0) {
      self2.altInput.value = getDateStr(self2.config.altFormat);
    }
    if (triggerChange2 !== false)
      triggerEvent("onValueUpdate");
  }
  function onMonthNavClick(e2) {
    var eventTarget = getEventTarget(e2);
    var isPrevMonth = self2.prevMonthNav.contains(eventTarget);
    var isNextMonth = self2.nextMonthNav.contains(eventTarget);
    if (isPrevMonth || isNextMonth) {
      changeMonth(isPrevMonth ? -1 : 1);
    } else if (self2.yearElements.indexOf(eventTarget) >= 0) {
      eventTarget.select();
    } else if (eventTarget.classList.contains("arrowUp")) {
      self2.changeYear(self2.currentYear + 1);
    } else if (eventTarget.classList.contains("arrowDown")) {
      self2.changeYear(self2.currentYear - 1);
    }
  }
  function timeWrapper(e2) {
    e2.preventDefault();
    var isKeyDown = e2.type === "keydown", eventTarget = getEventTarget(e2), input = eventTarget;
    if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
      self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
    }
    var min4 = parseFloat(input.getAttribute("min")), max4 = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e2.delta || (isKeyDown ? e2.which === 38 ? 1 : -1 : 0);
    var newValue = curValue + step * delta;
    if (typeof input.value !== "undefined" && input.value.length === 2) {
      var isHourElem = input === self2.hourElement, isMinuteElem = input === self2.minuteElement;
      if (newValue < min4) {
        newValue = max4 + newValue + int(!isHourElem) + (int(isHourElem) && int(!self2.amPM));
        if (isMinuteElem)
          incrementNumInput(void 0, -1, self2.hourElement);
      } else if (newValue > max4) {
        newValue = input === self2.hourElement ? newValue - max4 - int(!self2.amPM) : min4;
        if (isMinuteElem)
          incrementNumInput(void 0, 1, self2.hourElement);
      }
      if (self2.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {
        self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
      }
      input.value = pad3(newValue);
    }
  }
  init();
  return self2;
}
function _flatpickr(nodeList, config) {
  var nodes = Array.prototype.slice.call(nodeList).filter(function(x) {
    return x instanceof HTMLElement;
  });
  var instances = [];
  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    try {
      if (node.getAttribute("data-fp-omit") !== null)
        continue;
      if (node._flatpickr !== void 0) {
        node._flatpickr.destroy();
        node._flatpickr = void 0;
      }
      node._flatpickr = FlatpickrInstance(node, config || {});
      instances.push(node._flatpickr);
    } catch (e2) {
      console.error(e2);
    }
  }
  return instances.length === 1 ? instances[0] : instances;
}
if (typeof HTMLElement !== "undefined" && typeof HTMLCollection !== "undefined" && typeof NodeList !== "undefined") {
  HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function(config) {
    return _flatpickr(this, config);
  };
  HTMLElement.prototype.flatpickr = function(config) {
    return _flatpickr([this], config);
  };
}
var flatpickr = function(selector, config) {
  if (typeof selector === "string") {
    return _flatpickr(window.document.querySelectorAll(selector), config);
  } else if (selector instanceof Node) {
    return _flatpickr([selector], config);
  } else {
    return _flatpickr(selector, config);
  }
};
flatpickr.defaultConfig = {};
flatpickr.l10ns = {
  en: __assign2({}, default_default),
  default: __assign2({}, default_default)
};
flatpickr.localize = function(l10n2) {
  flatpickr.l10ns.default = __assign2(__assign2({}, flatpickr.l10ns.default), l10n2);
};
flatpickr.setDefaults = function(config) {
  flatpickr.defaultConfig = __assign2(__assign2({}, flatpickr.defaultConfig), config);
};
flatpickr.parseDate = createDateParser({});
flatpickr.formatDate = createDateFormatter({});
flatpickr.compareDates = compareDates;
if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
  jQuery.fn.flatpickr = function(config) {
    return _flatpickr(this, config);
  };
}
Date.prototype.fp_incr = function(days) {
  return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
};
if (typeof window !== "undefined") {
  window.flatpickr = flatpickr;
}
var esm_default = flatpickr;

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DatePicker/DatePicker.js
var import_l10n = __toESM(require_l10n());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DatePickerInput/DatePickerInput.js
var import_classnames70 = __toESM(require_classnames());
var import_prop_types84 = __toESM(require_prop_types());
var import_react116 = __toESM(require_react());
var DatePickerInput = import_react116.default.forwardRef(function DatePickerInput2(props, ref) {
  var _a;
  const {
    datePickerType,
    decorator,
    disabled = false,
    helperText,
    hideLabel,
    id,
    invalid = false,
    invalidText,
    labelText,
    onClick = () => {
    },
    onChange = () => {
    },
    pattern = "\\d{1,2}\\/\\d{1,2}\\/\\d{4}",
    placeholder,
    size: size6 = "md",
    slug,
    type = "text",
    warn: warn2,
    warnText,
    ...rest3
  } = props;
  const prefix = usePrefix();
  const {
    isFluid
  } = (0, import_react116.useContext)(FormContext);
  const datePickerInputInstanceId = useId();
  const datePickerInputProps = {
    id,
    onChange: (event) => {
      if (!disabled) {
        onChange(event);
      }
    },
    onClick: (event) => {
      if (!disabled) {
        onClick(event);
      }
    },
    pattern,
    placeholder,
    type
  };
  const wrapperClasses = (0, import_classnames70.default)(`${prefix}--date-picker-input__wrapper`, {
    [`${prefix}--date-picker-input__wrapper--invalid`]: invalid,
    [`${prefix}--date-picker-input__wrapper--warn`]: warn2,
    [`${prefix}--date-picker-input__wrapper--slug`]: slug,
    [`${prefix}--date-picker-input__wrapper--decorator`]: decorator
  });
  const labelClasses = (0, import_classnames70.default)(`${prefix}--label`, {
    [`${prefix}--visually-hidden`]: hideLabel,
    [`${prefix}--label--disabled`]: disabled,
    [`${prefix}--label--readonly`]: rest3.readOnly
  });
  const helperTextClasses = (0, import_classnames70.default)(`${prefix}--form__helper-text`, {
    [`${prefix}--form__helper-text--disabled`]: disabled
  });
  const inputClasses = (0, import_classnames70.default)(`${prefix}--date-picker__input`, {
    [`${prefix}--date-picker__input--${size6}`]: size6,
    [`${prefix}--date-picker__input--invalid`]: invalid,
    [`${prefix}--date-picker__input--warn`]: warn2
  });
  const containerClasses = (0, import_classnames70.default)(`${prefix}--date-picker-container`, {
    [`${prefix}--date-picker--nolabel`]: !labelText,
    [`${prefix}--date-picker--fluid--invalid`]: isFluid && invalid,
    [`${prefix}--date-picker--fluid--warn`]: isFluid && warn2
  });
  const datePickerInputHelperId = !helperText ? void 0 : `detepicker-input-helper-text-${datePickerInputInstanceId}`;
  const inputProps = {
    ...rest3,
    ...datePickerInputProps,
    className: inputClasses,
    disabled,
    ref,
    ["aria-describedby"]: helperText ? datePickerInputHelperId : void 0
  };
  if (invalid) {
    inputProps["data-invalid"] = true;
  }
  const input = import_react116.default.createElement("input", inputProps);
  let normalizedDecorator = import_react116.default.isValidElement(slug ?? decorator) ? slug ?? decorator : null;
  if (normalizedDecorator && ((_a = normalizedDecorator["type"]) == null ? void 0 : _a.displayName) === "AILabel") {
    normalizedDecorator = import_react116.default.cloneElement(normalizedDecorator, {
      size: "mini"
    });
  }
  return import_react116.default.createElement("div", {
    className: containerClasses
  }, labelText && import_react116.default.createElement(Text, {
    as: "label",
    htmlFor: id,
    className: labelClasses
  }, labelText), import_react116.default.createElement("div", {
    className: wrapperClasses
  }, import_react116.default.createElement("span", null, input, slug ? normalizedDecorator : decorator ? import_react116.default.createElement("div", {
    className: `${prefix}--date-picker-input-inner-wrapper--decorator`
  }, normalizedDecorator) : "", isFluid && import_react116.default.createElement(DatePickerIcon, {
    datePickerType
  }), import_react116.default.createElement(DatePickerIcon, {
    datePickerType,
    invalid,
    warn: warn2
  }))), invalid && import_react116.default.createElement(import_react116.default.Fragment, null, isFluid && import_react116.default.createElement("hr", {
    className: `${prefix}--date-picker__divider`
  }), import_react116.default.createElement(Text, {
    as: "div",
    className: `${prefix}--form-requirement`
  }, invalidText)), warn2 && import_react116.default.createElement(import_react116.default.Fragment, null, isFluid && import_react116.default.createElement("hr", {
    className: `${prefix}--date-picker__divider`
  }), import_react116.default.createElement(Text, {
    as: "div",
    className: `${prefix}--form-requirement`
  }, warnText)), helperText && !invalid && import_react116.default.createElement(Text, {
    as: "div",
    id: datePickerInputHelperId,
    className: helperTextClasses
  }, helperText));
});
DatePickerInput.propTypes = {
  /**
   * The type of the date picker:
   *
   * * `simple` - Without calendar dropdown.
   * * `single` - With calendar dropdown and single date.
   * * `range` - With calendar dropdown and a date range.
   */
  datePickerType: import_prop_types84.default.oneOf(["simple", "single", "range"]),
  /**
   * **Experimental**: Provide a decorator component to be rendered inside the `RadioButton` component
   */
  decorator: import_prop_types84.default.node,
  /**
   * Specify whether or not the input should be disabled
   */
  disabled: import_prop_types84.default.bool,
  /**
   * Provide text that is used alongside the control label for additional help
   */
  helperText: import_prop_types84.default.node,
  /**
   * Specify if the label should be hidden
   */
  hideLabel: import_prop_types84.default.bool,
  /**
   * Specify an id that uniquely identifies the `<input>`
   */
  id: import_prop_types84.default.string.isRequired,
  /**
   * Specify whether or not the input should be invalid
   */
  invalid: import_prop_types84.default.bool,
  /**
   * Specify the text to be rendered when the input is invalid
   */
  invalidText: import_prop_types84.default.node,
  /**
   * Provide the text that will be read by a screen reader when visiting this
   * control
   */
  labelText: import_prop_types84.default.node.isRequired,
  /**
   * Specify an `onChange` handler that is called whenever a change in the
   * input field has occurred
   */
  onChange: import_prop_types84.default.func,
  /**
   * Provide a function to be called when the input field is clicked
   */
  onClick: import_prop_types84.default.func,
  /**
   * Provide a regular expression that the input value must match
   */
  pattern: (props, propName, componentName) => {
    if (props[propName] === void 0) {
      return;
    }
    try {
      new RegExp(props[propName]);
    } catch (e2) {
      return new Error(`Invalid value of prop '${propName}' supplied to '${componentName}', it should be a valid regular expression`);
    }
  },
  /**
   * Specify the placeholder text
   */
  placeholder: import_prop_types84.default.string,
  /**
   * whether the DatePicker is to be readOnly
   */
  readOnly: import_prop_types84.default.bool,
  /**
   * Specify the size of the Date Picker Input. Currently supports either `sm`, `md`, or `lg` as an option.
   */
  size: import_prop_types84.default.oneOf(["sm", "md", "lg"]),
  slug: deprecate(import_prop_types84.default.node, "The `slug` prop has been deprecated and will be removed in the next major version. Use the decorator prop instead."),
  /**
   * Specify the type of the `<input>`
   */
  type: import_prop_types84.default.string,
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types84.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types84.default.node
};
function DatePickerIcon(_ref) {
  let {
    datePickerType,
    invalid,
    warn: warn2
  } = _ref;
  const prefix = usePrefix();
  const {
    isFluid
  } = (0, import_react116.useContext)(FormContext);
  if (datePickerType === "simple" && !invalid && !warn2) {
    if (!isFluid) {
      return null;
    }
  }
  if (invalid) {
    return import_react116.default.createElement(WarningFilled, {
      className: `${prefix}--date-picker__icon ${prefix}--date-picker__icon--invalid`
    });
  }
  if (!invalid && warn2) {
    return import_react116.default.createElement(WarningAltFilled, {
      className: `${prefix}--date-picker__icon ${prefix}--date-picker__icon--warn`
    });
  }
  return import_react116.default.createElement(Calendar, {
    className: `${prefix}--date-picker__icon`,
    role: "img",
    "aria-hidden": "true"
  });
}
DatePickerIcon.propTypes = {
  /**
   * The type of the date picker:
   *
   * * `simple` - Without calendar dropdown.
   * * `single` - With calendar dropdown and single date.
   * * `range` - With calendar dropdown and a date range.
   */
  datePickerType: import_prop_types84.default.oneOf(["simple", "single", "range"]),
  /**
   * Specify whether or not the input should be invalid
   */
  invalid: import_prop_types84.default.bool,
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types84.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DatePicker/plugins/appendToPlugin.js
var carbonFlatpickrAppendToPlugin = (config) => (fp) => {
  const handlePreCalendarPosition = () => {
    Promise.resolve().then(() => {
      const {
        calendarContainer,
        config: fpConfig,
        _positionElement: positionElement
      } = fp;
      const {
        appendTo
      } = fpConfig;
      const {
        left: containerLeft,
        top: containerTop
      } = appendTo.getBoundingClientRect();
      const {
        left: refLeft,
        bottom: refBottom
      } = positionElement.getBoundingClientRect();
      if ((appendTo !== appendTo.ownerDocument.body || containerLeft !== 0 || containerTop !== 0) && appendTo.ownerDocument.defaultView.getComputedStyle(appendTo).getPropertyValue("position") === "static") {
        throw new Error("Floating menu container must not have `position:static`.");
      }
      calendarContainer.style.top = `${refBottom - containerTop + 2}px`;
      calendarContainer.style.left = `${refLeft - containerLeft}px`;
    });
  };
  const register = () => {
    fp.loadedPlugins.push("carbonFlatpickrAppendToPlugin");
  };
  return {
    appendTo: config.appendTo,
    onReady: register,
    onPreCalendarPosition: handlePreCalendarPosition
  };
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DatePicker/plugins/fixEventsPlugin.js
var carbonFlatpickrFixEventsPlugin = (config) => (fp) => {
  const {
    inputFrom,
    inputTo,
    lastStartValue
  } = config;
  const handleClickOutside = (event) => {
    if (!fp.isOpen || fp.calendarContainer.contains(event.target) || event.target === inputFrom || event.target === inputTo) {
      return;
    }
    fp.close();
  };
  const handleKeydown = (event) => {
    const {
      target
    } = event;
    if (inputFrom === target || inputTo === target) {
      if (match(event, Enter)) {
        fp.setDate([inputFrom.value, inputTo && inputTo.value], true, fp.config.dateFormat);
        event.stopPropagation();
      } else if (match(event, ArrowLeft) || match(event, ArrowRight2)) {
        event.stopPropagation();
      } else if (match(event, ArrowDown)) {
        event.preventDefault();
        fp.open();
      } else if (!fp.config.allowInput) {
        event.stopPropagation();
        event.preventDefault();
      }
    }
  };
  const parseDateWithFormat = (dateStr) => fp.parseDate(dateStr, fp.config.dateFormat);
  const handleBlur = (event) => {
    const {
      target
    } = event;
    if (inputTo === target && fp.selectedDates[1]) {
      const withoutTime = (date) => date == null ? void 0 : date.setHours(0, 0, 0, 0);
      const selectedToDate = withoutTime(new Date(fp.selectedDates[1]));
      const currentValueToDate = withoutTime(parseDateWithFormat(inputTo.value));
      if (selectedToDate && currentValueToDate && selectedToDate !== currentValueToDate) {
        fp.setDate([inputFrom.value, inputTo && inputTo.value], true, fp.config.dateFormat);
      }
    }
    const isValidDate = (date) => (date == null ? void 0 : date.toString()) !== "Invalid Date";
    if (inputTo === target && fp.selectedDates.length === 1 && inputTo.value) {
      if (isValidDate(parseDateWithFormat(inputTo.value))) {
        fp.setDate([inputFrom.value, inputTo.value], true, fp.config.dateFormat);
      }
    }
    if (inputTo === target && !inputFrom.value && lastStartValue.current) {
      if (isValidDate(parseDateWithFormat(lastStartValue.current))) {
        inputFrom.value = lastStartValue.current;
        if (inputTo.value) {
          fp.setDate([inputFrom.value, inputTo.value], true, fp.config.dateFormat);
        }
      }
    }
  };
  const release = () => {
    const {
      inputFrom: inputFrom2,
      inputTo: inputTo2
    } = config;
    if (inputTo2) {
      inputTo2.removeEventListener("keydown", handleKeydown, true);
      inputTo2.removeEventListener("blur", handleBlur, true);
    }
    inputFrom2.removeEventListener("keydown", handleKeydown, true);
    document.removeEventListener("click", handleClickOutside, true);
  };
  const init = () => {
    release();
    const {
      inputFrom: inputFrom2,
      inputTo: inputTo2
    } = config;
    inputFrom2.addEventListener("keydown", handleKeydown, true);
    if (inputTo2) {
      inputTo2.addEventListener("keydown", handleKeydown, true);
      inputTo2.addEventListener("blur", handleBlur, true);
    }
    document.addEventListener("click", handleClickOutside, true);
  };
  const register = () => {
    fp.loadedPlugins.push("carbonFlatpickrFixEventsPlugin");
  };
  return {
    onReady: [register, init],
    onDestroy: [release]
  };
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DatePicker/plugins/rangePlugin.js
var import_rangePlugin = __toESM(require_rangePlugin());
var carbonFlatpickrRangePlugin = (config) => {
  const factory = (0, import_rangePlugin.default)(Object.assign({
    position: "left"
  }, config));
  return (fp) => {
    const origSetDate = fp.setDate;
    const init = () => {
      fp.setDate = function setDate(dates, triggerChange, format) {
        origSetDate.call(this, dates, triggerChange, format);
        if (!triggerChange && dates.length === 2) {
          const {
            _input: inputFrom
          } = fp;
          const {
            input: inputTo
          } = config;
          [inputFrom, inputTo].forEach((input, i) => {
            if (input) {
              input.value = !dates[i] ? "" : fp.formatDate(new Date(dates[i]), fp.config.dateFormat);
            }
          });
        }
      };
    };
    const origRangePlugin = factory(fp);
    const {
      onReady: origOnReady
    } = origRangePlugin;
    return Object.assign(origRangePlugin, {
      onReady: [init, origOnReady],
      onPreCalendarPosition() {
      }
    });
  };
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/internal/useSavedCallback.js
var import_react117 = __toESM(require_react());
function useSavedCallback(callback) {
  const savedCallback = (0, import_react117.useRef)(callback);
  (0, import_react117.useEffect)(() => {
    savedCallback.current = callback;
  });
  return (0, import_react117.useCallback)(function() {
    if (savedCallback.current) {
      return savedCallback.current(...arguments);
    }
  }, []);
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DatePicker/DatePicker.js
import_l10n.default.en.weekdays.shorthand.forEach((_day, index4) => {
  const currentDay = import_l10n.default.en.weekdays.shorthand;
  if (currentDay[index4] === "Thu" || currentDay[index4] === "Th") {
    currentDay[index4] = "Th";
  } else {
    currentDay[index4] = currentDay[index4].charAt(0);
  }
});
var forEach2 = Array.prototype.forEach;
var monthToStr2 = (monthNumber, shorthand, locale) => locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
var carbonFlatpickrMonthSelectPlugin = (config) => (fp) => {
  const setupElements = () => {
    if (!fp.monthElements) {
      return;
    }
    fp.monthElements.forEach((elem) => {
      if (!elem.parentNode) {
        return;
      }
      elem.parentNode.removeChild(elem);
    });
    fp.monthElements.splice(0, fp.monthElements.length, ...fp.monthElements.map(() => {
      const monthElement = fp._createElement("span", config.classFlatpickrCurrentMonth);
      monthElement.textContent = monthToStr2(fp.currentMonth, config.shorthand === true, fp.l10n);
      fp.yearElements[0].closest(config.selectorFlatpickrMonthYearContainer).insertBefore(monthElement, fp.yearElements[0].closest(config.selectorFlatpickrYearContainer));
      return monthElement;
    }));
  };
  const updateCurrentMonth = () => {
    if (fp.monthElements) {
      const monthStr = monthToStr2(fp.currentMonth, config.shorthand === true, fp.l10n);
      fp.yearElements.forEach((elem) => {
        const currentMonthContainer = elem.closest(config.selectorFlatpickrMonthYearContainer);
        Array.prototype.forEach.call(currentMonthContainer.querySelectorAll(".cur-month"), (monthElement) => {
          monthElement.textContent = monthStr;
        });
      });
    }
  };
  const register = () => {
    fp.loadedPlugins.push("carbonFlatpickrMonthSelectPlugin");
  };
  return {
    onMonthChange: updateCurrentMonth,
    onValueUpdate: updateCurrentMonth,
    onOpen: updateCurrentMonth,
    onReady: [setupElements, updateCurrentMonth, register]
  };
};
function isLabelTextEmpty(children) {
  return children.every((child) => !child.props.labelText);
}
var rightArrowHTML = `<svg width="16px" height="16px" viewBox="0 0 16 16">
  <polygon points="11,8 6,13 5.3,12.3 9.6,8 5.3,3.7 6,3 "/>
</svg>`;
var leftArrowHTML = `<svg width="16px" height="16px" viewBox="0 0 16 16">
  <polygon points="5,8 10,3 10.7,3.7 6.4,8 10.7,12.3 10,13 "/>
</svg>`;
function updateClassNames(calendar, prefix) {
  const calendarContainer = calendar.calendarContainer;
  const daysContainer = calendar.days;
  if (calendarContainer && daysContainer) {
    calendarContainer.classList.add(`${prefix}--date-picker__calendar`);
    calendarContainer.querySelector(".flatpickr-month").classList.add(`${prefix}--date-picker__month`);
    calendarContainer.querySelector(".flatpickr-weekdays").classList.add(`${prefix}--date-picker__weekdays`);
    calendarContainer.querySelector(".flatpickr-days").classList.add(`${prefix}--date-picker__days`);
    forEach2.call(calendarContainer.querySelectorAll(".flatpickr-weekday"), (item) => {
      const currentItem = item;
      currentItem.innerHTML = currentItem.innerHTML.replace(/\s+/g, "");
      currentItem.classList.add(`${prefix}--date-picker__weekday`);
    });
    forEach2.call(daysContainer.querySelectorAll(".flatpickr-day"), (item) => {
      item.classList.add(`${prefix}--date-picker__day`);
      item.setAttribute("role", "button");
      if (item.classList.contains("today") && calendar.selectedDates.length > 0) {
        item.classList.add("no-border");
      } else if (item.classList.contains("today") && calendar.selectedDates.length === 0) {
        item.classList.remove("no-border");
      }
    });
  }
}
var DatePicker = import_react118.default.forwardRef(function DatePicker2(_ref, ref) {
  let {
    allowInput,
    appendTo,
    children,
    className,
    closeOnSelect = true,
    dateFormat = "m/d/Y",
    datePickerType,
    disable,
    enable,
    inline: inline5,
    invalid,
    invalidText,
    warn: warn2,
    warnText,
    light = false,
    locale = "en",
    maxDate,
    minDate,
    onChange,
    onClose,
    onOpen,
    readOnly = false,
    short = false,
    value,
    parseDate: parseDateProp,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const {
    isFluid
  } = (0, import_react118.useContext)(FormContext);
  const [hasInput, setHasInput] = (0, import_react118.useState)(false);
  const startInputField = (0, import_react118.useCallback)((node) => {
    if (node !== null) {
      startInputField.current = node;
      setHasInput(true);
    }
  }, []);
  const lastStartValue = (0, import_react118.useRef)("");
  const [calendarCloseEvent, setCalendarCloseEvent] = (0, import_react118.useState)(null);
  const handleCalendarClose = (0, import_react118.useCallback)((selectedDates, dateStr, instance) => {
    var _a;
    if (lastStartValue.current && selectedDates[0] && !startInputField.current.value) {
      startInputField.current.value = lastStartValue.current;
      calendarRef.current.setDate([startInputField.current.value, (_a = endInputField == null ? void 0 : endInputField.current) == null ? void 0 : _a.value], true, calendarRef.current.config.dateFormat);
    }
    if (onClose) {
      onClose(selectedDates, dateStr, instance);
    }
  }, [onClose]);
  const onCalendarClose = (selectedDates, dateStr, instance, e2) => {
    if (e2 && e2.type === "clickOutside") {
      return;
    }
    setCalendarCloseEvent({
      selectedDates,
      dateStr,
      instance
    });
  };
  (0, import_react118.useEffect)(() => {
    if (calendarCloseEvent) {
      const {
        selectedDates,
        dateStr,
        instance
      } = calendarCloseEvent;
      handleCalendarClose(selectedDates, dateStr, instance);
      setCalendarCloseEvent(null);
    }
  }, [calendarCloseEvent, handleCalendarClose]);
  const endInputField = (0, import_react118.useRef)(null);
  const calendarRef = (0, import_react118.useRef)(null);
  const savedOnChange = useSavedCallback(onChange);
  const savedOnOpen = useSavedCallback(onOpen);
  const datePickerClasses = (0, import_classnames71.default)(`${prefix}--date-picker`, {
    [`${prefix}--date-picker--short`]: short,
    [`${prefix}--date-picker--light`]: light,
    [`${prefix}--date-picker--simple`]: datePickerType === "simple",
    [`${prefix}--date-picker--single`]: datePickerType === "single",
    [`${prefix}--date-picker--range`]: datePickerType === "range",
    [`${prefix}--date-picker--nolabel`]: datePickerType === "range" && isLabelTextEmpty(children)
  });
  const wrapperClasses = (0, import_classnames71.default)(`${prefix}--form-item`, {
    [String(className)]: className
  });
  const childrenWithProps = import_react118.default.Children.toArray(children).map((child, index4) => {
    if (index4 === 0 && child.type === import_react118.default.createElement(DatePickerInput, child.props).type) {
      return import_react118.default.cloneElement(child, {
        datePickerType,
        ref: startInputField,
        readOnly
      });
    }
    if (index4 === 1 && child.type === import_react118.default.createElement(DatePickerInput, child.props).type) {
      return import_react118.default.cloneElement(child, {
        datePickerType,
        ref: endInputField,
        readOnly
      });
    }
    if (index4 === 0) {
      return import_react118.default.cloneElement(child, {
        ref: startInputField,
        readOnly
      });
    }
    if (index4 === 1) {
      return import_react118.default.cloneElement(child, {
        ref: endInputField,
        readOnly
      });
    }
  });
  (0, import_react118.useEffect)(() => {
    if (datePickerType !== "single" && datePickerType !== "range") {
      return;
    }
    if (!startInputField.current) {
      return;
    }
    const onHook = (_electedDates, _dateStr, instance) => {
      updateClassNames(instance, prefix);
      if (startInputField == null ? void 0 : startInputField.current) {
        startInputField.current.readOnly = readOnly;
      }
      if (endInputField == null ? void 0 : endInputField.current) {
        endInputField.current.readOnly = readOnly;
      }
    };
    const enableOrDisable = enable ? "enable" : "disable";
    let enableOrDisableArr;
    if (!enable && !disable) {
      enableOrDisableArr = [];
    } else if (enable) {
      enableOrDisableArr = enable;
    } else {
      enableOrDisableArr = disable;
    }
    let localeData;
    if (typeof locale === "object") {
      const location = locale.locale ? locale.locale : "en";
      localeData = {
        ...import_l10n.default[location],
        ...locale
      };
    } else {
      localeData = import_l10n.default[locale];
    }
    let parseDate;
    if (!parseDateProp && dateFormat === "m/d/Y") {
      parseDate = (date) => {
        const month = date.split("/")[0] <= 12 && date.split("/")[0] > 0 ? parseInt(date.split("/")[0]) : 1;
        const year = parseInt(date.split("/")[2]);
        if (month && year) {
          const daysInMonth = new Date(year, month, 0).getDate();
          const day = date.split("/")[1] <= daysInMonth && date.split("/")[1] > 0 ? parseInt(date.split("/")[1]) : 1;
          return /* @__PURE__ */ new Date(`${year}/${month}/${day}`);
        } else {
          return false;
        }
      };
    } else if (parseDateProp) {
      parseDate = parseDateProp;
    }
    const {
      current: start
    } = startInputField;
    const {
      current: end
    } = endInputField;
    const flatpickerconfig = {
      inline: inline5 ?? false,
      onClose: onCalendarClose,
      disableMobile: true,
      defaultDate: value,
      closeOnSelect,
      mode: datePickerType,
      allowInput: allowInput ?? true,
      dateFormat,
      locale: localeData,
      [enableOrDisable]: enableOrDisableArr,
      minDate,
      maxDate,
      parseDate,
      plugins: [datePickerType === "range" ? carbonFlatpickrRangePlugin({
        input: endInputField.current
      }) : () => {
      }, appendTo ? carbonFlatpickrAppendToPlugin({
        appendTo
      }) : () => {
      }, carbonFlatpickrMonthSelectPlugin({
        selectorFlatpickrMonthYearContainer: ".flatpickr-current-month",
        selectorFlatpickrYearContainer: ".numInputWrapper",
        selectorFlatpickrCurrentMonth: ".cur-month",
        classFlatpickrCurrentMonth: "cur-month"
      }), carbonFlatpickrFixEventsPlugin({
        inputFrom: startInputField.current,
        inputTo: endInputField.current,
        lastStartValue
      })],
      clickOpens: !readOnly,
      noCalendar: readOnly,
      nextArrow: rightArrowHTML,
      prevArrow: leftArrowHTML,
      onChange: function() {
        if (savedOnChange && !readOnly) {
          savedOnChange(...arguments);
        }
      },
      onReady: onHook,
      onMonthChange: onHook,
      onYearChange: onHook,
      onOpen: function() {
        onHook(...arguments);
        savedOnOpen(...arguments);
      },
      onValueUpdate: onHook
    };
    const calendar = esm_default(start, flatpickerconfig);
    calendarRef.current = calendar;
    function handleArrowDown(event) {
      var _a, _b;
      if (match(event, Escape)) {
        (_a = calendar == null ? void 0 : calendar.calendarContainer) == null ? void 0 : _a.classList.remove("open");
      }
      if (match(event, ArrowDown)) {
        if (event.target == endInputField.current) {
          (_b = calendar == null ? void 0 : calendar.calendarContainer) == null ? void 0 : _b.classList.add("open");
        }
        const {
          calendarContainer,
          selectedDateElem: fpSelectedDateElem,
          todayDateElem: fptodayDateElem
        } = calendar;
        const selectedDateElem = calendarContainer.querySelector(".selected") && fpSelectedDateElem;
        const todayDateElem = calendarContainer.querySelector(".today") && fptodayDateElem;
        (selectedDateElem || todayDateElem || calendarContainer.querySelector(".flatpickr-day[tabindex]") || calendarContainer).focus();
      }
    }
    function handleOnChange(event) {
      const {
        target
      } = event;
      if (target === start) {
        lastStartValue.current = start.value;
      }
      if (start.value !== "") {
        return;
      }
      if (!calendar.selectedDates) {
        return;
      }
      if (calendar.selectedDates.length === 0) {
        return;
      }
    }
    function handleKeyPress(event) {
      if (match(event, Enter) && closeOnSelect && datePickerType == "single") {
        calendar.calendarContainer.classList.remove("open");
      }
    }
    if (start) {
      start.addEventListener("keydown", handleArrowDown);
      start.addEventListener("change", handleOnChange);
      start.addEventListener("keypress", handleKeyPress);
      if (calendar && calendar.calendarContainer) {
        calendar.calendarContainer.setAttribute("role", "application");
        calendar.calendarContainer.setAttribute("aria-label", "calendar-container");
      }
    }
    if (end) {
      end.addEventListener("keydown", handleArrowDown);
      end.addEventListener("change", handleOnChange);
      end.addEventListener("keypress", handleKeyPress);
    }
    return () => {
      if (calendar && calendar.destroy) {
        calendar.destroy();
      }
      if (value) {
        if (startInputField == null ? void 0 : startInputField.current) {
          startInputField.current.value = "";
        }
        if (endInputField == null ? void 0 : endInputField.current) {
          endInputField.current.value = "";
        }
      }
      if (start) {
        start.removeEventListener("keydown", handleArrowDown);
        start.removeEventListener("change", handleOnChange);
        start.removeEventListener("keypress", handleKeyPress);
      }
      if (end) {
        end.removeEventListener("keydown", handleArrowDown);
        end.removeEventListener("change", handleOnChange);
        end.removeEventListener("change", handleKeyPress);
      }
    };
  }, [savedOnChange, savedOnOpen, readOnly, closeOnSelect, hasInput]);
  (0, import_react118.useImperativeHandle)(ref, () => ({
    get calendar() {
      return calendarRef.current;
    }
  }));
  (0, import_react118.useEffect)(() => {
    var _a;
    if ((_a = calendarRef == null ? void 0 : calendarRef.current) == null ? void 0 : _a.set) {
      calendarRef.current.set({
        dateFormat
      });
    }
  }, [dateFormat]);
  (0, import_react118.useEffect)(() => {
    var _a;
    if ((_a = calendarRef == null ? void 0 : calendarRef.current) == null ? void 0 : _a.set) {
      calendarRef.current.set("minDate", minDate);
    }
  }, [minDate]);
  (0, import_react118.useEffect)(() => {
    var _a;
    if ((_a = calendarRef == null ? void 0 : calendarRef.current) == null ? void 0 : _a.set) {
      calendarRef.current.set("allowInput", allowInput);
    }
  }, [allowInput]);
  (0, import_react118.useEffect)(() => {
    var _a;
    if ((_a = calendarRef == null ? void 0 : calendarRef.current) == null ? void 0 : _a.set) {
      calendarRef.current.set("maxDate", maxDate);
    }
  }, [maxDate]);
  (0, import_react118.useEffect)(() => {
    var _a;
    if (((_a = calendarRef == null ? void 0 : calendarRef.current) == null ? void 0 : _a.set) && disable) {
      calendarRef.current.set("disable", disable);
    }
  }, [disable]);
  (0, import_react118.useEffect)(() => {
    var _a;
    if (((_a = calendarRef == null ? void 0 : calendarRef.current) == null ? void 0 : _a.set) && enable) {
      calendarRef.current.set("enable", enable);
    }
  }, [enable]);
  (0, import_react118.useEffect)(() => {
    var _a;
    if (((_a = calendarRef == null ? void 0 : calendarRef.current) == null ? void 0 : _a.set) && inline5) {
      calendarRef.current.set("inline", inline5);
    }
  }, [inline5]);
  (0, import_react118.useEffect)(() => {
    var _a;
    if (value === "") {
      (_a = calendarRef.current) == null ? void 0 : _a.clear();
      if (startInputField.current) {
        startInputField.current.value = "";
      }
      if (endInputField.current) {
        endInputField.current.value = "";
      }
    }
  }, [value]);
  (0, import_react118.useEffect)(() => {
    const handleMouseDown = (event) => {
      var _a;
      if (calendarRef.current && calendarRef.current.isOpen && !calendarRef.current.calendarContainer.contains(event.target) && !startInputField.current.contains(event.target) && !((_a = endInputField.current) == null ? void 0 : _a.contains(event.target))) {
        closeCalendar();
      }
    };
    const closeCalendar = (event) => {
      calendarRef.current.close();
      onCalendarClose(calendarRef.current.selectedDates, "", calendarRef.current, {
        type: "clickOutside"
      });
    };
    document.addEventListener("mousedown", handleMouseDown, true);
    return () => {
      document.removeEventListener("mousedown", handleMouseDown, true);
    };
  }, [calendarRef, startInputField, endInputField, onCalendarClose]);
  (0, import_react118.useEffect)(() => {
    var _a;
    if ((_a = calendarRef == null ? void 0 : calendarRef.current) == null ? void 0 : _a.set) {
      if (value !== void 0) {
        calendarRef.current.setDate(value);
      }
      updateClassNames(calendarRef.current, prefix);
    } else if (!calendarRef.current && value) {
      startInputField.current.value = value;
    }
  }, [value, prefix]);
  (0, import_react118.useEffect)(() => {
    if (!calendarRef.current || !startInputField.current) return;
    const handleKeyDown = (event) => {
      if (match(event, Tab) && !event.shiftKey && document.activeElement === endInputField.current && calendarRef.current.isOpen) {
        calendarRef.current.close();
        onCalendarClose(calendarRef.current.selectedDates, "", calendarRef.current, event);
      }
    };
    document.addEventListener("keydown", handleKeyDown, true);
    return () => document.removeEventListener("keydown", handleKeyDown, true);
  }, [calendarRef, startInputField, endInputField, onCalendarClose]);
  let fluidError;
  if (isFluid) {
    if (invalid) {
      fluidError = import_react118.default.createElement(import_react118.default.Fragment, null, import_react118.default.createElement(WarningFilled, {
        className: `${prefix}--date-picker__icon ${prefix}--date-picker__icon--invalid`
      }), import_react118.default.createElement("hr", {
        className: `${prefix}--date-picker__divider`
      }), import_react118.default.createElement("div", {
        className: `${prefix}--form-requirement`
      }, invalidText));
    }
    if (warn2 && !invalid) {
      fluidError = import_react118.default.createElement(import_react118.default.Fragment, null, import_react118.default.createElement(WarningAltFilled, {
        className: `${prefix}--date-picker__icon ${prefix}--date-picker__icon--warn`
      }), import_react118.default.createElement("hr", {
        className: `${prefix}--date-picker__divider`
      }), import_react118.default.createElement("div", {
        className: `${prefix}--form-requirement`
      }, warnText));
    }
  }
  return import_react118.default.createElement("div", _extends({
    className: wrapperClasses,
    ref
  }, rest3), import_react118.default.createElement("div", {
    className: datePickerClasses
  }, childrenWithProps), fluidError);
});
DatePicker.propTypes = {
  /**
   * Flatpickr prop passthrough enables direct date input, and when set to false,
   * we must clear dates manually by resetting the value prop to empty string making it a controlled input.
   */
  allowInput: import_prop_types85.default.bool,
  /**
   * The DOM element the Flatpicker should be inserted into. `<body>` by default.
   */
  appendTo: import_prop_types85.default.object,
  /**
   * The child nodes.
   */
  children: import_prop_types85.default.node,
  /**
   * The CSS class names.
   */
  className: import_prop_types85.default.string,
  /**
   * flatpickr prop passthrough. Controls whether the calendar dropdown closes upon selection.
   */
  closeOnSelect: import_prop_types85.default.bool,
  /**
   * The date format.
   */
  dateFormat: import_prop_types85.default.string,
  /**
   * The type of the date picker:
   *
   * * `simple` - Without calendar dropdown.
   * * `single` - With calendar dropdown and single date.
   * * `range` - With calendar dropdown and a date range.
   */
  datePickerType: import_prop_types85.default.oneOf(["simple", "single", "range"]),
  /**
   * The flatpickr `disable` option that allows a user to disable certain dates.
   */
  disable: import_prop_types85.default.array,
  /**
   * The flatpickr `enable` option that allows a user to enable certain dates.
   */
  enable: import_prop_types85.default.array,
  /**
   * The flatpickr `inline` option.
   */
  inline: import_prop_types85.default.bool,
  /**
   * Specify whether or not the control is invalid (Fluid only)
   */
  invalid: import_prop_types85.default.bool,
  /**
   * Provide the text that is displayed when the control is in error state (Fluid Only)
   */
  invalidText: import_prop_types85.default.node,
  /**
   * `true` to use the light version.
   */
  light: deprecate(import_prop_types85.default.bool, "The `light` prop for `DatePicker` has been deprecated in favor of the new `Layer` component. It will be removed in the next major release."),
  /**
   *  The language locale used to format the days of the week, months, and numbers. The full list of supported locales can be found here https://github.com/flatpickr/flatpickr/tree/master/src/l10n
   */
  locale: import_prop_types85.default.oneOfType([import_prop_types85.default.object, import_prop_types85.default.oneOf([
    "ar",
    // Arabic
    "at",
    // Austria
    "az",
    // Azerbaijan
    "be",
    // Belarusian
    "bg",
    // Bulgarian
    "bn",
    // Bangla
    "bs",
    // Bosnia
    "cat",
    // Catalan
    "cs",
    // Czech
    "cy",
    // Welsh
    "da",
    // Danish
    "de",
    // German
    "en",
    // English
    "eo",
    // Esperanto
    "es",
    // Spanish
    "et",
    // Estonian
    "fa",
    // Persian
    "fi",
    // Finnish
    "fo",
    // Faroese
    "fr",
    // French
    "ga",
    // Gaelic
    "gr",
    // Greek
    "he",
    // Hebrew
    "hi",
    // Hindi
    "hr",
    // Croatian
    "hu",
    // Hungarian
    "id",
    // Indonesian
    "is",
    // Icelandic
    "it",
    // Italian
    "ja",
    // Japanese
    "ka",
    // Georgian
    "km",
    // Khmer
    "ko",
    // Korean
    "kz",
    // Kazakh
    "lt",
    // Lithuanian
    "lv",
    // Latvian
    "mk",
    // Macedonian
    "mn",
    // Mongolian
    "ms",
    // Malaysian
    "my",
    // Burmese
    "nl",
    // Dutch
    "no",
    // Norwegian
    "pa",
    // Punjabi
    "pl",
    // Polish
    "pt",
    // Portuguese
    "ro",
    // Romanian
    "ru",
    // Russian
    "si",
    // Sinhala
    "sk",
    // Slovak
    "sl",
    // Slovenian
    "sq",
    // Albanian
    "sr",
    // Serbian
    "sv",
    // Swedish
    "th",
    // Thai
    "tr",
    // Turkish
    "uk",
    // Ukrainian
    "uz",
    // Uzbek
    "uz_latn",
    // Uzbek Latin
    "vn",
    // Vietnamese
    "zh_tw",
    // Mandarin Traditional
    "zh"
    // Mandarin
  ])]),
  /**
   * The maximum date that a user can pick to.
   */
  maxDate: import_prop_types85.default.oneOfType([import_prop_types85.default.string, import_prop_types85.default.number]),
  /**
   * The minimum date that a user can start picking from.
   */
  minDate: import_prop_types85.default.oneOfType([import_prop_types85.default.string, import_prop_types85.default.number]),
  /**
   * The `change` event handler.
   * `(dates: Date[], dStr: string, fp: Instance, data?: any):void;`
   */
  onChange: import_prop_types85.default.func,
  /**
   * The `close` event handler.
   * `(dates: Date[], dStr: string, fp: Instance, data?: any):void;`
   */
  onClose: import_prop_types85.default.func,
  /**
   * The `open` event handler.
   * `(dates: Date[], dStr: string, fp: Instance, data?: any):void;`
   */
  onOpen: import_prop_types85.default.func,
  /**
   * flatpickr prop passthrough. Controls how dates are parsed.
   */
  parseDate: import_prop_types85.default.func,
  /**
   * whether the DatePicker is to be readOnly
   * if boolean applies to all inputs
   * if array applies to each input in order
   */
  readOnly: import_prop_types85.default.oneOfType([import_prop_types85.default.bool, import_prop_types85.default.array]),
  /**
   * `true` to use the short version.
   */
  short: import_prop_types85.default.bool,
  /**
   * The value of the date value provided to flatpickr, could
   * be a date, a date number, a date string, an array of dates.
   */
  value: import_prop_types85.default.oneOfType([import_prop_types85.default.string, import_prop_types85.default.arrayOf(import_prop_types85.default.oneOfType([import_prop_types85.default.string, import_prop_types85.default.number, import_prop_types85.default.object])), import_prop_types85.default.object, import_prop_types85.default.number]),
  /**
   * Specify whether the control is currently in warning state (Fluid only)
   */
  warn: import_prop_types85.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state (Fluid only)
   */
  warnText: import_prop_types85.default.node
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/DatePicker/DatePicker.Skeleton.js
var import_prop_types86 = __toESM(require_prop_types());
var import_react119 = __toESM(require_react());
var import_classnames72 = __toESM(require_classnames());
var DatePickerSkeleton = (_ref) => {
  let {
    range: range3,
    id,
    hideLabel,
    className,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const dateInput = import_react119.default.createElement("div", {
    className: `${prefix}--date-picker-container`
  }, !hideLabel && import_react119.default.createElement("span", {
    className: `${prefix}--label`,
    id
  }), import_react119.default.createElement("div", {
    className: `${prefix}--date-picker__input ${prefix}--skeleton`
  }));
  if (range3) {
    return import_react119.default.createElement("div", {
      className: `${prefix}--form-item`
    }, import_react119.default.createElement("div", _extends({
      className: (0, import_classnames72.default)(`${prefix}--date-picker`, `${prefix}--date-picker--range`, `${prefix}--skeleton`, className)
    }, rest3), dateInput, dateInput));
  }
  return import_react119.default.createElement("div", {
    className: `${prefix}--form-item`
  }, import_react119.default.createElement("div", _extends({
    className: (0, import_classnames72.default)(`${prefix}--date-picker`, `${prefix}--date-picker--short`, `${prefix}--date-picker--simple`, `${prefix}--skeleton`, className)
  }, rest3), dateInput));
};
DatePickerSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types86.default.string,
  /**
   * Specify whether the label should be hidden, or not
   */
  hideLabel: import_prop_types86.default.bool,
  /**
   * Specify the id to add.
   */
  id: import_prop_types86.default.string,
  /**
   * Specify whether the skeleton should be of range date picker.
   */
  range: import_prop_types86.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Dropdown/Dropdown.js
var import_react120 = __toESM(require_react());
var import_classnames73 = __toESM(require_classnames());
var import_prop_types87 = __toESM(require_prop_types());
var {
  ItemMouseMove: ItemMouseMove3,
  MenuMouseLeave: MenuMouseLeave3
} = useSelect.stateChangeTypes;
var defaultItemToString3 = (item) => {
  if (typeof item === "string") {
    return item;
  }
  if (typeof item === "number") {
    return `${item}`;
  }
  if (item !== null && typeof item === "object" && "label" in item && typeof item["label"] === "string") {
    return item["label"];
  }
  return "";
};
function stateReducer2(state, actionAndChanges) {
  const {
    changes,
    type
  } = actionAndChanges;
  switch (type) {
    case ItemMouseMove3:
    case MenuMouseLeave3:
      if (changes.highlightedIndex === state.highlightedIndex) {
        return state;
      }
      return changes;
    default:
      return changes;
  }
}
var Dropdown = import_react120.default.forwardRef((_ref, ref) => {
  let {
    autoAlign = false,
    className: containerClassName,
    decorator,
    disabled = false,
    direction = "bottom",
    items: itemsProp,
    label,
    ["aria-label"]: ariaLabel,
    ariaLabel: deprecatedAriaLabel,
    itemToString: itemToString3 = defaultItemToString3,
    itemToElement = null,
    renderSelectedItem,
    type = "default",
    size: size$1,
    onChange,
    id,
    titleText = "",
    hideLabel,
    helperText = "",
    translateWithId: translateWithId8,
    light,
    invalid,
    invalidText,
    warn: warn2,
    warnText,
    initialSelectedItem,
    selectedItem: controlledSelectedItem,
    downshiftProps,
    readOnly,
    slug,
    ...other
  } = _ref;
  const enableFloatingStyles = useFeatureFlag("enable-v12-dynamic-floating-styles");
  const {
    refs,
    floatingStyles,
    middlewareData
  } = useFloating2(
    enableFloatingStyles || autoAlign ? {
      placement: direction,
      // The floating element is positioned relative to its nearest
      // containing block (usually the viewport). It will in many cases also
      // “break” the floating element out of a clipping ancestor.
      // https://floating-ui.com/docs/misc#clipping
      strategy: "fixed",
      // Middleware order matters, arrow should be last
      middleware: [size3({
        apply(_ref2) {
          let {
            rects,
            elements
          } = _ref2;
          Object.assign(elements.floating.style, {
            width: `${rects.reference.width}px`
          });
        }
      }), autoAlign && flip3(), autoAlign && hide5()],
      whileElementsMounted: autoUpdate
    } : {}
    // When autoAlign is turned off & the `enable-v12-dynamic-floating-styles` feature flag is not
    // enabled, floating-ui will not be used
  );
  (0, import_react120.useEffect)(() => {
    var _a;
    if (enableFloatingStyles || autoAlign) {
      const updatedFloatingStyles = {
        ...floatingStyles,
        visibility: ((_a = middlewareData.hide) == null ? void 0 : _a.referenceHidden) ? "hidden" : "visible"
      };
      Object.keys(updatedFloatingStyles).forEach((style) => {
        if (refs.floating.current) {
          refs.floating.current.style[style] = updatedFloatingStyles[style];
        }
      });
    }
  }, [floatingStyles, autoAlign, refs.floating]);
  const prefix = usePrefix();
  const {
    isFluid
  } = (0, import_react120.useContext)(FormContext);
  const onSelectedItemChange = (0, import_react120.useCallback)((_ref3) => {
    let {
      selectedItem: selectedItem2
    } = _ref3;
    if (onChange) {
      onChange({
        selectedItem: selectedItem2 ?? null
      });
    }
  }, [onChange]);
  const isItemDisabled2 = (0, import_react120.useCallback)((item, _index) => {
    const isObject2 = item !== null && typeof item === "object";
    return isObject2 && "disabled" in item && item.disabled === true;
  }, []);
  const onHighlightedIndexChange = (0, import_react120.useCallback)((changes) => {
    const {
      highlightedIndex: highlightedIndex2
    } = changes;
    if (highlightedIndex2 !== void 0 && highlightedIndex2 > -1 && typeof window !== void 0) {
      const itemArray = document.querySelectorAll(`li.${prefix}--list-box__menu-item[role="option"]`);
      const highlightedItem = itemArray[highlightedIndex2];
      if (highlightedItem) {
        highlightedItem.scrollIntoView({
          behavior: "smooth",
          block: "nearest"
        });
      }
    }
  }, [prefix]);
  const items = (0, import_react120.useMemo)(() => itemsProp, [itemsProp]);
  const selectProps = (0, import_react120.useMemo)(() => ({
    items,
    itemToString: itemToString3,
    initialSelectedItem,
    onSelectedItemChange,
    stateReducer: stateReducer2,
    isItemDisabled: isItemDisabled2,
    onHighlightedIndexChange,
    ...downshiftProps
  }), [items, itemToString3, initialSelectedItem, onSelectedItemChange, stateReducer2, isItemDisabled2, onHighlightedIndexChange, downshiftProps]);
  const dropdownInstanceId = useId();
  if (controlledSelectedItem !== void 0) {
    selectProps.selectedItem = controlledSelectedItem;
  }
  const {
    isOpen,
    getToggleButtonProps,
    getLabelProps,
    getMenuProps,
    getItemProps,
    selectedItem,
    highlightedIndex
  } = useSelect(selectProps);
  const inline5 = type === "inline";
  const showWarning = !invalid && warn2;
  const [isFocused, setIsFocused] = (0, import_react120.useState)(false);
  const className = (0, import_classnames73.default)(`${prefix}--dropdown`, {
    [`${prefix}--dropdown--invalid`]: invalid,
    [`${prefix}--dropdown--warning`]: showWarning,
    [`${prefix}--dropdown--open`]: isOpen,
    [`${prefix}--dropdown--focus`]: isFocused,
    [`${prefix}--dropdown--inline`]: inline5,
    [`${prefix}--dropdown--disabled`]: disabled,
    [`${prefix}--dropdown--light`]: light,
    [`${prefix}--dropdown--readonly`]: readOnly,
    [`${prefix}--dropdown--${size$1}`]: size$1,
    [`${prefix}--list-box--up`]: direction === "top",
    [`${prefix}--autoalign`]: autoAlign
  });
  const titleClasses = (0, import_classnames73.default)(`${prefix}--label`, {
    [`${prefix}--label--disabled`]: disabled,
    [`${prefix}--visually-hidden`]: hideLabel
  });
  const helperClasses = (0, import_classnames73.default)(`${prefix}--form__helper-text`, {
    [`${prefix}--form__helper-text--disabled`]: disabled
  });
  const wrapperClasses = (0, import_classnames73.default)(`${prefix}--dropdown__wrapper`, `${prefix}--list-box__wrapper`, containerClassName, {
    [`${prefix}--dropdown__wrapper--inline`]: inline5,
    [`${prefix}--list-box__wrapper--inline`]: inline5,
    [`${prefix}--dropdown__wrapper--inline--invalid`]: inline5 && invalid,
    [`${prefix}--list-box__wrapper--inline--invalid`]: inline5 && invalid,
    [`${prefix}--list-box__wrapper--fluid--invalid`]: isFluid && invalid,
    [`${prefix}--list-box__wrapper--slug`]: slug,
    [`${prefix}--list-box__wrapper--decorator`]: decorator
  });
  const helperId = !helperText ? void 0 : `dropdown-helper-text-${dropdownInstanceId}`;
  const ItemToElement = itemToElement;
  const toggleButtonProps = (0, import_react120.useMemo)(() => getToggleButtonProps({
    "aria-label": ariaLabel || deprecatedAriaLabel
  }), [getToggleButtonProps, ariaLabel, deprecatedAriaLabel, isOpen]);
  const helper = helperText && !isFluid ? import_react120.default.createElement("div", {
    id: helperId,
    className: helperClasses
  }, helperText) : null;
  const handleFocus = (evt) => {
    setIsFocused(evt.type === "focus" && !selectedItem ? true : false);
  };
  const mergedRef = mergeRefs$1(toggleButtonProps.ref, ref);
  const [currTimer, setCurrTimer] = (0, import_react120.useState)();
  const [isTyping, setIsTyping] = (0, import_react120.useState)(false);
  const onKeyDownHandler = (0, import_react120.useCallback)((evt) => {
    if (evt.code !== "Space" || !["ArrowDown", "ArrowUp", " ", "Enter"].includes(evt.key)) {
      setIsTyping(true);
    }
    if (isTyping && evt.code === "Space" || !["ArrowDown", "ArrowUp", " ", "Enter"].includes(evt.key)) {
      if (currTimer) {
        clearTimeout(currTimer);
      }
      setCurrTimer(setTimeout(() => {
        setIsTyping(false);
      }, 3e3));
    }
    if (["ArrowDown"].includes(evt.key)) {
      setIsFocused(false);
    }
    if (["Enter"].includes(evt.key) && !selectedItem && !isOpen) {
      setIsFocused(true);
    }
    if (toggleButtonProps.onKeyDown && (evt.key !== "ArrowUp" || isOpen && evt.key === "ArrowUp")) {
      toggleButtonProps.onKeyDown(evt);
    }
  }, [isTyping, currTimer, toggleButtonProps]);
  const readOnlyEventHandlers = (0, import_react120.useMemo)(() => {
    if (readOnly) {
      return {
        onClick: (evt) => {
          var _a;
          evt.preventDefault();
          (_a = mergedRef == null ? void 0 : mergedRef.current) == null ? void 0 : _a.focus();
        },
        onKeyDown: (evt) => {
          const selectAccessKeys = ["ArrowDown", "ArrowUp", " ", "Enter"];
          if (selectAccessKeys.includes(evt.key)) {
            evt.preventDefault();
          }
        }
      };
    } else {
      return {
        onKeyDown: onKeyDownHandler
      };
    }
  }, [readOnly, onKeyDownHandler]);
  const menuProps = (0, import_react120.useMemo)(() => getMenuProps({
    ref: enableFloatingStyles || autoAlign ? refs.setFloating : null
  }), [autoAlign, getMenuProps, refs.setFloating, enableFloatingStyles]);
  const normalizedDecorator = (0, import_react120.useMemo)(() => {
    var _a;
    let element = slug ?? decorator;
    if (element && ((_a = element["type"]) == null ? void 0 : _a.displayName) === "AILabel") {
      return import_react120.default.cloneElement(element, {
        size: "mini"
      });
    }
    return import_react120.default.isValidElement(element) ? element : null;
  }, [slug, decorator]);
  return import_react120.default.createElement("div", _extends({
    className: wrapperClasses
  }, other), titleText && import_react120.default.createElement("label", _extends({
    className: titleClasses
  }, getLabelProps()), titleText), import_react120.default.createElement(ListBox3, {
    onFocus: handleFocus,
    onBlur: handleFocus,
    size: size$1,
    className,
    invalid,
    invalidText,
    warn: warn2,
    warnText,
    light,
    isOpen,
    ref: enableFloatingStyles || autoAlign ? refs.setReference : null,
    id
  }, invalid && import_react120.default.createElement(WarningFilled, {
    className: `${prefix}--list-box__invalid-icon`
  }), showWarning && import_react120.default.createElement(WarningAltFilled, {
    className: `${prefix}--list-box__invalid-icon ${prefix}--list-box__invalid-icon--warning`
  }), import_react120.default.createElement("button", _extends({
    type: "button",
    className: `${prefix}--list-box__field`,
    disabled,
    "aria-disabled": readOnly ? true : void 0,
    "aria-describedby": !inline5 && !invalid && !warn2 && helper ? helperId : void 0,
    title: selectedItem && itemToString3 !== void 0 ? itemToString3(selectedItem) : defaultItemToString3(label)
  }, toggleButtonProps, readOnlyEventHandlers, {
    ref: mergedRef
  }), import_react120.default.createElement("span", {
    className: `${prefix}--list-box__label`
  }, selectedItem ? renderSelectedItem ? renderSelectedItem(selectedItem) : itemToString3(selectedItem) : label), import_react120.default.createElement(ListBox3.MenuIcon, {
    isOpen,
    translateWithId: translateWithId8
  })), slug ? normalizedDecorator : decorator ? import_react120.default.createElement("div", {
    className: `${prefix}--list-box__inner-wrapper--decorator`
  }, normalizedDecorator) : "", import_react120.default.createElement(ListBox3.Menu, menuProps, isOpen && items.map((item, index4) => {
    const isObject2 = item !== null && typeof item === "object";
    const itemProps = getItemProps({
      item,
      index: index4
    });
    if (item !== null && typeof item === "object" && Object.prototype.hasOwnProperty.call(item, "id")) {
      itemProps.id = item["id"];
    }
    const title = isObject2 && "text" in item && itemToElement ? item.text : itemToString3(item);
    return import_react120.default.createElement(ListBox3.MenuItem, _extends({
      key: itemProps.id,
      isActive: selectedItem === item,
      isHighlighted: highlightedIndex === index4,
      title,
      disabled: itemProps["aria-disabled"]
    }, itemProps), typeof item === "object" && ItemToElement !== void 0 && ItemToElement !== null ? import_react120.default.createElement(ItemToElement, _extends({
      key: itemProps.id
    }, item)) : itemToString3(item), selectedItem === item && import_react120.default.createElement(Checkmark, {
      className: `${prefix}--list-box__menu-item__selected-icon`
    }));
  }))), !inline5 && !invalid && !warn2 && helper);
});
Dropdown.displayName = "Dropdown";
Dropdown.propTypes = {
  /**
   * 'aria-label' of the ListBox component.
   * Specify a label to be read by screen readers on the container node
   */
  ["aria-label"]: import_prop_types87.default.string,
  /**
   * Deprecated, please use `aria-label` instead.
   * Specify a label to be read by screen readers on the container note.
   */
  ariaLabel: deprecate(import_prop_types87.default.string, "This prop syntax has been deprecated. Please use the new `aria-label`."),
  /**
   * **Experimental**: Will attempt to automatically align the floating element to avoid collisions with the viewport and being clipped by ancestor elements.
   */
  autoAlign: import_prop_types87.default.bool,
  /**
   * Provide a custom className to be applied on the cds--dropdown node
   */
  className: import_prop_types87.default.string,
  /**
   * **Experimental**: Provide a `decorator` component to be rendered inside the `Dropdown` component
   */
  decorator: import_prop_types87.default.node,
  /**
   * Specify the direction of the dropdown. Can be either top or bottom.
   */
  direction: import_prop_types87.default.oneOf(["top", "bottom"]),
  /**
   * Disable the control
   */
  disabled: import_prop_types87.default.bool,
  /**
   * Additional props passed to Downshift.
   *
   * **Use with caution:** anything you define here overrides the components'
   * internal handling of that prop. Downshift APIs and internals are subject to
   * change, and in some cases they can not be shimmed by Carbon to shield you
   * from potentially breaking changes.
   */
  downshiftProps: import_prop_types87.default.object,
  /**
   * Provide helper text that is used alongside the control label for
   * additional help
   */
  helperText: import_prop_types87.default.node,
  /**
   * Specify whether the title text should be hidden or not
   */
  hideLabel: import_prop_types87.default.bool,
  /**
   * Specify a custom `id`
   */
  id: import_prop_types87.default.string.isRequired,
  /**
   * Allow users to pass in an arbitrary item or a string (in case their items are an array of strings)
   * from their collection that are pre-selected
   */
  initialSelectedItem: import_prop_types87.default.oneOfType([import_prop_types87.default.object, import_prop_types87.default.string, import_prop_types87.default.number]),
  /**
   * Specify if the currently selected value is invalid.
   */
  invalid: import_prop_types87.default.bool,
  /**
   * Message which is displayed if the value is invalid.
   */
  invalidText: import_prop_types87.default.node,
  /**
   * Function to render items as custom components instead of strings.
   * Defaults to null and is overridden by a getter
   */
  itemToElement: import_prop_types87.default.func,
  /**
   * Helper function passed to downshift that allows the library to render a
   * given item to a string label. By default, it extracts the `label` field
   * from a given item to serve as the item label in the list.
   */
  itemToString: import_prop_types87.default.func,
  /**
   * We try to stay as generic as possible here to allow individuals to pass
   * in a collection of whatever kind of data structure they prefer
   */
  items: import_prop_types87.default.array.isRequired,
  /**
   * Generic `label` that will be used as the textual representation of what
   * this field is for
   */
  label: import_prop_types87.default.node.isRequired,
  /**
   * `true` to use the light version.
   */
  light: deprecate(import_prop_types87.default.bool, "The `light` prop for `Dropdown` has been deprecated in favor of the new `Layer` component. It will be removed in the next major release."),
  /**
   * `onChange` is a utility for this controlled component to communicate to a
   * consuming component what kind of internal state changes are occurring.
   */
  onChange: import_prop_types87.default.func,
  /**
   * Whether or not the Dropdown is readonly
   */
  readOnly: import_prop_types87.default.bool,
  /**
   * An optional callback to render the currently selected item as a react element instead of only
   * as a string.
   */
  renderSelectedItem: import_prop_types87.default.func,
  /**
   * In the case you want to control the dropdown selection entirely.
   */
  selectedItem: import_prop_types87.default.oneOfType([import_prop_types87.default.object, import_prop_types87.default.string, import_prop_types87.default.number]),
  /**
   * Specify the size of the ListBox. Currently supports either `sm`, `md` or `lg` as an option.
   */
  size: ListBoxSize,
  /**
   * **Experimental**: Provide a `Slug` component to be rendered inside the `Dropdown` component
   */
  slug: deprecate(import_prop_types87.default.node, "The `slug` prop for `Dropdown` has been deprecated in favor of the new `decorator` prop. It will be removed in the next major release."),
  /**
   * Provide the title text that will be read by a screen reader when
   * visiting this control
   */
  titleText: import_prop_types87.default.node.isRequired,
  /**
   * Callback function for translating ListBoxMenuIcon SVG title
   */
  translateWithId: import_prop_types87.default.func,
  /**
   * The dropdown type, `default` or `inline`
   */
  type: ListBoxType,
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types87.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types87.default.node
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Dropdown/Dropdown.Skeleton.js
var import_prop_types88 = __toESM(require_prop_types());
var import_react122 = __toESM(require_react());
var import_classnames74 = __toESM(require_classnames());
var DropdownSkeleton = (_ref) => {
  let {
    className,
    size: size6,
    hideLabel,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const wrapperClasses = (0, import_classnames74.default)(className, `${prefix}--skeleton`, `${prefix}--form-item`, {
    [`${prefix}--list-box--${size6}`]: size6
  });
  return import_react122.default.createElement("div", _extends({
    className: wrapperClasses
  }, rest3), !hideLabel && import_react122.default.createElement("span", {
    className: `${prefix}--label ${prefix}--skeleton`
  }), import_react122.default.createElement("div", {
    className: `${prefix}--skeleton ${prefix}--dropdown`
  }));
};
DropdownSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types88.default.string,
  /**
   * Specify whether the label should be hidden, or not
   */
  hideLabel: import_prop_types88.default.bool,
  /**
   * Specify the size of the ListBox.
   */
  size: ListBoxSize
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ErrorBoundary/ErrorBoundary.js
var import_react124 = __toESM(require_react());
var import_prop_types89 = __toESM(require_prop_types());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ErrorBoundary/ErrorBoundaryContext.js
var import_react123 = __toESM(require_react());
var ErrorBoundaryContext = (0, import_react123.createContext)({
  log(error2, info) {
    console.log(info.componentStack);
  }
});

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ErrorBoundary/ErrorBoundary.js
var ErrorBoundary = class extends import_react124.default.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "context", void 0);
    _defineProperty(this, "state", {
      hasError: false
    });
  }
  static getDerivedStateFromError() {
    return {
      hasError: true
    };
  }
  componentDidCatch(error2, info) {
    this.context.log(error2, info);
  }
  componentDidUpdate(prevProps) {
    if (prevProps.children !== this.props.children) {
      this.setState({
        hasError: false
      });
    }
  }
  render() {
    if (this.state.hasError) {
      return this.props.fallback;
    }
    return this.props.children;
  }
};
_defineProperty(ErrorBoundary, "propTypes", {
  children: import_prop_types89.default.node,
  fallback: import_prop_types89.default.node
});
_defineProperty(ErrorBoundary, "contextType", ErrorBoundaryContext);

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ExpandableSearch/ExpandableSearch.js
var import_react125 = __toESM(require_react());
var import_classnames75 = __toESM(require_classnames());
var ExpandableSearch = import_react125.default.forwardRef(function ExpandableSearch2(_ref, forwardedRef) {
  let {
    onBlur,
    onChange,
    onExpand,
    onKeyDown,
    defaultValue,
    isExpanded,
    ...props
  } = _ref;
  const [expanded, setExpanded] = (0, import_react125.useState)(isExpanded || false);
  const [hasContent, setHasContent] = (0, import_react125.useState)(defaultValue ? true : false);
  const searchRef = (0, import_react125.useRef)(null);
  const prefix = usePrefix();
  function handleBlur(evt) {
    const relatedTargetIsAllowed = evt.relatedTarget && evt.relatedTarget.classList.contains(`${prefix}--search-close`);
    if (expanded && !relatedTargetIsAllowed && !hasContent && !isExpanded) {
      setExpanded(false);
    }
  }
  (0, import_react125.useEffect)(() => {
    setExpanded(!!isExpanded);
  }, [isExpanded]);
  function handleChange(evt) {
    setHasContent(evt.target.value !== "");
  }
  function handleExpand() {
    var _a, _b;
    setExpanded(true);
    (_b = (_a = searchRef.current) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
  }
  function handleKeyDown(evt) {
    var _a;
    if (expanded && match(evt, Escape)) {
      evt.stopPropagation();
      if (!((_a = evt.target) == null ? void 0 : _a.value) && !isExpanded) {
        setExpanded(false);
      }
    }
  }
  const classes = (0, import_classnames75.default)(`${prefix}--search--expandable`, {
    [`${prefix}--search--expanded`]: expanded
  }, props.className);
  return import_react125.default.createElement(Search2, _extends({}, props, {
    defaultValue,
    isExpanded: expanded,
    ref: mergeRefs$1(searchRef, forwardedRef),
    className: classes,
    onBlur: composeEventHandlers([onBlur, handleBlur]),
    onChange: composeEventHandlers([onChange, handleChange]),
    onExpand: composeEventHandlers([onExpand, handleExpand]),
    onKeyDown: composeEventHandlers([onKeyDown, handleKeyDown])
  }));
});
ExpandableSearch.propTypes = Search2.propTypes;
ExpandableSearch.displayName = "ExpandableSearch";

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FileUploader/FileUploader.js
var import_classnames77 = __toESM(require_classnames());
var import_prop_types92 = __toESM(require_prop_types());
var import_react128 = __toESM(require_react());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FileUploader/Filename.js
var import_prop_types90 = __toESM(require_prop_types());
var import_react126 = __toESM(require_react());
var _Close5;
function Filename(_ref) {
  let {
    iconDescription = "Uploading file",
    status = "uploading",
    invalid,
    name,
    tabIndex = 0,
    ["aria-describedby"]: ariaDescribedBy,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  switch (status) {
    case "uploading":
      return import_react126.default.createElement(Loading, {
        description: iconDescription,
        small: true,
        withOverlay: false,
        className: `${prefix}--file-loading`
      });
    case "edit":
      return import_react126.default.createElement(import_react126.default.Fragment, null, invalid && import_react126.default.createElement(WarningFilled, {
        className: `${prefix}--file-invalid`
      }), import_react126.default.createElement("button", _extends({
        "aria-label": `${iconDescription} - ${name}`,
        className: `${prefix}--file-close`,
        type: "button",
        tabIndex
      }, rest3, {
        "aria-describedby": invalid ? ariaDescribedBy : void 0
      }), _Close5 || (_Close5 = import_react126.default.createElement(Close, null))));
    case "complete":
      return import_react126.default.createElement(CheckmarkFilled, _extends({
        "aria-label": iconDescription,
        className: `${prefix}--file-complete`
      }, rest3, {
        tabIndex: -1
      }), iconDescription && import_react126.default.createElement("title", null, iconDescription));
    default:
      return null;
  }
}
Filename.propTypes = {
  /**
   * Specify an id that describes the error to be read by screen readers when the filename is invalid
   */
  ["aria-describedby"]: import_prop_types90.default.string,
  /**
   * Provide a description of the SVG icon to denote file upload status
   */
  iconDescription: import_prop_types90.default.string,
  /**
   * Specify if the file is invalid
   */
  invalid: import_prop_types90.default.bool,
  /**
   * Name of the uploaded file
   */
  name: import_prop_types90.default.string,
  /**
   * Status of the file upload
   */
  status: import_prop_types90.default.oneOf(["edit", "complete", "uploading"]),
  /**
   * Provide a custom tabIndex value for the `<Filename>`
   */
  tabIndex: import_prop_types90.default.number
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FileUploader/FileUploaderButton.js
var import_classnames76 = __toESM(require_classnames());
var import_prop_types91 = __toESM(require_prop_types());
var import_react127 = __toESM(require_react());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/prop-types/types.js
var ButtonKinds2 = ["primary", "secondary", "danger", "ghost", "danger--primary", "danger--ghost", "danger--tertiary", "tertiary"];

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FileUploader/FileUploaderButton.js
function FileUploaderButton(_ref) {
  let {
    accept,
    buttonKind = "primary",
    className,
    disabled = false,
    disableLabelChanges = false,
    id,
    labelText: ownerLabelText = "Add file",
    multiple = false,
    onChange = noopFn,
    name,
    size: size6 = "md",
    // eslint-disable-next-line react/prop-types
    innerRef,
    ...other
  } = _ref;
  const prefix = usePrefix();
  const [labelText, setLabelText] = (0, import_react127.useState)(ownerLabelText);
  const [prevOwnerLabelText, setPrevOwnerLabelText] = (0, import_react127.useState)(ownerLabelText);
  const {
    current: inputId
  } = (0, import_react127.useRef)(id || uniqueId2());
  const inputNode = (0, import_react127.useRef)(null);
  const classes = (0, import_classnames76.default)(`${prefix}--btn`, className, {
    [`${prefix}--btn--${buttonKind}`]: buttonKind,
    [`${prefix}--btn--disabled`]: disabled,
    // V11: remove field, small
    [`${prefix}--btn--md`]: size6 === "field" || size6 === "md",
    [`${prefix}--btn--sm`]: size6 === "small" || size6 === "sm",
    [`${prefix}--layout--size-${size6}`]: size6
  });
  if (ownerLabelText !== prevOwnerLabelText) {
    setLabelText(ownerLabelText);
    setPrevOwnerLabelText(ownerLabelText);
  }
  function onClick(event) {
    event.target.value = null;
    if (inputNode.current) {
      inputNode.current.value = "";
      inputNode.current.click();
    }
  }
  function onKeyDown(event) {
    if (matches(event, [Enter, Space]) && inputNode.current) {
      inputNode.current.value = "";
      inputNode.current.click();
    }
  }
  function handleOnChange(event) {
    var _a;
    const files = event.target.files;
    const length = ((_a = event.target.files) == null ? void 0 : _a.length) || 0;
    if (files && !disableLabelChanges) {
      if (length > 1) {
        setLabelText(`${length} files`);
      } else if (length === 1) {
        setLabelText(files[0].name);
      }
    }
    onChange(event);
  }
  return import_react127.default.createElement(import_react127.default.Fragment, null, import_react127.default.createElement("button", _extends({
    type: "button",
    disabled,
    className: classes,
    onClick,
    onKeyDown
  }, other, {
    tabIndex: other.tabIndex !== void 0 ? parseInt(other.tabIndex) : void 0
  }), labelText), import_react127.default.createElement("label", {
    className: `${prefix}--visually-hidden`,
    ref: innerRef,
    htmlFor: inputId
  }, import_react127.default.createElement("span", null, labelText)), import_react127.default.createElement("input", {
    className: `${prefix}--visually-hidden`,
    ref: inputNode,
    id: inputId,
    disabled,
    type: "file",
    tabIndex: -1,
    multiple,
    accept: accept == null ? void 0 : accept.toString(),
    name,
    onChange: handleOnChange
  }));
}
FileUploaderButton.propTypes = {
  /**
   * Specify the types of files that this input should be able to receive
   */
  accept: import_prop_types91.default.arrayOf(import_prop_types91.default.string),
  /**
   * Specify the type of underlying button
   */
  buttonKind: import_prop_types91.default.oneOf(ButtonKinds2),
  /**
   * Provide a custom className to be applied to the container node
   */
  className: import_prop_types91.default.string,
  /**
   * Specify whether you want to disable any updates to the FileUploaderButton
   * label
   */
  disableLabelChanges: import_prop_types91.default.bool,
  /**
   * Specify whether file input is disabled
   */
  disabled: import_prop_types91.default.bool,
  /**
   * Provide a unique id for the underlying `<input>` node
   */
  id: import_prop_types91.default.string,
  /**
   * Provide the label text to be read by screen readers when interacting with
   * this control
   */
  labelText: import_prop_types91.default.node,
  /**
   * Specify if the component should accept multiple files to upload
   */
  multiple: import_prop_types91.default.bool,
  /**
   * Provide a name for the underlying `<input>` node
   */
  name: import_prop_types91.default.string,
  /**
   * Provide an optional `onChange` hook that is called each time the `<input>`
   * value changes
   */
  onChange: import_prop_types91.default.func,
  /**
   * Provide an optional `onClick` hook that is called each time the button is
   * clicked
   */
  onClick: import_prop_types91.default.func,
  /**
   * Provide an accessibility role for the `<FileUploaderButton>`
   */
  role: import_prop_types91.default.string,
  /**
   * Specify the size of the FileUploaderButton, from a list of available
   * sizes.
   */
  size: import_prop_types91.default.oneOf(["sm", "md", "lg"]),
  /**
   * Provide a custom tabIndex value for the `<FileUploaderButton>`
   */
  tabIndex: deprecate(import_prop_types91.default.number, "The `tabIndex` prop for `FileUploaderButton` has been deprecated since it now renders a button element by default.")
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FileUploader/FileUploader.js
var FileUploader = import_react128.default.forwardRef((_ref, ref) => {
  let {
    accept,
    buttonKind,
    buttonLabel,
    className,
    disabled,
    filenameStatus,
    iconDescription,
    labelDescription,
    labelTitle,
    multiple,
    name,
    onChange,
    onClick,
    onDelete,
    size: size6,
    ...other
  } = _ref;
  const fileUploaderInstanceId = useId("file-uploader");
  const [state, updateState] = (0, import_react128.useState)({
    fileNames: []
  });
  const nodes = [];
  const prefix = usePrefix();
  const handleChange = (evt) => {
    evt.stopPropagation();
    const filenames = Array.prototype.map.call(evt.target.files, (file) => file.name);
    updateState((prevState) => ({
      fileNames: multiple ? [.../* @__PURE__ */ new Set([...prevState.fileNames, ...filenames])] : filenames
    }));
    if (onChange) {
      onChange(evt);
    }
  };
  const handleClick2 = (evt, _ref2) => {
    var _a, _b;
    let {
      index: index4,
      filenameStatus: filenameStatus2
    } = _ref2;
    if (filenameStatus2 === "edit") {
      evt.stopPropagation();
      const filteredArray = state.fileNames.filter((filename) => {
        var _a2, _b2;
        return filename !== ((_b2 = (_a2 = nodes[index4]) == null ? void 0 : _a2.innerText) == null ? void 0 : _b2.trim());
      });
      updateState({
        fileNames: filteredArray
      });
      if (onDelete) {
        onDelete(evt);
        (_b = (_a = uploaderButton.current) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
      }
      onClick == null ? void 0 : onClick(evt);
    }
  };
  (0, import_react128.useImperativeHandle)(ref, () => ({
    clearFiles() {
      updateState({
        fileNames: []
      });
    }
  }));
  const uploaderButton = import_react128.default.createRef();
  const classes = (0, import_classnames77.default)({
    [`${prefix}--form-item`]: true,
    [className]: className
  });
  const getHelperLabelClasses = (baseClass) => (0, import_classnames77.default)(baseClass, {
    [`${prefix}--label-description--disabled`]: disabled
  });
  const selectedFileClasses = (0, import_classnames77.default)(`${prefix}--file__selected-file`, {
    [`${prefix}--file__selected-file--md`]: size6 === "field" || size6 === "md",
    [`${prefix}--file__selected-file--sm`]: size6 === "small" || size6 === "sm"
  });
  return import_react128.default.createElement("div", _extends({
    className: classes
  }, other), !labelTitle ? null : import_react128.default.createElement(Text, {
    as: "h3",
    className: getHelperLabelClasses(`${prefix}--file--label`)
  }, labelTitle), import_react128.default.createElement(Text, {
    as: "p",
    className: getHelperLabelClasses(`${prefix}--label-description`),
    id: fileUploaderInstanceId
  }, labelDescription), import_react128.default.createElement(FileUploaderButton, {
    innerRef: uploaderButton,
    disabled,
    labelText: buttonLabel,
    multiple,
    buttonKind,
    onChange: handleChange,
    disableLabelChanges: true,
    accept,
    name,
    size: size6,
    "aria-describedby": fileUploaderInstanceId
  }), import_react128.default.createElement("div", {
    className: `${prefix}--file-container`
  }, state.fileNames.length === 0 ? null : state.fileNames.map((name2, index4) => import_react128.default.createElement("span", _extends({
    key: index4,
    className: selectedFileClasses,
    ref: (node) => nodes[index4] = node
    // eslint-disable-line
  }, other), import_react128.default.createElement(Text, {
    as: "p",
    className: `${prefix}--file-filename`,
    id: name2
  }, name2), import_react128.default.createElement("span", {
    className: `${prefix}--file__state-container`
  }, import_react128.default.createElement(Filename, {
    name: name2,
    iconDescription,
    status: filenameStatus,
    onKeyDown: (evt) => {
      if (matches(evt, [Enter, Space])) {
        handleClick2(evt, {
          index: index4,
          filenameStatus
        });
      }
    },
    onClick: (evt) => handleClick2(evt, {
      index: index4,
      filenameStatus
    })
  }))))));
});
FileUploader.propTypes = {
  /**
   * Specify the types of files that this input should be able to receive
   */
  accept: import_prop_types92.default.arrayOf(import_prop_types92.default.string),
  /**
   * Specify the type of the `<FileUploaderButton>`
   */
  buttonKind: import_prop_types92.default.oneOf(ButtonKinds),
  /**
   * Provide the label text to be read by screen readers when interacting with
   * the `<FileUploaderButton>`
   */
  buttonLabel: import_prop_types92.default.string,
  /**
   * Provide a custom className to be applied to the container node
   */
  className: import_prop_types92.default.string,
  /**
   * Specify whether file input is disabled
   */
  disabled: import_prop_types92.default.bool,
  /**
   * Specify the status of the File Upload
   */
  filenameStatus: import_prop_types92.default.oneOf(["edit", "complete", "uploading"]).isRequired,
  /**
   * Provide a description for the complete/close icon that can be read by screen readers
   */
  iconDescription: import_prop_types92.default.string,
  /**
   * Specify the description text of this `<FileUploader>`
   */
  labelDescription: import_prop_types92.default.string,
  /**
   * Specify the title text of this `<FileUploader>`
   */
  labelTitle: import_prop_types92.default.string,
  /**
   * Specify if the component should accept multiple files to upload
   */
  multiple: import_prop_types92.default.bool,
  /**
   * Provide a name for the underlying `<input>` node
   */
  name: import_prop_types92.default.string,
  /**
   * Provide an optional `onChange` hook that is called each time the input is
   * changed
   */
  onChange: import_prop_types92.default.func,
  /**
   * Provide an optional `onClick` hook that is called each time the
   * FileUploader is clicked
   */
  onClick: import_prop_types92.default.func,
  /**
   * Provide an optional `onDelete` hook that is called when an uploaded item
   * is removed
   */
  onDelete: import_prop_types92.default.func,
  /**
   * Specify the size of the FileUploaderButton, from a list of available
   * sizes.
   */
  size: import_prop_types92.default.oneOf(["sm", "md", "lg"])
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FileUploader/FileUploader.Skeleton.js
var import_prop_types93 = __toESM(require_prop_types());
var import_react129 = __toESM(require_react());
var import_classnames78 = __toESM(require_classnames());
var _SkeletonText4;
var _ButtonSkeleton;
function FileUploaderSkeleton(_ref) {
  let {
    className,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  return import_react129.default.createElement("div", _extends({
    className: (0, import_classnames78.default)(`${prefix}--form-item`, className)
  }, rest3), _SkeletonText4 || (_SkeletonText4 = import_react129.default.createElement(SkeletonText, {
    heading: true,
    width: "100px"
  })), import_react129.default.createElement(SkeletonText, {
    width: "225px",
    className: `${prefix}--label-description`
  }), _ButtonSkeleton || (_ButtonSkeleton = import_react129.default.createElement(ButtonSkeleton, null)));
}
FileUploaderSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types93.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FileUploader/FileUploaderDropContainer.js
var import_react130 = __toESM(require_react());
var import_prop_types94 = __toESM(require_prop_types());
var import_classnames79 = __toESM(require_classnames());
function FileUploaderDropContainer(_ref) {
  let {
    accept = [],
    className,
    id,
    disabled,
    labelText = "Add file",
    multiple = false,
    name,
    onAddFiles = noopFn,
    onClick,
    pattern = ".[0-9a-z]+$",
    // eslint-disable-next-line react/prop-types
    innerRef,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const inputRef = (0, import_react130.useRef)(null);
  const {
    current: uid
  } = (0, import_react130.useRef)(id || uniqueId2());
  const [isActive, setActive] = (0, import_react130.useState)(false);
  const dropareaClasses = (0, import_classnames79.default)(`${prefix}--file__drop-container`, `${prefix}--file-browse-btn`, {
    [`${prefix}--file__drop-container--drag-over`]: isActive,
    [`${prefix}--file-browse-btn--disabled`]: disabled
  }, className);
  function validateFiles(transferredFiles) {
    if (!accept.length) {
      return transferredFiles;
    }
    const acceptedTypes = new Set(accept);
    return transferredFiles.reduce((acc, curr) => {
      const {
        name: name2,
        type: mimeType = ""
      } = curr;
      const fileExtensionRegExp = new RegExp(pattern, "i");
      const [fileExtension] = name2.match(fileExtensionRegExp) ?? [];
      if (fileExtension === void 0) {
        return acc;
      }
      if (acceptedTypes.has(mimeType) || acceptedTypes.has(fileExtension.toLowerCase())) {
        return acc.concat([curr]);
      }
      curr.invalidFileType = true;
      return acc.concat([curr]);
    }, []);
  }
  function handleChange(event) {
    const files = [...event.target.files ?? []];
    const addedFiles = validateFiles(files);
    return onAddFiles(event, {
      addedFiles
    });
  }
  function handleDrop(event) {
    const files = [...event.dataTransfer.files];
    const addedFiles = validateFiles(files);
    return onAddFiles(event, {
      addedFiles
    });
  }
  const handleClick2 = () => {
    var _a;
    if (!disabled) {
      (_a = inputRef.current) == null ? void 0 : _a.click();
    }
  };
  return import_react130.default.createElement("div", {
    className: `${prefix}--file`,
    onDragOver: (evt) => {
      evt.stopPropagation();
      evt.preventDefault();
      if (disabled) {
        return;
      }
      setActive(true);
      evt.dataTransfer.dropEffect = "copy";
    },
    onDragLeave: (evt) => {
      evt.stopPropagation();
      evt.preventDefault();
      if (disabled) {
        return;
      }
      setActive(false);
      evt.dataTransfer.dropEffect = "move";
    },
    onDrop: (evt) => {
      evt.stopPropagation();
      evt.preventDefault();
      if (disabled) {
        return;
      }
      setActive(false);
      handleDrop(evt);
    }
  }, import_react130.default.createElement("button", _extends({
    type: "button",
    className: dropareaClasses,
    ref: innerRef,
    onKeyDown: (evt) => {
      var _a;
      if (matches(evt, [Enter, Space])) {
        evt.preventDefault();
        (_a = inputRef.current) == null ? void 0 : _a.click();
      }
    },
    onClick: composeEventHandlers([onClick, handleClick2])
  }, rest3), labelText), import_react130.default.createElement("label", {
    htmlFor: uid,
    className: `${prefix}--visually-hidden`
  }, labelText), import_react130.default.createElement("input", {
    type: "file",
    id: uid,
    className: `${prefix}--file-input`,
    ref: inputRef,
    tabIndex: -1,
    disabled,
    accept: accept.join(","),
    name,
    multiple,
    onChange: handleChange,
    onClick: (evt) => {
      evt.target.value = "";
    }
  }));
}
FileUploaderDropContainer.propTypes = {
  /**
   * Specify the types of files that this input should be able to receive
   */
  accept: import_prop_types94.default.arrayOf(import_prop_types94.default.string),
  /**
   * Provide a custom className to be applied to the container node
   */
  className: import_prop_types94.default.string,
  /**
   * Specify whether file input is disabled
   */
  disabled: import_prop_types94.default.bool,
  /**
   * Provide a unique id for the underlying `<input>` node
   */
  id: import_prop_types94.default.string,
  /**
   * Provide the label text to be read by screen readers when interacting with
   * this control
   */
  labelText: import_prop_types94.default.string.isRequired,
  /**
   * Specify if the component should accept multiple files to upload
   */
  multiple: import_prop_types94.default.bool,
  /**
   * Provide a name for the underlying `<input>` node
   */
  name: import_prop_types94.default.string,
  /**
   * Event handler that is called after files are added to the uploader
   * The event handler signature looks like `onAddFiles(evt, { addedFiles })`
   */
  onAddFiles: import_prop_types94.default.func,
  /**
   * Provide an optional function to be called when the button element
   * is clicked
   */
  onClick: import_prop_types94.default.func,
  /**
   * Provide a custom regex pattern for the acceptedTypes
   */
  pattern: import_prop_types94.default.string,
  /**
   * Provide an accessibility role for the `<FileUploaderButton>`
   */
  role: deprecate(import_prop_types94.default.number, "The `role` prop for `FileUploaderButton` has been deprecated since it now renders a button element by default, and has an implicit role of button."),
  /**
   * Provide a custom tabIndex value for the `<FileUploaderButton>`
   */
  tabIndex: deprecate(import_prop_types94.default.number, "The `tabIndex` prop for `FileUploaderButton` has been deprecated since it now renders a button element by default.")
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FileUploader/FileUploaderItem.js
var import_classnames80 = __toESM(require_classnames());
var import_prop_types95 = __toESM(require_prop_types());
var import_react131 = __toESM(require_react());
function FileUploaderItem(_ref) {
  let {
    uuid,
    name,
    status = "uploading",
    iconDescription,
    onDelete = noopFn,
    invalid,
    errorSubject,
    errorBody,
    size: size6,
    className,
    ...other
  } = _ref;
  const textRef = (0, import_react131.useRef)(null);
  const [isEllipsisApplied, setIsEllipsisApplied] = (0, import_react131.useState)(false);
  const prefix = usePrefix();
  const {
    current: id
  } = (0, import_react131.useRef)(uuid || uniqueId2());
  const classes = (0, import_classnames80.default)(`${prefix}--file__selected-file`, className, {
    [`${prefix}--file__selected-file--invalid`]: invalid,
    [`${prefix}--file__selected-file--md`]: size6 === "md",
    [`${prefix}--file__selected-file--sm`]: size6 === "sm"
  });
  const isInvalid = invalid ? `${prefix}--file-filename-container-wrap-invalid` : `${prefix}--file-filename-container-wrap`;
  const filterSpaceName = (name2) => {
    return name2 == null ? void 0 : name2.replace(/\s+/g, "");
  };
  const isEllipsisActive2 = (element) => {
    setIsEllipsisApplied(element.offsetWidth < element.scrollWidth);
    return element.offsetWidth < element.scrollWidth;
  };
  (0, import_react131.useLayoutEffect)(() => {
    isEllipsisActive2(textRef.current);
  }, [prefix, name]);
  return import_react131.default.createElement("span", _extends({
    className: classes
  }, other), isEllipsisApplied ? import_react131.default.createElement("div", {
    className: isInvalid
  }, import_react131.default.createElement(Tooltip, {
    label: name,
    align: "bottom",
    className: `${prefix}--file-filename-tooltip`
  }, import_react131.default.createElement("button", {
    className: `${prefix}--file-filename-button`,
    type: "button"
  }, import_react131.default.createElement(Text, {
    ref: textRef,
    as: "p",
    title: name,
    className: `${prefix}--file-filename-button`,
    id: filterSpaceName(name)
  }, name)))) : import_react131.default.createElement(Text, {
    ref: textRef,
    as: "p",
    title: name,
    className: `${prefix}--file-filename`,
    id: filterSpaceName(name)
  }, name), import_react131.default.createElement("div", {
    className: `${prefix}--file-container-item`
  }, import_react131.default.createElement("span", {
    className: `${prefix}--file__state-container`
  }, import_react131.default.createElement(Filename, {
    name,
    iconDescription,
    status,
    invalid,
    "aria-describedby": invalid && errorSubject ? `${filterSpaceName(name)}-id-error` : void 0,
    onKeyDown: (evt) => {
      if (matches(evt, [Enter, Space])) {
        if (status === "edit") {
          evt.preventDefault();
          onDelete(evt, {
            uuid: id
          });
        }
      }
    },
    onClick: (evt) => {
      if (status === "edit") {
        onDelete(evt, {
          uuid: id
        });
      }
    }
  }))), invalid && errorSubject && import_react131.default.createElement("div", {
    className: `${prefix}--form-requirement`,
    role: "alert",
    id: `${filterSpaceName(name)}-id-error`
  }, import_react131.default.createElement(Text, {
    as: "div",
    className: `${prefix}--form-requirement__title`
  }, errorSubject), errorBody && import_react131.default.createElement(Text, {
    as: "p",
    className: `${prefix}--form-requirement__supplement`
  }, errorBody)));
}
FileUploaderItem.propTypes = {
  /**
   * Error message body for an invalid file upload
   */
  errorBody: import_prop_types95.default.string,
  /**
   * Error message subject for an invalid file upload
   */
  errorSubject: import_prop_types95.default.string,
  /**
   * Description of status icon (displayed in native tooltip)
   */
  iconDescription: import_prop_types95.default.string,
  /**
   * Specify if the currently uploaded file is invalid
   */
  invalid: import_prop_types95.default.bool,
  /**
   * Name of the uploaded file
   */
  name: import_prop_types95.default.string,
  /**
   * Event handler that is called after removing a file from the file uploader
   * The event handler signature looks like `onDelete(evt, { uuid })`
   */
  onDelete: import_prop_types95.default.func,
  /**
   * Specify the size of the FileUploaderButton, from a list of available
   * sizes.
   */
  size: import_prop_types95.default.oneOf(["sm", "md", "lg"]),
  /**
   * Status of the file upload
   */
  status: import_prop_types95.default.oneOf(["uploading", "edit", "complete"]),
  /**
   * Unique identifier for the file object
   */
  uuid: import_prop_types95.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FormGroup/FormGroup.js
var import_prop_types96 = __toESM(require_prop_types());
var import_react132 = __toESM(require_react());
var import_classnames81 = __toESM(require_classnames());
var FormGroup = (_ref) => {
  let {
    disabled = false,
    legendId,
    legendText,
    invalid = false,
    children,
    className,
    message = false,
    messageText = "",
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const classNamesFieldset = (0, import_classnames81.default)(`${prefix}--fieldset`, className);
  return import_react132.default.createElement("fieldset", _extends({
    disabled
  }, invalid && {
    "data-invalid": ""
  }, {
    className: classNamesFieldset
  }, rest3, {
    "aria-labelledby": rest3["aria-labelledby"] || legendId
  }), import_react132.default.createElement("legend", {
    className: `${prefix}--label`,
    id: legendId || rest3["aria-labelledby"]
  }, legendText), children, message ? import_react132.default.createElement("div", {
    className: `${prefix}--form__requirements`
  }, messageText) : null);
};
FormGroup.propTypes = {
  /**
   * Provide the children form elements to be rendered inside of the <fieldset>
   */
  children: import_prop_types96.default.node,
  /**
   * Provide a custom className to be applied to the containing <fieldset> node
   */
  className: import_prop_types96.default.string,
  /**
   * Specify whether the FormGroup should be disabled
   */
  disabled: import_prop_types96.default.bool,
  /**
   * Specify whether the <FormGroup> is invalid
   */
  invalid: import_prop_types96.default.bool,
  /**
   * Provide id for the fieldset <legend> which corresponds to the fieldset
   * `aria-labelledby`
   */
  legendId: import_prop_types96.default.node,
  /**
   * Provide the text to be rendered inside of the fieldset <legend>
   */
  legendText: import_prop_types96.default.node.isRequired,
  /**
   * Specify whether the message should be displayed in the <FormGroup>
   */
  message: import_prop_types96.default.bool,
  /**
   * Provide the text for the message in the <FormGroup>
   */
  messageText: import_prop_types96.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FormItem/FormItem.js
var import_prop_types97 = __toESM(require_prop_types());
var import_react133 = __toESM(require_react());
var import_classnames82 = __toESM(require_classnames());
function FormItem(_ref) {
  let {
    className,
    children,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const classNames = (0, import_classnames82.default)(`${prefix}--form-item`, className);
  return import_react133.default.createElement("div", _extends({
    className: classNames
  }, rest3), children);
}
FormItem.propTypes = {
  /**
   * Provide content to be rendered in the form item
   */
  children: import_prop_types97.default.node,
  /**
   * Provide a custom className to be applied to the containing node
   */
  className: import_prop_types97.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FormLabel/FormLabel.js
var import_prop_types98 = __toESM(require_prop_types());
var import_react134 = __toESM(require_react());
var import_classnames83 = __toESM(require_classnames());
function FormLabel(_ref) {
  let {
    className: customClassName,
    children,
    id,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const className = (0, import_classnames83.default)(`${prefix}--label`, `${prefix}--label--no-margin`, customClassName);
  return import_react134.default.createElement(Text, _extends({
    as: "label",
    htmlFor: id,
    className
  }, rest3), children);
}
FormLabel.propTypes = {
  /**
   * Specify the content of the form label
   */
  children: import_prop_types98.default.node,
  /**
   * Provide a custom className to be applied to the containing <label> node
   */
  className: import_prop_types98.default.string,
  /**
   * Provide a unique id for the given <FormLabel>
   */
  id: import_prop_types98.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Grid/FlexGrid.js
var import_classnames84 = __toESM(require_classnames());
var import_prop_types100 = __toESM(require_prop_types());
var import_react135 = __toESM(require_react());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Grid/GridContext.js
var import_prop_types99 = __toESM(require_prop_types());
var React4 = __toESM(require_react());
var GridSettingsContext = React4.createContext({
  mode: "flexbox",
  subgrid: false
});
var GridSettings = (_ref) => {
  let {
    children,
    mode,
    subgrid = false
  } = _ref;
  const value = React4.useMemo(() => {
    return {
      mode,
      subgrid
    };
  }, [mode, subgrid]);
  return React4.createElement(GridSettingsContext.Provider, {
    value
  }, children);
};
var gridModes = ["flexbox", "css-grid"];
GridSettings.propTypes = {
  /**
   * Pass in components which will be rendered within the `GridSettings`
   * component
   */
  children: import_prop_types99.default.node,
  /**
   * Specify the gutter mode for the GridContext
   */
  mode: import_prop_types99.default.oneOf(gridModes).isRequired,
  /**
   * Specify whether subgrid should be enabled
   */
  subgrid: import_prop_types99.default.bool
};
var useGridSettings = () => {
  return React4.useContext(GridSettingsContext);
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Grid/FlexGrid.js
function FlexGrid(_ref) {
  let {
    as: BaseComponent = "div",
    condensed = false,
    narrow = false,
    fullWidth = false,
    className: containerClassName,
    children,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const className = (0, import_classnames84.default)(containerClassName, {
    [`${prefix}--grid`]: true,
    [`${prefix}--grid--condensed`]: condensed,
    [`${prefix}--grid--narrow`]: narrow,
    [`${prefix}--grid--full-width`]: fullWidth
  });
  const BaseComponentAsAny = BaseComponent;
  return import_react135.default.createElement(GridSettings, {
    mode: "flexbox",
    subgrid: false
  }, import_react135.default.createElement(BaseComponentAsAny, _extends({
    className
  }, rest3), children));
}
FlexGrid.propTypes = {
  /**
   * Provide a custom element to render instead of the default <div>
   */
  as: import_prop_types100.default.oneOfType([import_prop_types100.default.string, import_prop_types100.default.elementType]),
  /**
   * Pass in content that will be rendered within the `FlexGrid`
   */
  children: import_prop_types100.default.node,
  /**
   * Specify a custom className to be applied to the `FlexGrid`
   */
  className: import_prop_types100.default.string,
  /**
   * Collapse the gutter to 1px. Useful for fluid layouts.
   * Rows have 1px of margin between them to match gutter.
   */
  condensed: import_prop_types100.default.bool,
  /**
   * Remove the default max width that the grid has set
   */
  fullWidth: import_prop_types100.default.bool,
  /**
   * Container hangs 16px into the gutter. Useful for
   * typographic alignment with and without containers.
   */
  narrow: import_prop_types100.default.bool
};
var FlexGridComponent = FlexGrid;

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Grid/Grid.js
var import_prop_types102 = __toESM(require_prop_types());
var import_react137 = __toESM(require_react());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Grid/CSSGrid.js
var import_classnames85 = __toESM(require_classnames());
var import_prop_types101 = __toESM(require_prop_types());
var import_react136 = __toESM(require_react());
function CSSGrid(_ref) {
  let {
    align,
    as: BaseComponent = "div",
    children,
    className: customClassName,
    condensed = false,
    fullWidth = false,
    narrow = false,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const {
    subgrid
  } = useGridSettings();
  let mode = "wide";
  if (narrow) {
    mode = "narrow";
  } else if (condensed) {
    mode = "condensed";
  }
  if (subgrid) {
    return import_react136.default.createElement(GridSettings, {
      mode: "css-grid",
      subgrid: true
    }, import_react136.default.createElement(Subgrid, _extends({
      as: BaseComponent,
      className: customClassName,
      mode
    }, rest3), children));
  }
  const className = (0, import_classnames85.default)(customClassName, {
    [`${prefix}--css-grid`]: true,
    [`${prefix}--css-grid--condensed`]: mode === "condensed",
    [`${prefix}--css-grid--narrow`]: mode === "narrow",
    [`${prefix}--css-grid--full-width`]: fullWidth,
    [`${prefix}--css-grid--start`]: align === "start",
    [`${prefix}--css-grid--end`]: align === "end"
  });
  const BaseComponentAsAny = BaseComponent;
  return import_react136.default.createElement(GridSettings, {
    mode: "css-grid",
    subgrid: true
  }, import_react136.default.createElement(BaseComponentAsAny, _extends({
    className
  }, rest3), children));
}
CSSGrid.propTypes = {
  /**
   * Specify grid aligment. Default is center
   */
  align: import_prop_types101.default.oneOf(["start", "center", "end"]),
  /**
   * Provide a custom element to render instead of the default <div>
   */
  as: import_prop_types101.default.oneOfType([import_prop_types101.default.string, import_prop_types101.default.elementType]),
  /**
   * Pass in content that will be rendered within the `Grid`
   */
  children: import_prop_types101.default.node,
  /**
   * Specify a custom className to be applied to the `Grid`
   */
  className: import_prop_types101.default.string,
  /**
   * Collapse the gutter to 1px. Useful for fluid layouts.
   * Rows have 1px of margin between them to match gutter.
   */
  condensed: import_prop_types101.default.bool,
  /**
   * Remove the default max width that the grid has set
   */
  fullWidth: import_prop_types101.default.bool,
  /**
   * Container hangs 16px into the gutter. Useful for
   * typographic alignment with and without containers.
   */
  narrow: import_prop_types101.default.bool
};
var Subgrid = (_ref2) => {
  let {
    as: BaseComponent = "div",
    className: customClassName,
    children,
    mode,
    ...rest3
  } = _ref2;
  const prefix = usePrefix();
  const className = (0, import_classnames85.default)(customClassName, {
    [`${prefix}--subgrid`]: true,
    [`${prefix}--subgrid--condensed`]: mode === "condensed",
    [`${prefix}--subgrid--narrow`]: mode === "narrow",
    [`${prefix}--subgrid--wide`]: mode === "wide"
  });
  return import_react136.default.createElement(BaseComponent, _extends({}, rest3, {
    className
  }), children);
};
Subgrid.propTypes = {
  /**
   * Provide a custom element to render instead of the default <div>
   */
  as: import_prop_types101.default.oneOfType([import_prop_types101.default.string, import_prop_types101.default.elementType]),
  /**
   * Pass in content that will be rendered within the `Subgrid`
   */
  children: import_prop_types101.default.node,
  /**
   * Specify a custom className to be applied to the `Subgrid`
   */
  className: import_prop_types101.default.string,
  /**
   * Specify the gutter mode for the subgrid
   */
  mode: import_prop_types101.default.oneOf(["wide", "narrow", "condensed"])
};
var CSSGridComponent = CSSGrid;

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Grid/Grid.js
function Grid(props) {
  const enableCSSGrid = useFeatureFlag("enable-css-grid");
  if (enableCSSGrid) {
    return import_react137.default.createElement(CSSGridComponent, props);
  }
  return import_react137.default.createElement(FlexGridComponent, props);
}
Grid.propTypes = {
  /**
   * Specify grid aligment. Default is center
   */
  align: import_prop_types102.default.oneOf(["start", "center", "end"]),
  /**
   * Provide a custom element to render instead of the default <div>
   */
  as: import_prop_types102.default.oneOfType([import_prop_types102.default.string, import_prop_types102.default.elementType]),
  /**
   * Pass in content that will be rendered within the `Grid`
   */
  children: import_prop_types102.default.node,
  /**
   * Specify a custom className to be applied to the `Grid`
   */
  className: import_prop_types102.default.string,
  /**
   * Collapse the gutter to 1px. Useful for fluid layouts.
   * Rows have 1px of margin between them to match gutter.
   */
  condensed: import_prop_types102.default.bool,
  /**
   * Remove the default max width that the grid has set
   */
  fullWidth: import_prop_types102.default.bool,
  /**
   * Container hangs 16px into the gutter. Useful for
   * typographic alignment with and without containers.
   */
  narrow: import_prop_types102.default.bool
};
var GridAsGridComponent = Grid;

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Grid/Row.js
var import_classnames86 = __toESM(require_classnames());
var import_prop_types103 = __toESM(require_prop_types());
var import_react138 = __toESM(require_react());
function Row(_ref) {
  let {
    as: BaseComponent = "div",
    condensed = false,
    narrow = false,
    className: containerClassName,
    children,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const className = (0, import_classnames86.default)(containerClassName, {
    [`${prefix}--row`]: true,
    [`${prefix}--row--condensed`]: condensed,
    [`${prefix}--row--narrow`]: narrow
  });
  const BaseComponentAsAny = BaseComponent;
  return import_react138.default.createElement(BaseComponentAsAny, _extends({
    className
  }, rest3), children);
}
Row.propTypes = {
  /**
   * Provide a custom element to render instead of the default <div>
   */
  as: import_prop_types103.default.oneOfType([import_prop_types103.default.string, import_prop_types103.default.elementType]),
  /**
   * Pass in content that will be rendered within the `Row`
   */
  children: import_prop_types103.default.node,
  /**
   * Specify a custom className to be applied to the `Row`
   */
  className: import_prop_types103.default.string,
  /**
   * Specify a single row as condensed.Rows that are adjacent
   * and are condensed will have 2px of margin between them to match gutter.
   */
  condensed: import_prop_types103.default.bool,
  /**
   * Specify a single row as narrow. The container will hang
   * 16px into the gutter.
   */
  narrow: import_prop_types103.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Grid/Column.js
var import_classnames87 = __toESM(require_classnames());
var import_prop_types104 = __toESM(require_prop_types());
var import_react139 = __toESM(require_react());
function Column(_ref) {
  let {
    as: BaseComponent = "div",
    children,
    className: customClassName,
    sm,
    md,
    lg,
    xlg,
    max: max4,
    ...rest3
  } = _ref;
  const {
    mode
  } = useGridSettings();
  const prefix = usePrefix();
  if (mode === "css-grid") {
    return import_react139.default.createElement(CSSGridColumn, _extends({
      as: BaseComponent,
      className: customClassName,
      sm,
      md,
      lg,
      xlg,
      max: max4
    }, rest3), children);
  }
  const columnClassName = getClassNameForFlexGridBreakpoints([sm, md, lg, xlg, max4], prefix);
  const className = (0, import_classnames87.default)(customClassName, columnClassName, {
    [`${prefix}--col`]: columnClassName.length === 0
  });
  const BaseComponentAsAny = BaseComponent;
  return import_react139.default.createElement(BaseComponentAsAny, _extends({
    className
  }, rest3), children);
}
var percentSpanType = import_prop_types104.default.oneOf(["25%", "50%", "75%", "100%"]);
var spanPropType = enabled("enable-css-grid") ? import_prop_types104.default.oneOfType([import_prop_types104.default.bool, import_prop_types104.default.number, import_prop_types104.default.shape({
  span: import_prop_types104.default.oneOfType([import_prop_types104.default.number, percentSpanType]),
  offset: import_prop_types104.default.number,
  start: import_prop_types104.default.number,
  end: import_prop_types104.default.number
}), percentSpanType]) : import_prop_types104.default.oneOfType([import_prop_types104.default.bool, import_prop_types104.default.number, import_prop_types104.default.shape({
  span: import_prop_types104.default.number,
  offset: import_prop_types104.default.number
})]);
Column.propTypes = {
  /**
   * Provide a custom element to render instead of the default <div>
   */
  as: import_prop_types104.default.oneOfType([import_prop_types104.default.string, import_prop_types104.default.elementType]),
  /**
   * Pass in content that will be rendered within the `Column`
   */
  children: import_prop_types104.default.node,
  /**
   * Specify a custom className to be applied to the `Column`
   */
  className: import_prop_types104.default.string,
  /**
   * Specify column span for the `lg` breakpoint (Default breakpoint up to 1312px)
   * This breakpoint supports 16 columns by default.
   *
   * @see https://www.carbondesignsystem.com/guidelines/layout#breakpoints
   */
  lg: spanPropType,
  /**
   * Specify column span for the `max` breakpoint. This breakpoint supports 16
   * columns by default.
   *
   * @see https://www.carbondesignsystem.com/guidelines/layout#breakpoints
   */
  max: spanPropType,
  /**
   * Specify column span for the `md` breakpoint (Default breakpoint up to 1056px)
   * This breakpoint supports 8 columns by default.
   *
   * @see https://www.carbondesignsystem.com/guidelines/layout#breakpoints
   */
  md: spanPropType,
  /**
   * Specify column span for the `sm` breakpoint (Default breakpoint up to 672px)
   * This breakpoint supports 4 columns by default.
   *
   * @see https://www.carbondesignsystem.com/guidelines/layout#breakpoints
   */
  sm: spanPropType,
  /**
   * Specify constant column span, start, or end values that will not change
   * based on breakpoint
   */
  span: import_prop_types104.default.oneOfType([import_prop_types104.default.number, percentSpanType]),
  /**
   * Specify column span for the `xlg` breakpoint (Default breakpoint up to
   * 1584px) This breakpoint supports 16 columns by default.
   *
   * @see https://www.carbondesignsystem.com/guidelines/layout#breakpoints
   */
  xlg: spanPropType
};
function CSSGridColumn(_ref2) {
  let {
    as: BaseComponent = "div",
    children,
    className: containerClassName,
    sm,
    md,
    lg,
    xlg,
    max: max4,
    span,
    ...rest3
  } = _ref2;
  const prefix = usePrefix();
  const breakpointClassName = getClassNameForBreakpoints([sm, md, lg, xlg, max4], prefix);
  const spanClassName = getClassNameForSpan(span, prefix);
  const className = (0, import_classnames87.default)(containerClassName, breakpointClassName, spanClassName, {
    [`${prefix}--css-grid-column`]: true
  });
  return import_react139.default.createElement(BaseComponent, _extends({
    className
  }, rest3), children);
}
CSSGridColumn.propTypes = {
  /**
   * Provide a custom element to render instead of the default <div>
   */
  as: import_prop_types104.default.oneOfType([import_prop_types104.default.string, import_prop_types104.default.elementType]),
  /**
   * Pass in content that will be rendered within the `Column`
   */
  children: import_prop_types104.default.node,
  /**
   * Specify a custom className to be applied to the `Column`
   */
  className: import_prop_types104.default.string,
  /**
   * Specify column span for the `lg` breakpoint (Default breakpoint up to 1312px)
   * This breakpoint supports 16 columns by default.
   *
   * @see https://www.carbondesignsystem.com/guidelines/layout#breakpoints
   */
  lg: spanPropType,
  /**
   * Specify column span for the `max` breakpoint. This breakpoint supports 16
   * columns by default.
   *
   * @see https://www.carbondesignsystem.com/guidelines/layout#breakpoints
   */
  max: spanPropType,
  /**
   * Specify column span for the `md` breakpoint (Default breakpoint up to 1056px)
   * This breakpoint supports 8 columns by default.
   *
   * @see https://www.carbondesignsystem.com/guidelines/layout#breakpoints
   */
  md: spanPropType,
  /**
   * Specify column span for the `sm` breakpoint (Default breakpoint up to 672px)
   * This breakpoint supports 4 columns by default.
   *
   * @see https://www.carbondesignsystem.com/guidelines/layout#breakpoints
   */
  sm: spanPropType,
  /**
   * Specify constant column span, start,  or end values that will not change
   * based on breakpoint
   */
  span: import_prop_types104.default.oneOfType([import_prop_types104.default.number, percentSpanType, import_prop_types104.default.shape({
    span: import_prop_types104.default.oneOfType([import_prop_types104.default.number, percentSpanType]),
    start: import_prop_types104.default.number,
    end: import_prop_types104.default.number
  })]),
  /**
   * Specify column span for the `xlg` breakpoint (Default breakpoint up to
   * 1584px) This breakpoint supports 16 columns by default.
   *
   * @see https://www.carbondesignsystem.com/guidelines/layout#breakpoints
   */
  xlg: spanPropType
};
var breakpointNames = ["sm", "md", "lg", "xlg", "max"];
function getClassNameForBreakpoints(breakpoints2, prefix) {
  const classNames = [];
  for (let i = 0; i < breakpoints2.length; i++) {
    const breakpoint = breakpoints2[i];
    if (breakpoint === void 0 || breakpoint === null) {
      continue;
    }
    const name = breakpointNames[i];
    if (breakpoint === true) {
      classNames.push(`${prefix}--${name}:col-span-auto`);
      continue;
    }
    if (typeof breakpoint === "string") {
      classNames.push(`${prefix}--${name}:col-span-${breakpoint.replace("%", "")}`);
      continue;
    }
    if (typeof breakpoint === "number") {
      classNames.push(`${prefix}--${name}:col-span-${breakpoint}`);
      continue;
    }
    if (typeof breakpoint === "object") {
      const {
        span,
        offset: offset5,
        start,
        end
      } = breakpoint;
      if (typeof offset5 === "number") {
        classNames.push(`${prefix}--${name}:col-start-${offset5 > 0 ? offset5 + 1 : "auto"}`);
      }
      if (typeof start === "number") {
        classNames.push(`${prefix}--${name}:col-start-${start ? start : "auto"}`);
      }
      if (typeof end === "number") {
        classNames.push(`${prefix}--${name}:col-end-${end}`);
      }
      if (typeof span === "number") {
        classNames.push(`${prefix}--${name}:col-span-${span}`);
      } else if (typeof span === "string") {
        classNames.push(`${prefix}--${name}:col-span-${span.slice(0, -1)}`);
        continue;
      }
    }
  }
  return classNames.join(" ");
}
function getClassNameForFlexGridBreakpoints(breakpoints2, prefix) {
  const classNames = [];
  for (let i = 0; i < breakpoints2.length; i++) {
    const breakpoint = breakpoints2[i];
    if (breakpoint === void 0 || breakpoint === null) {
      continue;
    }
    const name = breakpointNames[i];
    if (breakpoint === true) {
      classNames.push(`${prefix}--col-${name}`);
      continue;
    }
    if (typeof breakpoint === "number") {
      classNames.push(`${prefix}--col-${name}-${breakpoint}`);
      continue;
    }
    if (typeof breakpoint === "object") {
      const {
        span,
        offset: offset5
      } = breakpoint;
      if (typeof span === "number") {
        classNames.push(`${prefix}--col-${name}-${span}`);
      }
      if (span === true) {
        classNames.push(`${prefix}--col-${name}`);
      }
      if (typeof offset5 === "number") {
        classNames.push(`${prefix}--offset-${name}-${offset5}`);
      }
    }
  }
  return classNames.join(" ");
}
function getClassNameForSpan(value, prefix) {
  const classNames = [];
  if (typeof value === "number") {
    classNames.push(`${prefix}--col-span-${value}`);
  } else if (typeof value === "string") {
    classNames.push(`${prefix}--col-span-${value.slice(0, -1)}`);
  } else if (typeof value === "object") {
    const {
      span,
      start,
      end
    } = value;
    if (span !== void 0 && span !== null) {
      classNames.push(`${prefix}--col-span-${span}`);
    }
    if (start !== void 0 && start !== null) {
      classNames.push(`${prefix}--col-start-${start}`);
    }
    if (end !== void 0 && end !== null) {
      classNames.push(`${prefix}--col-end-${end}`);
    }
  }
  return classNames.join("");
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Grid/ColumnHang.js
var import_classnames88 = __toESM(require_classnames());
var import_prop_types105 = __toESM(require_prop_types());
var import_react140 = __toESM(require_react());
function ColumnHang(_ref) {
  let {
    as: BaseComponent = "div",
    className: customClassName,
    children,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const className = (0, import_classnames88.default)(customClassName, `${prefix}--grid-column-hang`);
  const BaseComponentAsAny = BaseComponent;
  return import_react140.default.createElement(BaseComponentAsAny, _extends({}, rest3, {
    className
  }), children);
}
ColumnHang.propTypes = {
  /**
   * Provide a custom element to render instead of the default <div>
   */
  as: import_prop_types105.default.oneOfType([import_prop_types105.default.string, import_prop_types105.default.elementType]),
  /**
   * Pass in content that will be rendered within the `Grid`
   */
  children: import_prop_types105.default.node,
  /**
   * Specify a custom className to be applied to the `Grid`
   */
  className: import_prop_types105.default.string
};
var ColumnHangComponent = ColumnHang;

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Icon/Icon.Skeleton.js
var import_prop_types106 = __toESM(require_prop_types());
var import_react141 = __toESM(require_react());
var import_classnames89 = __toESM(require_classnames());
var IconSkeleton = (_ref) => {
  let {
    className,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  return import_react141.default.createElement("div", _extends({
    className: (0, import_classnames89.default)(`${prefix}--icon--skeleton`, className)
  }, rest3));
};
IconSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types106.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/IdPrefix/index.js
var import_prop_types107 = __toESM(require_prop_types());
var import_react142 = __toESM(require_react());
function IdPrefix(_ref) {
  let {
    children,
    prefix
  } = _ref;
  return import_react142.default.createElement(IdPrefixContext.Provider, {
    value: prefix
  }, children);
}
IdPrefix.propTypes = {
  children: import_prop_types107.default.node,
  /**
   * The value used to prefix the auto-generated id placed on some DOM elements
   */
  prefix: import_prop_types107.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ListItem/ListItem.js
var import_prop_types108 = __toESM(require_prop_types());
var import_react143 = __toESM(require_react());
var import_classnames90 = __toESM(require_classnames());
function ListItem(_ref) {
  let {
    className,
    children,
    ...other
  } = _ref;
  const prefix = usePrefix();
  const classNames = (0, import_classnames90.default)(`${prefix}--list__item`, className);
  return import_react143.default.createElement(Text, _extends({
    as: "li",
    className: classNames
  }, other), children);
}
ListItem.propTypes = {
  /**
   * Specify the content for the ListItem
   */
  children: import_prop_types108.default.node,
  /**
   * Specify an optional className to apply to the underlying `<li>` node
   */
  className: import_prop_types108.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/MenuButton/index.js
var import_react144 = __toESM(require_react());
var import_prop_types109 = __toESM(require_prop_types());
var import_classnames91 = __toESM(require_classnames());
var validButtonKinds = ["primary", "tertiary", "ghost"];
var defaultButtonKind = "primary";
var MenuButton = (0, import_react144.forwardRef)(function MenuButton2(_ref, forwardRef13) {
  let {
    children,
    className,
    disabled,
    kind = defaultButtonKind,
    label,
    size: size$1 = "lg",
    menuAlignment = "bottom",
    tabIndex = 0,
    menuTarget,
    ...rest3
  } = _ref;
  const enableOnlyFloatingStyles = useFeatureFlag("enable-v12-dynamic-floating-styles");
  const id = useId("MenuButton");
  const prefix = usePrefix();
  const triggerRef = (0, import_react144.useRef)(null);
  let middlewares = [];
  if (!enableOnlyFloatingStyles) {
    middlewares = [flip3({
      crossAxis: false
    })];
  }
  if (menuAlignment === "bottom" || menuAlignment === "top") {
    middlewares.push(size3({
      apply(_ref2) {
        let {
          rects,
          elements
        } = _ref2;
        Object.assign(elements.floating.style, {
          width: `${rects.reference.width}px`
        });
      }
    }));
  }
  const {
    refs,
    floatingStyles,
    placement,
    middlewareData
  } = useFloating2({
    placement: menuAlignment,
    // The floating element is positioned relative to its nearest
    // containing block (usually the viewport). It will in many cases also
    // “break” the floating element out of a clipping ancestor.
    // https://floating-ui.com/docs/misc#clipping
    strategy: "fixed",
    // Middleware order matters, arrow should be last
    middleware: middlewares,
    whileElementsMounted: autoUpdate
  });
  const ref = mergeRefs$1(forwardRef13, triggerRef);
  const {
    open,
    handleClick: hookOnClick,
    handleMousedown,
    handleClose
  } = useAttachedMenu(triggerRef);
  (0, import_react144.useLayoutEffect)(() => {
    Object.keys(floatingStyles).forEach((style) => {
      if (refs.floating.current) {
        refs.floating.current.style[style] = floatingStyles[style];
      }
    });
  }, [floatingStyles, refs.floating, middlewareData, placement, open]);
  function handleClick2() {
    if (triggerRef.current) {
      hookOnClick();
    }
  }
  const containerClasses = (0, import_classnames91.default)(`${prefix}--menu-button__container`, className);
  const triggerClasses = (0, import_classnames91.default)(`${prefix}--menu-button__trigger`, {
    [`${prefix}--menu-button__trigger--open`]: open
  });
  const menuClasses = (0, import_classnames91.default)(`${prefix}--menu-button__${menuAlignment}`);
  return import_react144.default.createElement("div", _extends({}, rest3, {
    ref,
    "aria-owns": open ? id : void 0,
    className: containerClasses
  }), import_react144.default.createElement(Button, {
    ref: refs.setReference,
    className: triggerClasses,
    size: size$1,
    tabIndex,
    kind,
    renderIcon: ChevronDown,
    disabled,
    "aria-haspopup": true,
    "aria-expanded": open,
    onClick: handleClick2,
    onMouseDown: handleMousedown,
    "aria-controls": open ? id : void 0
  }, label), import_react144.default.createElement(Menu2, {
    containerRef: triggerRef,
    menuAlignment,
    className: menuClasses,
    ref: refs.setFloating,
    id,
    legacyAutoalign: false,
    label,
    mode: "basic",
    size: size$1,
    open,
    onClose: handleClose,
    target: menuTarget
  }, children));
});
MenuButton.propTypes = {
  /**
   * A collection of MenuItems to be rendered as actions for this MenuButton.
   */
  children: import_prop_types109.default.node.isRequired,
  /**
   * Additional CSS class names.
   */
  className: import_prop_types109.default.string,
  /**
   * Specify whether the MenuButton should be disabled, or not.
   */
  disabled: import_prop_types109.default.bool,
  /**
   * Specify the type of button to be used as the base for the trigger button.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  kind: import_prop_types109.default.oneOf(validButtonKinds),
  /**
   * Provide the label to be renderd on the trigger button.
   */
  label: import_prop_types109.default.string.isRequired,
  /**
   * Experimental property. Specify how the menu should align with the button element
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  menuAlignment: import_prop_types109.default.oneOf(["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end"]),
  /**
   * Specify the size of the button and menu.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  size: import_prop_types109.default.oneOf(["sm", "md", "lg"]),
  /**
   * Specify the tabIndex of the button.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  tabIndex: import_prop_types109.default.number,
  /**
   * Specify a DOM node where the Menu should be rendered in. Defaults to document.body.
   */
  menuTarget: import_prop_types109.default.instanceOf(typeof Element !== "undefined" ? Element : Object)
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Modal/Modal.js
var import_prop_types110 = __toESM(require_prop_types());
var import_react146 = __toESM(require_react());
var import_classnames92 = __toESM(require_classnames());
var ModalSizes = ["xs", "sm", "md", "lg"];
var Modal = import_react146.default.forwardRef(function Modal2(_ref, ref) {
  var _a;
  let {
    "aria-label": ariaLabelProp,
    children,
    className,
    decorator,
    modalHeading = "",
    modalLabel = "",
    modalAriaLabel,
    passiveModal = false,
    secondaryButtonText,
    primaryButtonText,
    open,
    onRequestClose = noopFn,
    onRequestSubmit = noopFn,
    onSecondarySubmit,
    primaryButtonDisabled = false,
    danger,
    alert,
    secondaryButtons,
    selectorPrimaryFocus = "[data-modal-primary-focus]",
    selectorsFloatingMenus,
    shouldSubmitOnEnter,
    size: size6,
    hasScrollingContent = false,
    closeButtonLabel = "Close",
    preventCloseOnClickOutside = false,
    isFullWidth,
    launcherButtonRef,
    loadingStatus = "inactive",
    loadingDescription,
    loadingIconDescription,
    onLoadingSuccess = noopFn,
    slug,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const button = (0, import_react146.useRef)(null);
  const secondaryButton = (0, import_react146.useRef)(null);
  const contentRef = (0, import_react146.useRef)(null);
  const innerModal = (0, import_react146.useRef)(null);
  const startTrap = (0, import_react146.useRef)(null);
  const endTrap = (0, import_react146.useRef)(null);
  const [isScrollable, setIsScrollable] = (0, import_react146.useState)(false);
  const modalInstanceId = `modal-${useId()}`;
  const modalLabelId = `${prefix}--modal-header__label--${modalInstanceId}`;
  const modalHeadingId = `${prefix}--modal-header__heading--${modalInstanceId}`;
  const modalBodyId = `${prefix}--modal-body--${modalInstanceId}`;
  const modalCloseButtonClass = `${prefix}--modal-close`;
  const primaryButtonClass = (0, import_classnames92.default)({
    [`${prefix}--btn--loading`]: loadingStatus !== "inactive"
  });
  const loadingActive = loadingStatus !== "inactive";
  const focusTrapWithoutSentinels = useFeatureFlag("enable-experimental-focus-wrap-without-sentinels");
  function isCloseButton(element) {
    return !onSecondarySubmit && element === secondaryButton.current || element.classList.contains(modalCloseButtonClass);
  }
  function handleKeyDown(evt) {
    evt.stopPropagation();
    if (open) {
      if (match(evt, Escape)) {
        onRequestClose(evt);
      }
      if (match(evt, Enter) && shouldSubmitOnEnter && !isCloseButton(evt.target)) {
        onRequestSubmit(evt);
      }
      if (focusTrapWithoutSentinels && match(evt, Tab) && innerModal.current) {
        wrapFocusWithoutSentinels({
          containerNode: innerModal.current,
          currentActiveNode: evt.target,
          event: evt
        });
      }
    }
  }
  function handleOnClick(evt) {
    const target = evt.target;
    evt.stopPropagation();
    if (!preventCloseOnClickOutside && !elementOrParentIsFloatingMenu(target, selectorsFloatingMenus) && innerModal.current && !innerModal.current.contains(target)) {
      onRequestClose(evt);
    }
  }
  function handleBlur(_ref2) {
    let {
      target: oldActiveNode,
      relatedTarget: currentActiveNode
    } = _ref2;
    if (open && currentActiveNode && oldActiveNode) {
      const {
        current: bodyNode
      } = innerModal;
      const {
        current: startTrapNode
      } = startTrap;
      const {
        current: endTrapNode
      } = endTrap;
      wrapFocus({
        bodyNode,
        startTrapNode,
        endTrapNode,
        currentActiveNode,
        oldActiveNode,
        selectorsFloatingMenus
      });
    }
  }
  const onSecondaryButtonClick = onSecondarySubmit ? onSecondarySubmit : onRequestClose;
  const modalClasses = (0, import_classnames92.default)(`${prefix}--modal`, {
    [`${prefix}--modal-tall`]: !passiveModal,
    "is-visible": open,
    [`${prefix}--modal--danger`]: danger,
    [`${prefix}--modal--slug`]: slug,
    [`${prefix}--modal--decorator`]: decorator
  }, className);
  const containerClasses = (0, import_classnames92.default)(`${prefix}--modal-container`, {
    [`${prefix}--modal-container--${size6}`]: size6,
    [`${prefix}--modal-container--full-width`]: isFullWidth
  });
  const contentClasses = (0, import_classnames92.default)(`${prefix}--modal-content`, {
    [`${prefix}--modal-scroll-content`]: hasScrollingContent || isScrollable
  });
  const footerClasses = (0, import_classnames92.default)(`${prefix}--modal-footer`, {
    [`${prefix}--modal-footer--three-button`]: Array.isArray(secondaryButtons) && secondaryButtons.length === 2
  });
  const asStringOrUndefined = (node) => {
    return typeof node === "string" ? node : void 0;
  };
  const modalLabelStr = asStringOrUndefined(modalLabel);
  const modalHeadingStr = asStringOrUndefined(modalHeading);
  const ariaLabel = modalLabelStr || ariaLabelProp || modalAriaLabel || modalHeadingStr;
  const getAriaLabelledBy = modalLabel ? modalLabelId : modalHeadingId;
  const hasScrollingContentProps = hasScrollingContent || isScrollable ? {
    tabIndex: 0,
    role: "region",
    "aria-label": ariaLabel,
    "aria-labelledby": getAriaLabelledBy
  } : {};
  const alertDialogProps = {};
  if (alert && passiveModal) {
    alertDialogProps.role = "alert";
  }
  if (alert && !passiveModal) {
    alertDialogProps.role = "alertdialog";
    alertDialogProps["aria-describedby"] = modalBodyId;
  }
  (0, import_react146.useEffect)(() => {
    return () => {
      toggleClass(document.body, `${prefix}--body--with-modal-open`, false);
    };
  }, [prefix]);
  (0, import_react146.useEffect)(() => {
    toggleClass(document.body, `${prefix}--body--with-modal-open`, open ?? false);
  }, [open, prefix]);
  (0, import_react146.useEffect)(() => {
    if (!open && launcherButtonRef) {
      setTimeout(() => {
        var _a2;
        (_a2 = launcherButtonRef == null ? void 0 : launcherButtonRef.current) == null ? void 0 : _a2.focus();
      });
    }
  }, [open, launcherButtonRef]);
  (0, import_react146.useEffect)(() => {
    const initialFocus = (focusContainerElement) => {
      const containerElement = focusContainerElement || innerModal.current;
      const primaryFocusElement = containerElement ? containerElement.querySelector(danger ? `.${prefix}--btn--secondary` : selectorPrimaryFocus) : null;
      if (primaryFocusElement) {
        return primaryFocusElement;
      }
      return button && button.current;
    };
    const focusButton = (focusContainerElement) => {
      const target = initialFocus(focusContainerElement);
      if (target !== null) {
        target.focus();
      }
    };
    if (open) {
      focusButton(innerModal.current);
    }
  }, [open, selectorPrimaryFocus, danger, prefix]);
  useIsomorphicEffect$1(() => {
    if (contentRef.current) {
      setIsScrollable(contentRef.current.scrollHeight > contentRef.current.clientHeight);
    }
    function handler() {
      if (contentRef.current) {
        setIsScrollable(contentRef.current.scrollHeight > contentRef.current.clientHeight);
      }
    }
    const debouncedHandler = debounce2(handler, 200);
    window.addEventListener("resize", debouncedHandler);
    return () => {
      debouncedHandler.cancel();
      window.removeEventListener("resize", debouncedHandler);
    };
  }, []);
  let normalizedDecorator = import_react146.default.isValidElement(slug ?? decorator) ? slug ?? decorator : null;
  if (normalizedDecorator && ((_a = normalizedDecorator["type"]) == null ? void 0 : _a.displayName) === "AILabel") {
    normalizedDecorator = import_react146.default.cloneElement(normalizedDecorator, {
      size: "sm"
    });
  }
  const modalButton = import_react146.default.createElement("div", {
    className: `${prefix}--modal-close-button`
  }, import_react146.default.createElement(IconButton, {
    className: modalCloseButtonClass,
    label: closeButtonLabel,
    onClick: onRequestClose,
    "aria-label": closeButtonLabel,
    align: "left",
    ref: button
  }, import_react146.default.createElement(Close, {
    size: 20,
    "aria-hidden": "true",
    tabIndex: "-1",
    className: `${modalCloseButtonClass}__icon`
  })));
  const modalBody = import_react146.default.createElement("div", _extends({
    ref: innerModal,
    role: "dialog"
  }, alertDialogProps, {
    className: containerClasses,
    "aria-label": ariaLabel,
    "aria-modal": "true",
    tabIndex: -1
  }), import_react146.default.createElement("div", {
    className: `${prefix}--modal-header`
  }, passiveModal && modalButton, modalLabel && import_react146.default.createElement(Text, {
    as: "h2",
    id: modalLabelId,
    className: `${prefix}--modal-header__label`
  }, modalLabel), import_react146.default.createElement(Text, {
    as: "h2",
    id: modalHeadingId,
    className: `${prefix}--modal-header__heading`
  }, modalHeading), slug ? normalizedDecorator : decorator ? import_react146.default.createElement("div", {
    className: `${prefix}--modal--inner__decorator`
  }, normalizedDecorator) : "", !passiveModal && modalButton), import_react146.default.createElement(Layer2, _extends({
    ref: contentRef,
    id: modalBodyId,
    className: contentClasses
  }, hasScrollingContentProps), children), !passiveModal && import_react146.default.createElement(ButtonSet, {
    className: footerClasses,
    "aria-busy": loadingActive
  }, Array.isArray(secondaryButtons) && secondaryButtons.length <= 2 ? secondaryButtons.map((_ref3, i) => {
    let {
      buttonText,
      onClick: onButtonClick
    } = _ref3;
    return import_react146.default.createElement(Button, {
      key: `${buttonText}-${i}`,
      kind: "secondary",
      onClick: onButtonClick
    }, buttonText);
  }) : secondaryButtonText && import_react146.default.createElement(Button, {
    disabled: loadingActive,
    kind: "secondary",
    onClick: onSecondaryButtonClick,
    ref: secondaryButton
  }, secondaryButtonText), import_react146.default.createElement(Button, {
    className: primaryButtonClass,
    kind: danger ? "danger" : "primary",
    disabled: loadingActive || primaryButtonDisabled,
    onClick: onRequestSubmit,
    ref: button
  }, loadingStatus === "inactive" ? primaryButtonText : import_react146.default.createElement(InlineLoading, {
    status: loadingStatus,
    description: loadingDescription,
    iconDescription: loadingIconDescription,
    className: `${prefix}--inline-loading--btn`,
    onSuccess: onLoadingSuccess
  }))));
  return import_react146.default.createElement(Layer2, _extends({}, rest3, {
    level: 0,
    onKeyDown: handleKeyDown,
    onClick: composeEventHandlers([rest3 == null ? void 0 : rest3.onClick, handleOnClick]),
    onBlur: !focusTrapWithoutSentinels ? handleBlur : () => {
    },
    className: modalClasses,
    role: "presentation",
    ref
  }), !focusTrapWithoutSentinels && import_react146.default.createElement("span", {
    ref: startTrap,
    tabIndex: 0,
    role: "link",
    className: `${prefix}--visually-hidden`
  }, "Focus sentinel"), modalBody, !focusTrapWithoutSentinels && import_react146.default.createElement("span", {
    ref: endTrap,
    tabIndex: 0,
    role: "link",
    className: `${prefix}--visually-hidden`
  }, "Focus sentinel"));
});
Modal.propTypes = {
  /**
   * Specify whether the Modal is displaying an alert, error or warning
   * Should go hand in hand with the danger prop.
   */
  alert: import_prop_types110.default.bool,
  /**
   * Required props for the accessibility label of the header
   */
  ["aria-label"]: requiredIfGivenPropIsTruthy("hasScrollingContent", import_prop_types110.default.string),
  /**
   * Provide the contents of your Modal
   */
  children: import_prop_types110.default.node,
  /**
   * Specify an optional className to be applied to the modal root node
   */
  className: import_prop_types110.default.string,
  /**
   * Specify an label for the close button of the modal; defaults to close
   */
  closeButtonLabel: import_prop_types110.default.string,
  /**
   * Specify whether the Modal is for dangerous actions
   */
  danger: import_prop_types110.default.bool,
  /**
   * **Experimental**: Provide a decorator component to be rendered inside the `Modal` component
   */
  decorator: import_prop_types110.default.node,
  /**
   * Specify whether the modal contains scrolling content
   */
  hasScrollingContent: import_prop_types110.default.bool,
  /**
   * Specify the DOM element ID of the top-level node.
   */
  id: import_prop_types110.default.string,
  /**
   * Specify whether or not the Modal content should have any inner padding.
   */
  isFullWidth: import_prop_types110.default.bool,
  /**
   * Provide a ref to return focus to once the modal is closed.
   */
  launcherButtonRef: import_prop_types110.default.oneOfType([import_prop_types110.default.func, import_prop_types110.default.shape({
    current: import_prop_types110.default.any
  })]),
  /**
   * Specify the description for the loading text
   */
  loadingDescription: import_prop_types110.default.string,
  /**
   * Specify the description for the loading text
   */
  loadingIconDescription: import_prop_types110.default.string,
  /**
   * loading status
   */
  loadingStatus: import_prop_types110.default.oneOf(["inactive", "active", "finished", "error"]),
  /**
   * Specify a label to be read by screen readers on the modal root node
   */
  modalAriaLabel: import_prop_types110.default.string,
  /**
   * Specify the content of the modal header title.
   */
  modalHeading: import_prop_types110.default.node,
  /**
   * Specify the content of the modal header label.
   */
  modalLabel: import_prop_types110.default.node,
  /**
   * Specify a handler for keypresses.
   */
  onKeyDown: import_prop_types110.default.func,
  /**
   * Provide an optional handler to be invoked when loading is
   * successful
   */
  onLoadingSuccess: import_prop_types110.default.func,
  /**
   * Specify a handler for closing modal.
   * The handler should care of closing modal, e.g. changing `open` prop.
   */
  onRequestClose: import_prop_types110.default.func,
  /**
   * Specify a handler for "submitting" modal.
   * The handler should care of closing modal, e.g. changing `open` prop, if necessary.
   */
  onRequestSubmit: import_prop_types110.default.func,
  /**
   * Specify a handler for the secondary button.
   * Useful if separate handler from `onRequestClose` is desirable
   */
  onSecondarySubmit: import_prop_types110.default.func,
  /**
   * Specify whether the Modal is currently open
   */
  open: import_prop_types110.default.bool,
  /**
   * Specify whether the modal should be button-less
   */
  passiveModal: import_prop_types110.default.bool,
  /**
   * Prevent closing on click outside of modal
   */
  preventCloseOnClickOutside: import_prop_types110.default.bool,
  /**
   * Specify whether the Button should be disabled, or not
   */
  primaryButtonDisabled: import_prop_types110.default.bool,
  /**
   * Specify the text for the primary button
   */
  primaryButtonText: import_prop_types110.default.node,
  /**
   * Specify the text for the secondary button
   */
  secondaryButtonText: import_prop_types110.default.node,
  /**
   * Specify an array of config objects for secondary buttons
   * (`Array<{
   *   buttonText: string,
   *   onClick: function,
   * }>`).
   */
  secondaryButtons: (props, propName, componentName) => {
    if (props.secondaryButtons) {
      if (!Array.isArray(props.secondaryButtons) || props.secondaryButtons.length !== 2) {
        return new Error(`${propName} needs to be an array of two button config objects`);
      }
      const shape = {
        buttonText: import_prop_types110.default.node,
        onClick: import_prop_types110.default.func
      };
      props[propName].forEach((secondaryButton) => {
        import_prop_types110.default.checkPropTypes(shape, secondaryButton, propName, componentName);
      });
    }
    return null;
  },
  /**
   * Specify a CSS selector that matches the DOM element that should
   * be focused when the Modal opens
   */
  selectorPrimaryFocus: import_prop_types110.default.string,
  /**
   * Specify CSS selectors that match DOM elements working as floating menus.
   * Focusing on those elements won't trigger "focus-wrap" behavior
   */
  selectorsFloatingMenus: import_prop_types110.default.arrayOf(import_prop_types110.default.string.isRequired),
  /**
   * Specify if Enter key should be used as "submit" action
   */
  shouldSubmitOnEnter: import_prop_types110.default.bool,
  /**
   * Specify the size variant.
   */
  size: import_prop_types110.default.oneOf(ModalSizes),
  slug: deprecate(import_prop_types110.default.node, "The `slug` prop has been deprecated and will be removed in the next major version. Use the decorator prop instead.")
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ModalWrapper/ModalWrapper.js
var import_prop_types111 = __toESM(require_prop_types());
var import_react147 = __toESM(require_react());
var didWarnAboutDeprecation5 = false;
var ModalWrapper = class extends import_react147.default.Component {
  constructor() {
    super(...arguments);
    _defineProperty(this, "triggerButton", import_react147.default.createRef());
    _defineProperty(this, "modal", import_react147.default.createRef());
    _defineProperty(this, "state", {
      isOpen: false
    });
    _defineProperty(this, "handleOpen", () => {
      this.setState({
        isOpen: true
      });
    });
    _defineProperty(this, "handleClose", (evt) => {
      var _a;
      const innerModal = (_a = this.modal.current) == null ? void 0 : _a.querySelector("div");
      if (this.modal.current && evt && !(innerModal == null ? void 0 : innerModal.contains(evt.target)) && this.props.preventCloseOnClickOutside) {
        return;
      } else {
        this.setState({
          isOpen: false
        }, () => {
          var _a2;
          return (_a2 = this.triggerButton.current) == null ? void 0 : _a2.focus();
        });
      }
    });
    _defineProperty(this, "handleOnRequestSubmit", (evt) => {
      const {
        handleSubmit,
        shouldCloseAfterSubmit
      } = this.props;
      if (handleSubmit && shouldCloseAfterSubmit) {
        handleSubmit(evt);
        this.handleClose(evt);
      }
      handleSubmit == null ? void 0 : handleSubmit(evt);
    });
  }
  if(__DEV__) {
    true ? warning(didWarnAboutDeprecation5, "`<ModalWrapper>` has been deprecated in favor of `<ComposedModal/>` and will be removed in the next major version, `@carbon/react@v2.x`") : void 0;
    didWarnAboutDeprecation5 = true;
  }
  render() {
    const {
      children,
      onKeyDown = noopFn,
      buttonTriggerText,
      buttonTriggerClassName,
      renderTriggerButtonIcon,
      primaryButtonText = "Save",
      secondaryButtonText = "Cancel",
      triggerButtonIconDescription = "Provide icon description if icon is used",
      triggerButtonKind = "primary",
      disabled = false,
      handleSubmit,
      // eslint-disable-line @typescript-eslint/no-unused-vars
      shouldCloseAfterSubmit = true,
      // eslint-disable-line @typescript-eslint/no-unused-vars
      selectorPrimaryFocus = "[data-modal-primary-focus]",
      preventCloseOnClickOutside = false,
      // eslint-disable-line @typescript-eslint/no-unused-vars
      ...other
    } = this.props;
    const props = {
      ...other,
      selectorPrimaryFocus,
      open: this.state.isOpen,
      onRequestClose: this.handleClose,
      onRequestSubmit: this.handleOnRequestSubmit
    };
    return import_react147.default.createElement("div", {
      role: "presentation",
      onKeyDown: (evt) => {
        if (match(evt, Escape)) {
          this.handleClose(evt);
          onKeyDown(evt);
        }
      }
    }, import_react147.default.createElement(Button, {
      className: buttonTriggerClassName,
      disabled,
      kind: triggerButtonKind,
      renderIcon: renderTriggerButtonIcon,
      iconDescription: triggerButtonIconDescription,
      onClick: this.handleOpen,
      ref: this.triggerButton
    }, buttonTriggerText), import_react147.default.createElement(Modal, _extends({
      ref: this.modal,
      primaryButtonText,
      secondaryButtonText
    }, props), children));
  }
};
_defineProperty(ModalWrapper, "propTypes", {
  buttonTriggerClassName: import_prop_types111.default.string,
  buttonTriggerText: import_prop_types111.default.node,
  children: import_prop_types111.default.node,
  disabled: import_prop_types111.default.bool,
  handleOpen: import_prop_types111.default.func,
  handleSubmit: import_prop_types111.default.func,
  id: import_prop_types111.default.string,
  modalBeforeContent: import_prop_types111.default.bool,
  modalHeading: import_prop_types111.default.string,
  modalLabel: import_prop_types111.default.string,
  modalText: import_prop_types111.default.string,
  onKeyDown: import_prop_types111.default.func,
  passiveModal: import_prop_types111.default.bool,
  preventCloseOnClickOutside: import_prop_types111.default.bool,
  primaryButtonText: import_prop_types111.default.string,
  renderTriggerButtonIcon: import_prop_types111.default.oneOfType([import_prop_types111.default.func, import_prop_types111.default.object]),
  secondaryButtonText: import_prop_types111.default.string,
  selectorPrimaryFocus: import_prop_types111.default.string,
  shouldCloseAfterSubmit: import_prop_types111.default.bool,
  status: import_prop_types111.default.string,
  triggerButtonIconDescription: import_prop_types111.default.string,
  triggerButtonKind: import_prop_types111.default.oneOf(ButtonKinds),
  withHeader: import_prop_types111.default.bool
});

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/MultiSelect/MultiSelect.js
var import_classnames93 = __toESM(require_classnames());
var import_react_fast_compare4 = __toESM(require_react_fast_compare());
var import_prop_types114 = __toESM(require_prop_types());
var import_react149 = __toESM(require_react());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/MultiSelect/MultiSelectPropTypes.js
var import_prop_types112 = __toESM(require_prop_types());
var sortingPropTypes = {
  /**
   * Provide a compare function that is used to determine the ordering of
   * options. `compareItems` has the following function signature:
   *
   * compareFunction :
   *  (itemA: string, itemB: string, { locale: string }) => number
   */
  compareItems: import_prop_types112.default.func,
  /**
   * Provide a method that sorts all options in the control. Overriding this
   * prop means that you also have to handle the sort logic for selected versus
   * un-selected items. If you just want to control ordering, consider the
   * `compareItems` prop instead.
   *
   * `sortItems` has the following signature:
   *
   * sortItems :
   *   (items: Array<Item>, {
   *     selectedItems: Array<Item>,
   *     itemToString: Item => string,
   *     compareItems: (itemA: string, itemB: string, {
   *       locale: string
   *     }) => number,
   *     locale: string,
   *   }) => Array<Item>
   */
  sortItems: import_prop_types112.default.func
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/MultiSelect/tools/sorting.js
var defaultCompareItems = (itemA, itemB, _ref) => {
  let {
    locale
  } = _ref;
  return itemA.localeCompare(itemB, locale, {
    numeric: true
  });
};
var defaultSortItems = (items, _ref2) => {
  let {
    selectedItems = [],
    itemToString: itemToString3,
    compareItems,
    locale = "en"
  } = _ref2;
  return items.sort((itemA, itemB) => {
    if (itemA.isSelectAll) return -1;
    if (itemB.isSelectAll) return 1;
    const hasItemA = selectedItems.includes(itemA);
    const hasItemB = selectedItems.includes(itemB);
    if (hasItemA && !hasItemB) return -1;
    if (hasItemB && !hasItemA) return 1;
    return compareItems(itemToString3(itemA), itemToString3(itemB), {
      locale
    });
  });
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/internal/Selection.js
var import_react148 = __toESM(require_react());
var import_prop_types113 = __toESM(require_prop_types());
var import_react_fast_compare3 = __toESM(require_react_fast_compare());
function callOnChangeHandler(_ref) {
  let {
    isControlled,
    isMounted,
    onChangeHandlerControlled,
    onChangeHandlerUncontrolled,
    selectedItems
  } = _ref;
  if (isControlled) {
    if (isMounted && onChangeHandlerControlled) {
      onChangeHandlerControlled({
        selectedItems
      });
    }
  } else {
    onChangeHandlerUncontrolled(selectedItems);
  }
}
function useSelection(_ref2) {
  let {
    disabled,
    onChange,
    initialSelectedItems = [],
    selectedItems: controlledItems,
    selectAll = false,
    filteredItems = []
  } = _ref2;
  const isMounted = (0, import_react148.useRef)(false);
  const savedOnChange = (0, import_react148.useRef)(onChange);
  const [uncontrolledItems, setUncontrolledItems] = (0, import_react148.useState)(initialSelectedItems);
  const isControlled = !!controlledItems;
  const selectedItems = isControlled ? controlledItems : uncontrolledItems;
  const onItemChange = (0, import_react148.useCallback)((item) => {
    if (disabled) {
      return;
    }
    const allSelectableItems = filteredItems.filter((item2) => !item2.disabled);
    const disabledItemCount = filteredItems.filter((item2) => item2.disabled).length;
    let newSelectedItems;
    if (item && item.isSelectAll && selectedItems.length > 0) {
      newSelectedItems = [];
    } else if (item && item.isSelectAll && selectedItems.length == 0) {
      newSelectedItems = allSelectableItems;
    } else {
      let selectedIndex;
      selectedItems.forEach((selectedItem, index4) => {
        if ((0, import_react_fast_compare3.default)(selectedItem, item)) {
          selectedIndex = index4;
        }
      });
      if (selectedIndex === void 0) {
        newSelectedItems = selectedItems.concat(item);
        if (selectAll && filteredItems.length - 1 === newSelectedItems.length + disabledItemCount) {
          newSelectedItems = allSelectableItems;
        }
      } else {
        newSelectedItems = removeAtIndex(selectedItems, selectedIndex);
        newSelectedItems = newSelectedItems.filter((item2) => !item2.isSelectAll);
      }
    }
    callOnChangeHandler({
      isControlled,
      isMounted: isMounted.current,
      onChangeHandlerControlled: savedOnChange.current,
      onChangeHandlerUncontrolled: setUncontrolledItems,
      selectedItems: newSelectedItems
    });
  }, [disabled, selectedItems, filteredItems, selectAll, isControlled]);
  const clearSelection = (0, import_react148.useCallback)(() => {
    if (disabled) {
      return;
    }
    callOnChangeHandler({
      isControlled,
      isMounted: isMounted.current,
      onChangeHandlerControlled: savedOnChange.current,
      onChangeHandlerUncontrolled: setUncontrolledItems,
      selectedItems: []
    });
  }, [disabled, isControlled]);
  (0, import_react148.useEffect)(() => {
    savedOnChange.current = onChange;
  }, [onChange]);
  (0, import_react148.useEffect)(() => {
    if (isMounted.current && savedOnChange.current && !isControlled) {
      savedOnChange.current({
        selectedItems
      });
    }
  }, [isControlled, selectedItems]);
  (0, import_react148.useEffect)(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return {
    selectedItems,
    onItemChange,
    clearSelection
  };
}
var Selection = class extends import_react148.default.Component {
  constructor(props) {
    super(props);
    _defineProperty(this, "internalSetState", (stateToSet, callback) => this.setState(stateToSet, () => {
      if (callback) {
        callback();
      }
      if (this.props.onChange) {
        this.props.onChange(this.state);
      }
    }));
    _defineProperty(this, "handleClearSelection", () => {
      if (this.props.disabled) {
        return;
      }
      this.internalSetState({
        selectedItems: []
      });
    });
    _defineProperty(this, "handleSelectItem", (item) => {
      this.internalSetState((state) => ({
        selectedItems: state.selectedItems.concat(item)
      }));
    });
    _defineProperty(this, "handleRemoveItem", (index4) => {
      this.internalSetState((state) => ({
        selectedItems: removeAtIndex(state.selectedItems, index4)
      }));
    });
    _defineProperty(this, "handleOnItemChange", (item) => {
      if (this.props.disabled) {
        return;
      }
      const {
        selectedItems
      } = this.state;
      let selectedIndex;
      selectedItems.forEach((selectedItem, index4) => {
        if ((0, import_react_fast_compare3.default)(selectedItem, item)) {
          selectedIndex = index4;
        }
      });
      if (selectedIndex === void 0) {
        this.handleSelectItem(item);
        return;
      }
      this.handleRemoveItem(selectedIndex);
    });
    this.state = {
      selectedItems: props.initialSelectedItems
    };
  }
  render() {
    const {
      children,
      render
    } = this.props;
    const {
      selectedItems
    } = this.state;
    const renderProps = {
      selectedItems,
      onItemChange: this.handleOnItemChange,
      clearSelection: this.handleClearSelection
    };
    if (render !== void 0) {
      return render(renderProps);
    }
    if (children !== void 0) {
      return children(renderProps);
    }
    return null;
  }
};
_defineProperty(Selection, "propTypes", {
  children: import_prop_types113.default.func,
  disabled: import_prop_types113.default.bool,
  initialSelectedItems: import_prop_types113.default.array.isRequired,
  onChange: import_prop_types113.default.func,
  render: import_prop_types113.default.func
});
var removeAtIndex = (array, index4) => {
  const result = array.slice();
  result.splice(index4, 1);
  return result;
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/MultiSelect/MultiSelect.js
var {
  ItemClick: ItemClick2,
  ToggleButtonBlur: ToggleButtonBlur2,
  ToggleButtonKeyDownArrowDown: ToggleButtonKeyDownArrowDown2,
  ToggleButtonKeyDownArrowUp: ToggleButtonKeyDownArrowUp2,
  ToggleButtonKeyDownEnter: ToggleButtonKeyDownEnter2,
  ToggleButtonKeyDownEscape: ToggleButtonKeyDownEscape2,
  ToggleButtonKeyDownSpaceButton: ToggleButtonKeyDownSpaceButton2,
  ItemMouseMove: ItemMouseMove4,
  MenuMouseLeave: MenuMouseLeave4,
  ToggleButtonClick: ToggleButtonClick3,
  ToggleButtonKeyDownPageDown: ToggleButtonKeyDownPageDown2,
  ToggleButtonKeyDownPageUp: ToggleButtonKeyDownPageUp2,
  FunctionSetHighlightedIndex: FunctionSetHighlightedIndex2
} = useSelect.stateChangeTypes;
var defaultItemToString4 = (item) => {
  if (typeof item === "string") {
    return item;
  }
  if (typeof item === "number") {
    return `${item}`;
  }
  if (item !== null && typeof item === "object" && "label" in item && typeof item["label"] === "string") {
    return item["label"];
  }
  return "";
};
var MultiSelect = import_react149.default.forwardRef((_ref, ref) => {
  var _a;
  let {
    autoAlign = false,
    className: containerClassName,
    decorator,
    id,
    items,
    itemToElement,
    itemToString: itemToString3 = defaultItemToString4,
    titleText = false,
    hideLabel,
    helperText,
    label,
    type = "default",
    size: size$1,
    disabled = false,
    initialSelectedItems = [],
    sortItems = defaultSortItems,
    compareItems = defaultCompareItems,
    clearSelectionText = "To clear selection, press Delete or Backspace",
    clearAnnouncement = "all items have been cleared",
    clearSelectionDescription = "Total items selected: ",
    light,
    invalid,
    invalidText,
    warn: warn2,
    warnText,
    useTitleInItem,
    translateWithId: translateWithId8,
    downshiftProps,
    open = false,
    selectionFeedback = "top-after-reopen",
    onChange,
    onMenuChange,
    direction = "bottom",
    selectedItems: selected,
    readOnly,
    locale = "en",
    slug
  } = _ref;
  const filteredItems = (0, import_react149.useMemo)(() => {
    return items.filter((item) => {
      if (typeof item === "object" && item !== null) {
        for (const key in item) {
          if (Object.hasOwn(item, key) && item[key] === void 0) {
            return false;
          }
        }
      }
      return true;
    });
  }, [items]);
  let selectAll = filteredItems.some((item) => item.isSelectAll);
  if ((selected ?? []).length > 0 && selectAll) {
    console.warn("Warning: `selectAll` should not be used when `selectedItems` is provided. Please pass either `selectAll` or `selectedItems`, not both.");
    selectAll = false;
  }
  const prefix = usePrefix();
  const {
    isFluid
  } = (0, import_react149.useContext)(FormContext);
  const multiSelectInstanceId = useId();
  const [isFocused, setIsFocused] = (0, import_react149.useState)(false);
  const [inputFocused, setInputFocused] = (0, import_react149.useState)(false);
  const [isOpen, setIsOpen] = (0, import_react149.useState)(open || false);
  const [prevOpenProp, setPrevOpenProp] = (0, import_react149.useState)(open);
  const [topItems, setTopItems] = (0, import_react149.useState)([]);
  const [itemsCleared, setItemsCleared] = (0, import_react149.useState)(false);
  const enableFloatingStyles = useFeatureFlag("enable-v12-dynamic-floating-styles") || autoAlign;
  const {
    refs,
    floatingStyles,
    middlewareData
  } = useFloating2(enableFloatingStyles ? {
    placement: direction,
    // The floating element is positioned relative to its nearest
    // containing block (usually the viewport). It will in many cases also
    // “break” the floating element out of a clipping ancestor.
    // https://floating-ui.com/docs/misc#clipping
    strategy: "fixed",
    // Middleware order matters, arrow should be last
    middleware: [autoAlign && flip3({
      crossAxis: false
    }), size3({
      apply(_ref2) {
        let {
          rects,
          elements
        } = _ref2;
        Object.assign(elements.floating.style, {
          width: `${rects.reference.width}px`
        });
      }
    }), autoAlign && hide5()],
    whileElementsMounted: autoUpdate
  } : {});
  (0, import_react149.useLayoutEffect)(() => {
    var _a2;
    if (enableFloatingStyles) {
      const updatedFloatingStyles = {
        ...floatingStyles,
        visibility: ((_a2 = middlewareData.hide) == null ? void 0 : _a2.referenceHidden) ? "hidden" : "visible"
      };
      Object.keys(updatedFloatingStyles).forEach((style) => {
        if (refs.floating.current) {
          refs.floating.current.style[style] = updatedFloatingStyles[style];
        }
      });
    }
  }, [enableFloatingStyles, floatingStyles, refs.floating, middlewareData, open]);
  const {
    selectedItems: controlledSelectedItems,
    onItemChange,
    clearSelection
  } = useSelection({
    disabled,
    initialSelectedItems,
    onChange,
    selectedItems: selected,
    selectAll,
    filteredItems
  });
  const sortOptions = {
    selectedItems: controlledSelectedItems,
    itemToString: itemToString3,
    compareItems,
    locale
  };
  const selectProps = {
    stateReducer: stateReducer3,
    isOpen,
    itemToString: (filteredItems2) => {
      return Array.isArray(filteredItems2) && filteredItems2.map(function(item) {
        return itemToString3(item);
      }).join(", ") || "";
    },
    selectedItem: controlledSelectedItems,
    items: filteredItems,
    isItemDisabled(item, _index) {
      return item == null ? void 0 : item.disabled;
    },
    ...downshiftProps
  };
  const {
    getToggleButtonProps,
    getLabelProps,
    getMenuProps,
    getItemProps,
    selectedItem,
    highlightedIndex,
    setHighlightedIndex
  } = useSelect(selectProps);
  const toggleButtonProps = getToggleButtonProps({
    onFocus: () => {
      setInputFocused(true);
    },
    onBlur: () => {
      setInputFocused(false);
    },
    onKeyDown: (e2) => {
      if (!disabled) {
        if ((match(e2, Delete) || match(e2, Escape)) && !isOpen) {
          clearSelection();
          e2.stopPropagation();
        }
        if (!isOpen && match(e2, Delete) && selectedItems.length > 0) {
          setItemsCleared(true);
        }
        if ((match(e2, Space) || match(e2, ArrowDown) || match(e2, Enter)) && !isOpen) {
          setHighlightedIndex(0);
          setItemsCleared(false);
          setIsOpenWrapper(true);
        }
        if (match(e2, ArrowDown) && selectedItems.length === 0) {
          setInputFocused(false);
          setIsFocused(false);
        }
        if (match(e2, Escape) && isOpen) {
          setInputFocused(true);
        }
        if (match(e2, Enter) && isOpen) {
          setInputFocused(true);
        }
      }
    }
  });
  const mergedRef = mergeRefs$1(toggleButtonProps.ref, ref);
  const selectedItems = selectedItem;
  const setIsOpenWrapper = (open2) => {
    setIsOpen(open2);
    if (onMenuChange) {
      onMenuChange(open2);
    }
  };
  if (prevOpenProp !== open) {
    setIsOpenWrapper(open);
    setPrevOpenProp(open);
  }
  const inline5 = type === "inline";
  const showWarning = !invalid && warn2;
  const wrapperClasses = (0, import_classnames93.default)(`${prefix}--multi-select__wrapper`, `${prefix}--list-box__wrapper`, containerClassName, {
    [`${prefix}--multi-select__wrapper--inline`]: inline5,
    [`${prefix}--list-box__wrapper--inline`]: inline5,
    [`${prefix}--multi-select__wrapper--inline--invalid`]: inline5 && invalid,
    [`${prefix}--list-box__wrapper--inline--invalid`]: inline5 && invalid,
    [`${prefix}--list-box__wrapper--fluid--invalid`]: isFluid && invalid,
    [`${prefix}--list-box__wrapper--slug`]: slug,
    [`${prefix}--list-box__wrapper--decorator`]: decorator
  });
  const titleClasses = (0, import_classnames93.default)(`${prefix}--label`, {
    [`${prefix}--label--disabled`]: disabled,
    [`${prefix}--visually-hidden`]: hideLabel
  });
  const helperId = !helperText ? void 0 : `multiselect-helper-text-${multiSelectInstanceId}`;
  const fieldLabelId = `multiselect-field-label-${multiSelectInstanceId}`;
  const helperClasses = (0, import_classnames93.default)(`${prefix}--form__helper-text`, {
    [`${prefix}--form__helper-text--disabled`]: disabled
  });
  const className = (0, import_classnames93.default)(`${prefix}--multi-select`, {
    [`${prefix}--multi-select--invalid`]: invalid,
    [`${prefix}--multi-select--invalid--focused`]: invalid && inputFocused,
    [`${prefix}--multi-select--warning`]: showWarning,
    [`${prefix}--multi-select--inline`]: inline5,
    [`${prefix}--multi-select--selected`]: selectedItems && selectedItems.length > 0,
    [`${prefix}--list-box--up`]: direction === "top",
    [`${prefix}--multi-select--readonly`]: readOnly,
    [`${prefix}--autoalign`]: enableFloatingStyles,
    [`${prefix}--multi-select--selectall`]: selectAll
  });
  const ItemToElement = itemToElement;
  if (selectionFeedback === "fixed") {
    sortOptions.selectedItems = [];
  } else if (selectionFeedback === "top-after-reopen") {
    sortOptions.selectedItems = topItems;
  }
  function stateReducer3(state, actionAndChanges) {
    const {
      changes,
      props,
      type: type2
    } = actionAndChanges;
    const {
      highlightedIndex: highlightedIndex2
    } = changes;
    if (changes.isOpen && !isOpen) {
      setTopItems(controlledSelectedItems);
    }
    switch (type2) {
      case ToggleButtonKeyDownSpaceButton2:
      case ToggleButtonKeyDownEnter2:
        if (changes.selectedItem === void 0) {
          break;
        }
        if (Array.isArray(changes.selectedItem)) {
          break;
        }
        onItemChange(changes.selectedItem);
        return {
          ...changes,
          highlightedIndex: state.highlightedIndex
        };
      case ToggleButtonBlur2:
      case ToggleButtonKeyDownEscape2:
        setIsOpenWrapper(false);
        break;
      case ToggleButtonClick3:
        setIsOpenWrapper(changes.isOpen || false);
        return {
          ...changes,
          highlightedIndex: controlledSelectedItems.length > 0 ? 0 : void 0
        };
      case ItemClick2:
        setHighlightedIndex(changes.selectedItem);
        onItemChange(changes.selectedItem);
        return {
          ...changes,
          highlightedIndex: state.highlightedIndex
        };
      case MenuMouseLeave4:
        return {
          ...changes,
          highlightedIndex: state.highlightedIndex
        };
      case FunctionSetHighlightedIndex2:
        if (!isOpen) {
          return {
            ...changes,
            highlightedIndex: 0
          };
        } else {
          return {
            ...changes,
            highlightedIndex: filteredItems.indexOf(highlightedIndex2)
          };
        }
      case ToggleButtonKeyDownArrowDown2:
      case ToggleButtonKeyDownArrowUp2:
      case ToggleButtonKeyDownPageDown2:
      case ToggleButtonKeyDownPageUp2:
        if (highlightedIndex2 > -1) {
          const itemArray = document.querySelectorAll(`li.${prefix}--list-box__menu-item[role="option"]`);
          props.scrollIntoView(itemArray[highlightedIndex2]);
        }
        if (highlightedIndex2 === -1) {
          return {
            ...changes,
            highlightedIndex: 0
          };
        }
        return changes;
      case ItemMouseMove4:
        return {
          ...changes,
          highlightedIndex: state.highlightedIndex
        };
    }
    return changes;
  }
  const multiSelectFieldWrapperClasses = (0, import_classnames93.default)(`${prefix}--list-box__field--wrapper`, {
    [`${prefix}--list-box__field--wrapper--input-focused`]: inputFocused
  });
  const handleFocus = (evt) => {
    evt.target.classList.contains(`${prefix}--tag__close-icon`) ? setIsFocused(false) : setIsFocused(evt.type === "focus" ? true : false);
  };
  const readOnlyEventHandlers = readOnly ? {
    onClick: (evt) => {
      evt.preventDefault();
      if (mergedRef.current !== void 0) {
        mergedRef.current.focus();
      }
    },
    onKeyDown: (evt) => {
      const selectAccessKeys = ["ArrowDown", "ArrowUp", " ", "Enter"];
      if (selectAccessKeys.includes(evt.key)) {
        evt.preventDefault();
      }
    }
  } : {};
  let normalizedDecorator = import_react149.default.isValidElement(slug ?? decorator) ? slug ?? decorator : null;
  if (normalizedDecorator && ((_a = normalizedDecorator["type"]) == null ? void 0 : _a.displayName) === "AILabel") {
    normalizedDecorator = import_react149.default.cloneElement(normalizedDecorator, {
      size: "mini"
    });
  }
  const itemsSelectedText = selectedItems.length > 0 && selectedItems.map((item) => item == null ? void 0 : item.text);
  const selectedItemsLength = selectAll ? selectedItems.filter((item) => !item.isSelectAll).length : selectedItems.length;
  const menuProps = (0, import_react149.useMemo)(() => getMenuProps({
    ref: enableFloatingStyles ? refs.setFloating : null
  }), [enableFloatingStyles, getMenuProps, refs.setFloating]);
  return import_react149.default.createElement("div", {
    className: wrapperClasses
  }, import_react149.default.createElement("label", _extends({
    className: titleClasses
  }, getLabelProps()), titleText && titleText, selectedItems.length > 0 && import_react149.default.createElement("span", {
    className: `${prefix}--visually-hidden`
  }, clearSelectionDescription, " ", selectedItems.length, " ", itemsSelectedText, ",", clearSelectionText)), import_react149.default.createElement(ListBox3, {
    onFocus: isFluid ? handleFocus : void 0,
    onBlur: isFluid ? handleFocus : void 0,
    type,
    size: size$1,
    className,
    disabled,
    light,
    invalid,
    invalidText,
    warn: warn2,
    warnText,
    isOpen,
    id
  }, invalid && import_react149.default.createElement(WarningFilled, {
    className: `${prefix}--list-box__invalid-icon`
  }), showWarning && import_react149.default.createElement(WarningAltFilled, {
    className: `${prefix}--list-box__invalid-icon ${prefix}--list-box__invalid-icon--warning`
  }), import_react149.default.createElement("div", {
    className: multiSelectFieldWrapperClasses,
    ref: enableFloatingStyles ? refs.setReference : null
  }, selectedItems.length > 0 && import_react149.default.createElement(ListBox3.Selection, {
    readOnly,
    clearSelection: !disabled && !readOnly ? clearSelection : noopFn,
    selectionCount: selectedItemsLength,
    translateWithId: translateWithId8,
    disabled
  }), import_react149.default.createElement("button", _extends({
    type: "button",
    className: `${prefix}--list-box__field`,
    disabled,
    "aria-disabled": disabled || readOnly,
    "aria-describedby": !inline5 && !invalid && !warn2 && helperText ? helperId : void 0
  }, toggleButtonProps, {
    ref: mergedRef
  }, readOnlyEventHandlers), import_react149.default.createElement("span", {
    id: fieldLabelId,
    className: `${prefix}--list-box__label`
  }, label), import_react149.default.createElement(ListBox3.MenuIcon, {
    isOpen,
    translateWithId: translateWithId8
  })), slug ? normalizedDecorator : decorator ? import_react149.default.createElement("div", {
    className: `${prefix}--list-box__inner-wrapper--decorator`
  }, normalizedDecorator) : ""), import_react149.default.createElement(ListBox3.Menu, menuProps, isOpen && sortItems(filteredItems, sortOptions).map((item, index4) => {
    const isChecked = selectedItems.filter((selected2) => (0, import_react_fast_compare4.default)(selected2, item)).length > 0;
    const isIndeterminate = selectedItems.length !== 0 && item["isSelectAll"] && !isChecked;
    const itemProps = getItemProps({
      item,
      // we don't want Downshift to set aria-selected for us
      // we also don't want to set 'false' for reader verbosity's sake
      ["aria-selected"]: isChecked
    });
    const itemText = itemToString3(item);
    return import_react149.default.createElement(ListBox3.MenuItem, _extends({
      key: itemProps.id,
      isActive: isChecked && !item["isSelectAll"],
      "aria-label": itemText,
      isHighlighted: highlightedIndex === index4,
      title: itemText,
      disabled: itemProps["aria-disabled"]
    }, itemProps), import_react149.default.createElement("div", {
      className: `${prefix}--checkbox-wrapper`
    }, import_react149.default.createElement(Checkbox2, {
      id: `${itemProps.id}__checkbox`,
      labelText: itemToElement ? import_react149.default.createElement(ItemToElement, _extends({
        key: itemProps.id
      }, item)) : itemText,
      checked: isChecked,
      title: useTitleInItem ? itemText : void 0,
      indeterminate: isIndeterminate,
      disabled
    })));
  })), itemsCleared && import_react149.default.createElement("span", {
    "aria-live": "assertive",
    "aria-label": clearAnnouncement
  })), !inline5 && !invalid && !warn2 && helperText && import_react149.default.createElement("div", {
    id: helperId,
    className: helperClasses
  }, helperText));
});
MultiSelect.displayName = "MultiSelect";
MultiSelect.propTypes = {
  ...sortingPropTypes,
  /**
   * **Experimental**: Will attempt to automatically align the floating
   * element to avoid collisions with the viewport and being clipped by
   * ancestor elements.
   */
  autoAlign: import_prop_types114.default.bool,
  /**
   * Provide a custom class name to be added to the outermost node in the
   * component
   */
  className: import_prop_types114.default.string,
  /**
   * Specify the text that should be read for screen readers that describes total items selected
   */
  clearSelectionDescription: import_prop_types114.default.string,
  /**
   * Specify the text that should be read for screen readers to clear selection.
   */
  clearSelectionText: import_prop_types114.default.string,
  /**
   * Provide a compare function that is used to determine the ordering of
   * options. See 'sortItems' for more control. Consider
   * declaring function with `useCallback` to prevent unnecessary re-renders.
   */
  compareItems: import_prop_types114.default.func,
  /**
   * **Experimental**: Provide a decorator component to be rendered inside the `MultiSelect` component
   */
  decorator: import_prop_types114.default.node,
  /**
   * Specify the direction of the multiselect dropdown. Can be either top or bottom.
   */
  direction: import_prop_types114.default.oneOf(["top", "bottom"]),
  /**
   * Disable the control
   */
  disabled: import_prop_types114.default.bool,
  /**
   * Additional props passed to Downshift.
   *
   * **Use with caution:** anything you define here overrides the components'
   * internal handling of that prop. Downshift APIs and internals are subject to
   * change, and in some cases they can not be shimmed by Carbon to shield you
   * from potentially breaking changes.
   */
  downshiftProps: import_prop_types114.default.object,
  /**
   * Provide helper text that is used alongside the control label for
   * additional help
   */
  helperText: import_prop_types114.default.node,
  /**
   * Specify whether the title text should be hidden or not
   */
  hideLabel: import_prop_types114.default.bool,
  /**
   * Specify a custom `id`
   */
  id: import_prop_types114.default.string.isRequired,
  /**
   * Allow users to pass in arbitrary items from their collection that are
   * pre-selected
   */
  initialSelectedItems: import_prop_types114.default.array,
  /**
   * Is the current selection invalid?
   */
  invalid: import_prop_types114.default.bool,
  /**
   * If invalid, what is the error?
   */
  invalidText: import_prop_types114.default.node,
  /**
   * Function to render items as custom components instead of strings.
   * Defaults to null and is overridden by a getter
   */
  itemToElement: import_prop_types114.default.func,
  /**
   * Helper function passed to downshift that allows the library to render a
   * given item to a string label. By default, it extracts the `label` field
   * from a given item to serve as the item label in the list. Consider
   * declaring function with `useCallback` to prevent unnecessary re-renders.
   */
  itemToString: import_prop_types114.default.func,
  /**
   * We try to stay as generic as possible here to allow individuals to pass
   * in a collection of whatever kind of data structure they prefer
   */
  items: import_prop_types114.default.array.isRequired,
  /**
   * Generic `label` that will be used as the textual representation of what
   * this field is for
   */
  label: import_prop_types114.default.node.isRequired,
  /**
   * `true` to use the light version.
   */
  light: deprecate(import_prop_types114.default.bool, "The `light` prop for `MultiSelect` has been deprecated in favor of the new `Layer` component. It will be removed in the next major release."),
  /**
   * Specify the locale of the control. Used for the default `compareItems`
   * used for sorting the list of items in the control.
   */
  locale: import_prop_types114.default.string,
  /**
   * `onChange` is a utility for this controlled component to communicate to a
   * consuming component what kind of internal state changes are occurring.
   */
  onChange: import_prop_types114.default.func,
  /**
   * `onMenuChange` is a utility for this controlled component to communicate to a
   * consuming component that the menu was open(`true`)/closed(`false`).
   */
  onMenuChange: import_prop_types114.default.func,
  /**
   * Initialize the component with an open(`true`)/closed(`false`) menu.
   */
  open: import_prop_types114.default.bool,
  /**
   * Whether or not the Dropdown is readonly
   */
  readOnly: import_prop_types114.default.bool,
  /**
   * For full control of the selected items
   */
  selectedItems: import_prop_types114.default.array,
  /**
   * Specify feedback (mode) of the selection.
   * `top`: selected item jumps to top
   * `fixed`: selected item stays at it's position
   * `top-after-reopen`: selected item jump to top after reopen dropdown
   */
  selectionFeedback: import_prop_types114.default.oneOf(["top", "fixed", "top-after-reopen"]),
  /**
   * Specify the size of the ListBox. Currently supports either `sm`, `md` or `lg` as an option.
   */
  size: ListBoxSize,
  slug: deprecate(import_prop_types114.default.node, "The `slug` prop has been deprecated and will be removed in the next major version. Use the decorator prop instead."),
  /**
   * Provide a method that sorts all options in the control. Overriding this
   * prop means that you also have to handle the sort logic for selected versus
   * un-selected items. If you just want to control ordering, consider the
   * `compareItems` prop instead.
   *
   * The return value should be a number whose sign indicates the relative order
   * of the two elements: negative if a is less than b, positive if a is greater
   * than b, and zero if they are equal.
   *
   * sortItems :
   *   (items: Array<Item>, {
   *     selectedItems: Array<Item>,
   *     itemToString: Item => string,
   *     compareItems: (itemA: string, itemB: string, {
   *       locale: string
   *     }) => number,
   *     locale: string,
   *   }) => Array<Item>
   */
  sortItems: import_prop_types114.default.func,
  /**
   * Provide text to be used in a `<label>` element that is tied to the
   * multiselect via ARIA attributes.
   */
  titleText: import_prop_types114.default.node,
  /**
   * Callback function for translating ListBoxMenuIcon SVG title
   */
  translateWithId: import_prop_types114.default.func,
  /**
   * Specify 'inline' to create an inline multi-select.
   */
  type: import_prop_types114.default.oneOf(["default", "inline"]),
  /**
   * Specify title to show title on hover
   */
  useTitleInItem: import_prop_types114.default.bool,
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types114.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types114.default.node
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/MultiSelect/FilterableMultiSelect.js
var import_classnames94 = __toESM(require_classnames());
var import_react_fast_compare5 = __toESM(require_react_fast_compare());
var import_prop_types115 = __toESM(require_prop_types());
var import_react151 = __toESM(require_react());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ComboBox/tools/filter.js
var defaultFilterItems = (items, _ref) => {
  let {
    itemToString: itemToString3,
    inputValue
  } = _ref;
  return items.filter((item) => {
    if (!inputValue) {
      return true;
    }
    return itemToString3(item).toLowerCase().includes(inputValue.toLowerCase());
  });
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/MultiSelect/tools/itemToString.js
var import_invariant3 = __toESM(require_browser());
var itemToString2 = (item) => {
  !(typeof item.label === "string") ? true ? (0, import_invariant3.default)(false, "[MultiSelect] the default `itemToString` method expected to receive an item with a `label` field of type `string`. Instead received: `%s`", typeof item.label) : (0, import_invariant3.default)(false) : void 0;
  return item.label || "";
};
var defaultItemToString5 = (item) => {
  if (Array.isArray(item)) {
    return item.map(itemToString2);
  }
  return itemToString2(item);
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/MultiSelect/FilterableMultiSelect.js
var {
  InputBlur: InputBlur3,
  InputKeyDownEnter: InputKeyDownEnter3,
  ItemClick: ItemClick3,
  MenuMouseLeave: MenuMouseLeave5,
  InputKeyDownArrowUp: InputKeyDownArrowUp3,
  InputKeyDownArrowDown: InputKeyDownArrowDown3,
  ItemMouseMove: ItemMouseMove5,
  InputClick: InputClick2,
  ToggleButtonClick: ToggleButtonClick4,
  FunctionToggleMenu: FunctionToggleMenu3,
  InputChange: InputChange2,
  InputKeyDownEscape: InputKeyDownEscape2,
  FunctionSetHighlightedIndex: FunctionSetHighlightedIndex3
} = useCombobox.stateChangeTypes;
var {
  SelectedItemKeyDownBackspace: SelectedItemKeyDownBackspace2,
  SelectedItemKeyDownDelete: SelectedItemKeyDownDelete2,
  DropdownKeyDownBackspace: DropdownKeyDownBackspace2,
  FunctionRemoveSelectedItem: FunctionRemoveSelectedItem2
} = useMultipleSelection.stateChangeTypes;
var FilterableMultiSelect = import_react151.default.forwardRef(function FilterableMultiSelect2(_ref, ref) {
  var _a;
  let {
    autoAlign = false,
    className: containerClassName,
    clearSelectionDescription = "Total items selected: ",
    clearSelectionText = "To clear selection, press Delete or Backspace",
    compareItems = defaultCompareItems,
    decorator,
    direction = "bottom",
    disabled = false,
    downshiftProps,
    filterItems = defaultFilterItems,
    helperText,
    hideLabel,
    id,
    initialSelectedItems = [],
    invalid,
    invalidText,
    items,
    itemToElement: ItemToElement,
    // needs to be capitalized for react to render it correctly
    itemToString: itemToString3 = defaultItemToString5,
    light,
    locale = "en",
    onInputValueChange,
    open = false,
    onChange,
    onMenuChange,
    placeholder,
    readOnly,
    titleText,
    type,
    selectionFeedback = "top-after-reopen",
    selectedItems: selected,
    size: size$1,
    sortItems = defaultSortItems,
    translateWithId: translateWithId8,
    useTitleInItem,
    warn: warn2,
    warnText,
    slug
  } = _ref;
  const {
    isFluid
  } = (0, import_react151.useContext)(FormContext);
  const [isFocused, setIsFocused] = (0, import_react151.useState)(false);
  const [isOpen, setIsOpen] = (0, import_react151.useState)(!!open);
  const [prevOpen, setPrevOpen] = (0, import_react151.useState)(!!open);
  const [inputValue, setInputValue] = (0, import_react151.useState)("");
  const [topItems, setTopItems] = (0, import_react151.useState)(initialSelectedItems ?? []);
  const [inputFocused, setInputFocused] = (0, import_react151.useState)(false);
  const {
    selectedItems: controlledSelectedItems,
    onItemChange,
    clearSelection
  } = useSelection({
    disabled,
    initialSelectedItems,
    onChange,
    selectedItems: selected
  });
  const {
    refs,
    floatingStyles,
    middlewareData
  } = useFloating2(autoAlign ? {
    placement: direction,
    // The floating element is positioned relative to its nearest
    // containing block (usually the viewport). It will in many cases also
    // “break” the floating element out of a clipping ancestor.
    // https://floating-ui.com/docs/misc#clipping
    strategy: "fixed",
    // Middleware order matters, arrow should be last
    middleware: [flip3({
      crossAxis: false
    }), size3({
      apply(_ref2) {
        let {
          rects,
          elements
        } = _ref2;
        Object.assign(elements.floating.style, {
          width: `${rects.reference.width}px`
        });
      }
    }), hide5()],
    whileElementsMounted: autoUpdate
  } : {});
  (0, import_react151.useLayoutEffect)(() => {
    var _a2;
    if (autoAlign) {
      const updatedFloatingStyles = {
        ...floatingStyles,
        visibility: ((_a2 = middlewareData.hide) == null ? void 0 : _a2.referenceHidden) ? "hidden" : "visible"
      };
      Object.keys(updatedFloatingStyles).forEach((style) => {
        if (refs.floating.current) {
          refs.floating.current.style[style] = updatedFloatingStyles[style];
        }
      });
    }
  }, [autoAlign, floatingStyles, refs.floating, middlewareData, open]);
  const textInput = (0, import_react151.useRef)(null);
  const filterableMultiSelectInstanceId = useId();
  const prefix = usePrefix();
  if (prevOpen !== open) {
    setIsOpen(open);
    setPrevOpen(open);
  }
  const sortedItems = (0, import_react151.useMemo)(() => {
    return sortItems(filterItems(items, {
      itemToString: itemToString3,
      inputValue
    }), {
      selectedItems: {
        top: controlledSelectedItems,
        fixed: [],
        "top-after-reopen": topItems
      }[selectionFeedback],
      itemToString: itemToString3,
      compareItems,
      locale
    });
  }, [items, inputValue, controlledSelectedItems, topItems, selectionFeedback, itemToString3, compareItems, locale]);
  const inline5 = type === "inline";
  const showWarning = !invalid && warn2;
  const wrapperClasses = (0, import_classnames94.default)(`${prefix}--multi-select__wrapper`, `${prefix}--multi-select--filterable__wrapper`, `${prefix}--list-box__wrapper`, containerClassName, {
    [`${prefix}--multi-select__wrapper--inline`]: inline5,
    [`${prefix}--list-box__wrapper--inline`]: inline5,
    [`${prefix}--multi-select__wrapper--inline--invalid`]: inline5 && invalid,
    [`${prefix}--list-box__wrapper--inline--invalid`]: inline5 && invalid,
    [`${prefix}--list-box--up`]: direction === "top",
    [`${prefix}--list-box__wrapper--fluid--invalid`]: isFluid && invalid,
    [`${prefix}--list-box__wrapper--slug`]: slug,
    [`${prefix}--list-box__wrapper--decorator`]: decorator,
    [`${prefix}--autoalign`]: autoAlign
  });
  const helperId = !helperText ? void 0 : `filterablemultiselect-helper-text-${filterableMultiSelectInstanceId}`;
  const labelId = `${id}-label`;
  const titleClasses = (0, import_classnames94.default)({
    [`${prefix}--label`]: true,
    [`${prefix}--label--disabled`]: disabled,
    [`${prefix}--visually-hidden`]: hideLabel
  });
  const helperClasses = (0, import_classnames94.default)({
    [`${prefix}--form__helper-text`]: true,
    [`${prefix}--form__helper-text--disabled`]: disabled
  });
  const inputClasses = (0, import_classnames94.default)({
    [`${prefix}--text-input`]: true,
    [`${prefix}--text-input--empty`]: !inputValue,
    [`${prefix}--text-input--light`]: light
  });
  const helper = helperText ? import_react151.default.createElement("div", {
    id: helperId,
    className: helperClasses
  }, helperText) : null;
  const menuId = `${id}__menu`;
  const inputId = `${id}-input`;
  (0, import_react151.useEffect)(() => {
    if (!isOpen) {
      setTopItems(controlledSelectedItems);
    }
  }, [controlledSelectedItems, isOpen, setTopItems]);
  const validateHighlightFocus = () => {
    if (controlledSelectedItems.length > 0) {
      setHighlightedIndex(0);
    }
  };
  function handleMenuChange(forceIsOpen) {
    if (!readOnly) {
      const nextIsOpen = forceIsOpen ?? !isOpen;
      setIsOpen(nextIsOpen);
      validateHighlightFocus();
    }
  }
  (0, import_react151.useEffect)(() => {
    onMenuChange == null ? void 0 : onMenuChange(isOpen);
  }, [isOpen, onMenuChange]);
  const {
    getToggleButtonProps,
    getLabelProps,
    getMenuProps,
    getInputProps,
    highlightedIndex,
    setHighlightedIndex,
    getItemProps,
    openMenu,
    isOpen: isMenuOpen
  } = useCombobox({
    isOpen,
    items: sortedItems,
    // defaultHighlightedIndex: 0, // after selection, highlight the first item.
    itemToString: itemToString3,
    id,
    labelId,
    menuId,
    inputId,
    inputValue,
    stateReducer: stateReducer3,
    isItemDisabled(item, _index) {
      return item == null ? void 0 : item.disabled;
    }
  });
  function stateReducer3(state, actionAndChanges) {
    const {
      type: type2,
      props,
      changes
    } = actionAndChanges;
    const {
      highlightedIndex: highlightedIndex2
    } = changes;
    if (changes.isOpen && !isOpen) {
      setTopItems(controlledSelectedItems);
    }
    switch (type2) {
      case InputKeyDownEnter3:
        if (changes.selectedItem && changes.selectedItem.disabled !== true) {
          onItemChange(changes.selectedItem);
        }
        setHighlightedIndex(changes.selectedItem);
        return {
          ...changes,
          highlightedIndex: state.highlightedIndex
        };
      case ItemClick3:
        if (changes.selectedItem) {
          onItemChange(changes.selectedItem);
        }
        setHighlightedIndex(changes.selectedItem);
        return changes;
      case InputBlur3:
      case InputKeyDownEscape2:
        setIsOpen(false);
        return changes;
      case FunctionToggleMenu3:
      case ToggleButtonClick4:
        validateHighlightFocus();
        if (changes.isOpen && !changes.selectedItem) {
          return {
            ...changes
          };
        }
        return {
          ...changes,
          highlightedIndex: null
        };
      case InputChange2:
        if (onInputValueChange) {
          onInputValueChange(changes.inputValue);
        }
        setInputValue(changes.inputValue ?? "");
        setIsOpen(true);
        return {
          ...changes,
          highlightedIndex: 0
        };
      case InputClick2:
        validateHighlightFocus();
        if (changes.isOpen && !changes.selectedItem) {
          return {
            ...changes
          };
        }
        return {
          ...changes,
          isOpen: false,
          highlightedIndex: null
        };
      case MenuMouseLeave5:
        return {
          ...changes,
          highlightedIndex: state.highlightedIndex
        };
      case InputKeyDownArrowUp3:
      case InputKeyDownArrowDown3:
        if (InputKeyDownArrowDown3 === type2 && !isOpen) {
          setIsOpen(true);
          return {
            ...changes,
            highlightedIndex: 0
          };
        }
        if (highlightedIndex2 > -1) {
          const itemArray = document.querySelectorAll(`li.${prefix}--list-box__menu-item[role="option"]`);
          props.scrollIntoView(itemArray[highlightedIndex2]);
        }
        if (highlightedIndex2 === -1) {
          return {
            ...changes,
            highlightedIndex: 0
          };
        }
        return changes;
      case ItemMouseMove5:
        return {
          ...changes,
          highlightedIndex: state.highlightedIndex
        };
      case FunctionSetHighlightedIndex3:
        if (!isOpen) {
          return {
            ...changes,
            highlightedIndex: 0
          };
        } else {
          return {
            ...changes,
            highlightedIndex: props.items.indexOf(highlightedIndex2)
          };
        }
      default:
        return changes;
    }
  }
  const {
    getDropdownProps
  } = useMultipleSelection({
    activeIndex: highlightedIndex,
    initialSelectedItems,
    selectedItems: controlledSelectedItems,
    onStateChange(changes) {
      switch (changes.type) {
        case SelectedItemKeyDownBackspace2:
        case SelectedItemKeyDownDelete2:
        case DropdownKeyDownBackspace2:
        case FunctionRemoveSelectedItem2: {
          clearSelection();
          break;
        }
      }
    },
    ...downshiftProps
  });
  (0, import_react151.useEffect)(() => {
    if (isOpen && !isMenuOpen) {
      openMenu();
    }
  });
  function clearInputValue(event) {
    var _a2;
    const value = (_a2 = textInput.current) == null ? void 0 : _a2.value;
    if ((value == null ? void 0 : value.length) === 1 || event && match(event, Escape)) {
      setInputValue("");
    } else {
      setInputValue(value ?? "");
    }
    if (textInput.current) {
      textInput.current.focus();
    }
  }
  let normalizedDecorator = import_react151.default.isValidElement(slug ?? decorator) ? slug ?? decorator : null;
  if (normalizedDecorator && ((_a = normalizedDecorator["type"]) == null ? void 0 : _a.displayName) === "AILabel") {
    normalizedDecorator = import_react151.default.cloneElement(normalizedDecorator, {
      size: "mini"
    });
  }
  const className = (0, import_classnames94.default)(`${prefix}--multi-select`, `${prefix}--combo-box`, `${prefix}--multi-select--filterable`, {
    [`${prefix}--multi-select--invalid`]: invalid,
    [`${prefix}--multi-select--invalid--focused`]: invalid && inputFocused,
    [`${prefix}--multi-select--open`]: isOpen,
    [`${prefix}--multi-select--inline`]: inline5,
    [`${prefix}--multi-select--selected`]: (controlledSelectedItems == null ? void 0 : controlledSelectedItems.length) > 0,
    [`${prefix}--multi-select--filterable--input-focused`]: inputFocused,
    [`${prefix}--multi-select--readonly`]: readOnly
  });
  const labelProps = getLabelProps();
  const buttonProps = getToggleButtonProps({
    disabled,
    onClick: () => {
      var _a2;
      handleMenuChange(!isOpen);
      (_a2 = textInput.current) == null ? void 0 : _a2.focus();
    },
    // When we moved the "root node" of Downshift to the <input> for
    // ARIA 1.2 compliance, we unfortunately hit this branch for the
    // "mouseup" event that downshift listens to:
    // https://github.com/downshift-js/downshift/blob/v5.2.1/src/downshift.js#L1051-L1065
    //
    // As a result, it will reset the state of the component and so we
    // stop the event from propagating to prevent this. This allows the
    // toggleMenu behavior for the toggleButton to correctly open and
    // close the menu.
    onMouseUp(event) {
      if (isOpen) {
        event.stopPropagation();
      }
    }
  });
  const inputProps = getInputProps(getDropdownProps({
    "aria-controls": isOpen ? menuId : void 0,
    "aria-describedby": helperText ? helperId : void 0,
    "aria-haspopup": "listbox",
    // Remove excess aria `aria-labelledby`. HTML <label for>
    // provides this aria information.
    "aria-labelledby": void 0,
    disabled,
    placeholder,
    preventKeyAction: isOpen,
    onClick: () => handleMenuChange(true),
    onKeyDown(event) {
      const $input = event.target;
      const $value = $input.value;
      if (match(event, Space)) {
        event.stopPropagation();
      }
      if (match(event, Enter)) {
        handleMenuChange(true);
      }
      if (!disabled) {
        if (match(event, Delete) || match(event, Escape)) {
          if (isOpen) {
            handleMenuChange(true);
            clearInputValue(event);
            event.stopPropagation();
          } else if (!isOpen) {
            clearInputValue(event);
            clearSelection();
            event.stopPropagation();
          }
        }
      }
      if (match(event, Tab)) {
        handleMenuChange(false);
      }
      if (match(event, Home)) {
        $input.setSelectionRange(0, 0);
      }
      if (match(event, End)) {
        $input.setSelectionRange($value.length, $value.length);
      }
    },
    onFocus: () => setInputFocused(true),
    onBlur: () => {
      !isOpen && setInputFocused(false);
      setInputValue("");
    }
  }));
  const menuProps = (0, import_react151.useMemo)(() => getMenuProps({
    ref: autoAlign ? refs.setFloating : null
  }, {
    suppressRefError: true
  }), [autoAlign, getMenuProps, refs.setFloating]);
  const handleFocus = (evt) => {
    if ((evt == null ? void 0 : evt.target.classList.contains(`${prefix}--tag__close-icon`)) || (evt == null ? void 0 : evt.target.classList.contains(`${prefix}--list-box__selection`))) {
      setIsFocused(false);
    } else {
      setIsFocused((evt == null ? void 0 : evt.type) === "focus" ? true : false);
    }
  };
  const mergedRef = mergeRefs$1(textInput, inputProps.ref);
  const readOnlyEventHandlers = readOnly ? {
    onClick: (evt) => {
      evt.preventDefault();
      if (mergedRef.current !== void 0) {
        mergedRef.current.focus();
      }
    },
    onKeyDown: (evt) => {
      const selectAccessKeys = ["ArrowDown", "ArrowUp", " ", "Enter"];
      if (selectAccessKeys.includes(evt.key)) {
        evt.preventDefault();
      }
    }
  } : {};
  const clearSelectionContent = controlledSelectedItems.length > 0 ? import_react151.default.createElement("span", {
    className: `${prefix}--visually-hidden`
  }, clearSelectionDescription, " ", controlledSelectedItems.length, ",", clearSelectionText) : import_react151.default.createElement("span", {
    className: `${prefix}--visually-hidden`
  }, clearSelectionDescription, ": 0");
  return import_react151.default.createElement("div", {
    className: wrapperClasses
  }, titleText ? import_react151.default.createElement("label", _extends({
    className: titleClasses
  }, labelProps), titleText, import_react151.default.createElement("span", {
    className: `${prefix}--visually-hidden`
  }, clearSelectionContent)) : null, import_react151.default.createElement(ListBox3, {
    onFocus: isFluid ? handleFocus : void 0,
    onBlur: isFluid ? handleFocus : void 0,
    className,
    disabled,
    light,
    ref,
    id,
    invalid,
    invalidText,
    warn: warn2,
    warnText,
    isOpen: !readOnly && isOpen,
    size: size$1
  }, import_react151.default.createElement("div", {
    className: `${prefix}--list-box__field`,
    ref: autoAlign ? refs.setReference : null
  }, controlledSelectedItems.length > 0 && import_react151.default.createElement(ListBoxSelection2, {
    readOnly,
    clearSelection: () => {
      clearSelection();
      if (textInput.current) {
        textInput.current.focus();
      }
    },
    selectionCount: controlledSelectedItems.length,
    translateWithId: translateWithId8,
    disabled
  }), import_react151.default.createElement("input", _extends({
    className: inputClasses
  }, inputProps, {
    ref: mergedRef
  }, readOnlyEventHandlers, {
    readOnly
  })), invalid && import_react151.default.createElement(WarningFilled, {
    className: `${prefix}--list-box__invalid-icon`
  }), showWarning && import_react151.default.createElement(WarningAltFilled, {
    className: `${prefix}--list-box__invalid-icon ${prefix}--list-box__invalid-icon--warning`
  }), inputValue && import_react151.default.createElement(ListBoxSelection2, {
    clearSelection: clearInputValue,
    disabled,
    translateWithId: translateWithId8,
    readOnly,
    onMouseUp: (event) => {
      event.stopPropagation();
    }
  }), import_react151.default.createElement(ListBoxTrigger, _extends({}, buttonProps, {
    isOpen,
    translateWithId: translateWithId8
  }))), slug ? normalizedDecorator : decorator ? import_react151.default.createElement("div", {
    className: `${prefix}--list-box__inner-wrapper--decorator`
  }, normalizedDecorator) : "", import_react151.default.createElement(ListBox3.Menu, menuProps, isOpen ? sortedItems.map((item, index4) => {
    const isChecked = controlledSelectedItems.filter((selected2) => (0, import_react_fast_compare5.default)(selected2, item)).length > 0;
    const itemProps = getItemProps({
      item,
      ["aria-selected"]: isChecked
    });
    const itemText = itemToString3(item);
    const disabled2 = itemProps["aria-disabled"];
    const {
      "aria-disabled": unusedAriaDisabled,
      // eslint-disable-line @typescript-eslint/no-unused-vars
      ...modifiedItemProps
    } = itemProps;
    return import_react151.default.createElement(ListBox3.MenuItem, _extends({
      key: itemProps.id,
      "aria-label": itemText,
      isActive: isChecked,
      isHighlighted: highlightedIndex === index4,
      title: itemText,
      disabled: disabled2
    }, modifiedItemProps), import_react151.default.createElement("div", {
      className: `${prefix}--checkbox-wrapper`
    }, import_react151.default.createElement("span", {
      title: useTitleInItem ? itemText : void 0,
      className: `${prefix}--checkbox-label`,
      "data-contained-checkbox-state": isChecked,
      id: `${itemProps.id}-item`
    }, ItemToElement ? import_react151.default.createElement(ItemToElement, _extends({
      key: itemProps.id
    }, item)) : itemText)));
  }) : null)), !inline5 && !invalid && !warn2 ? helper : null);
});
FilterableMultiSelect.propTypes = {
  /**
   * Deprecated, aria-label is no longer needed
   * Specify a label to be read by screen readers on the container node
   */
  ["aria-label"]: deprecate(import_prop_types115.default.string, "ariaLabel / aria-label props are no longer required for FilterableMultiSelect"),
  /**
   * Deprecated, please use `aria-label` instead.
   * Specify a label to be read by screen readers on the container note.
   */
  ariaLabel: deprecate(import_prop_types115.default.string, "ariaLabel / aria-label props are no longer required for FilterableMultiSelect"),
  /**
   * **Experimental**: Will attempt to automatically align the floating
   * element to avoid collisions with the viewport and being clipped by
   * ancestor elements.
   */
  autoAlign: import_prop_types115.default.bool,
  /**
   * Specify the text that should be read for screen readers that describes total items selected
   */
  clearSelectionDescription: import_prop_types115.default.string,
  /**
   * Specify the text that should be read for screen readers to clear selection.
   */
  clearSelectionText: import_prop_types115.default.string,
  /**
   * **Experimental**: Provide a decorator component to be rendered inside the `FilterableMultiSelect` component
   */
  decorator: import_prop_types115.default.node,
  /**
   * Specify the direction of the multiselect dropdown. Can be either top or bottom.
   */
  direction: import_prop_types115.default.oneOf(["top", "bottom"]),
  /**
   * Disable the control
   */
  disabled: import_prop_types115.default.bool,
  /**
   * Additional props passed to Downshift.
   *
   * **Use with caution:** anything you define here overrides the components'
   * internal handling of that prop. Downshift APIs and internals are subject to
   * change, and in some cases they can not be shimmed by Carbon to shield you
   * from potentially breaking changes.
   */
  // @ts-ignore
  downshiftProps: import_prop_types115.default.shape(Downshift$1.propTypes),
  /**
   * Specify whether the title text should be hidden or not
   */
  hideLabel: import_prop_types115.default.bool,
  /**
   * Specify a custom `id`
   */
  id: import_prop_types115.default.string.isRequired,
  /**
   * Allow users to pass in arbitrary items from their collection that are
   * pre-selected
   */
  initialSelectedItems: import_prop_types115.default.array,
  /**
   * Is the current selection invalid?
   */
  invalid: import_prop_types115.default.bool,
  /**
   * If invalid, what is the error?
   */
  invalidText: import_prop_types115.default.node,
  /**
   * Function to render items as custom components instead of strings.
   * Defaults to null and is overridden by a getter
   */
  itemToElement: import_prop_types115.default.func,
  /**
   * Helper function passed to downshift that allows the library to render a
   * given item to a string label. By default, it extracts the `label` field
   * from a given item to serve as the item label in the list.
   */
  itemToString: import_prop_types115.default.func,
  /**
   * We try to stay as generic as possible here to allow individuals to pass
   * in a collection of whatever kind of data structure they prefer
   */
  items: import_prop_types115.default.array.isRequired,
  /**
   * `true` to use the light version.
   */
  light: deprecate(import_prop_types115.default.bool, "The `light` prop for `FilterableMultiSelect` has been deprecated in favor of the new `Layer` component. It will be removed in the next major release."),
  /**
   * Specify the locale of the control. Used for the default `compareItems`
   * used for sorting the list of items in the control.
   */
  locale: import_prop_types115.default.string,
  /**
   * `onChange` is a utility for this controlled component to communicate to a
   * consuming component what kind of internal state changes are occurring.
   */
  onChange: import_prop_types115.default.func,
  /**
   * `onInputValueChange` is a utility for this controlled component to communicate to
   * the currently typed input.
   */
  onInputValueChange: import_prop_types115.default.func,
  /**
   * `onMenuChange` is a utility for this controlled component to communicate to a
   * consuming component that the menu was opened(`true`)/closed(`false`).
   */
  onMenuChange: import_prop_types115.default.func,
  /**
   * Initialize the component with an open(`true`)/closed(`false`) menu.
   */
  open: import_prop_types115.default.bool,
  /**
   * Generic `placeholder` that will be used as the textual representation of
   * what this field is for
   */
  placeholder: import_prop_types115.default.string,
  /**
   * Specify feedback (mode) of the selection.
   * `top`: selected item jumps to top
   * `fixed`: selected item stays at it's position
   * `top-after-reopen`: selected item jump to top after reopen dropdown
   */
  selectionFeedback: import_prop_types115.default.oneOf(["top", "fixed", "top-after-reopen"]),
  /**
   * Specify the size of the ListBox. Currently supports either `sm`, `md` or `lg` as an option.
   */
  size: ListBoxSize,
  slug: deprecate(import_prop_types115.default.node, "The `slug` prop has been deprecated and will be removed in the next major version. Use the decorator prop instead."),
  ...sortingPropTypes,
  /**
   * Provide text to be used in a `<label>` element that is tied to the
   * combobox via ARIA attributes.
   */
  titleText: import_prop_types115.default.node,
  /**
   * Callback function for translating ListBoxMenuIcon SVG title
   */
  translateWithId: import_prop_types115.default.func,
  /**
   * Specify title to show title on hover
   */
  useTitleInItem: import_prop_types115.default.bool,
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types115.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types115.default.node
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/MultiSelect/index.js
FilterableMultiSelect.displayName = "MultiSelect.Filterable";
MultiSelect.Filterable = FilterableMultiSelect;
if (true) {
  deprecateFieldOnObject(MultiSelect, "Filterable", FilterableMultiSelect);
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Notification/Notification.js
var import_prop_types116 = __toESM(require_prop_types());
var import_react153 = __toESM(require_react());
var import_classnames95 = __toESM(require_classnames());
function useEscapeToClose(ref, callback) {
  let override = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  const handleKeyDown = (event) => {
    var _a;
    const elementContainsFocus = ref.current && document.activeElement === ref.current || ((_a = ref.current) == null ? void 0 : _a.contains(document.activeElement));
    if (matches(event, [Escape]) && override && elementContainsFocus) {
      callback(event);
    }
  };
  useIsomorphicEffect$1(() => {
    if (ref.current !== null) {
      document.addEventListener("keydown", handleKeyDown, false);
    }
    return () => document.removeEventListener("keydown", handleKeyDown, false);
  });
}
function NotificationActionButton(_ref) {
  let {
    children,
    className: customClassName,
    onClick,
    inline: inline5,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const className = (0, import_classnames95.default)(customClassName, {
    [`${prefix}--actionable-notification__action-button`]: true
  });
  return import_react153.default.createElement(Button, _extends({
    className,
    kind: inline5 ? "ghost" : "tertiary",
    onClick,
    size: "sm"
  }, rest3), children);
}
NotificationActionButton.propTypes = {
  /**
   * Specify the content of the notification action button.
   */
  children: import_prop_types116.default.node,
  /**
   * Specify an optional className to be applied to the notification action button
   */
  className: import_prop_types116.default.string,
  /**
   * Specify if the visual treatment of the button should be for an inline notification
   */
  inline: import_prop_types116.default.bool,
  /**
   * Optionally specify a click handler for the notification action button.
   */
  onClick: import_prop_types116.default.func
};
function NotificationButton(_ref2) {
  let {
    "aria-label": ariaLabel = "close notification",
    ariaLabel: deprecatedAriaLabel,
    className,
    type = "button",
    renderIcon: IconTag = Close,
    name,
    notificationType = "toast",
    ...rest3
  } = _ref2;
  const prefix = usePrefix();
  const buttonClassName = (0, import_classnames95.default)(className, {
    [`${prefix}--${notificationType}-notification__close-button`]: notificationType
  });
  const iconClassName = (0, import_classnames95.default)({
    [`${prefix}--${notificationType}-notification__close-icon`]: notificationType
  });
  return import_react153.default.createElement("button", _extends({}, rest3, {
    // eslint-disable-next-line react/button-has-type
    type,
    "aria-label": deprecatedAriaLabel || ariaLabel,
    title: deprecatedAriaLabel || ariaLabel,
    className: buttonClassName
  }), IconTag && import_react153.default.createElement(IconTag, {
    className: iconClassName,
    name
  }));
}
NotificationButton.propTypes = {
  /**
   * Specify a label to be read by screen readers on the container node
   */
  ["aria-label"]: import_prop_types116.default.string,
  /**
   * Deprecated, please use `aria-label` instead.
   * Specify a label to be read by screen readers on the container note.
   */
  ariaLabel: deprecate(import_prop_types116.default.string, "This prop syntax has been deprecated. Please use the new `aria-label`."),
  /**
   * Specify an optional className to be applied to the notification button
   */
  className: import_prop_types116.default.string,
  /**
   * Specify an optional icon for the Button through a string,
   * if something but regular "close" icon is desirable
   */
  name: import_prop_types116.default.string,
  /**
   * Specify the notification type
   */
  notificationType: import_prop_types116.default.oneOf(["toast", "inline", "actionable"]),
  /**
   * Optional prop to allow overriding the icon rendering.
   * Can be a React component class
   */
  renderIcon: import_prop_types116.default.oneOfType([import_prop_types116.default.func, import_prop_types116.default.object]),
  /**
   * Optional prop to specify the type of the Button
   */
  type: import_prop_types116.default.string
};
var iconTypes = {
  error: ErrorFilled,
  success: CheckmarkFilled,
  warning: WarningFilled,
  ["warning-alt"]: WarningAltFilled,
  info: InformationFilled,
  ["info-square"]: InformationSquareFilled
};
function NotificationIcon(_ref3) {
  let {
    iconDescription,
    kind,
    notificationType
  } = _ref3;
  const prefix = usePrefix();
  const IconForKind = iconTypes[kind];
  if (!IconForKind) {
    return null;
  }
  return import_react153.default.createElement(IconForKind, {
    className: `${prefix}--${notificationType}-notification__icon`,
    size: 20
  }, import_react153.default.createElement("title", null, iconDescription));
}
NotificationIcon.propTypes = {
  iconDescription: import_prop_types116.default.string.isRequired,
  kind: import_prop_types116.default.oneOf(["error", "success", "warning", "warning-alt", "info", "info-square"]).isRequired,
  notificationType: import_prop_types116.default.oneOf(["inline", "toast"]).isRequired
};
function ToastNotification(_ref4) {
  let {
    ["aria-label"]: ariaLabel,
    // @ts-expect-error: deprecated prop
    ariaLabel: deprecatedAriaLabel,
    role = "status",
    onClose,
    onCloseButtonClick = noopFn,
    statusIconDescription,
    className,
    children,
    kind = "error",
    lowContrast,
    hideCloseButton = false,
    timeout: timeout2 = 0,
    title,
    caption,
    subtitle,
    ...rest3
  } = _ref4;
  const [isOpen, setIsOpen] = (0, import_react153.useState)(true);
  const prefix = usePrefix();
  const containerClassName = (0, import_classnames95.default)(className, {
    [`${prefix}--toast-notification`]: true,
    [`${prefix}--toast-notification--low-contrast`]: lowContrast,
    [`${prefix}--toast-notification--${kind}`]: kind
  });
  const contentRef = (0, import_react153.useRef)(null);
  useNoInteractiveChildren(contentRef);
  const handleClose = (evt) => {
    if (!onClose || onClose(evt) !== false) {
      setIsOpen(false);
    }
  };
  const ref = (0, import_react153.useRef)(null);
  function handleCloseButtonClick(event) {
    onCloseButtonClick(event);
    handleClose(event);
  }
  const savedOnClose = (0, import_react153.useRef)(onClose);
  (0, import_react153.useEffect)(() => {
    savedOnClose.current = onClose;
  });
  (0, import_react153.useEffect)(() => {
    if (!timeout2) {
      return;
    }
    const timeoutId2 = window.setTimeout((event) => {
      setIsOpen(false);
      if (savedOnClose.current) {
        savedOnClose.current(event);
      }
    }, timeout2);
    return () => {
      window.clearTimeout(timeoutId2);
    };
  }, [timeout2]);
  if (!isOpen) {
    return null;
  }
  return import_react153.default.createElement("div", _extends({
    ref
  }, rest3, {
    role,
    className: containerClassName
  }), import_react153.default.createElement(NotificationIcon, {
    notificationType: "toast",
    kind,
    iconDescription: statusIconDescription || `${kind} icon`
  }), import_react153.default.createElement("div", {
    ref: contentRef,
    className: `${prefix}--toast-notification__details`
  }, title && import_react153.default.createElement(Text, {
    as: "div",
    className: `${prefix}--toast-notification__title`
  }, title), subtitle && import_react153.default.createElement(Text, {
    as: "div",
    className: `${prefix}--toast-notification__subtitle`
  }, subtitle), caption && import_react153.default.createElement(Text, {
    as: "div",
    className: `${prefix}--toast-notification__caption`
  }, caption), children), !hideCloseButton && import_react153.default.createElement(NotificationButton, {
    notificationType: "toast",
    onClick: handleCloseButtonClick,
    "aria-label": deprecatedAriaLabel || ariaLabel
  }));
}
ToastNotification.propTypes = {
  /**
   * Provide a description for "close" icon button that can be read by screen readers
   */
  ["aria-label"]: import_prop_types116.default.string,
  /**
   * Deprecated, please use `aria-label` instead.
   * Provide a description for "close" icon button that can be read by screen readers
   */
  ariaLabel: deprecate(import_prop_types116.default.string, "This prop syntax has been deprecated. Please use the new `aria-label`."),
  /**
   * Specify the caption
   */
  caption: import_prop_types116.default.string,
  /**
   * Specify the content
   */
  children: import_prop_types116.default.node,
  /**
   * Specify an optional className to be applied to the notification box
   */
  className: import_prop_types116.default.string,
  /**
   * Specify the close button should be disabled, or not
   */
  hideCloseButton: import_prop_types116.default.bool,
  /**
   * Specify what state the notification represents
   */
  kind: import_prop_types116.default.oneOf(["error", "info", "info-square", "success", "warning", "warning-alt"]),
  /**
   * Specify whether you are using the low contrast variant of the ToastNotification.
   */
  lowContrast: import_prop_types116.default.bool,
  /**
   * Provide a function that is called when menu is closed
   */
  onClose: import_prop_types116.default.func,
  /**
   * Provide a function that is called when the close button is clicked
   */
  onCloseButtonClick: import_prop_types116.default.func,
  /**
   * By default, this value is "status". You can also provide an alternate
   * role if it makes sense from the accessibility-side
   */
  role: import_prop_types116.default.oneOf(["alert", "log", "status"]),
  /**
   * Provide a description for "status" icon that can be read by screen readers
   */
  statusIconDescription: import_prop_types116.default.string,
  /**
   * Specify the subtitle
   */
  subtitle: import_prop_types116.default.string,
  /**
   * Specify an optional duration the notification should be closed in
   */
  timeout: import_prop_types116.default.number,
  /**
   * Specify the title
   */
  title: import_prop_types116.default.string
};
function InlineNotification(_ref5) {
  let {
    ["aria-label"]: ariaLabel,
    children,
    title,
    subtitle,
    role = "status",
    onClose,
    onCloseButtonClick = noopFn,
    statusIconDescription,
    className,
    kind = "error",
    lowContrast,
    hideCloseButton = false,
    ...rest3
  } = _ref5;
  const [isOpen, setIsOpen] = (0, import_react153.useState)(true);
  const prefix = usePrefix();
  const containerClassName = (0, import_classnames95.default)(className, {
    [`${prefix}--inline-notification`]: true,
    [`${prefix}--inline-notification--low-contrast`]: lowContrast,
    [`${prefix}--inline-notification--${kind}`]: kind,
    [`${prefix}--inline-notification--hide-close-button`]: hideCloseButton
  });
  const contentRef = (0, import_react153.useRef)(null);
  useNoInteractiveChildren(contentRef);
  const handleClose = (evt) => {
    if (!onClose || onClose(evt) !== false) {
      setIsOpen(false);
    }
  };
  const ref = (0, import_react153.useRef)(null);
  function handleCloseButtonClick(event) {
    onCloseButtonClick(event);
    handleClose(event);
  }
  if (!isOpen) {
    return null;
  }
  return import_react153.default.createElement("div", _extends({
    ref
  }, rest3, {
    role,
    className: containerClassName
  }), import_react153.default.createElement("div", {
    className: `${prefix}--inline-notification__details`
  }, import_react153.default.createElement(NotificationIcon, {
    notificationType: "inline",
    kind,
    iconDescription: statusIconDescription || `${kind} icon`
  }), import_react153.default.createElement("div", {
    ref: contentRef,
    className: `${prefix}--inline-notification__text-wrapper`
  }, title && import_react153.default.createElement(Text, {
    as: "div",
    className: `${prefix}--inline-notification__title`
  }, title), subtitle && import_react153.default.createElement(Text, {
    as: "div",
    className: `${prefix}--inline-notification__subtitle`
  }, subtitle), children)), !hideCloseButton && import_react153.default.createElement(NotificationButton, {
    notificationType: "inline",
    onClick: handleCloseButtonClick,
    "aria-label": ariaLabel
  }));
}
InlineNotification.propTypes = {
  /**
   * Provide a description for "close" icon button that can be read by screen readers
   */
  ["aria-label"]: import_prop_types116.default.string,
  /**
   * Specify the content
   */
  children: import_prop_types116.default.node,
  /**
   * Specify an optional className to be applied to the notification box
   */
  className: import_prop_types116.default.string,
  /**
   * Specify the close button should be disabled, or not
   */
  hideCloseButton: import_prop_types116.default.bool,
  /**
   * Specify what state the notification represents
   */
  kind: import_prop_types116.default.oneOf(["error", "info", "info-square", "success", "warning", "warning-alt"]),
  /**
   * Specify whether you are using the low contrast variant of the InlineNotification.
   */
  lowContrast: import_prop_types116.default.bool,
  /**
   * Provide a function that is called when menu is closed
   */
  onClose: import_prop_types116.default.func,
  /**
   * Provide a function that is called when the close button is clicked
   */
  onCloseButtonClick: import_prop_types116.default.func,
  /**
   * By default, this value is "status". You can also provide an alternate
   * role if it makes sense from the accessibility-side.
   */
  role: import_prop_types116.default.oneOf(["alert", "log", "status"]),
  /**
   * Provide a description for "status" icon that can be read by screen readers
   */
  statusIconDescription: import_prop_types116.default.string,
  /**
   * Specify the subtitle
   */
  subtitle: import_prop_types116.default.string,
  /**
   * Specify the title
   */
  title: import_prop_types116.default.string
};
function ActionableNotification(_ref6) {
  let {
    actionButtonLabel,
    ["aria-label"]: ariaLabel,
    // @ts-expect-error: deprecated prop
    ariaLabel: deprecatedAriaLabel,
    children,
    role = "alertdialog",
    onActionButtonClick,
    onClose,
    onCloseButtonClick = noopFn,
    statusIconDescription,
    className,
    inline: inline5 = false,
    kind = "error",
    lowContrast,
    hideCloseButton = false,
    hasFocus = true,
    closeOnEscape = true,
    title,
    subtitle,
    ...rest3
  } = _ref6;
  const [isOpen, setIsOpen] = (0, import_react153.useState)(true);
  const prefix = usePrefix();
  const id = useId("actionable-notification");
  const subtitleId = useId("actionable-notification-subtitle");
  const containerClassName = (0, import_classnames95.default)(className, {
    [`${prefix}--actionable-notification`]: true,
    [`${prefix}--actionable-notification--toast`]: !inline5,
    [`${prefix}--actionable-notification--low-contrast`]: lowContrast,
    [`${prefix}--actionable-notification--${kind}`]: kind,
    [`${prefix}--actionable-notification--hide-close-button`]: hideCloseButton
  });
  const innerModal = (0, import_react153.useRef)(null);
  const startTrap = (0, import_react153.useRef)(null);
  const endTrap = (0, import_react153.useRef)(null);
  const ref = (0, import_react153.useRef)(null);
  const focusTrapWithoutSentinels = useFeatureFlag("enable-experimental-focus-wrap-without-sentinels");
  useIsomorphicEffect$1(() => {
    if (hasFocus) {
      const button = document.querySelector("button.cds--actionable-notification__action-button");
      button == null ? void 0 : button.focus();
    }
  });
  function handleBlur(_ref7) {
    let {
      target: oldActiveNode,
      relatedTarget: currentActiveNode
    } = _ref7;
    if (isOpen && currentActiveNode && oldActiveNode) {
      const {
        current: bodyNode
      } = innerModal;
      const {
        current: startTrapNode
      } = startTrap;
      const {
        current: endTrapNode
      } = endTrap;
      wrapFocus({
        bodyNode,
        startTrapNode,
        endTrapNode,
        currentActiveNode,
        oldActiveNode
      });
    }
  }
  function handleKeyDown(event) {
    if (isOpen && match(event, Tab) && ref.current) {
      wrapFocusWithoutSentinels({
        containerNode: ref.current,
        currentActiveNode: event.target,
        event
      });
    }
  }
  const handleClose = (evt) => {
    if (!onClose || onClose(evt) !== false) {
      setIsOpen(false);
    }
  };
  useEscapeToClose(ref, handleCloseButtonClick, closeOnEscape);
  function handleCloseButtonClick(event) {
    onCloseButtonClick(event);
    handleClose(event);
  }
  if (!isOpen) {
    return null;
  }
  return import_react153.default.createElement("div", _extends({}, rest3, {
    ref,
    role,
    className: containerClassName,
    "aria-labelledby": title ? id : subtitleId,
    onBlur: !focusTrapWithoutSentinels ? handleBlur : () => {
    },
    onKeyDown: focusTrapWithoutSentinels ? handleKeyDown : () => {
    }
  }), !focusTrapWithoutSentinels && import_react153.default.createElement("span", {
    ref: startTrap,
    tabIndex: 0,
    role: "link",
    className: `${prefix}--visually-hidden`
  }, "Focus sentinel"), import_react153.default.createElement("div", {
    className: `${prefix}--actionable-notification__details`
  }, import_react153.default.createElement(NotificationIcon, {
    notificationType: inline5 ? "inline" : "toast",
    kind,
    iconDescription: statusIconDescription || `${kind} icon`
  }), import_react153.default.createElement("div", {
    className: `${prefix}--actionable-notification__text-wrapper`
  }, import_react153.default.createElement("div", {
    className: `${prefix}--actionable-notification__content`
  }, title && import_react153.default.createElement(Text, {
    as: "div",
    className: `${prefix}--actionable-notification__title`,
    id
  }, title), subtitle && import_react153.default.createElement(Text, {
    as: "div",
    className: `${prefix}--actionable-notification__subtitle`,
    id: subtitleId
  }, subtitle), children))), import_react153.default.createElement("div", {
    className: `${prefix}--actionable-notification__button-wrapper`,
    ref: innerModal
  }, actionButtonLabel && import_react153.default.createElement(NotificationActionButton, {
    onClick: onActionButtonClick,
    inline: inline5
  }, actionButtonLabel), !hideCloseButton && import_react153.default.createElement(NotificationButton, {
    "aria-label": deprecatedAriaLabel || ariaLabel,
    notificationType: "actionable",
    onClick: handleCloseButtonClick
  })), !focusTrapWithoutSentinels && import_react153.default.createElement("span", {
    ref: endTrap,
    tabIndex: 0,
    role: "link",
    className: `${prefix}--visually-hidden`
  }, "Focus sentinel"));
}
ActionableNotification.propTypes = {
  /**
   * Pass in the action button label that will be rendered within the ActionableNotification.
   */
  actionButtonLabel: import_prop_types116.default.string,
  /**
   * Provide a description for "close" icon button that can be read by screen readers
   */
  ["aria-label"]: import_prop_types116.default.string,
  /**
   * Deprecated, please use `aria-label` instead.
   * Provide a description for "close" icon button that can be read by screen readers
   */
  ariaLabel: deprecate(import_prop_types116.default.string, "This prop syntax has been deprecated. Please use the new `aria-label`."),
  /**
   * Specify the content
   */
  children: import_prop_types116.default.node,
  /**
   * Specify an optional className to be applied to the notification box
   */
  className: import_prop_types116.default.string,
  /**
   * Specify if pressing the escape key should close notifications
   */
  closeOnEscape: import_prop_types116.default.bool,
  /**
   * Specify if focus should be moved to the component when the notification contains actions
   */
  hasFocus: deprecate(import_prop_types116.default.bool, "hasFocus is deprecated. To conform to accessibility requirements hasFocus should always be `true` for ActionableNotification. If you were setting this prop to `false`, consider using the Callout component instead."),
  /**
   * Specify the close button should be disabled, or not
   */
  hideCloseButton: import_prop_types116.default.bool,
  /*
   * Specify if the notification should have inline styling applied instead of toast
   */
  inline: import_prop_types116.default.bool,
  /**
   * Specify what state the notification represents
   */
  kind: import_prop_types116.default.oneOf(["error", "info", "info-square", "success", "warning", "warning-alt"]),
  /**
   * Specify whether you are using the low contrast variant of the ActionableNotification.
   */
  lowContrast: import_prop_types116.default.bool,
  /**
   * Provide a function that is called when the action is clicked
   */
  onActionButtonClick: import_prop_types116.default.func,
  /**
   * Provide a function that is called when menu is closed
   */
  onClose: import_prop_types116.default.func,
  /**
   * Provide a function that is called when the close button is clicked
   */
  onCloseButtonClick: import_prop_types116.default.func,
  /**
   * By default, this value is "alertdialog". You can also provide an alternate
   * role if it makes sense from the accessibility-side.
   */
  role: import_prop_types116.default.string,
  /**
   * Provide a description for "status" icon that can be read by screen readers
   */
  statusIconDescription: import_prop_types116.default.string,
  /**
   * Specify the subtitle
   */
  subtitle: import_prop_types116.default.node,
  /**
   * Specify the title
   */
  title: import_prop_types116.default.string
};
var propMappingFunction8 = (deprecatedValue) => {
  const mapping = {
    error: "warning",
    // only redirect error -> warning
    success: "info"
    // only redirect success -> info
  };
  return mapping[deprecatedValue];
};
function Callout(_ref8) {
  let {
    actionButtonLabel,
    children,
    onActionButtonClick,
    title,
    titleId,
    subtitle,
    statusIconDescription,
    className,
    kind = "info",
    lowContrast,
    ...rest3
  } = _ref8;
  const prefix = usePrefix();
  const containerClassName = (0, import_classnames95.default)(className, {
    [`${prefix}--actionable-notification`]: true,
    [`${prefix}--actionable-notification--low-contrast`]: lowContrast,
    [`${prefix}--actionable-notification--${kind}`]: kind,
    [`${prefix}--actionable-notification--hide-close-button`]: true
  });
  const ref = (0, import_react153.useRef)(null);
  useInteractiveChildrenNeedDescription(ref, `interactive child node(s) should have an \`aria-describedby\` property with a value matching the value of \`titleId\``);
  return import_react153.default.createElement("div", _extends({
    ref
  }, rest3, {
    className: containerClassName
  }), import_react153.default.createElement("div", {
    className: `${prefix}--actionable-notification__details`
  }, import_react153.default.createElement(NotificationIcon, {
    notificationType: "inline",
    kind,
    iconDescription: statusIconDescription || `${kind} icon`
  }), import_react153.default.createElement("div", {
    className: `${prefix}--actionable-notification__text-wrapper`
  }, title && import_react153.default.createElement(Text, {
    as: "div",
    id: titleId,
    className: `${prefix}--actionable-notification__title`
  }, title), subtitle && import_react153.default.createElement(Text, {
    as: "div",
    className: `${prefix}--actionable-notification__subtitle`
  }, subtitle), children)), import_react153.default.createElement("div", {
    className: `${prefix}--actionable-notification__button-wrapper`
  }, actionButtonLabel && import_react153.default.createElement(NotificationActionButton, {
    onClick: onActionButtonClick,
    "aria-describedby": titleId,
    inline: true
  }, actionButtonLabel)));
}
Callout.propTypes = {
  /**
   * Pass in the action button label that will be rendered within the ActionableNotification.
   */
  actionButtonLabel: import_prop_types116.default.string,
  /**
   * Specify the content
   */
  children: import_prop_types116.default.node,
  /**
   * Specify an optional className to be applied to the notification box
   */
  className: import_prop_types116.default.string,
  /**
   * Specify what state the notification represents
   */
  kind: deprecateValuesWithin(import_prop_types116.default.oneOf(["error", "info", "info-square", "success", "warning", "warning-alt"]), ["warning", "info"], propMappingFunction8),
  /**
   * Specify whether you are using the low contrast variant of the Callout.
   */
  lowContrast: import_prop_types116.default.bool,
  /**
   * Provide a function that is called when the action is clicked
   */
  onActionButtonClick: import_prop_types116.default.func,
  /**
   * Provide a description for "status" icon that can be read by screen readers
   */
  statusIconDescription: import_prop_types116.default.string,
  /**
   * Specify the subtitle
   */
  subtitle: import_prop_types116.default.node,
  /**
   * Specify the title
   */
  title: import_prop_types116.default.string,
  /**
   * Specify the id for the element containing the title
   */
  titleId: import_prop_types116.default.string
};
var didWarnAboutDeprecation6 = false;
var StaticNotification = (props) => {
  if (true) {
    true ? warning(didWarnAboutDeprecation6, "`StaticNotification` has been renamed to `Callout`.Run the following codemod to automatically update usages in yourproject: `npx @carbon/upgrade migrate refactor-to-callout --write`") : void 0;
    didWarnAboutDeprecation6 = true;
  }
  return import_react153.default.createElement(Callout, props);
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/NumberInput/NumberInput.Skeleton.js
var import_prop_types117 = __toESM(require_prop_types());
var import_react154 = __toESM(require_react());
var import_classnames96 = __toESM(require_classnames());
function NumberInputSkeleton(_ref) {
  let {
    hideLabel,
    className,
    size: size6 = "md",
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  return import_react154.default.createElement("div", _extends({
    className: (0, import_classnames96.default)(`${prefix}--form-item`, className)
  }, rest3), !hideLabel && import_react154.default.createElement("span", {
    className: `${prefix}--label ${prefix}--skeleton`
  }), import_react154.default.createElement("div", {
    className: `${prefix}--number ${prefix}--skeleton ${prefix}--number--${size6}`
  }));
}
NumberInputSkeleton.propTypes = {
  /**
   * Specify an optional className to add to the form item wrapper.
   */
  className: import_prop_types117.default.string,
  /**
   * Specify whether the label should be hidden, or not
   */
  hideLabel: import_prop_types117.default.bool,
  /**
   * Specify the size of the Number Input.
   */
  size: import_prop_types117.default.oneOf(["sm", "md", "lg"])
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/NumberInput/NumberInput.js
var import_classnames97 = __toESM(require_classnames());
var import_prop_types118 = __toESM(require_prop_types());
var import_react156 = __toESM(require_react());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/internal/useNormalizedInputProps.js
var import_react155 = __toESM(require_react());
function useNormalizedInputProps(_ref) {
  let {
    id,
    readOnly,
    disabled,
    invalid,
    invalidText,
    warn: warn2,
    warnText
  } = _ref;
  const prefix = usePrefix();
  const normalizedProps = {
    disabled: !readOnly && disabled,
    invalid: !readOnly && invalid,
    invalidId: `${id}-error-msg`,
    warn: !readOnly && !invalid && warn2,
    warnId: `${id}-warn-msg`,
    validation: null,
    icon: null,
    helperId: `${id}-helper-text`
  };
  if (normalizedProps.invalid) {
    normalizedProps.icon = WarningFilled;
    normalizedProps.validation = import_react155.default.createElement(Text, {
      as: "div",
      className: `${prefix}--form-requirement`,
      id: normalizedProps.invalidId
    }, invalidText);
  } else if (normalizedProps.warn) {
    normalizedProps.icon = WarningAltFilled;
    normalizedProps.validation = import_react155.default.createElement(Text, {
      as: "div",
      className: `${prefix}--form-requirement`,
      id: normalizedProps.warnId
    }, warnText);
  }
  return normalizedProps;
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/NumberInput/NumberInput.js
var _Subtract;
var _Add;
var translationIds3 = {
  "increment.number": "increment.number",
  "decrement.number": "decrement.number"
};
var defaultTranslations7 = {
  [translationIds3["increment.number"]]: "Increment number",
  [translationIds3["decrement.number"]]: "Decrement number"
};
var NumberInput = import_react156.default.forwardRef(function NumberInput2(props, forwardRef13) {
  var _a, _b;
  const {
    allowEmpty = false,
    className: customClassName,
    decorator,
    disabled = false,
    disableWheel: disableWheelProp = false,
    defaultValue = 0,
    helperText = "",
    hideLabel = false,
    hideSteppers,
    iconDescription,
    id,
    label,
    invalid = false,
    invalidText,
    light,
    max: max4,
    min: min4,
    onChange,
    onClick,
    onKeyUp,
    readOnly,
    size: size6 = "md",
    slug,
    step = 1,
    translateWithId: t2 = (id2) => defaultTranslations7[id2],
    warn: warn2 = false,
    warnText = "",
    value: controlledValue,
    ...rest3
  } = props;
  const prefix = usePrefix();
  const {
    isFluid
  } = (0, import_react156.useContext)(FormContext);
  const [isFocused, setIsFocused] = (0, import_react156.useState)(false);
  const [value, setValue] = (0, import_react156.useState)(() => {
    if (controlledValue !== void 0) {
      return controlledValue;
    }
    if (defaultValue !== void 0) {
      return defaultValue;
    }
    if (allowEmpty) {
      return "";
    }
    return 0;
  });
  const [prevControlledValue, setPrevControlledValue] = (0, import_react156.useState)(controlledValue);
  const inputRef = (0, import_react156.useRef)(null);
  const ref = useMergedRefs([forwardRef13, inputRef]);
  const numberInputClasses = (0, import_classnames97.default)({
    [`${prefix}--number`]: true,
    [`${prefix}--number--helpertext`]: true,
    [`${prefix}--number--readonly`]: readOnly,
    [`${prefix}--number--light`]: light,
    [`${prefix}--number--nolabel`]: hideLabel,
    [`${prefix}--number--nosteppers`]: hideSteppers,
    [`${prefix}--number--${size6}`]: size6
  });
  const isInputValid = getInputValidity({
    allowEmpty,
    invalid,
    value,
    max: max4,
    min: min4
  });
  const normalizedProps = useNormalizedInputProps({
    id,
    readOnly,
    disabled,
    invalid: !isInputValid,
    invalidText,
    warn: warn2,
    warnText
  });
  const [incrementNumLabel, decrementNumLabel] = [t2("increment.number"), t2("decrement.number")];
  const wrapperClasses = (0, import_classnames97.default)(`${prefix}--number__input-wrapper`, {
    [`${prefix}--number__input-wrapper--warning`]: normalizedProps.warn,
    [`${prefix}--number__input-wrapper--slug`]: slug,
    [`${prefix}--number__input-wrapper--decorator`]: decorator
  });
  const iconClasses = (0, import_classnames97.default)({
    [`${prefix}--number__invalid`]: normalizedProps.invalid || normalizedProps.warn,
    [`${prefix}--number__invalid--warning`]: normalizedProps.warn
  });
  if (controlledValue !== prevControlledValue) {
    setValue(controlledValue);
    setPrevControlledValue(controlledValue);
  }
  let ariaDescribedBy = void 0;
  if (normalizedProps.invalid) {
    ariaDescribedBy = normalizedProps.invalidId;
  }
  if (normalizedProps.warn) {
    ariaDescribedBy = normalizedProps.warnId;
  }
  if (!normalizedProps.validation) {
    ariaDescribedBy = helperText ? normalizedProps.helperId : void 0;
  }
  function handleOnChange(event) {
    if (disabled) {
      return;
    }
    const state = {
      value: allowEmpty && event.target.value === "" ? "" : Number(event.target.value),
      direction: value < event.target.value ? "up" : "down"
    };
    setValue(state.value);
    if (onChange) {
      onChange(event, state);
    }
  }
  const handleFocus = (evt) => {
    if ("type" in evt.target && evt.target.type === "button") {
      setIsFocused(false);
    } else {
      setIsFocused(evt.type === "focus" ? true : false);
    }
  };
  const outerElementClasses = (0, import_classnames97.default)(`${prefix}--form-item`, {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    [customClassName]: !!customClassName,
    [`${prefix}--number-input--fluid--invalid`]: isFluid && normalizedProps.invalid,
    [`${prefix}--number-input--fluid--focus`]: isFluid && isFocused,
    [`${prefix}--number-input--fluid--disabled`]: isFluid && disabled
  });
  const Icon = normalizedProps.icon;
  function handleStepperClick(event, direction) {
    if (inputRef.current) {
      const currentValue = Number(inputRef.current.value);
      let newValue = direction === "up" ? currentValue + step : currentValue - step;
      if (min4 !== void 0) {
        newValue = Math.max(newValue, min4);
      }
      if (max4 !== void 0) {
        newValue = Math.min(newValue, max4);
      }
      const currentInputValue = inputRef.current ? inputRef.current.value : "";
      const state = {
        value: allowEmpty && currentInputValue === "" && step === 0 ? "" : newValue,
        direction
      };
      setValue(state.value);
      if (onChange) {
        onChange(event, state);
      }
      if (onClick) {
        onClick(event, state);
      }
    }
  }
  let normalizedDecorator = import_react156.default.isValidElement(slug ?? decorator) ? slug ?? decorator : null;
  if (normalizedDecorator && ((_a = normalizedDecorator["type"]) == null ? void 0 : _a.displayName) === "AILabel") {
    normalizedDecorator = import_react156.default.cloneElement(normalizedDecorator, {
      size: "mini"
    });
  }
  let isRevertActive;
  if (normalizedDecorator && ((_b = normalizedDecorator["type"]) == null ? void 0 : _b.displayName) === "AILabel") {
    isRevertActive = normalizedDecorator.props.revertActive;
  }
  (0, import_react156.useEffect)(() => {
    if (!isRevertActive && slug && defaultValue) {
      setValue(defaultValue);
    }
  }, [defaultValue, isRevertActive, slug]);
  return import_react156.default.createElement("div", {
    className: outerElementClasses,
    onFocus: isFluid ? handleFocus : void 0,
    onBlur: isFluid ? handleFocus : void 0
  }, import_react156.default.createElement("div", {
    className: numberInputClasses,
    "data-invalid": normalizedProps.invalid ? true : void 0
  }, import_react156.default.createElement(Label, {
    disabled: normalizedProps.disabled,
    hideLabel,
    id,
    label
  }), import_react156.default.createElement("div", {
    className: wrapperClasses
  }, import_react156.default.createElement("input", _extends({}, rest3, {
    "data-invalid": normalizedProps.invalid ? true : void 0,
    "aria-invalid": normalizedProps.invalid,
    "aria-describedby": ariaDescribedBy,
    "aria-readonly": readOnly,
    disabled: normalizedProps.disabled,
    ref,
    id,
    max: max4,
    min: min4,
    onClick,
    onChange: handleOnChange,
    onKeyUp,
    onFocus: (e2) => {
      if (disableWheelProp) {
        e2.target.addEventListener("wheel", disableWheel);
      }
      if (rest3.onFocus) {
        rest3.onFocus(e2);
      }
    },
    onBlur: (e2) => {
      if (disableWheelProp) {
        e2.target.removeEventListener("wheel", disableWheel);
      }
      if (rest3.onBlur) {
        rest3.onBlur(e2);
      }
    },
    pattern: "[0-9]*",
    readOnly,
    step,
    type: "number",
    value
  })), slug ? normalizedDecorator : decorator ? import_react156.default.createElement("div", {
    className: `${prefix}--number__input-inner-wrapper--decorator`
  }, normalizedDecorator) : "", Icon ? import_react156.default.createElement(Icon, {
    className: iconClasses
  }) : null, !hideSteppers && import_react156.default.createElement("div", {
    className: `${prefix}--number__controls`
  }, import_react156.default.createElement("button", {
    "aria-label": decrementNumLabel || iconDescription,
    className: `${prefix}--number__control-btn down-icon`,
    disabled: disabled || readOnly,
    onClick: (event) => handleStepperClick(event, "down"),
    tabIndex: -1,
    title: decrementNumLabel || iconDescription,
    type: "button"
  }, _Subtract || (_Subtract = import_react156.default.createElement(Subtract, {
    className: "down-icon"
  }))), import_react156.default.createElement("div", {
    className: `${prefix}--number__rule-divider`
  }), import_react156.default.createElement("button", {
    "aria-label": incrementNumLabel || iconDescription,
    className: `${prefix}--number__control-btn up-icon`,
    disabled: disabled || readOnly,
    onClick: (event) => handleStepperClick(event, "up"),
    tabIndex: -1,
    title: incrementNumLabel || iconDescription,
    type: "button"
  }, _Add || (_Add = import_react156.default.createElement(Add, {
    className: "up-icon"
  }))), import_react156.default.createElement("div", {
    className: `${prefix}--number__rule-divider`
  }))), isFluid && import_react156.default.createElement("hr", {
    className: `${prefix}--number-input__divider`
  }), normalizedProps.validation ? normalizedProps.validation : import_react156.default.createElement(HelperText, {
    id: normalizedProps.helperId,
    disabled,
    description: helperText
  })));
});
NumberInput.propTypes = {
  /**
   * `true` to allow empty string.
   */
  allowEmpty: import_prop_types118.default.bool,
  /**
   * Specify an optional className to be applied to the wrapper node
   */
  className: import_prop_types118.default.string,
  /**
   * **Experimental**: Provide a `decorator` component to be rendered inside the `NumberInput` component
   */
  decorator: import_prop_types118.default.node,
  /**
   * Optional starting value for uncontrolled state
   */
  defaultValue: import_prop_types118.default.oneOfType([import_prop_types118.default.number, import_prop_types118.default.string]),
  /**
   * Specify if the wheel functionality for the input should be disabled, or not
   */
  disableWheel: import_prop_types118.default.bool,
  /**
   * Specify if the control should be disabled, or not
   */
  disabled: import_prop_types118.default.bool,
  /**
   * Provide text that is used alongside the control label for additional help
   */
  helperText: import_prop_types118.default.node,
  /**
   * Specify whether you want the underlying label to be visually hidden
   */
  hideLabel: import_prop_types118.default.bool,
  /**
   * Specify whether you want the steppers to be hidden
   */
  hideSteppers: import_prop_types118.default.bool,
  /**
   * Provide a description for up/down icons that can be read by screen readers
   */
  iconDescription: import_prop_types118.default.string,
  /**
   * Specify a custom `id` for the input
   */
  id: import_prop_types118.default.string.isRequired,
  /**
   * Specify if the currently value is invalid.
   */
  invalid: import_prop_types118.default.bool,
  /**
   * Message which is displayed if the value is invalid.
   */
  invalidText: import_prop_types118.default.node,
  /**
   * Generic `label` that will be used as the textual representation of what
   * this field is for
   */
  label: import_prop_types118.default.node,
  /**
   * `true` to use the light version.
   */
  light: deprecate(import_prop_types118.default.bool, "The `light` prop for `NumberInput` is no longer needed and has been deprecated in v11 in favor of the new `Layer` component. It will be moved in the next major release."),
  /**
   * The maximum value.
   */
  max: import_prop_types118.default.number,
  /**
   * The minimum value.
   */
  min: import_prop_types118.default.number,
  /**
   * Provide an optional handler that is called when the internal state of
   * NumberInput changes. This handler is called with event and state info.
   * `(event, { value, direction }) => void`
   */
  onChange: import_prop_types118.default.func,
  /**
   * Provide an optional function to be called when the up/down button is clicked
   */
  onClick: import_prop_types118.default.func,
  /**
   * Provide an optional function to be called when a key is pressed in the number input
   */
  onKeyUp: import_prop_types118.default.func,
  /**
   * Specify if the component should be read-only
   */
  readOnly: import_prop_types118.default.bool,
  /**
   * Specify the size of the Number Input.
   */
  size: import_prop_types118.default.oneOf(["sm", "md", "lg"]),
  /**
   * **Experimental**: Provide a `Slug` component to be rendered inside the `NumberInput` component
   */
  slug: deprecate(import_prop_types118.default.node, "The `slug` prop for `NumberInput` is no longer needed and has been deprecated in v11 in favor of the new `decorator` prop. It will be moved in the next major release."),
  /**
   * Specify how much the values should increase/decrease upon clicking on up/down button
   */
  step: import_prop_types118.default.number,
  /**
   * Provide custom text for the component for each translation id
   */
  translateWithId: import_prop_types118.default.func,
  /**
   * Specify the value of the input
   */
  value: import_prop_types118.default.oneOfType([import_prop_types118.default.number, import_prop_types118.default.string]),
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types118.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types118.default.node
};
var Label = (_ref) => {
  let {
    disabled,
    id,
    hideLabel,
    label
  } = _ref;
  const prefix = usePrefix();
  const className = (0, import_classnames97.default)({
    [`${prefix}--label`]: true,
    [`${prefix}--label--disabled`]: disabled,
    [`${prefix}--visually-hidden`]: hideLabel
  });
  if (label) {
    return import_react156.default.createElement(Text, {
      as: "label",
      htmlFor: id,
      className
    }, label);
  }
  return null;
};
Label.propTypes = {
  disabled: import_prop_types118.default.bool,
  hideLabel: import_prop_types118.default.bool,
  id: import_prop_types118.default.string,
  label: import_prop_types118.default.node
};
function HelperText(_ref2) {
  let {
    disabled,
    description,
    id
  } = _ref2;
  const prefix = usePrefix();
  const className = (0, import_classnames97.default)(`${prefix}--form__helper-text`, {
    [`${prefix}--form__helper-text--disabled`]: disabled
  });
  if (description) {
    return import_react156.default.createElement(Text, {
      as: "div",
      id,
      className
    }, description);
  }
  return null;
}
HelperText.propTypes = {
  description: import_prop_types118.default.node,
  disabled: import_prop_types118.default.bool,
  id: import_prop_types118.default.string
};
function getInputValidity(_ref3) {
  let {
    allowEmpty,
    invalid,
    value,
    max: max4,
    min: min4
  } = _ref3;
  if (invalid) {
    return false;
  }
  if (value === "") {
    return allowEmpty;
  }
  if (value > max4 || value < min4) {
    return false;
  }
  return true;
}
function disableWheel(e2) {
  e2.preventDefault();
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/OrderedList/OrderedList.js
var import_prop_types119 = __toESM(require_prop_types());
var import_react157 = __toESM(require_react());
var import_classnames98 = __toESM(require_classnames());
function OrderedList(_ref) {
  let {
    className,
    nested = false,
    native = false,
    isExpressive = false,
    ...other
  } = _ref;
  const prefix = usePrefix();
  const classNames = (0, import_classnames98.default)({
    [`${prefix}--list--ordered`]: !native,
    [`${prefix}--list--ordered--native`]: native,
    [`${prefix}--list--nested`]: nested,
    [`${prefix}--list--expressive`]: isExpressive
  }, className);
  return import_react157.default.createElement("ol", _extends({
    className: classNames
  }, other));
}
OrderedList.propTypes = {
  /**
   * Provide list items to be rendered in the ordered list
   */
  children: import_prop_types119.default.node,
  /**
   * Provide an optional className to be applied to the containing <ol> node
   */
  className: import_prop_types119.default.string,
  /**
   * Specify whether this ordered list expressive or not
   */
  isExpressive: import_prop_types119.default.bool,
  /**
   * Specify whether this ordered list should use native list styles instead of custom counter
   */
  native: import_prop_types119.default.bool,
  /**
   * Specify whether this ordered list is nested inside of another nested list
   */
  nested: import_prop_types119.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Pagination/Pagination.js
var import_classnames102 = __toESM(require_classnames());
var import_prop_types123 = __toESM(require_prop_types());
var import_react161 = __toESM(require_react());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Select/Select.js
var import_prop_types120 = __toESM(require_prop_types());
var import_react158 = __toESM(require_react());
var import_classnames99 = __toESM(require_classnames());
var Select = import_react158.default.forwardRef(function Select2(_ref, ref) {
  var _a;
  let {
    className,
    decorator,
    id,
    inline: inline5 = false,
    labelText = "Select",
    disabled = false,
    children,
    // reserved for use with Pagination component
    noLabel = false,
    // eslint-disable-next-line no-unused-vars
    hideLabel = false,
    invalid = false,
    invalidText = "",
    helperText = "",
    light = false,
    readOnly,
    size: size6,
    warn: warn2 = false,
    warnText,
    onChange,
    slug,
    ...other
  } = _ref;
  const prefix = usePrefix();
  const {
    isFluid
  } = (0, import_react158.useContext)(FormContext);
  const [isFocused, setIsFocused] = (0, import_react158.useState)(false);
  const [title, setTitle] = (0, import_react158.useState)("");
  const selectInstanceId = useId();
  const selectClasses = (0, import_classnames99.default)({
    [`${prefix}--select`]: true,
    [`${prefix}--select--inline`]: inline5,
    [`${prefix}--select--light`]: light,
    [`${prefix}--select--invalid`]: invalid,
    [`${prefix}--select--disabled`]: disabled,
    [`${prefix}--select--readonly`]: readOnly,
    [`${prefix}--select--warning`]: warn2,
    [`${prefix}--select--fluid--invalid`]: isFluid && invalid,
    [`${prefix}--select--fluid--focus`]: isFluid && isFocused,
    [`${prefix}--select--slug`]: slug,
    [`${prefix}--select--decorator`]: decorator
  });
  const labelClasses = (0, import_classnames99.default)(`${prefix}--label`, {
    [`${prefix}--visually-hidden`]: hideLabel,
    [`${prefix}--label--disabled`]: disabled
  });
  const inputClasses = (0, import_classnames99.default)({
    [`${prefix}--select-input`]: true,
    [`${prefix}--select-input--${size6}`]: size6
  });
  const errorId = `${id}-error-msg`;
  const errorText = (() => {
    if (invalid) {
      return invalidText;
    }
    if (warn2) {
      return warnText;
    }
  })();
  const error2 = invalid || warn2 ? import_react158.default.createElement(Text, {
    as: "div",
    className: `${prefix}--form-requirement`,
    id: errorId
  }, errorText) : null;
  const helperTextClasses = (0, import_classnames99.default)(`${prefix}--form__helper-text`, {
    [`${prefix}--form__helper-text--disabled`]: disabled
  });
  const helperId = !helperText ? void 0 : `select-helper-text-${selectInstanceId}`;
  const helper = helperText ? import_react158.default.createElement(Text, {
    as: "div",
    id: helperId,
    className: helperTextClasses
  }, helperText) : null;
  const ariaProps = {};
  if (invalid) {
    ariaProps["aria-describedby"] = errorId;
  } else if (!inline5 && !isFluid) {
    ariaProps["aria-describedby"] = helper ? helperId : void 0;
  }
  const handleFocus = (evt) => {
    setIsFocused(evt.type === "focus" ? true : false);
  };
  const handleChange = (evt) => {
    var _a2;
    setTitle((_a2 = evt == null ? void 0 : evt.target) == null ? void 0 : _a2.value);
  };
  const readOnlyEventHandlers = {
    onMouseDown: (evt) => {
      if (readOnly) {
        evt.preventDefault();
        evt.target.focus();
      }
    },
    onKeyDown: (evt) => {
      const selectAccessKeys = ["ArrowDown", "ArrowUp", " "];
      if (readOnly && selectAccessKeys.includes(evt.key)) {
        evt.preventDefault();
      }
    }
  };
  let normalizedDecorator = import_react158.default.isValidElement(slug ?? decorator) ? slug ?? decorator : null;
  if (normalizedDecorator && ((_a = normalizedDecorator["type"]) == null ? void 0 : _a.displayName) === "AILabel") {
    normalizedDecorator = import_react158.default.cloneElement(normalizedDecorator, {
      size: "mini"
    });
  }
  const input = (() => {
    return import_react158.default.createElement(import_react158.default.Fragment, null, import_react158.default.createElement("select", _extends({}, other, ariaProps, {
      id,
      className: inputClasses,
      disabled: disabled || void 0,
      "aria-invalid": invalid || void 0,
      "aria-readonly": readOnly || void 0,
      title,
      onChange: composeEventHandlers([onChange, handleChange])
    }, readOnlyEventHandlers, {
      ref
    }), children), import_react158.default.createElement(ChevronDown, {
      className: `${prefix}--select__arrow`
    }), invalid && import_react158.default.createElement(WarningFilled, {
      className: `${prefix}--select__invalid-icon`
    }), !invalid && warn2 && import_react158.default.createElement(WarningAltFilled, {
      className: `${prefix}--select__invalid-icon ${prefix}--select__invalid-icon--warning`
    }));
  })();
  return import_react158.default.createElement("div", {
    className: (0, import_classnames99.default)(`${prefix}--form-item`, className)
  }, import_react158.default.createElement("div", {
    className: selectClasses
  }, !noLabel && import_react158.default.createElement(Text, {
    as: "label",
    htmlFor: id,
    className: labelClasses
  }, labelText), inline5 && import_react158.default.createElement("div", {
    className: `${prefix}--select-input--inline__wrapper`
  }, import_react158.default.createElement("div", {
    className: `${prefix}--select-input__wrapper`,
    "data-invalid": invalid || null
  }, input), error2), !inline5 && import_react158.default.createElement("div", {
    className: `${prefix}--select-input__wrapper`,
    "data-invalid": invalid || null,
    onFocus: handleFocus,
    onBlur: handleFocus
  }, input, slug ? normalizedDecorator : decorator ? import_react158.default.createElement("div", {
    className: `${prefix}--select__inner-wrapper--decorator`
  }, normalizedDecorator) : "", isFluid && import_react158.default.createElement("hr", {
    className: `${prefix}--select__divider`
  }), isFluid && error2 ? error2 : null), !inline5 && !isFluid && error2 ? error2 : helper));
});
Select.displayName = "Select";
Select.propTypes = {
  /**
   * Provide the contents of your Select
   */
  children: import_prop_types120.default.node,
  /**
   * Specify an optional className to be applied to the node containing the label and the select box
   */
  className: import_prop_types120.default.string,
  /**
   * **Experimental**: Provide a decorator component to be rendered inside the `Select` component
   */
  decorator: import_prop_types120.default.node,
  /**
   * Optionally provide the default value of the `<select>`
   */
  defaultValue: import_prop_types120.default.any,
  /**
   * Specify whether the control is disabled
   */
  disabled: import_prop_types120.default.bool,
  /**
   * Provide text that is used alongside the control label for additional help
   */
  helperText: import_prop_types120.default.node,
  /**
   * Specify whether the label should be hidden, or not
   */
  hideLabel: import_prop_types120.default.bool,
  /**
   * Specify a custom `id` for the `<select>`
   */
  id: import_prop_types120.default.string.isRequired,
  /**
   * Specify whether you want the inline version of this control
   */
  inline: import_prop_types120.default.bool,
  /**
   * Specify if the currently value is invalid.
   */
  invalid: import_prop_types120.default.bool,
  /**
   * Message which is displayed if the value is invalid.
   */
  invalidText: import_prop_types120.default.node,
  /**
   * Provide label text to be read by screen readers when interacting with the
   * control
   */
  labelText: import_prop_types120.default.node,
  /**
   * `true` to use the light version. For use on $ui-01 backgrounds only.
   * Don't use this to make tile background color same as container background color.
   */
  light: deprecate(import_prop_types120.default.bool, "The `light` prop for `Select` is no longer needed and has been deprecated in v11 in favor of the new `Layer` component. It will be moved in the next major release."),
  /**
   * Reserved for use with Pagination component. Will not render a label for the
   * select since Pagination renders one for us.
   */
  noLabel: import_prop_types120.default.bool,
  /**
   * Provide an optional `onChange` hook that is called each time the value of
   * the underlying `<input>` changes
   */
  onChange: import_prop_types120.default.func,
  /**
   * Whether the select should be read-only
   */
  readOnly: import_prop_types120.default.bool,
  /**
   * Specify the size of the Select Input.
   */
  size: import_prop_types120.default.oneOf(["sm", "md", "lg"]),
  slug: deprecate(import_prop_types120.default.node, "The `slug` prop has been deprecated and will be removed in the next major version. Use the decorator prop instead."),
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types120.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types120.default.node
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Select/Select.Skeleton.js
var import_prop_types121 = __toESM(require_prop_types());
var import_react159 = __toESM(require_react());
var import_classnames100 = __toESM(require_classnames());
var SelectSkeleton = (_ref) => {
  let {
    hideLabel,
    className,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  return import_react159.default.createElement("div", _extends({
    className: (0, import_classnames100.default)(`${prefix}--form-item`, className)
  }, rest3), !hideLabel && import_react159.default.createElement("span", {
    className: `${prefix}--label ${prefix}--skeleton`
  }), import_react159.default.createElement("div", {
    className: `${prefix}--select ${prefix}--skeleton`
  }, import_react159.default.createElement("div", {
    className: `${prefix}--select-input`
  })));
};
SelectSkeleton.propTypes = {
  /**
   * Specify an optional className to add to the form item wrapper.
   */
  className: import_prop_types121.default.string,
  /**
   * Specify whether the label should be hidden, or not
   */
  hideLabel: import_prop_types121.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/SelectItem/SelectItem.js
var import_prop_types122 = __toESM(require_prop_types());
var import_react160 = __toESM(require_react());
var import_classnames101 = __toESM(require_classnames());
var SelectItem = (_ref) => {
  let {
    className,
    value = "",
    disabled = false,
    hidden = false,
    text = "",
    ...other
  } = _ref;
  const prefix = usePrefix();
  const selectItemClasses = (0, import_classnames101.default)({
    [`${prefix}--select-option`]: true,
    ...className && {
      [className]: className
    }
  });
  return import_react160.default.createElement("option", _extends({}, other, {
    className: selectItemClasses,
    value,
    disabled,
    hidden
  }), text);
};
SelectItem.propTypes = {
  /**
   * Specify an optional className to be applied to the node
   */
  className: import_prop_types122.default.string,
  /**
   * Specify whether the <SelectItem> should be disabled
   */
  disabled: import_prop_types122.default.bool,
  /**
   * Specify whether the <SelectItem> is hidden
   */
  hidden: import_prop_types122.default.bool,
  /**
   * Provide the contents of your <SelectItem>
   */
  text: import_prop_types122.default.string.isRequired,
  /**
   * Specify the value of the <SelectItem>
   */
  value: import_prop_types122.default.any.isRequired
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/tools/array.js
function equals(arr1, arr2) {
  if (!Array.isArray(arr1) || !Array.isArray(arr2) || arr1.length !== arr2.length) {
    return false;
  }
  if (arr1 === arr2) {
    return true;
  }
  for (let i = 0; i < arr1.length; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Pagination/Pagination.js
var _CaretLeft2;
var _CaretRight2;
function mapPageSizesToObject(sizes2) {
  return typeof sizes2[0] === "object" && sizes2[0] !== null ? sizes2 : sizes2.map((size6) => ({
    text: size6,
    value: size6
  }));
}
function renderSelectItems(total) {
  let counter = 1;
  const itemArr = [];
  while (counter <= total) {
    itemArr.push(import_react161.default.createElement(SelectItem, {
      key: counter,
      value: counter,
      text: String(counter)
    }));
    counter++;
  }
  return itemArr;
}
function getPageSize(pageSizes, pageSize) {
  if (pageSize) {
    const hasSize = pageSizes.find((size6) => {
      return pageSize === size6.value;
    });
    if (hasSize) {
      return pageSize;
    }
  }
  return pageSizes[0].value;
}
var Pagination = import_react161.default.forwardRef(function Pagination2(_ref, ref) {
  let {
    backwardText = "Previous page",
    className: customClassName = "",
    disabled = false,
    forwardText = "Next page",
    id,
    isLastPage = false,
    itemText = (min4, max4) => `${min4}–${max4} items`,
    itemRangeText = (min4, max4, total) => `${min4}–${max4} of ${total} items`,
    itemsPerPageText = "Items per page:",
    onChange,
    pageNumberText: _pageNumberText = "Page Number",
    pageRangeText = (_current, total) => `of ${total} ${total === 1 ? "page" : "pages"}`,
    page: controlledPage = 1,
    pageInputDisabled,
    pageSize: controlledPageSize,
    pageSizeInputDisabled,
    pageSizes: controlledPageSizes,
    pageText = (page2) => `page ${page2}`,
    pagesUnknown = false,
    size: size6 = "md",
    totalItems,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const inputId = useFallbackId(id == null ? void 0 : id.toString());
  const backBtnRef = (0, import_react161.useRef)(null);
  const forwardBtnRef = (0, import_react161.useRef)(null);
  const [pageSizes, setPageSizes] = (0, import_react161.useState)(() => {
    return mapPageSizesToObject(controlledPageSizes);
  });
  const [prevPageSizes, setPrevPageSizes] = (0, import_react161.useState)(controlledPageSizes);
  const [page, setPage] = (0, import_react161.useState)(controlledPage);
  const [prevControlledPage, setPrevControlledPage] = (0, import_react161.useState)(controlledPage);
  const [pageSize, setPageSize] = (0, import_react161.useState)(() => {
    return getPageSize(pageSizes, controlledPageSize);
  });
  const [prevControlledPageSize, setPrevControlledPageSize] = (0, import_react161.useState)(controlledPageSize);
  const className = (0, import_classnames102.default)({
    [`${prefix}--pagination`]: true,
    [`${prefix}--pagination--${size6}`]: size6,
    [customClassName]: !!customClassName
  });
  const totalPages = totalItems ? Math.max(Math.ceil(totalItems / pageSize), 1) : 1;
  const backButtonDisabled = disabled || page === 1;
  const backButtonClasses = (0, import_classnames102.default)({
    [`${prefix}--pagination__button`]: true,
    [`${prefix}--pagination__button--backward`]: true,
    [`${prefix}--pagination__button--no-index`]: backButtonDisabled
  });
  const forwardButtonDisabled = disabled || page === totalPages && !pagesUnknown;
  const forwardButtonClasses = (0, import_classnames102.default)({
    [`${prefix}--pagination__button`]: true,
    [`${prefix}--pagination__button--forward`]: true,
    [`${prefix}--pagination__button--no-index`]: forwardButtonDisabled
  });
  const selectItems = renderSelectItems(totalPages);
  if (controlledPage !== prevControlledPage) {
    setPage(controlledPage);
    setPrevControlledPage(controlledPage);
  }
  if (controlledPageSize !== prevControlledPageSize) {
    setPageSize(getPageSize(pageSizes, controlledPageSize));
    setPrevControlledPageSize(controlledPageSize);
  }
  if (!equals(controlledPageSizes, prevPageSizes)) {
    const pageSizes2 = mapPageSizesToObject(controlledPageSizes);
    const hasPageSize = pageSizes2.find((size7) => {
      return size7.value === pageSize;
    });
    if (!hasPageSize) {
      setPage(1);
    }
    setPageSizes(pageSizes2);
    setPrevPageSizes(controlledPageSizes);
  }
  function handleSizeChange(event) {
    const pageSize2 = Number(event.target.value);
    const changes = {
      pageSize: pageSize2,
      page: 1
    };
    setPage(changes.page);
    setPageSize(changes.pageSize);
    if (onChange) {
      onChange(changes);
    }
  }
  function handlePageInputChange(event) {
    const page2 = Number(event.target.value);
    if (page2 > 0 && totalItems && page2 <= Math.max(Math.ceil(totalItems / pageSize), 1)) {
      setPage(page2);
      if (onChange) {
        onChange({
          page: page2,
          pageSize
        });
      }
    }
  }
  function incrementPage() {
    const nextPage = page + 1;
    setPage(nextPage);
    if (nextPage === totalPages && (backBtnRef == null ? void 0 : backBtnRef.current)) {
      backBtnRef.current.focus();
    }
    if (onChange) {
      onChange({
        page: nextPage,
        pageSize,
        ref: backBtnRef
      });
    }
  }
  function decrementPage() {
    const nextPage = page - 1;
    setPage(nextPage);
    if (nextPage === 1 && (forwardBtnRef == null ? void 0 : forwardBtnRef.current)) {
      forwardBtnRef.current.focus();
    }
    if (onChange) {
      onChange({
        page: nextPage,
        pageSize,
        ref: forwardBtnRef
      });
    }
  }
  return import_react161.default.createElement("div", _extends({
    className,
    ref
  }, rest3), import_react161.default.createElement("div", {
    className: `${prefix}--pagination__left`
  }, import_react161.default.createElement("label", {
    id: `${prefix}-pagination-select-${inputId}-count-label`,
    className: `${prefix}--pagination__text`,
    htmlFor: `${prefix}-pagination-select-${inputId}`
  }, itemsPerPageText), import_react161.default.createElement(Select, {
    id: `${prefix}-pagination-select-${inputId}`,
    className: `${prefix}--select__item-count`,
    labelText: "",
    hideLabel: true,
    noLabel: true,
    inline: true,
    onChange: handleSizeChange,
    disabled: pageSizeInputDisabled || disabled,
    value: pageSize
  }, pageSizes.map((sizeObj) => import_react161.default.createElement(SelectItem, {
    key: sizeObj.value,
    value: sizeObj.value,
    text: String(sizeObj.text)
  }))), import_react161.default.createElement("span", {
    className: `${prefix}--pagination__text ${prefix}--pagination__items-count`
  }, pagesUnknown || !totalItems ? totalItems === 0 ? itemRangeText(0, 0, 0) : itemText(pageSize * (page - 1) + 1, page * pageSize) : itemRangeText(Math.min(pageSize * (page - 1) + 1, totalItems), Math.min(page * pageSize, totalItems), totalItems))), import_react161.default.createElement("div", {
    className: `${prefix}--pagination__right`
  }, pagesUnknown ? import_react161.default.createElement("span", {
    className: `${prefix}--pagination__text ${prefix}--pagination__page-text ${prefix}--pagination__unknown-pages-text`
  }, pageText(page)) : import_react161.default.createElement(import_react161.default.Fragment, null, import_react161.default.createElement(Select, {
    id: `${prefix}-pagination-select-${inputId}-right`,
    className: `${prefix}--select__page-number`,
    labelText: `Page of ${totalPages} pages`,
    inline: true,
    hideLabel: true,
    onChange: handlePageInputChange,
    value: page,
    disabled: pageInputDisabled || disabled
  }, selectItems), import_react161.default.createElement("span", {
    className: `${prefix}--pagination__text`
  }, pageRangeText(page, totalPages))), import_react161.default.createElement("div", {
    className: `${prefix}--pagination__control-buttons`
  }, import_react161.default.createElement(IconButton, {
    align: "top",
    disabled: backButtonDisabled,
    kind: "ghost",
    className: backButtonClasses,
    label: backwardText,
    "aria-label": backwardText,
    onClick: decrementPage,
    ref: backBtnRef
  }, _CaretLeft2 || (_CaretLeft2 = import_react161.default.createElement(CaretLeft, null))), import_react161.default.createElement(IconButton, {
    align: "top-end",
    disabled: forwardButtonDisabled || isLastPage,
    kind: "ghost",
    className: forwardButtonClasses,
    label: forwardText,
    "aria-label": forwardText,
    onClick: incrementPage,
    ref: forwardBtnRef
  }, _CaretRight2 || (_CaretRight2 = import_react161.default.createElement(CaretRight, null))))));
});
Pagination.propTypes = {
  /**
   * The description for the backward icon.
   */
  backwardText: import_prop_types123.default.string,
  /**
   * The CSS class names.
   */
  className: import_prop_types123.default.string,
  /**
   * `true` if the backward/forward buttons, as well as the page select elements,  should be disabled.
   */
  disabled: import_prop_types123.default.bool,
  /**
   * The description for the forward icon.
   */
  forwardText: import_prop_types123.default.string,
  /**
   * The unique ID of this component instance.
   */
  id: import_prop_types123.default.oneOfType([import_prop_types123.default.string, import_prop_types123.default.number]),
  // TODO: remove when v9 is deprecated
  /**
   * `true` if the current page should be the last page.
   */
  isLastPage: import_prop_types123.default.bool,
  /**
   * The function returning a translatable text showing where the current page is,
   * in a manner of the range of items.
   */
  itemRangeText: import_prop_types123.default.func,
  /**
   * A variant of `itemRangeText`, used if the total number of items is unknown.
   */
  itemText: import_prop_types123.default.func,
  /**
   * The translatable text indicating the number of items per page.
   */
  itemsPerPageText: import_prop_types123.default.string,
  /**
   * The callback function called when the current page changes.
   */
  onChange: import_prop_types123.default.func,
  /**
   * The current page.
   */
  page: import_prop_types123.default.number,
  /**
   * `true` if the select box to change the page should be disabled.
   */
  pageInputDisabled: import_prop_types123.default.bool,
  pageNumberText: import_prop_types123.default.string,
  /**
   * A function returning PII showing where the current page is.
   */
  pageRangeText: import_prop_types123.default.func,
  /**
   * The number dictating how many items a page contains.
   */
  pageSize: import_prop_types123.default.number,
  /**
   * `true` if the select box to change the items per page should be disabled.
   */
  pageSizeInputDisabled: import_prop_types123.default.bool,
  /**
   * The choices for `pageSize`.
   */
  pageSizes: import_prop_types123.default.oneOfType([import_prop_types123.default.arrayOf(import_prop_types123.default.number.isRequired), import_prop_types123.default.arrayOf(import_prop_types123.default.shape({
    text: import_prop_types123.default.string.isRequired,
    value: import_prop_types123.default.number.isRequired
  }).isRequired)]).isRequired,
  /**
   * The translatable text showing the current page.
   */
  pageText: import_prop_types123.default.func,
  /**
   * `true` if the total number of items is unknown.
   */
  pagesUnknown: import_prop_types123.default.bool,
  /**
   * Specify the size of the Pagination.
   */
  size: import_prop_types123.default.oneOf(["sm", "md", "lg"]),
  /**
   * The total number of items.
   */
  totalItems: import_prop_types123.default.number
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Pagination/Pagination.Skeleton.js
var import_prop_types124 = __toESM(require_prop_types());
var import_react162 = __toESM(require_react());
var import_classnames103 = __toESM(require_classnames());
var _SkeletonText5;
var _SkeletonText22;
var _SkeletonText32;
var _SkeletonText42;
function PaginationSkeleton(_ref) {
  let {
    className,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  return import_react162.default.createElement("div", _extends({
    className: (0, import_classnames103.default)(`${prefix}--pagination`, `${prefix}--skeleton`, className)
  }, rest3), import_react162.default.createElement("div", {
    className: `${prefix}--pagination__left`
  }, _SkeletonText5 || (_SkeletonText5 = import_react162.default.createElement(SkeletonText, {
    width: "70px"
  })), _SkeletonText22 || (_SkeletonText22 = import_react162.default.createElement(SkeletonText, {
    width: "35px"
  })), _SkeletonText32 || (_SkeletonText32 = import_react162.default.createElement(SkeletonText, {
    width: "105px"
  }))), import_react162.default.createElement("div", {
    className: `${prefix}--pagination__right ${prefix}--pagination--inline`
  }, _SkeletonText42 || (_SkeletonText42 = import_react162.default.createElement(SkeletonText, {
    width: "70px"
  }))));
}
PaginationSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types124.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/PaginationNav/PaginationNav.js
var import_prop_types125 = __toESM(require_prop_types());
var import_react164 = __toESM(require_react());
var import_classnames104 = __toESM(require_classnames());

// ../node_modules/.pnpm/@carbon+layout@11.29.0/node_modules/@carbon/layout/es/index.js
var baseFontSize = 16;
function rem(px) {
  return "".concat(px / baseFontSize, "rem");
}
var breakpoints = {
  sm: {
    width: rem(320),
    columns: 4,
    margin: "0"
  },
  md: {
    width: rem(672),
    columns: 8,
    margin: rem(16)
  },
  lg: {
    width: rem(1056),
    columns: 16,
    margin: rem(16)
  },
  xlg: {
    width: rem(1312),
    columns: 16,
    margin: rem(16)
  },
  max: {
    width: rem(1584),
    columns: 16,
    margin: rem(24)
  }
};
var miniUnit = 8;
function miniUnits(count2) {
  return rem(miniUnit * count2);
}
var spacing01 = miniUnits(0.25);
var spacing02 = miniUnits(0.5);
var spacing03 = miniUnits(1);
var spacing04 = miniUnits(1.5);
var spacing05 = miniUnits(2);
var spacing06 = miniUnits(3);
var spacing07 = miniUnits(4);
var spacing08 = miniUnits(5);
var spacing09 = miniUnits(6);
var spacing10 = miniUnits(8);
var spacing11 = miniUnits(10);
var spacing12 = miniUnits(12);
var spacing13 = miniUnits(20);
var spacing2 = [spacing01, spacing02, spacing03, spacing04, spacing05, spacing06, spacing07, spacing08, spacing09, spacing10, spacing11, spacing12, spacing13];
var layout01 = miniUnits(2);
var layout02 = miniUnits(3);
var layout03 = miniUnits(4);
var layout04 = miniUnits(6);
var layout05 = miniUnits(8);
var layout06 = miniUnits(12);
var layout07 = miniUnits(20);
var container01 = miniUnits(3);
var container02 = miniUnits(4);
var container03 = miniUnits(5);
var container04 = miniUnits(6);
var container05 = miniUnits(8);
var sizeXSmall = rem(24);
var sizeSmall = rem(32);
var sizeMedium = rem(40);
var sizeLarge = rem(48);
var sizeXLarge = rem(64);
var size2XLarge = rem(80);

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/internal/useMatchMedia.js
var import_react163 = __toESM(require_react());
function useMatchMedia(mediaQueryString) {
  const [matches4, setMatches] = (0, import_react163.useState)(() => {
    if (canUseDOM) {
      const mediaQueryList = window.matchMedia(mediaQueryString);
      return mediaQueryList.matches;
    }
    return false;
  });
  (0, import_react163.useEffect)(() => {
    function listener(event) {
      setMatches(event.matches);
    }
    const mediaQueryList = window.matchMedia(mediaQueryString);
    if (mediaQueryList.addEventListener) {
      mediaQueryList.addEventListener("change", listener);
    } else {
      mediaQueryList.addListener(listener);
    }
    setMatches(mediaQueryList.matches);
    return () => {
      if (mediaQueryList.addEventListener) {
        mediaQueryList.removeEventListener("change", listener);
      } else {
        mediaQueryList.removeListener(listener);
      }
    };
  }, [mediaQueryString]);
  return matches4;
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/PaginationNav/PaginationNav.js
var _CaretRight3;
var _CaretLeft3;
var _option;
var translationIds4 = {
  "carbon.pagination-nav.next": "Next",
  "carbon.pagination-nav.previous": "Previous",
  "carbon.pagination-nav.item": "Page",
  "carbon.pagination-nav.active": "Active",
  "carbon.pagination-nav.of": "of"
};
function translateWithId5(messageId) {
  return translationIds4[messageId];
}
function usePrevious(value) {
  const ref = (0, import_react164.useRef)(null);
  (0, import_react164.useEffect)(() => {
    ref.current = value;
  });
  return ref.current;
}
function calculateCuts(page, totalItems, itemsDisplayedOnPage) {
  let splitPoint = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  if (itemsDisplayedOnPage >= totalItems) {
    return {
      front: 0,
      back: 0
    };
  }
  const split = splitPoint || Math.ceil(itemsDisplayedOnPage / 2) - 1;
  let frontHidden = page + 1 - split;
  let backHidden = totalItems - page - (itemsDisplayedOnPage - split) + 1;
  if (frontHidden <= 1) {
    backHidden -= frontHidden <= 0 ? Math.abs(frontHidden) + 1 : 0;
    frontHidden = 0;
  }
  if (backHidden <= 1) {
    frontHidden -= backHidden <= 0 ? Math.abs(backHidden) + 1 : 0;
    backHidden = 0;
  }
  return {
    front: frontHidden,
    back: backHidden
  };
}
function DirectionButton(_ref) {
  let {
    direction,
    label,
    disabled,
    onClick
  } = _ref;
  const prefix = usePrefix();
  return import_react164.default.createElement("li", {
    className: `${prefix}--pagination-nav__list-item`
  }, import_react164.default.createElement(IconButton, {
    align: "bottom",
    disabled,
    kind: "ghost",
    label,
    onClick
  }, direction === "forward" ? _CaretRight3 || (_CaretRight3 = import_react164.default.createElement(CaretRight, null)) : _CaretLeft3 || (_CaretLeft3 = import_react164.default.createElement(CaretLeft, null))));
}
function PaginationItem(_ref2) {
  let {
    page,
    isActive,
    onClick,
    translateWithId: t2 = translateWithId5
  } = _ref2;
  const prefix = usePrefix();
  const itemLabel = t2("carbon.pagination-nav.item");
  return import_react164.default.createElement("li", {
    className: `${prefix}--pagination-nav__list-item`
  }, import_react164.default.createElement("button", {
    type: "button",
    className: (0, import_classnames104.default)(`${prefix}--pagination-nav__page`, {
      [`${prefix}--pagination-nav__page--active`]: isActive
    }),
    onClick,
    "data-page": page,
    "aria-current": isActive ? "page" : void 0
  }, import_react164.default.createElement("span", {
    className: `${prefix}--pagination-nav__accessibility-label`
  }, isActive ? `${t2("carbon.pagination-nav.active")}, ${itemLabel}` : itemLabel), page));
}
function PaginationOverflow(_ref3) {
  let {
    fromIndex = NaN,
    count: count2 = NaN,
    onSelect,
    // eslint-disable-next-line react/prop-types
    disableOverflow,
    translateWithId: t2 = translateWithId5
  } = _ref3;
  const prefix = usePrefix();
  if (disableOverflow === true && count2 > 1) {
    return import_react164.default.createElement("li", {
      className: `${prefix}--pagination-nav__list-item`
    }, import_react164.default.createElement("div", {
      className: `${prefix}--pagination-nav__select`
    }, import_react164.default.createElement("select", {
      className: `${prefix}--pagination-nav__page ${prefix}--pagination-nav__page--select`,
      "aria-label": `Select ${t2("carbon.pagination-nav.item")} number`,
      disabled: true
    }), import_react164.default.createElement("div", {
      className: `${prefix}--pagination-nav__select-icon-wrapper`
    }, import_react164.default.createElement(OverflowMenuHorizontal, {
      className: `${prefix}--pagination-nav__select-icon`
    }))));
  }
  if (count2 > 1) {
    return import_react164.default.createElement("li", {
      className: `${prefix}--pagination-nav__list-item`
    }, import_react164.default.createElement("div", {
      className: `${prefix}--pagination-nav__select`
    }, import_react164.default.createElement("select", {
      className: `${prefix}--pagination-nav__page ${prefix}--pagination-nav__page--select`,
      "aria-label": `Select ${t2("carbon.pagination-nav.item")} number`,
      onChange: (e2) => {
        const index4 = Number(e2.target.value);
        onSelect == null ? void 0 : onSelect(index4);
      }
    }, _option || (_option = import_react164.default.createElement("option", {
      value: "",
      hidden: true
    })), [...Array(count2)].map((e2, i) => import_react164.default.createElement("option", {
      value: (fromIndex + i).toString(),
      "data-page": fromIndex + i + 1,
      key: `overflow-${fromIndex + i}`
    }, fromIndex + i + 1))), import_react164.default.createElement("div", {
      className: `${prefix}--pagination-nav__select-icon-wrapper`
    }, import_react164.default.createElement(OverflowMenuHorizontal, {
      className: `${prefix}--pagination-nav__select-icon`
    }))));
  }
  if (count2 === 1) {
    return import_react164.default.createElement(PaginationItem, {
      page: fromIndex + 1,
      translateWithId: t2,
      onClick: () => {
        onSelect == null ? void 0 : onSelect(fromIndex);
      }
    });
  }
  return null;
}
var PaginationNav = import_react164.default.forwardRef(function PaginationNav2(_ref4, ref) {
  let {
    className,
    onChange = () => {
    },
    totalItems = NaN,
    disableOverflow,
    itemsShown = 10,
    page = 0,
    loop = false,
    size: size6 = "lg",
    translateWithId: t2 = translateWithId5,
    ...rest3
  } = _ref4;
  const smMediaQuery2 = `(max-width: ${breakpoints.sm.width})`;
  const isSm = useMatchMedia(smMediaQuery2);
  let numberOfPages;
  switch (size6) {
    case "md":
      numberOfPages = itemsShown === 4 ? itemsShown : 5;
      break;
    case "sm":
      numberOfPages = Math.max(4, Math.min(itemsShown, 7));
      break;
    default:
      numberOfPages = 4;
      break;
  }
  const [currentPage, setCurrentPage] = (0, import_react164.useState)(page);
  const [itemsDisplayedOnPage, setItemsDisplayedOnPage] = (0, import_react164.useState)(itemsShown >= 4 && !isSm ? itemsShown : numberOfPages);
  const [cuts, setCuts] = (0, import_react164.useState)(calculateCuts(currentPage, totalItems, itemsDisplayedOnPage));
  const prevPage = usePrevious(currentPage);
  const prefix = usePrefix();
  const [isOverflowDisabled, setIsOverFlowDisabled] = (0, import_react164.useState)(disableOverflow);
  function jumpToItem(index4) {
    if (index4 >= 0 && index4 < totalItems) {
      setCurrentPage(index4);
      onChange(index4);
    }
  }
  function jumpToNext() {
    const nextIndex = currentPage + 1;
    if (nextIndex >= totalItems) {
      if (loop) {
        jumpToItem(0);
      }
    } else {
      jumpToItem(nextIndex);
    }
  }
  function jumpToPrevious() {
    const previousIndex = currentPage - 1;
    if (previousIndex < 0) {
      if (loop) {
        jumpToItem(totalItems - 1);
      }
    } else {
      jumpToItem(previousIndex);
    }
  }
  function pageWouldBeHidden(page2) {
    const startOffset2 = itemsDisplayedOnPage <= 4 && page2 > 1 ? 0 : 1;
    const wouldBeHiddenInFront = page2 >= startOffset2 && page2 <= cuts.front || page2 === 0;
    const wouldBeHiddenInBack = page2 >= totalItems - cuts.back - 1 && page2 <= totalItems - 2;
    return wouldBeHiddenInFront || wouldBeHiddenInBack;
  }
  (0, import_react164.useEffect)(() => {
    setCurrentPage(page);
  }, [page]);
  (0, import_react164.useEffect)(() => {
    const itemsToBeShown = itemsShown >= 4 && !isSm ? itemsShown : numberOfPages;
    setItemsDisplayedOnPage(Math.max(itemsToBeShown, 4));
    setCuts(calculateCuts(currentPage, totalItems, Math.max(itemsToBeShown, 4)));
  }, [totalItems, itemsShown, isSm, size6]);
  (0, import_react164.useEffect)(() => {
    if (pageWouldBeHidden(currentPage)) {
      const delta = currentPage - (prevPage || 0);
      if (delta > 0) {
        const splitPoint = itemsDisplayedOnPage - 3;
        setCuts(calculateCuts(currentPage, totalItems, itemsDisplayedOnPage, splitPoint));
      } else {
        const splitPoint = itemsDisplayedOnPage > 4 ? 2 : 1;
        setCuts(calculateCuts(currentPage, totalItems, itemsDisplayedOnPage, splitPoint));
      }
    }
  }, [currentPage]);
  (0, import_react164.useEffect)(() => {
    setIsOverFlowDisabled(disableOverflow);
  }, [disableOverflow]);
  const classNames = (0, import_classnames104.default)(`${prefix}--pagination-nav`, className, {
    [`${prefix}--layout--size-${size6}`]: size6
  });
  const backwardButtonDisabled = !loop && currentPage === 0;
  const forwardButtonDisabled = !loop && currentPage === totalItems - 1;
  const startOffset = itemsDisplayedOnPage <= 4 && currentPage > 1 ? 0 : 1;
  return import_react164.default.createElement("nav", _extends({
    className: classNames,
    ref
  }, rest3, {
    "aria-label": "pagination"
  }), import_react164.default.createElement(
    "ul",
    {
      className: `${prefix}--pagination-nav__list`
    },
    import_react164.default.createElement(DirectionButton, {
      direction: "backward",
      "aria-label": t2("carbon.pagination-nav.previous"),
      label: t2("carbon.pagination-nav.previous"),
      disabled: backwardButtonDisabled,
      onClick: jumpToPrevious
    }),
    // render first item if at least 5 items can be displayed or
    // 4 items can be displayed and the current page is either 0 or 1
    (itemsDisplayedOnPage >= 5 || itemsDisplayedOnPage <= 4 && currentPage <= 1) && import_react164.default.createElement(PaginationItem, {
      page: 1,
      translateWithId: t2,
      isActive: currentPage === 0,
      onClick: () => {
        jumpToItem(0);
      }
    }),
    import_react164.default.createElement(PaginationOverflow, {
      fromIndex: startOffset,
      count: cuts.front,
      onSelect: jumpToItem,
      disableOverflow: isOverflowDisabled
    }),
    // render items between overflows
    [...Array(totalItems)].map((e2, i) => i).slice(startOffset + cuts.front, (1 + cuts.back) * -1).map((item) => import_react164.default.createElement(PaginationItem, {
      key: `item-${item}`,
      page: item + 1,
      translateWithId: t2,
      isActive: currentPage === item,
      onClick: () => {
        jumpToItem(item);
      }
    })),
    import_react164.default.createElement(PaginationOverflow, {
      fromIndex: totalItems - cuts.back - 1,
      count: cuts.back,
      onSelect: jumpToItem,
      disableOverflow: isOverflowDisabled
    }),
    // render last item unless there is only one in total
    totalItems > 1 && import_react164.default.createElement(PaginationItem, {
      page: totalItems,
      translateWithId: t2,
      isActive: currentPage === totalItems - 1,
      onClick: () => {
        jumpToItem(totalItems - 1);
      }
    }),
    import_react164.default.createElement(DirectionButton, {
      direction: "forward",
      "aria-label": t2("carbon.pagination-nav.next"),
      label: t2("carbon.pagination-nav.next"),
      disabled: forwardButtonDisabled,
      onClick: jumpToNext
    })
  ), import_react164.default.createElement("div", {
    "aria-live": "polite",
    "aria-atomic": "true",
    className: `${prefix}--pagination-nav__accessibility-label`
  }, `${t2("carbon.pagination-nav.item")} ${currentPage + 1} ${t2("carbon.pagination-nav.of")} ${totalItems}`));
});
DirectionButton.propTypes = {
  /**
   * The direction this button represents ("forward" or "backward").
   */
  direction: import_prop_types125.default.oneOf(["forward", "backward"]),
  /**
   * Whether or not the button should be disabled.
   */
  disabled: import_prop_types125.default.bool,
  /**
   * The label shown in the button's tooltip.
   */
  label: import_prop_types125.default.string,
  /**
   * The callback function called when the button is clicked.
   */
  onClick: import_prop_types125.default.func
};
PaginationItem.propTypes = {
  /**
   * Whether or not this is the currently active page.
   */
  isActive: import_prop_types125.default.bool,
  /**
   * The callback function called when the item is clicked.
   */
  onClick: import_prop_types125.default.func,
  /**
   * The page number this item represents.
   */
  page: import_prop_types125.default.number,
  /**
   * Specify a custom translation function that takes in a message identifier
   * and returns the localized string for the message
   */
  translateWithId: import_prop_types125.default.func
};
PaginationOverflow.propTypes = {
  /**
   * How many items to display in this overflow.
   */
  count: import_prop_types125.default.number,
  /**
   * From which index on this overflow should start displaying pages.
   */
  fromIndex: import_prop_types125.default.number,
  /**
   * The callback function called when the user selects a page from the overflow.
   */
  onSelect: import_prop_types125.default.func,
  /**
   * Specify a custom translation function that takes in a message identifier
   * and returns the localized string for the message
   */
  translateWithId: import_prop_types125.default.func
};
PaginationNav.displayName = "PaginationNav";
PaginationNav.propTypes = {
  /**
   * Additional CSS class names.
   */
  className: import_prop_types125.default.string,
  /**
   * If true, the '...' pagination overflow will not render page links between the first and last rendered buttons.
   * Set this to true if you are having performance problems with large data sets.
   */
  disableOverflow: import_prop_types125.default.bool,
  // eslint-disable-line react/prop-types
  /**
   * The number of items to be shown (minimum of 4 unless props.items < 4).
   */
  itemsShown: import_prop_types125.default.number,
  /**
   * Whether user should be able to loop through the items when reaching first / last.
   */
  loop: import_prop_types125.default.bool,
  /**
   * The callback function called when the current page changes.
   */
  onChange: import_prop_types125.default.func,
  /**
   * The index of current page.
   */
  page: import_prop_types125.default.number,
  /**
   * Specify the size of the PaginationNav.
   */
  size: import_prop_types125.default.oneOf(["sm", "md", "lg"]),
  /**
   * The total number of items.
   */
  totalItems: import_prop_types125.default.number,
  /**
   * Specify a custom translation function that takes in a message identifier
   * and returns the localized string for the message
   */
  translateWithId: import_prop_types125.default.func
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/TextInput/ControlledPasswordInput.js
var import_react165 = __toESM(require_react());
var import_classnames105 = __toESM(require_classnames());
var import_prop_types126 = __toESM(require_prop_types());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/TextInput/util.js
var invalidProps = (invalidId) => ({
  "data-invalid": true,
  "aria-invalid": true,
  "aria-describedby": invalidId
});
var warnProps = (warnId) => ({
  "aria-describedby": warnId
});
var helperProps = (helperId) => ({
  "aria-describedby": helperId
});
var textInputProps = (_ref) => {
  let {
    sharedTextInputProps,
    invalid,
    invalidId,
    warn: warn2,
    warnId,
    hasHelper,
    helperId
  } = _ref;
  return {
    ...sharedTextInputProps,
    ...invalid ? invalidProps(invalidId) : {},
    ...warn2 ? warnProps(warnId) : {},
    ...hasHelper ? helperProps(helperId) : {}
  };
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/TextInput/ControlledPasswordInput.js
var didWarnAboutDeprecation7 = false;
var ControlledPasswordInput = import_react165.default.forwardRef(function ControlledPasswordInput2(_ref, ref) {
  let {
    labelText,
    className,
    id,
    placeholder,
    onChange = noopFn,
    onClick = noopFn,
    disabled = false,
    hideLabel,
    invalid = false,
    invalidText = "",
    helperText = "",
    light,
    // eslint-disable-next-line react/prop-types
    type = "password",
    // eslint-disable-next-line react/prop-types
    togglePasswordVisibility,
    tooltipPosition = "bottom",
    tooltipAlignment = "center",
    hidePasswordLabel = "Hide password",
    showPasswordLabel = "Show password",
    size: size6 = void 0,
    ...other
  } = _ref;
  const prefix = usePrefix();
  const controlledPasswordInstanceId = useId();
  if (true) {
    true ? warning(didWarnAboutDeprecation7, "`<TextInput.ControlledPasswordInput>` has been deprecated in favor of `<TextInput.PasswordInput />` and will be removed in the next major release of `carbon-components-react`") : void 0;
    didWarnAboutDeprecation7 = true;
  }
  const errorId = id + "-error-msg";
  const textInputClasses = (0, import_classnames105.default)(`${prefix}--text-input`, `${prefix}--password-input`, className, {
    [`${prefix}--text-input--light`]: light,
    [`${prefix}--text-input--invalid`]: invalid,
    [`${prefix}--text-input--${size6}`]: size6
  });
  const sharedTextInputProps = {
    id,
    onChange: (evt) => {
      if (!disabled) {
        onChange == null ? void 0 : onChange(evt);
      }
    },
    onClick: (evt) => {
      if (!disabled) {
        onClick == null ? void 0 : onClick(evt);
      }
    },
    placeholder,
    type,
    ref,
    className: textInputClasses,
    ...other
  };
  const labelClasses = (0, import_classnames105.default)(`${prefix}--label`, {
    [`${prefix}--visually-hidden`]: hideLabel,
    [`${prefix}--label--disabled`]: disabled
  });
  const helperTextClasses = (0, import_classnames105.default)(`${prefix}--form__helper-text`, {
    [`${prefix}--form__helper-text--disabled`]: disabled
  });
  const label = labelText ? import_react165.default.createElement("label", {
    htmlFor: id,
    className: labelClasses
  }, labelText) : null;
  const error2 = invalid ? import_react165.default.createElement("div", {
    className: `${prefix}--form-requirement`,
    id: errorId
  }, invalidText) : null;
  const passwordIsVisible = type === "text";
  const passwordVisibilityIcon = passwordIsVisible ? import_react165.default.createElement(ViewOff, {
    className: `${prefix}--icon-visibility-off`
  }) : import_react165.default.createElement(View, {
    className: `${prefix}--icon-visibility-on`
  });
  const passwordVisibilityToggleClasses = (0, import_classnames105.default)(`${prefix}--text-input--password__visibility__toggle`, `${prefix}--btn`, `${prefix}--btn--icon-only`, `${prefix}--tooltip__trigger`, `${prefix}--tooltip--a11y`, {
    [`${prefix}--tooltip--${tooltipPosition}`]: tooltipPosition,
    [`${prefix}--tooltip--align-${tooltipAlignment}`]: tooltipAlignment
  });
  const helperId = !helperText ? void 0 : `controlled-password-helper-text-${controlledPasswordInstanceId}`;
  const input = import_react165.default.createElement(import_react165.default.Fragment, null, import_react165.default.createElement("input", _extends({}, textInputProps({
    invalid,
    sharedTextInputProps,
    invalidId: errorId,
    hasHelper: !error2 && helperText ? true : false,
    helperId
  }), {
    "data-toggle-password-visibility": type === "password"
  })), import_react165.default.createElement("button", {
    type: "button",
    className: passwordVisibilityToggleClasses,
    onClick: togglePasswordVisibility
  }, import_react165.default.createElement("span", {
    className: `${prefix}--assistive-text`
  }, passwordIsVisible ? hidePasswordLabel : showPasswordLabel), passwordVisibilityIcon));
  const helper = helperText ? import_react165.default.createElement("div", {
    id: helperId,
    className: helperTextClasses
  }, helperText) : null;
  return import_react165.default.createElement("div", {
    className: `${prefix}--form-item ${prefix}--text-input-wrapper ${prefix}--password-input-wrapper`
  }, label, import_react165.default.createElement("div", {
    className: `${prefix}--text-input__field-wrapper`,
    "data-invalid": invalid || null
  }, invalid && import_react165.default.createElement(WarningFilled, {
    className: `${prefix}--text-input__invalid-icon`
  }), input), error2 ? error2 : helper);
});
ControlledPasswordInput.displayName = "ControlledPasswordInput";
ControlledPasswordInput.propTypes = {
  /**
   * Provide a custom className that is applied directly to the underlying
   * `<input>` node
   */
  className: import_prop_types126.default.string,
  /**
   * Optionally provide the default value of the `<input>`
   */
  defaultValue: import_prop_types126.default.oneOfType([import_prop_types126.default.string, import_prop_types126.default.number]),
  /**
   * Specify whether the control is disabled
   */
  disabled: import_prop_types126.default.bool,
  /**
   * Provide text that is used alongside the control label for additional help
   */
  helperText: import_prop_types126.default.node,
  /**
   * Specify whether or not the underlying label is visually hidden
   */
  hideLabel: import_prop_types126.default.bool,
  /**
   * "Hide password" tooltip text on password visibility toggle
   */
  hidePasswordLabel: import_prop_types126.default.string,
  /**
   * Provide a unique identifier for the input field
   */
  id: import_prop_types126.default.string.isRequired,
  /**
   * Specify whether the control is currently invalid
   */
  invalid: import_prop_types126.default.bool,
  /**
   * Provide the text that is displayed when the control is in an invalid state
   */
  invalidText: import_prop_types126.default.node,
  /**
   * Provide the text that will be read by a screen reader when visiting this
   * control
   */
  labelText: import_prop_types126.default.node.isRequired,
  /**
   * `true` to use the light version. For use on $ui-01 backgrounds only.
   * Don't use this to make tile background color same as container background color.
   */
  light: deprecate(import_prop_types126.default.bool, "The `light` prop for `ControlledPasswordInput` has been deprecated in favor of the new `Layer` component. It will be removed in the next major release."),
  /**
   * Optionally provide an `onChange` handler that is called whenever `<input>`
   * is updated
   */
  onChange: import_prop_types126.default.func,
  /**
   * Optionally provide an `onClick` handler that is called whenever the
   * `<input>` is clicked
   */
  onClick: import_prop_types126.default.func,
  /**
   * Specify the placeholder attribute for the `<input>`
   */
  placeholder: import_prop_types126.default.string,
  /**
   * "Show password" tooltip text on password visibility toggle
   */
  showPasswordLabel: import_prop_types126.default.string,
  /**
   * Specify the size of the Text Input.
   */
  size: import_prop_types126.default.oneOf(["sm", "md", "lg"]),
  /**
   * Specify the alignment of the tooltip to the icon-only button.
   * Can be one of: start, center, or end.
   */
  tooltipAlignment: import_prop_types126.default.oneOf(["start", "center", "end"]),
  /**
   * Specify the direction of the tooltip for icon-only buttons.
   * Can be either top, right, bottom, or left.
   */
  tooltipPosition: import_prop_types126.default.oneOf(["top", "right", "bottom", "left"]),
  /**
   * Provide the current value of the `<input>`
   */
  value: import_prop_types126.default.oneOfType([import_prop_types126.default.string, import_prop_types126.default.number])
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/TextInput/PasswordInput.js
var import_react166 = __toESM(require_react());
var import_classnames106 = __toESM(require_classnames());
var import_prop_types127 = __toESM(require_prop_types());
var PasswordInput = import_react166.default.forwardRef(function PasswordInput2(_ref, ref) {
  let {
    className,
    disabled = false,
    helperText,
    hideLabel,
    hidePasswordLabel = "Hide password",
    id,
    inline: inline5,
    invalid = false,
    invalidText,
    labelText,
    light,
    onChange = () => {
    },
    onClick = () => {
    },
    onTogglePasswordVisibility,
    placeholder,
    readOnly,
    size: size6 = "md",
    showPasswordLabel = "Show password",
    tooltipPosition = "bottom",
    tooltipAlignment = "end",
    type = "password",
    warn: warn2 = false,
    warnText,
    ...rest3
  } = _ref;
  const [inputType, setInputType] = (0, import_react166.useState)(type);
  const prefix = usePrefix();
  const normalizedProps = useNormalizedInputProps({
    id,
    invalid,
    invalidText,
    warn: warn2,
    warnText,
    readOnly,
    disabled
  });
  const {
    isFluid
  } = (0, import_react166.useContext)(FormContext);
  const handleTogglePasswordVisibility = (event) => {
    setInputType(inputType === "password" ? "text" : "password");
    onTogglePasswordVisibility && onTogglePasswordVisibility(event);
  };
  const textInputClasses = (0, import_classnames106.default)(`${prefix}--text-input`, `${prefix}--password-input`, className, {
    [`${prefix}--text-input--light`]: light,
    [`${prefix}--text-input--invalid`]: normalizedProps.invalid,
    [`${prefix}--text-input--warning`]: normalizedProps.warn,
    [`${prefix}--text-input--${size6}`]: size6,
    // TODO: V12 - Remove this class
    [`${prefix}--layout--size-${size6}`]: size6
  });
  const sharedTextInputProps = {
    id,
    onChange: (evt) => {
      if (!disabled) {
        onChange(evt);
      }
    },
    onClick: (evt) => {
      if (!disabled) {
        onClick(evt);
      }
    },
    placeholder,
    type: inputType,
    className: textInputClasses,
    readOnly,
    ref,
    ...rest3
  };
  const inputWrapperClasses = (0, import_classnames106.default)(`${prefix}--form-item`, `${prefix}--text-input-wrapper`, `${prefix}--password-input-wrapper`, {
    [`${prefix}--text-input-wrapper--readonly`]: readOnly,
    [`${prefix}--text-input-wrapper--light`]: light,
    [`${prefix}--text-input-wrapper--inline`]: inline5,
    [`${prefix}--text-input--fluid`]: isFluid
  });
  const labelClasses = (0, import_classnames106.default)(`${prefix}--label`, {
    [`${prefix}--visually-hidden`]: hideLabel,
    [`${prefix}--label--disabled`]: disabled,
    [`${prefix}--label--inline`]: inline5,
    [`${prefix}--label--inline--${size6}`]: inline5 && !!size6
  });
  const helperTextClasses = (0, import_classnames106.default)(`${prefix}--form__helper-text`, {
    [`${prefix}--form__helper-text--disabled`]: disabled,
    [`${prefix}--form__helper-text--inline`]: inline5
  });
  const fieldOuterWrapperClasses = (0, import_classnames106.default)(`${prefix}--text-input__field-outer-wrapper`, {
    [`${prefix}--text-input__field-outer-wrapper--inline`]: inline5
  });
  const fieldWrapperClasses = (0, import_classnames106.default)(`${prefix}--text-input__field-wrapper`, {
    [`${prefix}--text-input__field-wrapper--warning`]: normalizedProps.warn
  });
  const iconClasses = (0, import_classnames106.default)({
    [`${prefix}--text-input__invalid-icon`]: normalizedProps.invalid || normalizedProps.warn,
    [`${prefix}--text-input__invalid-icon--warning`]: normalizedProps.warn
  });
  const label = labelText ? import_react166.default.createElement("label", {
    htmlFor: id,
    className: labelClasses
  }, labelText) : null;
  const helper = helperText ? import_react166.default.createElement("div", {
    id: normalizedProps.helperId,
    className: helperTextClasses
  }, helperText) : null;
  const passwordIsVisible = inputType === "text";
  const passwordVisibilityIcon = passwordIsVisible ? import_react166.default.createElement(ViewOff, {
    className: `${prefix}--icon-visibility-off`
  }) : import_react166.default.createElement(View, {
    className: `${prefix}--icon-visibility-on`
  });
  const passwordVisibilityToggleClasses = (0, import_classnames106.default)(`${prefix}--text-input--password__visibility__toggle`, `${prefix}--btn`, `${prefix}--tooltip__trigger`, `${prefix}--tooltip--a11y`, {
    [`${prefix}--tooltip--${tooltipPosition}`]: tooltipPosition,
    [`${prefix}--tooltip--align-${tooltipAlignment}`]: tooltipAlignment
  });
  let align = void 0;
  if (tooltipPosition === "top" || tooltipPosition === "bottom") {
    if (tooltipAlignment === "center") {
      align = tooltipPosition;
    }
    if (tooltipAlignment === "end") {
      align = `${tooltipPosition}-end`;
    }
    if (tooltipAlignment === "start") {
      align = `${tooltipPosition}-start`;
    }
  }
  if (tooltipPosition === "right" || tooltipPosition === "left") {
    align = tooltipPosition;
  }
  if (!hidePasswordLabel || hidePasswordLabel.trim() === "") {
    console.warn('Warning: The "hidePasswordLabel" should not be blank.');
  } else if (!showPasswordLabel || showPasswordLabel.trim() === "") {
    console.warn('Warning: The "showPasswordLabel" should not be blank.');
  }
  const input = import_react166.default.createElement(import_react166.default.Fragment, null, import_react166.default.createElement("input", _extends({}, textInputProps({
    sharedTextInputProps,
    invalid: normalizedProps.invalid,
    invalidId: normalizedProps.invalidId,
    warn: normalizedProps.warn,
    warnId: normalizedProps.warnId,
    hasHelper: Boolean(helperText && !isFluid && (inline5 || !inline5 && !normalizedProps.validation)),
    helperId: normalizedProps.helperId
  }), {
    disabled,
    "data-toggle-password-visibility": inputType === "password"
  })), isFluid && import_react166.default.createElement("hr", {
    className: `${prefix}--text-input__divider`
  }), import_react166.default.createElement(Tooltip, {
    align,
    className: `${prefix}--toggle-password-tooltip`,
    label: passwordIsVisible ? hidePasswordLabel : showPasswordLabel
  }, import_react166.default.createElement("button", {
    type: "button",
    className: passwordVisibilityToggleClasses,
    disabled: disabled || readOnly,
    onClick: handleTogglePasswordVisibility
  }, passwordVisibilityIcon)));
  (0, import_react166.useEffect)(() => {
    setInputType(type);
  }, [type]);
  const Icon = normalizedProps.icon;
  return import_react166.default.createElement("div", {
    className: inputWrapperClasses
  }, !inline5 ? label : import_react166.default.createElement("div", {
    className: `${prefix}--text-input__label-helper-wrapper`
  }, label, !isFluid && helper), import_react166.default.createElement("div", {
    className: fieldOuterWrapperClasses
  }, import_react166.default.createElement("div", {
    className: fieldWrapperClasses,
    "data-invalid": normalizedProps.invalid || null
  }, Icon && import_react166.default.createElement(Icon, {
    className: iconClasses
  }), input, isFluid && !inline5 && normalizedProps.validation), !isFluid && !inline5 && (normalizedProps.validation || helper)));
});
PasswordInput.displayName = "PasswordInput";
PasswordInput.propTypes = {
  /**
   * Provide a custom className that is applied directly to the underlying
   * `<input>` node
   */
  className: import_prop_types127.default.string,
  /**
   * Optionally provide the default value of the `<input>`
   */
  defaultValue: import_prop_types127.default.oneOfType([import_prop_types127.default.string, import_prop_types127.default.number]),
  /**
   * Specify whether the control is disabled
   */
  disabled: import_prop_types127.default.bool,
  /**
   * Provide text that is used alongside the control label for additional help
   */
  helperText: import_prop_types127.default.node,
  /**
   * Specify whether or not the underlying label is visually hidden
   */
  hideLabel: import_prop_types127.default.bool,
  /**
   * "Hide password" tooltip text on password visibility toggle
   */
  hidePasswordLabel: import_prop_types127.default.string,
  /**
   * Provide a unique identifier for the input field
   */
  id: import_prop_types127.default.string.isRequired,
  /**
   * `true` to use the inline version.
   */
  inline: import_prop_types127.default.bool,
  /**
   * Specify whether the control is currently invalid
   */
  invalid: import_prop_types127.default.bool,
  /**
   * Whether the PasswordInput should be read-only
   */
  readOnly: import_prop_types127.default.bool,
  /**
   * Provide the text that is displayed when the control is in an invalid state
   */
  invalidText: import_prop_types127.default.node,
  /**
   * Provide the text that will be read by a screen reader when visiting this
   * control
   */
  labelText: import_prop_types127.default.node.isRequired,
  /**
   * `true` to use the light version. For use on $ui-01 backgrounds only.
   * Don't use this to make tile background color same as container background color.
   */
  light: deprecate(import_prop_types127.default.bool, "The `light` prop for `PasswordInput` has been deprecated in favor of the new `Layer` component. It will be removed in the next major release."),
  /**
   * Optionally provide an `onChange` handler that is called whenever `<input>`
   * is updated
   */
  onChange: import_prop_types127.default.func,
  /**
   * Optionally provide an `onClick` handler that is called whenever the
   * `<input>` is clicked
   */
  onClick: import_prop_types127.default.func,
  /**
   * Callback function that is called whenever the toggle password visibility
   * button is clicked
   */
  onTogglePasswordVisibility: import_prop_types127.default.func,
  /**
   * Specify the placeholder attribute for the `<input>`
   */
  placeholder: import_prop_types127.default.string,
  /**
   * "Show password" tooltip text on password visibility toggle
   */
  showPasswordLabel: import_prop_types127.default.string,
  /**
   * Specify the size of the Text Input. Supports `sm`, `md`, or `lg`.
   */
  size: import_prop_types127.default.oneOf(["sm", "md", "lg"]),
  /**
   * Specify the alignment of the tooltip to the icon-only button.
   * Can be one of: start, center, or end.
   */
  tooltipAlignment: import_prop_types127.default.oneOf(["start", "center", "end"]),
  /**
   * Specify the direction of the tooltip for icon-only buttons.
   * Can be either top, right, bottom, or left.
   */
  tooltipPosition: import_prop_types127.default.oneOf(["top", "right", "bottom", "left"]),
  /**
   * The input type, either password or text
   */
  type: import_prop_types127.default.oneOf(["password", "text"]),
  /**
   * Provide the current value of the `<input>`
   */
  value: import_prop_types127.default.oneOfType([import_prop_types127.default.string, import_prop_types127.default.number]),
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types127.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types127.default.node
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/PrimaryButton/PrimaryButton.js
var import_react167 = __toESM(require_react());
var PrimaryButton = (props) => import_react167.default.createElement(Button, _extends({
  kind: "primary"
}, props));

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ProgressIndicator/ProgressIndicator.Skeleton.js
var import_prop_types128 = __toESM(require_prop_types());
var import_react168 = __toESM(require_react());
var import_classnames107 = __toESM(require_classnames());
var _CircleDash;
var _Step;
var _Step2;
var _Step3;
var _Step4;
function Step() {
  const prefix = usePrefix();
  return import_react168.default.createElement("li", {
    className: `${prefix}--progress-step ${prefix}--progress-step--incomplete`
  }, import_react168.default.createElement("div", {
    className: `${prefix}--progress-step-button ${prefix}--progress-step-button--unclickable`
  }, _CircleDash || (_CircleDash = import_react168.default.createElement(CircleDash, null)), import_react168.default.createElement("p", {
    className: `${prefix}--progress-label`
  }), import_react168.default.createElement("span", {
    className: `${prefix}--progress-line`
  })));
}
function ProgressIndicatorSkeleton(_ref) {
  let {
    className,
    vertical,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  return import_react168.default.createElement("ul", _extends({
    className: (0, import_classnames107.default)(`${prefix}--progress`, `${prefix}--skeleton`, {
      [`${prefix}--progress--vertical`]: vertical
    }, className)
  }, rest3), _Step || (_Step = import_react168.default.createElement(Step, null)), _Step2 || (_Step2 = import_react168.default.createElement(Step, null)), _Step3 || (_Step3 = import_react168.default.createElement(Step, null)), _Step4 || (_Step4 = import_react168.default.createElement(Step, null)));
}
ProgressIndicatorSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types128.default.string,
  /**
   * Determines whether or not the ProgressIndicator should be rendered vertically.
   */
  vertical: import_prop_types128.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ProgressIndicator/ProgressIndicator.js
var import_classnames108 = __toESM(require_classnames());
var import_prop_types129 = __toESM(require_prop_types());
var import_react169 = __toESM(require_react());
var defaultTranslations8 = {
  "carbon.progress-step.complete": "Complete",
  "carbon.progress-step.incomplete": "Incomplete",
  "carbon.progress-step.current": "Current",
  "carbon.progress-step.invalid": "Invalid"
};
function translateWithId6(messageId) {
  return defaultTranslations8[messageId];
}
function ProgressIndicator(_ref) {
  let {
    children,
    className: customClassName,
    currentIndex: controlledIndex = 0,
    onChange,
    spaceEqually,
    vertical,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const [currentIndex, setCurrentIndex] = (0, import_react169.useState)(controlledIndex);
  const [prevControlledIndex, setPrevControlledIndex] = (0, import_react169.useState)(controlledIndex);
  const className = (0, import_classnames108.default)({
    [`${prefix}--progress`]: true,
    [`${prefix}--progress--vertical`]: vertical,
    [`${prefix}--progress--space-equal`]: spaceEqually && !vertical,
    [customClassName ?? ""]: customClassName
  });
  if (controlledIndex !== prevControlledIndex) {
    setCurrentIndex(controlledIndex);
    setPrevControlledIndex(controlledIndex);
  }
  return import_react169.default.createElement("ul", _extends({
    className
  }, rest3), import_react169.default.Children.map(children, (child, index4) => {
    if (!import_react169.default.isValidElement(child)) {
      return null;
    }
    const onClick = onChange ? () => onChange(index4) : void 0;
    if (index4 === currentIndex) {
      return import_react169.default.cloneElement(child, {
        complete: child.props.complete,
        current: child.props.complete ? false : true,
        index: index4,
        onClick
      });
    }
    if (index4 < currentIndex) {
      return import_react169.default.cloneElement(child, {
        complete: true,
        index: index4,
        onClick
      });
    }
    if (index4 > currentIndex) {
      return import_react169.default.cloneElement(child, {
        complete: child.props.complete || false,
        index: index4,
        onClick
      });
    }
    return null;
  }));
}
ProgressIndicator.propTypes = {
  /**
   * Provide `<ProgressStep>` components to be rendered in the
   * `<ProgressIndicator>`
   */
  children: import_prop_types129.default.node,
  /**
   * Provide an optional className to be applied to the containing node
   */
  className: import_prop_types129.default.string,
  /**
   * Optionally specify the current step array index
   */
  currentIndex: import_prop_types129.default.number,
  /**
   * Optional callback called if a ProgressStep is clicked on.  Returns the index of the step.
   */
  onChange: import_prop_types129.default.func,
  /**
   * Specify whether the progress steps should be split equally in size in the div
   */
  spaceEqually: import_prop_types129.default.bool,
  /**
   * Determines whether or not the ProgressIndicator should be rendered vertically.
   */
  vertical: import_prop_types129.default.bool
};
function ProgressStep(_ref2) {
  let {
    label,
    description,
    className,
    current,
    complete,
    invalid,
    secondaryLabel,
    disabled,
    onClick,
    translateWithId: t2 = translateWithId6,
    ...rest3
  } = _ref2;
  const prefix = usePrefix();
  const classes = (0, import_classnames108.default)({
    [`${prefix}--progress-step`]: true,
    [`${prefix}--progress-step--current`]: current,
    [`${prefix}--progress-step--complete`]: complete,
    [`${prefix}--progress-step--incomplete`]: !complete && !current,
    [`${prefix}--progress-step--disabled`]: disabled,
    [className ?? ""]: className
  });
  const handleKeyDown = (e2) => {
    if (matches(e2, [Enter, Space]) && onClick) {
      onClick(e2);
    }
  };
  const SVGIcon = (_ref3) => {
    let {
      complete: complete2,
      current: current2,
      description: description2,
      invalid: invalid2,
      prefix: prefix2
    } = _ref3;
    if (invalid2) {
      return import_react169.default.createElement(Warning, {
        className: `${prefix2}--progress__warning`
      }, import_react169.default.createElement("title", null, description2));
    }
    if (current2) {
      return import_react169.default.createElement(Incomplete, null, import_react169.default.createElement("title", null, description2));
    }
    if (complete2) {
      return import_react169.default.createElement(CheckmarkOutline, null, import_react169.default.createElement("title", null, description2));
    }
    return import_react169.default.createElement(CircleDash, null, import_react169.default.createElement("title", null, description2));
  };
  let message = t2("carbon.progress-step.incomplete");
  if (current) {
    message = t2("carbon.progress-step.current");
  }
  if (complete) {
    message = t2("carbon.progress-step.complete");
  }
  if (invalid) {
    message = t2("carbon.progress-step.invalid");
  }
  return import_react169.default.createElement("li", {
    className: classes
  }, import_react169.default.createElement("button", _extends({
    type: "button",
    className: (0, import_classnames108.default)(`${prefix}--progress-step-button`, {
      [`${prefix}--progress-step-button--unclickable`]: !onClick || current
    }),
    disabled,
    "aria-disabled": disabled,
    tabIndex: !current && onClick && !disabled ? 0 : -1,
    onClick: !current ? onClick : void 0,
    onKeyDown: handleKeyDown,
    title: label
  }, rest3), import_react169.default.createElement(SVGIcon, {
    complete,
    current,
    description,
    invalid,
    prefix
  }), import_react169.default.createElement("div", {
    className: `${prefix}--progress-text`
  }, import_react169.default.createElement(Text, {
    as: "p",
    className: `${prefix}--progress-label`
  }, label), secondaryLabel !== null && secondaryLabel !== void 0 ? import_react169.default.createElement(Text, {
    as: "p",
    className: `${prefix}--progress-optional`
  }, secondaryLabel) : null), import_react169.default.createElement("span", {
    className: `${prefix}--assistive-text`
  }, message), import_react169.default.createElement("span", {
    className: `${prefix}--progress-line`
  })));
}
ProgressStep.propTypes = {
  /**
   * Provide an optional className to be applied to the containing `<li>` node
   */
  className: import_prop_types129.default.string,
  /**
   * Specify whether the step has been completed
   */
  complete: import_prop_types129.default.bool,
  /**
   * Specify whether the step is the current step
   */
  current: import_prop_types129.default.bool,
  /**
   * Provide a description for the `<ProgressStep>`
   */
  description: import_prop_types129.default.string,
  /**
   * Specify whether the step is disabled
   */
  disabled: import_prop_types129.default.bool,
  /**
   * Index of the current step within the ProgressIndicator
   */
  index: import_prop_types129.default.number,
  /**
   * Specify whether the step is invalid
   */
  invalid: import_prop_types129.default.bool,
  /**
   * Provide the label for the `<ProgressStep>`
   */
  label: import_prop_types129.default.node.isRequired,
  /**
   * A callback called if the step is clicked or the enter key is pressed
   */
  onClick: import_prop_types129.default.func,
  /**
   * Provide the props that describe a progress step tooltip
   */
  overflowTooltipProps: import_prop_types129.default.object,
  /**
   * Provide an optional secondary label
   */
  secondaryLabel: import_prop_types129.default.string,
  /**
   * The ID of the tooltip content.
   */
  tooltipId: import_prop_types129.default.string,
  /**
   * Optional method that takes in a message id and returns an
   * internationalized string.
   */
  translateWithId: import_prop_types129.default.func
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/RadioButton/RadioButton.Skeleton.js
var import_prop_types130 = __toESM(require_prop_types());
var import_react170 = __toESM(require_react());
var import_classnames109 = __toESM(require_classnames());
function RadioButtonSkeleton(props) {
  const {
    className,
    ...rest3
  } = props;
  const prefix = usePrefix();
  return import_react170.default.createElement("div", _extends({
    className: (0, import_classnames109.default)(`${prefix}--radio-button-wrapper`, className)
  }, rest3), import_react170.default.createElement("div", {
    className: `${prefix}--radio-button ${prefix}--skeleton`
  }), import_react170.default.createElement("span", {
    className: `${prefix}--radio-button__label ${prefix}--skeleton`
  }));
}
RadioButtonSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types130.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/RadioButtonGroup/RadioButtonGroup.js
var import_prop_types131 = __toESM(require_prop_types());
var import_react171 = __toESM(require_react());
var import_classnames110 = __toESM(require_classnames());
var RadioButtonGroup = import_react171.default.forwardRef((props, ref) => {
  var _a;
  const {
    children,
    className,
    decorator,
    defaultSelected,
    disabled,
    helperText,
    invalid = false,
    invalidText,
    labelPosition = "right",
    legendText,
    name,
    onChange = () => {
    },
    orientation = "horizontal",
    readOnly,
    valueSelected,
    warn: warn2 = false,
    warnText,
    slug,
    required,
    ...rest3
  } = props;
  const prefix = usePrefix();
  const [selected, setSelected] = (0, import_react171.useState)(valueSelected ?? defaultSelected);
  const [prevValueSelected, setPrevValueSelected] = (0, import_react171.useState)(valueSelected);
  const radioButtonGroupInstanceId = useId();
  if (valueSelected !== prevValueSelected) {
    setSelected(valueSelected);
    setPrevValueSelected(valueSelected);
  }
  function getRadioButtons() {
    const mappedChildren = import_react171.default.Children.map(children, (radioButton) => {
      if (!radioButton) {
        return;
      }
      const newProps = {
        name,
        key: radioButton.props.value,
        value: radioButton.props.value,
        onChange: handleOnChange,
        checked: radioButton.props.value === selected,
        required
      };
      if (!selected && radioButton.props.checked) {
        newProps.checked = true;
      }
      return import_react171.default.cloneElement(radioButton, newProps);
    });
    return mappedChildren;
  }
  function handleOnChange(newSelection, value, evt) {
    if (!readOnly) {
      if (newSelection !== selected) {
        setSelected(newSelection);
        onChange(newSelection, name, evt);
      }
    }
  }
  const showWarning = !readOnly && !invalid && warn2;
  const showHelper = !invalid && !disabled && !warn2;
  const wrapperClasses = (0, import_classnames110.default)(`${prefix}--form-item`, className);
  const fieldsetClasses = (0, import_classnames110.default)(`${prefix}--radio-button-group`, {
    [`${prefix}--radio-button-group--${orientation}`]: orientation === "vertical",
    [`${prefix}--radio-button-group--label-${labelPosition}`]: labelPosition,
    [`${prefix}--radio-button-group--readonly`]: readOnly,
    [`${prefix}--radio-button-group--invalid`]: !readOnly && invalid,
    [`${prefix}--radio-button-group--warning`]: showWarning,
    [`${prefix}--radio-button-group--slug`]: slug,
    [`${prefix}--radio-button-group--decorator`]: decorator
  });
  const helperClasses = (0, import_classnames110.default)(`${prefix}--form__helper-text`, {
    [`${prefix}--form__helper-text--disabled`]: disabled
  });
  const helperId = !helperText ? void 0 : `radio-button-group-helper-text-${radioButtonGroupInstanceId}`;
  const helper = helperText ? import_react171.default.createElement("div", {
    id: helperId,
    className: helperClasses
  }, helperText) : null;
  const divRef = (0, import_react171.useRef)(null);
  let normalizedDecorator = import_react171.default.isValidElement(slug ?? decorator) ? slug ?? decorator : null;
  if (normalizedDecorator && ((_a = normalizedDecorator["type"]) == null ? void 0 : _a.displayName) === "AILabel") {
    normalizedDecorator = import_react171.default.cloneElement(normalizedDecorator, {
      size: "mini",
      kind: "default"
    });
  }
  return import_react171.default.createElement("div", {
    className: wrapperClasses,
    ref: mergeRefs$1(divRef, ref)
  }, import_react171.default.createElement("fieldset", _extends({
    className: fieldsetClasses,
    disabled,
    "data-invalid": invalid ? true : void 0,
    "aria-describedby": showHelper && helperText ? helperId : void 0
  }, rest3), legendText && import_react171.default.createElement(Legend, {
    className: `${prefix}--label`
  }, legendText, slug ? normalizedDecorator : decorator ? import_react171.default.createElement("div", {
    className: `${prefix}--radio-button-group-inner--decorator`
  }, normalizedDecorator) : ""), getRadioButtons()), import_react171.default.createElement("div", {
    className: `${prefix}--radio-button__validation-msg`
  }, !readOnly && invalid && import_react171.default.createElement(import_react171.default.Fragment, null, import_react171.default.createElement(WarningFilled, {
    className: `${prefix}--radio-button__invalid-icon`
  }), import_react171.default.createElement("div", {
    className: `${prefix}--form-requirement`
  }, invalidText)), showWarning && import_react171.default.createElement(import_react171.default.Fragment, null, import_react171.default.createElement(WarningAltFilled, {
    className: `${prefix}--radio-button__invalid-icon ${prefix}--radio-button__invalid-icon--warning`
  }), import_react171.default.createElement("div", {
    className: `${prefix}--form-requirement`
  }, warnText))), showHelper && helper);
});
RadioButtonGroup.propTypes = {
  /**
   * Provide a collection of `<RadioButton>` components to render in the group
   */
  children: import_prop_types131.default.node,
  /**
   * Provide an optional className to be applied to the container node
   */
  className: import_prop_types131.default.string,
  /**
   * **Experimental**: Provide a decorator component to be rendered inside the `RadioButtonGroup` component
   */
  decorator: import_prop_types131.default.node,
  /**
   * Specify the `<RadioButton>` to be selected by default
   */
  defaultSelected: import_prop_types131.default.oneOfType([import_prop_types131.default.string, import_prop_types131.default.number]),
  /**
   * Specify whether the group is disabled
   */
  disabled: import_prop_types131.default.bool,
  /**
   * Provide text that is used alongside the control label for additional help
   */
  helperText: import_prop_types131.default.node,
  /**
   * Specify whether the control is currently invalid
   */
  invalid: import_prop_types131.default.bool,
  /**
   * Provide the text that is displayed when the control is in an invalid state
   */
  invalidText: import_prop_types131.default.node,
  /**
   * Provide where label text should be placed
   */
  labelPosition: import_prop_types131.default.oneOf(["left", "right"]),
  /**
   * Provide a legend to the RadioButtonGroup input that you are
   * exposing to the user
   */
  legendText: import_prop_types131.default.node,
  /**
   * Specify the name of the underlying `<input>` nodes
   */
  name: import_prop_types131.default.string.isRequired,
  /**
   * Provide an optional `onChange` hook that is called whenever the value of
   * the group changes
   */
  onChange: import_prop_types131.default.func,
  /**
   * Provide where radio buttons should be placed
   */
  orientation: import_prop_types131.default.oneOf(["horizontal", "vertical"]),
  /**
   * Whether the RadioButtonGroup should be read-only
   */
  readOnly: import_prop_types131.default.bool,
  /**
   * `true` to specify if radio selection in group is required.
   */
  required: import_prop_types131.default.bool,
  /**
   * **Experimental**: Provide a `Slug` component to be rendered inside the `RadioButtonGroup` component
   */
  slug: deprecate(import_prop_types131.default.node, "The `slug` prop has been deprecated and will be removed in the next major version. Use the decorator prop instead."),
  /**
   * Specify the value that is currently selected in the group
   */
  valueSelected: import_prop_types131.default.oneOfType([import_prop_types131.default.string, import_prop_types131.default.number]),
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types131.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types131.default.node
};
RadioButtonGroup.displayName = "RadioButtonGroup";

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/RadioTile/RadioTile.js
var import_classnames111 = __toESM(require_classnames());
var import_prop_types132 = __toESM(require_prop_types());
var import_react172 = __toESM(require_react());
var _RadioButtonChecked;
var _RadioButton;
var _CheckmarkFilled;
var RadioTile = import_react172.default.forwardRef(function RadioTile2(_ref, ref) {
  var _a;
  let {
    children,
    className: customClassName,
    decorator,
    disabled,
    light,
    checked,
    name,
    value,
    id,
    onChange = noopFn,
    tabIndex = 0,
    hasRoundedCorners,
    slug,
    required,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const inputId = useFallbackId(id);
  const className = (0, import_classnames111.default)(customClassName, `${prefix}--tile`, `${prefix}--tile--selectable`, `${prefix}--tile--radio`, {
    [`${prefix}--tile--is-selected`]: checked,
    [`${prefix}--tile--light`]: light,
    [`${prefix}--tile--disabled`]: disabled,
    [`${prefix}--tile--slug`]: slug,
    [`${prefix}--tile--slug-rounded`]: slug && hasRoundedCorners,
    [`${prefix}--tile--decorator`]: decorator,
    [`${prefix}--tile--decorator-rounded`]: decorator && hasRoundedCorners
  });
  const v12TileRadioIcons = useFeatureFlag("enable-v12-tile-radio-icons");
  function icon() {
    if (v12TileRadioIcons) {
      if (checked) {
        return _RadioButtonChecked || (_RadioButtonChecked = import_react172.default.createElement(RadioButtonChecked, null));
      } else {
        return _RadioButton || (_RadioButton = import_react172.default.createElement(RadioButton, null));
      }
    } else {
      return _CheckmarkFilled || (_CheckmarkFilled = import_react172.default.createElement(CheckmarkFilled, null));
    }
  }
  function handleOnChange(evt) {
    onChange(value, name, evt);
  }
  function handleOnKeyDown2(evt) {
    if (matches(evt, [Enter, Space])) {
      evt.preventDefault();
      onChange(value, name, evt);
    }
  }
  let normalizedDecorator = import_react172.default.isValidElement(slug ?? decorator) ? slug ?? decorator : null;
  if (normalizedDecorator && ((_a = normalizedDecorator["type"]) == null ? void 0 : _a.displayName) === "AILabel") {
    normalizedDecorator = import_react172.default.cloneElement(normalizedDecorator, {
      size: "xs"
    });
  }
  return import_react172.default.createElement("div", null, import_react172.default.createElement("input", {
    checked,
    className: `${prefix}--tile-input`,
    disabled,
    id: inputId,
    name,
    onChange: !disabled ? handleOnChange : void 0,
    onKeyDown: !disabled ? handleOnKeyDown2 : void 0,
    tabIndex: !disabled ? tabIndex : void 0,
    type: "radio",
    value,
    ref,
    required
  }), import_react172.default.createElement("label", _extends({}, rest3, {
    htmlFor: inputId,
    className
  }), import_react172.default.createElement("span", {
    className: `${prefix}--tile__checkmark`
  }, icon()), import_react172.default.createElement(Text, {
    className: `${prefix}--tile-content`
  }, children), slug ? normalizedDecorator : decorator ? import_react172.default.createElement("div", {
    className: `${prefix}--tile--inner-decorator`
  }, normalizedDecorator) : ""));
});
RadioTile.displayName = "RadioTile";
RadioTile.propTypes = {
  /**
   * Specify whether the `RadioTile` should be checked.
   */
  checked: import_prop_types132.default.bool,
  /**
   * The `RadioTile` content.
   */
  children: import_prop_types132.default.node,
  /**
   * Provide an optional `className` to be applied to the underlying `<label>`.
   */
  className: import_prop_types132.default.string,
  /**
   * **Experimental**: Provide a `decorator` component to be rendered inside the `RadioTile` component
   */
  decorator: import_prop_types132.default.node,
  /**
   * Specify whether the `RadioTile` should be disabled.
   */
  disabled: import_prop_types132.default.bool,
  /**
   * Specify if the `ExpandableTile` component should be rendered with rounded corners.
   * Only valid when `slug` prop is present
   */
  hasRoundedCorners: import_prop_types132.default.bool,
  /**
   * Provide a unique id for the underlying `<input>`.
   */
  id: import_prop_types132.default.string,
  /**
   * `true` to use the light version. For use on `$layer-01` backgrounds only.
   * Don't use this to make tile background color same as container background color.
   */
  light: deprecate(import_prop_types132.default.bool, "The `light` prop for `RadioTile` is no longer needed and has been deprecated in v11 in favor of the new `Layer` component. It will be removed in the next major release."),
  /**
   * Provide a `name` for the underlying `<input>`.
   */
  name: import_prop_types132.default.string,
  /**
   * Provide an optional `onChange` hook that is called each time the value of
   * the underlying `<input>` changes.
   */
  onChange: import_prop_types132.default.func,
  /**
   * `true` to specify if the control is required.
   */
  required: import_prop_types132.default.bool,
  /**
   * **Experimental**: Provide a `Slug` component to be rendered inside the `RadioTile` component
   */
  slug: deprecate(import_prop_types132.default.node, "The `slug` prop for `RadioTile` has been deprecated in favor of the new `decorator` prop. It will be removed in the next major release."),
  /**
   * Specify the tab index of the underlying `<input>`.
   */
  tabIndex: import_prop_types132.default.number,
  /**
   * Specify the value of the underlying `<input>`.
   */
  value: import_prop_types132.default.oneOfType([import_prop_types132.default.string, import_prop_types132.default.number]).isRequired
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/SecondaryButton/SecondaryButton.js
var import_react173 = __toESM(require_react());
var SecondaryButton = (props) => import_react173.default.createElement(Button, _extends({
  kind: "secondary"
}, props));

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/SelectItemGroup/SelectItemGroup.js
var import_prop_types133 = __toESM(require_prop_types());
var import_react174 = __toESM(require_react());
var import_classnames112 = __toESM(require_classnames());
var SelectItemGroup = (_ref) => {
  let {
    children,
    className,
    disabled = false,
    label,
    ...other
  } = _ref;
  const prefix = usePrefix();
  const classNames = (0, import_classnames112.default)(`${prefix}--select-optgroup`, className);
  return import_react174.default.createElement("optgroup", _extends({
    className: classNames,
    label,
    disabled
  }, other), children);
};
SelectItemGroup.propTypes = {
  /**
   * Provide the contents of your <SelectItemGroup>
   */
  children: import_prop_types133.default.node,
  /**
   * Specify an optional className to be applied to the node
   */
  className: import_prop_types133.default.string,
  /**
   * Specify whether the <SelectItemGroup> should be disabled
   */
  disabled: import_prop_types133.default.bool,
  /**
   * Specify the label to be displayed
   */
  label: import_prop_types133.default.string.isRequired
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/SkeletonIcon/SkeletonIcon.js
var import_prop_types134 = __toESM(require_prop_types());
var import_react175 = __toESM(require_react());
var import_classnames113 = __toESM(require_classnames());
var SkeletonIcon = (_ref) => {
  let {
    className,
    ...other
  } = _ref;
  const prefix = usePrefix();
  const skeletonIconClasses = (0, import_classnames113.default)(className, {
    [`${prefix}--icon--skeleton`]: true
  });
  return import_react175.default.createElement("div", _extends({
    className: skeletonIconClasses
  }, other));
};
SkeletonIcon.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types134.default.string,
  /**
   * The CSS styles.
   */
  style: import_prop_types134.default.object
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/SkeletonPlaceholder/SkeletonPlaceholder.js
var import_react176 = __toESM(require_react());
var import_prop_types135 = __toESM(require_prop_types());
var import_classnames114 = __toESM(require_classnames());
var SkeletonPlaceholder = (_ref) => {
  let {
    className,
    ...other
  } = _ref;
  const prefix = usePrefix();
  const skeletonPlaceholderClasses = (0, import_classnames114.default)({
    [`${prefix}--skeleton__placeholder`]: true
  }, className);
  return import_react176.default.createElement("div", _extends({
    className: skeletonPlaceholderClasses
  }, other));
};
SkeletonPlaceholder.propTypes = {
  /**
   * Add a custom class to the component
   * to set the height and width
   */
  className: import_prop_types135.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Slider/Slider.js
var import_react178 = __toESM(require_react());
var import_prop_types136 = __toESM(require_prop_types());
var import_classnames115 = __toESM(require_classnames());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Slider/SliderHandles.js
var import_react177 = __toESM(require_react());
var _path;
var _path2;
var _path3;
var _path4;
var _path5;
var _path6;
var _path7;
var _path8;
var _path9;
var _path10;
var _path11;
var _path12;
var _path13;
var _path14;
var LowerHandle = (props) => import_react177.default.createElement(PrefixContext.Consumer, null, (prefix) => import_react177.default.createElement("svg", _extends({
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 16 24",
  className: `${prefix}--slider__thumb-icon ${prefix}--slider__thumb-icon--lower`
}, props), _path || (_path = import_react177.default.createElement("path", {
  d: "M15.08 6.46H16v11.08h-.92zM4.46 17.54c-.25 0-.46-.21-.46-.46V6.92a.465.465 0 0 1 .69-.4l8.77 5.08a.46.46 0 0 1 0 .8l-8.77 5.08c-.07.04-.15.06-.23.06Z"
})), _path2 || (_path2 = import_react177.default.createElement("path", {
  fill: "none",
  d: "M-4 0h24v24H-4z"
}))));
var LowerHandleFocus = (props) => import_react177.default.createElement(PrefixContext.Consumer, null, (prefix) => import_react177.default.createElement("svg", _extends({
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 16 24",
  className: `${prefix}--slider__thumb-icon ${prefix}--slider__thumb-icon--lower ${prefix}--slider__thumb-icon--focus`
}, props), _path3 || (_path3 = import_react177.default.createElement("path", {
  d: "M15.08 6.46H16v11.08h-.92zM4.46 17.54c-.25 0-.46-.21-.46-.46V6.92a.465.465 0 0 1 .69-.4l8.77 5.08a.46.46 0 0 1 0 .8l-8.77 5.08c-.07.04-.15.06-.23.06Z"
})), _path4 || (_path4 = import_react177.default.createElement("path", {
  fill: "none",
  d: "M-4 0h24v24H-4z"
})), _path5 || (_path5 = import_react177.default.createElement("path", {
  d: "M15.08 0H16v6.46h-.92z"
})), _path6 || (_path6 = import_react177.default.createElement("path", {
  d: "M0 0h.92v24H0zM15.08 0H16v24h-.92z"
})), _path7 || (_path7 = import_react177.default.createElement("path", {
  d: "M0 .92V0h16v.92zM0 24v-.92h16V24z"
}))));
var UpperHandle = (props) => import_react177.default.createElement(PrefixContext.Consumer, null, (prefix) => import_react177.default.createElement("svg", _extends({
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 16 24",
  className: `${prefix}--slider__thumb-icon ${prefix}--slider__thumb-icon--upper`
}, props), _path8 || (_path8 = import_react177.default.createElement("path", {
  d: "M0 6.46h.92v11.08H0zM11.54 6.46c.25 0 .46.21.46.46v10.15a.465.465 0 0 1-.69.4L2.54 12.4a.46.46 0 0 1 0-.8l8.77-5.08c.07-.04.15-.06.23-.06Z"
})), _path9 || (_path9 = import_react177.default.createElement("path", {
  fill: "none",
  d: "M-4 0h24v24H-4z"
}))));
var UpperHandleFocus = (props) => import_react177.default.createElement(PrefixContext.Consumer, null, (prefix) => import_react177.default.createElement("svg", _extends({
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 16 24",
  className: `${prefix}--slider__thumb-icon ${prefix}--slider__thumb-icon--upper ${prefix}--slider__thumb-icon--focus`
}, props), _path10 || (_path10 = import_react177.default.createElement("path", {
  d: "M0 6.46h.92v11.08H0zM11.54 6.46c.25 0 .46.21.46.46v10.15a.465.465 0 0 1-.69.4L2.54 12.4a.46.46 0 0 1 0-.8l8.77-5.08c.07-.04.15-.06.23-.06Z"
})), _path11 || (_path11 = import_react177.default.createElement("path", {
  fill: "none",
  d: "M-4 0h24v24H-4z"
})), _path12 || (_path12 = import_react177.default.createElement("path", {
  d: "M.92 24H0v-6.46h.92z"
})), _path13 || (_path13 = import_react177.default.createElement("path", {
  d: "M16 24h-.92V0H16zM.92 24H0V0h.92z"
})), _path14 || (_path14 = import_react177.default.createElement("path", {
  d: "M16 23.08V24H0v-.92zM16 0v.92H0V0z"
}))));

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Slider/Slider.js
var ThumbWrapper = (_ref) => {
  let {
    hasTooltip = false,
    className,
    style,
    children,
    ...rest3
  } = _ref;
  if (hasTooltip) {
    return (
      // eslint-disable-next-line react/forbid-component-props
      import_react178.default.createElement(Tooltip, _extends({
        className,
        style
      }, rest3), children)
    );
  } else {
    return (
      // eslint-disable-next-line react/forbid-dom-props
      import_react178.default.createElement("div", {
        className,
        style
      }, children)
    );
  }
};
ThumbWrapper.propTypes = {
  /**
   * The thumb node itself.
   */
  children: import_prop_types136.default.node,
  /**
   * CSS wrapper class names.
   */
  className: import_prop_types136.default.string,
  /**
   * Should the thumb show a tooltip with the current value?
   */
  hasTooltip: import_prop_types136.default.bool.isRequired,
  /**
   * Percentage offset for the select thumb value.
   */
  style: import_prop_types136.default.object
};
var translationIds5 = {
  autoCorrectAnnouncement: "carbon.slider.auto-correct-announcement"
};
function translateWithId7(translationId, translationState) {
  if (translationState == null ? void 0 : translationState.correctedValue) {
    const {
      correctedValue
    } = translationState;
    return `The inputted value "${correctedValue}" was corrected to the nearest allowed digit.`;
  }
  return "";
}
var defaultFormatLabel = (value, label) => {
  return typeof label === "function" ? label(value) : `${value}${label}`;
};
var EVENT_THROTTLE = 16;
var DRAG_EVENT_TYPES = /* @__PURE__ */ new Set(["mousemove", "touchmove"]);
var DRAG_STOP_EVENT_TYPES2 = /* @__PURE__ */ new Set(["mouseup", "touchend", "touchcancel"]);
var HandlePosition = function(HandlePosition2) {
  HandlePosition2["LOWER"] = "lower";
  HandlePosition2["UPPER"] = "upper";
  return HandlePosition2;
}(HandlePosition || {});
var Slider = class extends import_react178.PureComponent {
  constructor(props) {
    var _this;
    super(props);
    _this = this;
    _defineProperty(this, "state", {
      value: this.props.value,
      valueUpper: this.props.unstable_valueUpper,
      left: 0,
      leftUpper: 0,
      needsOnRelease: false,
      isValid: true,
      isValidUpper: true,
      activeHandle: null,
      correctedValue: null,
      correctedPosition: null,
      isRtl: false
    });
    _defineProperty(this, "thumbRef", void 0);
    _defineProperty(this, "thumbRefUpper", void 0);
    _defineProperty(this, "filledTrackRef", void 0);
    _defineProperty(this, "element", null);
    _defineProperty(this, "inputId", "");
    _defineProperty(this, "track", void 0);
    _defineProperty(this, "onDragStart", (evt) => {
      if (this.props.disabled || this.props.readOnly) {
        return;
      }
      evt.preventDefault();
      DRAG_STOP_EVENT_TYPES2.forEach((element) => {
        var _a;
        (_a = this.element) == null ? void 0 : _a.ownerDocument.addEventListener(element, this.onDragStop);
      });
      DRAG_EVENT_TYPES.forEach((element) => {
        var _a;
        (_a = this.element) == null ? void 0 : _a.ownerDocument.addEventListener(element, this.onDrag);
      });
      const clientX = this.getClientXFromEvent(evt);
      let activeHandle;
      if (this.hasTwoHandles()) {
        if (evt.target == this.thumbRef.current) {
          activeHandle = HandlePosition.LOWER;
        } else if (evt.target == this.thumbRefUpper.current) {
          activeHandle = HandlePosition.UPPER;
        } else {
          const distanceToLower = this.calcDistanceToHandle(HandlePosition.LOWER, clientX);
          const distanceToUpper = this.calcDistanceToHandle(HandlePosition.UPPER, clientX);
          if (distanceToLower <= distanceToUpper) {
            activeHandle = HandlePosition.LOWER;
          } else {
            activeHandle = HandlePosition.UPPER;
          }
        }
      }
      const focusOptions = {
        preventScroll: true
      };
      if (this.hasTwoHandles()) {
        if (this.thumbRef.current && activeHandle === HandlePosition.LOWER) {
          this.thumbRef.current.focus(focusOptions);
        } else if (this.thumbRefUpper.current && activeHandle === HandlePosition.UPPER) {
          this.thumbRefUpper.current.focus(focusOptions);
        }
      } else if (this.thumbRef.current) {
        this.thumbRef.current.focus(focusOptions);
      }
      this.setState({
        activeHandle
      });
      this.onDrag(evt, activeHandle);
    });
    _defineProperty(this, "onDragStop", () => {
      if (this.props.disabled || this.props.readOnly) {
        return;
      }
      DRAG_STOP_EVENT_TYPES2.forEach((element) => {
        var _a;
        (_a = this.element) == null ? void 0 : _a.ownerDocument.removeEventListener(element, this.onDragStop);
      });
      DRAG_EVENT_TYPES.forEach((element) => {
        var _a;
        (_a = this.element) == null ? void 0 : _a.ownerDocument.removeEventListener(element, this.onDrag);
      });
      this.setState({
        needsOnRelease: true,
        isValid: true,
        isValidUpper: true
      });
    });
    _defineProperty(this, "_onDrag", function(evt) {
      let activeHandle = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      activeHandle = activeHandle ?? _this.state.activeHandle;
      if (_this.props.disabled || _this.props.readOnly || !evt) {
        return;
      }
      const clientX = _this.getClientXFromEvent(evt);
      const {
        value,
        left
      } = _this.calcValue({
        clientX,
        value: _this.state.value
      });
      if (_this.hasTwoHandles() && activeHandle) {
        _this.setValueLeftForHandle(activeHandle, {
          value: _this.nearestStepValue(value),
          left
        });
      } else {
        _this.setState({
          value: _this.nearestStepValue(value),
          left,
          isValid: true
        });
      }
      _this.setState({
        correctedValue: null,
        correctedPosition: null
      });
    });
    _defineProperty(this, "onDrag", throttle2(this._onDrag, EVENT_THROTTLE, {
      leading: true,
      trailing: false
    }));
    _defineProperty(this, "onKeyDown", (evt) => {
      if (this.props.disabled || this.props.readOnly) {
        return;
      }
      const {
        step = 1,
        stepMultiplier = 4
      } = this.props;
      let delta = 0;
      if (matches(evt, [ArrowDown, ArrowLeft])) {
        delta = -step;
      } else if (matches(evt, [ArrowUp2, ArrowRight2])) {
        delta = step;
      } else {
        return;
      }
      if (evt.shiftKey) {
        delta *= stepMultiplier;
      }
      if (this.hasTwoHandles() && this.state.activeHandle) {
        const currentValue = this.state.activeHandle === HandlePosition.LOWER ? this.state.value : this.state.valueUpper;
        const {
          value,
          left
        } = this.calcValue({
          value: this.calcValueForDelta(currentValue, delta, this.props.step)
        });
        this.setValueLeftForHandle(this.state.activeHandle, {
          value: this.nearestStepValue(value),
          left
        });
      } else {
        const {
          value,
          left
        } = this.calcValue({
          // Ensures custom value from `<input>` won't cause skipping next stepping
          // point with right arrow key, e.g. Typing 51 in `<input>`, moving focus
          // onto the thumb and the hitting right arrow key should yield 52 instead
          // of 54.
          value: this.calcValueForDelta(this.state.value, delta, this.props.step)
        });
        this.setState({
          value: this.nearestStepValue(value),
          left,
          isValid: true
        });
      }
      this.setState({
        correctedValue: null,
        correctedPosition: null
      });
    });
    _defineProperty(this, "onChange", (evt) => {
      if (this.props.disabled || this.props.readOnly) {
        return;
      }
      if (!evt || !("target" in evt) || typeof evt.target.value !== "string") {
        return;
      }
      const activeHandle = evt.target.dataset.handlePosition ?? HandlePosition.LOWER;
      const targetValue = Number.parseFloat(evt.target.value);
      if (this.hasTwoHandles()) {
        if (isNaN(targetValue)) {
          this.setValueForHandle(activeHandle, evt.target.value);
        } else if (this.isValidValueForPosition({
          handle: activeHandle,
          value: targetValue,
          min: this.props.min,
          max: this.props.max
        })) {
          this.processNewInputValue(evt.target);
        } else {
          this.setValueForHandle(activeHandle, targetValue);
        }
      } else {
        if (isNaN(targetValue)) {
          this.setState({
            value: evt.target.value
          });
        } else if (this.isValidValue({
          value: targetValue,
          min: this.props.min,
          max: this.props.max
        })) {
          this.processNewInputValue(evt.target);
        } else {
          this.setState({
            value: targetValue
          });
        }
      }
    });
    _defineProperty(this, "onBlur", (evt) => {
      var _a, _b, _c, _d;
      if (!evt || !("target" in evt) || typeof evt.target.value !== "string") {
        return;
      }
      const {
        value: targetValue
      } = evt.target;
      this.processNewInputValue(evt.target);
      (_d = (_c = this.props).onBlur) == null ? void 0 : _d.call(_c, {
        value: targetValue,
        handlePosition: (_b = (_a = evt.target) == null ? void 0 : _a.dataset) == null ? void 0 : _b.handlePosition
      });
    });
    _defineProperty(this, "onInputKeyDown", (evt) => {
      if (this.props.disabled || this.props.readOnly) {
        return;
      }
      if (!evt || !("target" in evt) || typeof evt.target.value !== "string") {
        return;
      }
      if (matches(evt, [Enter])) {
        this.processNewInputValue(evt.target);
      }
    });
    _defineProperty(this, "processNewInputValue", (input) => {
      var _a;
      this.setState({
        correctedValue: null,
        correctedPosition: null
      });
      const targetValue = Number.parseFloat(input.value);
      const validity = !isNaN(targetValue);
      const handlePosition = (_a = input == null ? void 0 : input.dataset) == null ? void 0 : _a.handlePosition;
      if (handlePosition === HandlePosition.LOWER) {
        this.setState({
          isValid: validity
        });
      } else if (handlePosition === HandlePosition.UPPER) {
        this.setState({
          isValidUpper: validity
        });
      }
      this.setState({
        isValid: validity
      });
      if (validity) {
        const adjustedValue = handlePosition ? this.getAdjustedValueForPosition({
          handle: handlePosition,
          value: targetValue,
          min: this.props.min,
          max: this.props.max
        }) : this.getAdjustedValue({
          value: targetValue,
          min: this.props.min,
          max: this.props.max
        });
        if (adjustedValue !== targetValue) {
          this.setState({
            correctedValue: targetValue.toString(),
            correctedPosition: handlePosition
          });
        } else {
          this.setState({
            correctedValue: null,
            correctedPosition: null
          });
        }
        const {
          value,
          left
        } = this.calcValue({
          value: adjustedValue,
          useRawValue: true
        });
        if (handlePosition) {
          this.setValueLeftForHandle(handlePosition, {
            value,
            left
          });
        } else {
          this.setState({
            value,
            left
          });
        }
      }
    });
    _defineProperty(this, "calcLeftPercent", (_ref2) => {
      var _a, _b;
      let {
        clientX,
        value,
        range: range3
      } = _ref2;
      const boundingRect = (_b = (_a = this.element) == null ? void 0 : _a.getBoundingClientRect) == null ? void 0 : _b.call(_a);
      let width = boundingRect ? boundingRect.right - boundingRect.left : 0;
      if (width <= 0) {
        width = 1;
      }
      if (clientX) {
        const leftOffset = this.state.isRtl ? ((boundingRect == null ? void 0 : boundingRect.right) ?? 0) - clientX : clientX - ((boundingRect == null ? void 0 : boundingRect.left) ?? 0);
        return leftOffset / width;
      } else if (value !== null && value !== void 0 && range3) {
        return range3 === 0 ? 0 : (value - this.props.min) / range3;
      }
      return 0;
    });
    _defineProperty(this, "calcSteppedValuePercent", (_ref3) => {
      let {
        leftPercent,
        range: range3
      } = _ref3;
      const {
        step = 1
      } = this.props;
      const totalSteps = range3 / step;
      let steppedValue = Math.round(leftPercent * totalSteps) * step;
      const steppedPercent = this.clamp(steppedValue / range3, 0, 1);
      steppedValue = this.clamp(steppedValue + this.props.min, this.props.min, this.props.max);
      return [steppedValue, steppedPercent];
    });
    _defineProperty(this, "calcValue", (_ref4) => {
      let {
        clientX,
        value,
        useRawValue = false
      } = _ref4;
      const range3 = this.props.max - this.props.min;
      const leftPercent = this.calcLeftPercent({
        clientX,
        value,
        range: range3
      });
      if (useRawValue) {
        return {
          value,
          left: Math.min(1, Math.max(0, leftPercent)) * 100
        };
      }
      const [steppedValue, steppedPercent] = this.calcSteppedValuePercent({
        leftPercent,
        range: range3
      });
      return {
        value: steppedValue,
        left: steppedPercent * 100
      };
    });
    _defineProperty(this, "calcDistanceToHandle", (handle, clientX) => {
      const handleBoundingRect = this.getHandleBoundingRect(handle);
      const handleX = handleBoundingRect.left + handleBoundingRect.width / 2;
      return Math.abs(handleX - clientX);
    });
    _defineProperty(this, "calcValueForDelta", function(currentValue, delta) {
      let step = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      return (delta > 0 ? Math.floor(currentValue / step) * step : currentValue) + delta;
    });
    _defineProperty(this, "setValueLeftForHandle", (handle, _ref5) => {
      let {
        value: newValue,
        left: newLeft
      } = _ref5;
      const {
        value,
        valueUpper,
        left,
        leftUpper
      } = this.state;
      if (handle === HandlePosition.LOWER) {
        this.setState({
          value: valueUpper && newValue > valueUpper ? valueUpper : newValue,
          left: valueUpper && newValue > valueUpper ? leftUpper : newLeft,
          isValid: true
        });
      } else {
        this.setState({
          valueUpper: value && newValue < value ? value : newValue,
          leftUpper: value && newValue < value ? left : newLeft,
          isValidUpper: true
        });
      }
    });
    _defineProperty(this, "setValueForHandle", (handle, value) => {
      if (handle === HandlePosition.LOWER) {
        this.setState({
          value,
          isValid: true
        });
      } else {
        this.setState({
          valueUpper: value,
          isValidUpper: true
        });
      }
    });
    _defineProperty(this, "isValidValueForPosition", (_ref6) => {
      let {
        handle,
        value: newValue,
        min: min4,
        max: max4
      } = _ref6;
      const {
        value,
        valueUpper
      } = this.state;
      if (!this.isValidValue({
        value: newValue,
        min: min4,
        max: max4
      })) {
        return false;
      }
      if (handle === HandlePosition.LOWER) {
        return !valueUpper || newValue <= valueUpper;
      } else if (handle === HandlePosition.UPPER) {
        return !value || newValue >= value;
      }
      return false;
    });
    _defineProperty(this, "isValidValue", (_ref7) => {
      let {
        value,
        min: min4,
        max: max4
      } = _ref7;
      return !(value < min4 || value > max4);
    });
    _defineProperty(this, "getAdjustedValueForPosition", (_ref8) => {
      let {
        handle,
        value: newValue,
        min: min4,
        max: max4
      } = _ref8;
      const {
        value,
        valueUpper
      } = this.state;
      newValue = this.getAdjustedValue({
        value: newValue,
        min: min4,
        max: max4
      });
      if (handle === HandlePosition.LOWER && valueUpper) {
        newValue = newValue > valueUpper ? valueUpper : newValue;
      } else if (handle === HandlePosition.UPPER && value) {
        newValue = newValue < value ? value : newValue;
      }
      return newValue;
    });
    _defineProperty(this, "getAdjustedValue", (_ref9) => {
      let {
        value,
        min: min4,
        max: max4
      } = _ref9;
      if (value < min4) {
        value = min4;
      }
      if (value > max4) {
        value = max4;
      }
      return value;
    });
    _defineProperty(this, "getHandleBoundingRect", (handle) => {
      var _a, _b, _c, _d;
      let boundingRect;
      if (handle === HandlePosition.LOWER) {
        boundingRect = (_b = (_a = this == null ? void 0 : this.thumbRef) == null ? void 0 : _a.current) == null ? void 0 : _b.getBoundingClientRect();
      } else {
        boundingRect = (_d = (_c = this == null ? void 0 : this.thumbRefUpper) == null ? void 0 : _c.current) == null ? void 0 : _d.getBoundingClientRect();
      }
      return boundingRect ?? new DOMRect();
    });
    this.thumbRef = import_react178.default.createRef();
    this.thumbRefUpper = import_react178.default.createRef();
    this.filledTrackRef = import_react178.default.createRef();
  }
  /**
   * Sets up initial slider position and value in response to component mount.
   */
  componentDidMount() {
    if (this.element) {
      const isRtl = (document == null ? void 0 : document.dir) === "rtl";
      if (this.hasTwoHandles()) {
        const {
          value,
          left
        } = this.calcValue({
          value: this.state.value,
          useRawValue: true
        });
        const {
          value: valueUpper,
          left: leftUpper
        } = this.calcValue({
          value: this.state.valueUpper,
          useRawValue: true
        });
        this.setState({
          isRtl,
          value,
          left,
          valueUpper,
          leftUpper
        });
      } else {
        const {
          value,
          left
        } = this.calcValue({
          value: this.state.value,
          useRawValue: true
        });
        this.setState({
          isRtl,
          value,
          left
        });
      }
    }
  }
  /**
   * Handles firing of `onChange` and `onRelease` callbacks to parent in
   * response to state changes.
   *
   * @param {*} prevProps prevProps
   * @param {*} prevState The previous Slider state, used to see if callbacks
   * should be called.
   */
  componentDidUpdate(prevProps, prevState) {
    if (this.hasTwoHandles()) {
      if (this.filledTrackRef.current) {
        this.filledTrackRef.current.style.transform = this.state.isRtl ? `translate(${100 - this.state.leftUpper}%, -50%) scaleX(${(this.state.leftUpper - this.state.left) / 100})` : `translate(${this.state.left}%, -50%) scaleX(${(this.state.leftUpper - this.state.left) / 100})`;
      }
    } else {
      if (this.filledTrackRef.current) {
        this.filledTrackRef.current.style.transform = this.state.isRtl ? `translate(100%, -50%) scaleX(-${this.state.left / 100})` : `translate(0%, -50%) scaleX(${this.state.left / 100})`;
      }
    }
    if ((prevState.value !== this.state.value || prevState.valueUpper !== this.state.valueUpper) && typeof this.props.onChange === "function") {
      this.props.onChange({
        value: this.state.value,
        valueUpper: this.state.valueUpper
      });
    }
    if (this.state.needsOnRelease && typeof this.props.onRelease === "function") {
      this.props.onRelease({
        value: this.state.value,
        valueUpper: this.state.valueUpper
      });
      this.setState({
        needsOnRelease: false
      });
    }
    if (prevProps.value === this.props.value && prevProps.unstable_valueUpper === this.props.unstable_valueUpper && prevProps.max === this.props.max && prevProps.min === this.props.min) {
      return;
    }
    this.setState(this.calcValue({
      value: this.props.value,
      useRawValue: true
    }));
    if (this.props.unstable_valueUpper !== void 0) {
      const {
        value: valueUpper,
        left: leftUpper
      } = this.calcValue({
        value: this.props.unstable_valueUpper,
        useRawValue: true
      });
      this.setState({
        valueUpper,
        leftUpper
      });
    } else {
      this.setState({
        valueUpper: void 0,
        leftUpper: void 0
      });
    }
  }
  /**
   * Synonymous to ECMA2017+ `Math.clamp`.
   *
   * @param {number} val
   * @param {number} min
   * @param {number} max
   *
   * @returns `val` if `max>=val>=min`; `min` if `val<min`; `max` if `val>max`.
   */
  clamp(val, min4, max4) {
    return Math.max(min4, Math.min(val, max4));
  }
  /**
   * Takes a value and ensures it fits to the steps of the range
   * @param value
   * @returns value of the nearest step
   */
  nearestStepValue(value) {
    const tempInput = document.createElement("input");
    tempInput.type = "range";
    tempInput.min = `${this.props.min}`;
    tempInput.max = `${this.props.max}`;
    tempInput.step = `${this.props.step}`;
    tempInput.value = `${value}`;
    return parseFloat(tempInput.value);
  }
  getClientXFromEvent(event) {
    let clientX;
    if ("clientX" in event) {
      clientX = event.clientX;
    } else if ("touches" in event && 0 in event.touches && "clientX" in event.touches[0]) {
      clientX = event.touches[0].clientX;
    }
    return clientX;
  }
  hasTwoHandles() {
    return this.state.valueUpper !== void 0;
  }
  // syncs invalid state and prop
  static getDerivedStateFromProps(props, state) {
    const {
      isValid,
      isValidUpper
    } = state;
    let derivedState = {};
    if (props.invalid === true) {
      if (isValid === true) {
        derivedState = {
          ...derivedState,
          isValid: false
        };
      }
      if (isValid === true) {
        derivedState = {
          ...derivedState,
          isValid: false
        };
      }
      if (isValidUpper === true) {
        derivedState = {
          ...derivedState,
          isValidUpper: false
        };
      }
    } else if (props.invalid === false) {
      if (isValid === false) {
        derivedState = {
          ...derivedState,
          isValid: true
        };
      }
      if (isValid === false) {
        derivedState = {
          ...derivedState,
          isValid: true
        };
      }
      if (isValidUpper === false) {
        derivedState = {
          ...derivedState,
          isValidUpper: true
        };
      }
    }
    return Object.entries(derivedState).length > 0 ? derivedState : null;
  }
  render() {
    var _LowerHandle, _LowerHandleFocus, _UpperHandle, _UpperHandleFocus, _UpperHandle2, _UpperHandleFocus2, _LowerHandle2, _LowerHandleFocus2;
    const {
      ariaLabelInput,
      unstable_ariaLabelInputUpper: ariaLabelInputUpper,
      className,
      hideTextInput = false,
      id = this.inputId = this.inputId || `__carbon-slider_${Math.random().toString(36).substr(2)}`,
      min: min4,
      minLabel = "",
      max: max4,
      maxLabel = "",
      formatLabel = defaultFormatLabel,
      labelText,
      step = 1,
      stepMultiplier: _stepMultiplier,
      inputType = "number",
      invalidText,
      required,
      disabled = false,
      name,
      unstable_nameUpper: nameUpper,
      light,
      readOnly = false,
      warn: warn2,
      warnText,
      translateWithId: t2 = translateWithId7,
      ...other
    } = this.props;
    const twoHandles = this.hasTwoHandles();
    delete other.onRelease;
    delete other.invalid;
    delete other.unstable_valueUpper;
    const {
      value,
      valueUpper,
      isValid,
      isValidUpper,
      correctedValue,
      correctedPosition,
      isRtl
    } = this.state;
    const showWarning = !readOnly && warn2 || typeof correctedValue !== null && correctedPosition === HandlePosition.LOWER && isValid;
    const showWarningUpper = !readOnly && warn2 || typeof correctedValue !== null && correctedPosition === (twoHandles ? HandlePosition.UPPER : HandlePosition.LOWER) && (twoHandles ? isValidUpper : isValid);
    return import_react178.default.createElement(PrefixContext.Consumer, null, (prefix) => {
      const labelId = `${id}-label`;
      const labelClasses = (0, import_classnames115.default)(`${prefix}--label`, {
        [`${prefix}--label--disabled`]: disabled
      });
      const containerClasses = (0, import_classnames115.default)(`${prefix}--slider-container`, {
        [`${prefix}--slider-container--two-handles`]: twoHandles,
        [`${prefix}--slider-container--disabled`]: disabled,
        [`${prefix}--slider-container--readonly`]: readOnly,
        [`${prefix}--slider-container--rtl`]: isRtl
      });
      const sliderClasses = (0, import_classnames115.default)(`${prefix}--slider`, {
        [`${prefix}--slider--disabled`]: disabled,
        [`${prefix}--slider--readonly`]: readOnly
      });
      const fixedInputClasses = [`${prefix}--text-input`, `${prefix}--slider-text-input`];
      const conditionalInputClasses = {
        [`${prefix}--text-input--light`]: light
      };
      const lowerInputClasses = (0, import_classnames115.default)([...fixedInputClasses, `${prefix}--slider-text-input--lower`, conditionalInputClasses, {
        [`${prefix}--text-input--invalid`]: !readOnly && !isValid,
        [`${prefix}--slider-text-input--warn`]: showWarning
      }]);
      const upperInputClasses = (0, import_classnames115.default)([...fixedInputClasses, `${prefix}--slider-text-input--upper`, conditionalInputClasses, {
        [`${prefix}--text-input--invalid`]: !readOnly && (twoHandles ? !isValidUpper : !isValid),
        [`${prefix}--slider-text-input--warn`]: showWarningUpper
      }]);
      const lowerInputWrapperClasses = (0, import_classnames115.default)([`${prefix}--text-input-wrapper`, `${prefix}--slider-text-input-wrapper`, `${prefix}--slider-text-input-wrapper--lower`, {
        [`${prefix}--text-input-wrapper--readonly`]: readOnly,
        [`${prefix}--slider-text-input-wrapper--hidden`]: hideTextInput
      }]);
      const upperInputWrapperClasses = (0, import_classnames115.default)([`${prefix}--text-input-wrapper`, `${prefix}--slider-text-input-wrapper`, `${prefix}--slider-text-input-wrapper--upper`, {
        [`${prefix}--text-input-wrapper--readonly`]: readOnly,
        [`${prefix}--slider-text-input-wrapper--hidden`]: hideTextInput
      }]);
      const lowerThumbClasses = (0, import_classnames115.default)(`${prefix}--slider__thumb`, {
        [`${prefix}--slider__thumb--lower`]: twoHandles
      });
      const upperThumbClasses = (0, import_classnames115.default)(`${prefix}--slider__thumb`, {
        [`${prefix}--slider__thumb--upper`]: twoHandles
      });
      const lowerThumbWrapperClasses = (0, import_classnames115.default)([`${prefix}--icon-tooltip`, `${prefix}--slider__thumb-wrapper`, {
        [`${prefix}--slider__thumb-wrapper--lower`]: twoHandles
      }]);
      const upperThumbWrapperClasses = (0, import_classnames115.default)([`${prefix}--icon-tooltip`, `${prefix}--slider__thumb-wrapper`, {
        [`${prefix}--slider__thumb-wrapper--upper`]: twoHandles
      }]);
      const lowerThumbWrapperProps = {
        style: {
          insetInlineStart: `${this.state.left}%`
        }
      };
      const upperThumbWrapperProps = {
        style: {
          insetInlineStart: `${this.state.leftUpper}%`
        }
      };
      return import_react178.default.createElement("div", {
        className: (0, import_classnames115.default)(`${prefix}--form-item`, className)
      }, import_react178.default.createElement(Text, {
        as: "label",
        htmlFor: twoHandles ? void 0 : id,
        className: labelClasses,
        id: labelId
      }, labelText), import_react178.default.createElement("div", {
        className: containerClasses
      }, twoHandles ? import_react178.default.createElement("div", {
        className: lowerInputWrapperClasses
      }, import_react178.default.createElement("input", {
        type: hideTextInput ? "hidden" : inputType,
        id: `${id}-lower-input-for-slider`,
        name,
        className: lowerInputClasses,
        value,
        "aria-label": ariaLabelInput,
        disabled,
        required,
        min: min4,
        max: max4,
        step,
        onChange: this.onChange,
        onBlur: this.onBlur,
        onKeyUp: this.props.onInputKeyUp,
        onKeyDown: this.onInputKeyDown,
        "data-invalid": !isValid && !readOnly ? true : null,
        "data-handle-position": HandlePosition.LOWER,
        "aria-invalid": !isValid && !readOnly ? true : void 0,
        readOnly
      }), !readOnly && !isValid && import_react178.default.createElement(WarningFilled, {
        className: `${prefix}--slider__invalid-icon`
      }), showWarning && import_react178.default.createElement(WarningAltFilled, {
        className: `${prefix}--slider__invalid-icon ${prefix}--slider__invalid-icon--warning`
      })) : null, import_react178.default.createElement(Text, {
        className: `${prefix}--slider__range-label`
      }, formatLabel(min4, minLabel)), import_react178.default.createElement("div", _extends({
        className: sliderClasses,
        ref: (node) => {
          this.element = node;
        },
        onMouseDown: this.onDragStart,
        onTouchStart: this.onDragStart,
        onKeyDown: this.onKeyDown,
        role: "presentation",
        tabIndex: -1,
        "data-invalid": (twoHandles ? !isValid || !isValidUpper : !isValid) && !readOnly ? true : null
      }, other), import_react178.default.createElement(ThumbWrapper, _extends({
        hasTooltip: hideTextInput,
        className: lowerThumbWrapperClasses,
        label: `${formatLabel(value, "")}`,
        align: "top"
      }, lowerThumbWrapperProps), import_react178.default.createElement("div", {
        className: lowerThumbClasses,
        role: "slider",
        id: twoHandles ? void 0 : id,
        tabIndex: readOnly || disabled ? void 0 : 0,
        "aria-valuetext": `${formatLabel(value, "")}`,
        "aria-valuemax": twoHandles ? valueUpper : max4,
        "aria-valuemin": min4,
        "aria-valuenow": value,
        "aria-labelledby": twoHandles ? void 0 : labelId,
        "aria-label": twoHandles ? ariaLabelInput : void 0,
        ref: this.thumbRef,
        onFocus: () => this.setState({
          activeHandle: HandlePosition.LOWER
        })
      }, twoHandles && !isRtl ? import_react178.default.createElement(import_react178.default.Fragment, null, _LowerHandle || (_LowerHandle = import_react178.default.createElement(LowerHandle, {
        "aria-label": ariaLabelInput
      })), _LowerHandleFocus || (_LowerHandleFocus = import_react178.default.createElement(LowerHandleFocus, {
        "aria-label": ariaLabelInput
      }))) : twoHandles && isRtl ? import_react178.default.createElement(import_react178.default.Fragment, null, _UpperHandle || (_UpperHandle = import_react178.default.createElement(UpperHandle, {
        "aria-label": ariaLabelInputUpper
      })), _UpperHandleFocus || (_UpperHandleFocus = import_react178.default.createElement(UpperHandleFocus, {
        "aria-label": ariaLabelInputUpper
      }))) : void 0)), twoHandles ? import_react178.default.createElement(ThumbWrapper, _extends({
        hasTooltip: hideTextInput,
        className: upperThumbWrapperClasses,
        label: `${formatLabel(valueUpper || 0, "")}`,
        align: "top"
      }, upperThumbWrapperProps), import_react178.default.createElement("div", {
        className: upperThumbClasses,
        role: "slider",
        tabIndex: readOnly || disabled ? void 0 : 0,
        "aria-valuemax": max4,
        "aria-valuemin": value,
        "aria-valuenow": valueUpper,
        "aria-label": ariaLabelInputUpper,
        ref: this.thumbRefUpper,
        onFocus: () => this.setState({
          activeHandle: HandlePosition.UPPER
        })
      }, twoHandles && !isRtl ? import_react178.default.createElement(import_react178.default.Fragment, null, _UpperHandle2 || (_UpperHandle2 = import_react178.default.createElement(UpperHandle, {
        "aria-label": ariaLabelInputUpper
      })), _UpperHandleFocus2 || (_UpperHandleFocus2 = import_react178.default.createElement(UpperHandleFocus, {
        "aria-label": ariaLabelInputUpper
      }))) : twoHandles && isRtl ? import_react178.default.createElement(import_react178.default.Fragment, null, _LowerHandle2 || (_LowerHandle2 = import_react178.default.createElement(LowerHandle, {
        "aria-label": ariaLabelInput
      })), _LowerHandleFocus2 || (_LowerHandleFocus2 = import_react178.default.createElement(LowerHandleFocus, {
        "aria-label": ariaLabelInput
      }))) : void 0)) : null, import_react178.default.createElement("div", {
        className: `${prefix}--slider__track`,
        ref: (node) => {
          this.track = node;
        }
      }), import_react178.default.createElement("div", {
        className: `${prefix}--slider__filled-track`,
        ref: this.filledTrackRef
      })), import_react178.default.createElement(Text, {
        className: `${prefix}--slider__range-label`
      }, formatLabel(max4, maxLabel)), import_react178.default.createElement("div", {
        className: upperInputWrapperClasses
      }, import_react178.default.createElement("input", {
        type: hideTextInput ? "hidden" : inputType,
        id: `${id}-${twoHandles ? "upper-" : ""}input-for-slider`,
        name: twoHandles ? nameUpper : name,
        className: upperInputClasses,
        value: twoHandles ? valueUpper : value,
        "aria-labelledby": !ariaLabelInput && !twoHandles ? labelId : void 0,
        "aria-label": twoHandles ? ariaLabelInputUpper : ariaLabelInput ? ariaLabelInput : void 0,
        disabled,
        required,
        min: min4,
        max: max4,
        step,
        onChange: this.onChange,
        onBlur: this.onBlur,
        onKeyDown: this.onInputKeyDown,
        onKeyUp: this.props.onInputKeyUp,
        "data-invalid": (twoHandles ? !isValidUpper : !isValid) && !readOnly ? true : null,
        "data-handle-position": twoHandles ? HandlePosition.UPPER : null,
        "aria-invalid": (twoHandles ? !isValidUpper : !isValid) && !readOnly ? true : void 0,
        readOnly
      }), !readOnly && (twoHandles ? !isValidUpper : !isValid) && import_react178.default.createElement(WarningFilled, {
        className: `${prefix}--slider__invalid-icon`
      }), showWarningUpper && import_react178.default.createElement(WarningAltFilled, {
        className: `${prefix}--slider__invalid-icon ${prefix}--slider__invalid-icon--warning`
      }))), !readOnly && (!isValid || !isValidUpper) && import_react178.default.createElement(Text, {
        as: "div",
        className: (0, import_classnames115.default)(`${prefix}--slider__validation-msg`, `${prefix}--slider__validation-msg--invalid`, `${prefix}--form-requirement`)
      }, invalidText), !readOnly && warn2 && isValid && isValidUpper && import_react178.default.createElement(Text, {
        as: "div",
        className: (0, import_classnames115.default)(`${prefix}--slider__validation-msg`, `${prefix}--form-requirement`)
      }, warnText), correctedValue && import_react178.default.createElement(Text, {
        as: "div",
        role: "alert",
        className: (0, import_classnames115.default)(`${prefix}--slider__status-msg`, `${prefix}--form-requirement`)
      }, t2(translationIds5.autoCorrectAnnouncement, {
        correctedValue
      })));
    });
  }
};
_defineProperty(Slider, "propTypes", {
  /**
   * The `ariaLabel` for the `<input>`.
   */
  ariaLabelInput: import_prop_types136.default.string,
  /**
   * The child nodes.
   */
  children: import_prop_types136.default.node,
  /**
   * The CSS class name for the slider.
   */
  className: import_prop_types136.default.string,
  /**
   * `true` to disable this slider.
   */
  disabled: import_prop_types136.default.bool,
  /**
   * The callback to format the label associated with the minimum/maximum value.
   */
  formatLabel: import_prop_types136.default.func,
  /**
   * `true` to hide the number input box.
   */
  hideTextInput: import_prop_types136.default.bool,
  /**
   * The ID of the `<input>`.
   */
  id: import_prop_types136.default.string,
  /**
   * The `type` attribute of the `<input>`.
   */
  inputType: import_prop_types136.default.string,
  /**
   * `Specify whether the Slider is currently invalid
   */
  invalid: import_prop_types136.default.bool,
  /**
   * Provide the text that is displayed when the Slider is in an invalid state
   */
  invalidText: import_prop_types136.default.node,
  /**
   * The label for the slider.
   */
  labelText: import_prop_types136.default.node,
  /**
   * `true` to use the light version.
   */
  light: deprecate(import_prop_types136.default.bool, "The `light` prop for `Slider` is no longer needed and has been deprecated in v11 in favor of the new `Layer` component. It will be moved in the next major release."),
  /**
   * The maximum value.
   */
  max: import_prop_types136.default.number.isRequired,
  /**
   * The label associated with the maximum value.
   */
  maxLabel: import_prop_types136.default.string,
  /**
   * The minimum value.
   */
  min: import_prop_types136.default.number.isRequired,
  /**
   * The label associated with the minimum value.
   */
  minLabel: import_prop_types136.default.string,
  /**
   * The `name` attribute of the `<input>`.
   */
  name: import_prop_types136.default.string,
  /**
   * Provide an optional function to be called when the input element
   * loses focus
   */
  onBlur: import_prop_types136.default.func,
  /**
   * The callback to get notified of change in value.
   */
  onChange: import_prop_types136.default.func,
  /**
   * Provide an optional function to be called when a key is pressed in the number input
   */
  onInputKeyUp: import_prop_types136.default.func,
  /**
   * The callback to get notified of value on handle release.
   */
  onRelease: import_prop_types136.default.func,
  /**
   * Whether the slider should be read-only
   */
  readOnly: import_prop_types136.default.bool,
  /**
   * `true` to specify if the control is required.
   */
  required: import_prop_types136.default.bool,
  /**
   * A value determining how much the value should increase/decrease by moving the thumb by mouse. If a value other than 1 is provided and the input is *not* hidden, the new step requirement should be added to a visible label. Values outside the `step` increment will be considered invalid.
   */
  step: import_prop_types136.default.number,
  /**
   * A value determining how much the value should increase/decrease by Shift+arrow keys,
   * which will be `(max - min) / stepMultiplier`.
   */
  stepMultiplier: import_prop_types136.default.number,
  /**
   * Supply a method to translate internal strings with your i18n tool of
   * choice. Translation keys are available on the `translationIds` field for
   * this component.
   */
  translateWithId: import_prop_types136.default.func,
  /**
   * The `ariaLabel` for the upper bound `<input>` when there are two handles.
   */
  unstable_ariaLabelInputUpper: import_prop_types136.default.string,
  /**
   * The `name` attribute of the upper bound `<input>` when there are two handles.
   */
  unstable_nameUpper: import_prop_types136.default.string,
  /**
   * The upper bound when there are two handles.
   */
  unstable_valueUpper: import_prop_types136.default.number,
  /**
   * The value of the slider. When there are two handles, value is the lower
   * bound.
   */
  value: import_prop_types136.default.number.isRequired,
  /**
   * `Specify whether the Slider is in a warn state
   */
  warn: import_prop_types136.default.bool,
  /**
   * Provide the text that is displayed when the Slider is in a warn state
   */
  warnText: import_prop_types136.default.node
});
_defineProperty(Slider, "contextType", FeatureFlagContext);
Slider.translationIds = Object.values(translationIds5);

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Slider/Slider.Skeleton.js
var import_prop_types137 = __toESM(require_prop_types());
var import_react179 = __toESM(require_react());
var import_classnames116 = __toESM(require_classnames());
var SliderSkeleton = (_ref) => {
  let {
    ariaLabel = "slider handle",
    unstable_ariaLabelHandleUpper: ariaLabelHandleUpper = "upper slider handle",
    hideLabel,
    className,
    twoHandles,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const [isRtl, setIsRtl] = (0, import_react179.useState)(false);
  useIsomorphicEffect$1(() => {
    setIsRtl(document ? document.dir === "rtl" : false);
  }, []);
  const containerClasses = (0, import_classnames116.default)(`${prefix}--slider-container`, `${prefix}--skeleton`, {
    [`${prefix}--slider-container--two-handles`]: twoHandles,
    [`${prefix}--slider-container--rtl`]: isRtl
  });
  const lowerThumbClasses = (0, import_classnames116.default)(`${prefix}--slider__thumb`, {
    [`${prefix}--slider__thumb--lower`]: twoHandles
  });
  const upperThumbClasses = (0, import_classnames116.default)(`${prefix}--slider__thumb`, {
    [`${prefix}--slider__thumb--upper`]: twoHandles
  });
  const lowerThumbWrapperClasses = (0, import_classnames116.default)(`${prefix}--slider__thumb-wrapper`, {
    [`${prefix}--slider__thumb-wrapper--lower`]: twoHandles
  });
  const upperThumbWrapperClasses = (0, import_classnames116.default)(`${prefix}--slider__thumb-wrapper`, {
    [`${prefix}--slider__thumb-wrapper--upper`]: twoHandles
  });
  return import_react179.default.createElement("div", _extends({
    className: (0, import_classnames116.default)(`${prefix}--form-item`, className)
  }, rest3), !hideLabel && import_react179.default.createElement("span", {
    className: `${prefix}--label ${prefix}--skeleton`
  }), import_react179.default.createElement("div", {
    className: containerClasses
  }, import_react179.default.createElement("span", {
    className: `${prefix}--slider__range-label`
  }), import_react179.default.createElement("div", {
    className: `${prefix}--slider`
  }, import_react179.default.createElement("div", {
    className: `${prefix}--slider__track`
  }), import_react179.default.createElement("div", {
    className: `${prefix}--slider__filled-track`
  }), import_react179.default.createElement("div", {
    className: lowerThumbWrapperClasses
  }, import_react179.default.createElement("div", {
    className: lowerThumbClasses
  }, twoHandles && !isRtl ? import_react179.default.createElement(LowerHandle, {
    "aria-label": ariaLabel
  }) : twoHandles && isRtl ? import_react179.default.createElement(UpperHandle, {
    "aria-label": ariaLabelHandleUpper
  }) : void 0)), twoHandles ? import_react179.default.createElement("div", {
    className: upperThumbWrapperClasses
  }, import_react179.default.createElement("div", {
    className: upperThumbClasses
  }, twoHandles && !isRtl ? import_react179.default.createElement(UpperHandle, {
    "aria-label": ariaLabelHandleUpper
  }) : twoHandles && isRtl ? import_react179.default.createElement(LowerHandle, {
    "aria-label": ariaLabel
  }) : void 0)) : void 0), import_react179.default.createElement("span", {
    className: `${prefix}--slider__range-label`
  })));
};
SliderSkeleton.propTypes = {
  /**
   * The `ariaLabel` for the handle icon.
   */
  ariaLabel: import_prop_types137.default.string,
  /**
   * The `ariaLabel` for the upper bound slider handle when there are two handles.
   */
  unstable_ariaLabelHandleUpper: import_prop_types137.default.string,
  /**
   * Specify an optional className to add to the form item wrapper.
   */
  className: import_prop_types137.default.string,
  /**
   * Specify whether the label should be hidden, or not
   */
  hideLabel: import_prop_types137.default.bool,
  /**
   * Turn the slider into a range slider.
   */
  twoHandles: import_prop_types137.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Slider/index.js
var Slider2 = createClassWrapper(Slider);

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Stack/HStack.js
var import_react181 = __toESM(require_react());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Stack/Stack.js
var import_react180 = __toESM(require_react());
var import_classnames117 = __toESM(require_classnames());
var import_prop_types138 = __toESM(require_prop_types());
var SPACING_STEPS = Array.from({
  length: spacing2.length - 1
}).map((_, step) => {
  return step + 1;
});
var Stack = import_react180.default.forwardRef(function Stack2(props, ref) {
  const {
    as: BaseComponent = "div",
    children,
    className: customClassName,
    gap,
    orientation = "vertical",
    ...rest3
  } = props;
  const prefix = usePrefix();
  const className = (0, import_classnames117.default)(customClassName, {
    [`${prefix}--stack-${orientation}`]: true,
    [`${prefix}--stack-scale-${gap}`]: typeof gap === "number"
  });
  const style = {
    ...rest3.style
  };
  if (typeof gap === "string") {
    style[`--${prefix}-stack-gap`] = gap;
  }
  return (
    // eslint-disable-next-line react/forbid-component-props
    import_react180.default.createElement(BaseComponent, _extends({}, rest3, {
      ref,
      className,
      style
    }), children)
  );
});
Stack.propTypes = {
  /**
   * Provide a custom element type to render as the outermost element in
   * the Stack component. By default, this component will render a `div`.
   */
  as: import_prop_types138.default.elementType,
  /**
   * Provide the elements that will be rendered as children inside of the Stack
   * component. These elements will have having spacing between them according
   * to the `step` and `orientation` prop
   */
  children: import_prop_types138.default.node,
  /**
   * Provide a custom class name to be used by the outermost element rendered by
   * Stack
   */
  className: import_prop_types138.default.string,
  /**
   * Provide either a custom value or a step from the spacing scale to be used
   * as the gap in the layout
   */
  gap: import_prop_types138.default.oneOfType([import_prop_types138.default.string, import_prop_types138.default.oneOf(SPACING_STEPS)]),
  /**
   * Specify the orientation of them items in the Stack
   */
  orientation: import_prop_types138.default.oneOf(["horizontal", "vertical"])
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Stack/HStack.js
var HStack = import_react181.default.forwardRef(function HStack2(_ref, ref) {
  let {
    children,
    ...props
  } = _ref;
  return import_react181.default.createElement(Stack, _extends({}, props, {
    ref,
    orientation: "horizontal"
  }), children);
});

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Stack/VStack.js
var import_react182 = __toESM(require_react());
var VStack = import_react182.default.forwardRef(function VStack2(props, ref) {
  return import_react182.default.createElement(Stack, _extends({}, props, {
    ref,
    orientation: "vertical"
  }));
});

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/StructuredList/StructuredList.js
var import_react184 = __toESM(require_react());
var import_prop_types139 = __toESM(require_prop_types());
var import_classnames118 = __toESM(require_classnames());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/internal/useOutsideClick.js
var import_react183 = __toESM(require_react());
function useOutsideClick(ref, callback) {
  const savedCallback = (0, import_react183.useRef)(callback);
  (0, import_react183.useEffect)(() => {
    savedCallback.current = callback;
  });
  if (canUseDOM) {
    useEvent(window, "click", (event) => {
      if (ref.current && !ref.current.contains(event.target)) {
        savedCallback.current(event);
      }
    });
  }
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/StructuredList/StructuredList.js
var _StructuredListCell;
var GridSelectedRowStateContext = import_react184.default.createContext(null);
var GridSelectedRowDispatchContext = import_react184.default.createContext(null);
function StructuredListWrapper(props) {
  const {
    children,
    selection,
    className,
    ["aria-label"]: ariaLabel = "Structured list section",
    // @ts-expect-error: Deprecated prop
    ariaLabel: deprecatedAriaLabel,
    isCondensed,
    isFlush,
    ...other
  } = props;
  const prefix = usePrefix();
  const classes = (0, import_classnames118.default)(`${prefix}--structured-list`, {
    [`${prefix}--structured-list--selection`]: selection,
    [`${prefix}--structured-list--condensed`]: isCondensed,
    [`${prefix}--structured-list--flush`]: isFlush && !selection
  }, className);
  const [selectedRow, setSelectedRow] = import_react184.default.useState(null);
  return import_react184.default.createElement(GridSelectedRowStateContext.Provider, {
    value: selectedRow
  }, import_react184.default.createElement(GridSelectedRowDispatchContext.Provider, {
    value: setSelectedRow
  }, import_react184.default.createElement("div", _extends({
    role: "table",
    className: classes
  }, other, {
    "aria-label": deprecatedAriaLabel || ariaLabel
  }), children)));
}
StructuredListWrapper.propTypes = {
  /**
   * Specify a label to be read by screen readers on the container node
   */
  ["aria-label"]: import_prop_types139.default.string,
  /**
   * Deprecated, please use `aria-label` instead.
   * Specify a label to be read by screen readers on the container note.
   */
  ariaLabel: deprecate(import_prop_types139.default.string, "This prop syntax has been deprecated. Please use the new `aria-label`."),
  /**
   * Provide the contents of your StructuredListWrapper
   */
  children: import_prop_types139.default.node,
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types139.default.string,
  /**
   * Specify if structured list is condensed, default is false
   */
  isCondensed: import_prop_types139.default.bool,
  /**
   * Specify if structured list is flush, not valid for selection variant, default is false
   */
  isFlush: import_prop_types139.default.bool,
  /**
   * Specify whether your StructuredListWrapper should have selections
   */
  selection: import_prop_types139.default.bool
};
function StructuredListHead(props) {
  const {
    children,
    className,
    ...other
  } = props;
  const prefix = usePrefix();
  const classes = (0, import_classnames118.default)(`${prefix}--structured-list-thead`, className);
  return import_react184.default.createElement("div", _extends({
    role: "rowgroup",
    className: classes
  }, other), children);
}
StructuredListHead.propTypes = {
  /**
   * Provide the contents of your StructuredListHead
   */
  children: import_prop_types139.default.node,
  /**
   * Specify an optional className to be applied to the node
   */
  className: import_prop_types139.default.string
};
function StructuredListBody(props) {
  const {
    children,
    className,
    ...other
  } = props;
  const prefix = usePrefix();
  const classes = (0, import_classnames118.default)(`${prefix}--structured-list-tbody`, className);
  return import_react184.default.createElement("div", _extends({
    className: classes,
    role: "rowgroup"
  }, other), children);
}
StructuredListBody.propTypes = {
  /**
   * Provide the contents of your StructuredListBody
   */
  children: import_prop_types139.default.node,
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types139.default.string,
  head: import_prop_types139.default.bool,
  /**
   * Provide a handler that is invoked on the key down event for the control
   */
  onKeyDown: import_prop_types139.default.func
};
var GridRowContext = import_react184.default.createContext(null);
function StructuredListRow(props) {
  const {
    onKeyDown,
    children,
    className,
    head: head3,
    onClick,
    selection,
    ...other
  } = props;
  const [hasFocusWithin, setHasFocusWithin] = (0, import_react184.useState)(false);
  const id = useId("grid-input");
  const selectedRow = import_react184.default.useContext(GridSelectedRowStateContext);
  const setSelectedRow = import_react184.default.useContext(GridSelectedRowDispatchContext);
  const prefix = usePrefix();
  const value = {
    id
  };
  const classes = (0, import_classnames118.default)(`${prefix}--structured-list-row`, {
    [`${prefix}--structured-list-row--header-row`]: head3,
    [`${prefix}--structured-list-row--focused-within`]: hasFocusWithin && !selection || hasFocusWithin && selection && (selectedRow === id || selectedRow === null),
    // Ensure focus on the first item when navigating through Tab keys and no row is selected (selectedRow === null)
    [`${prefix}--structured-list-row--selected`]: selectedRow === id
  }, className);
  const itemRef = (0, import_react184.useRef)(null);
  const handleClick2 = () => {
    setHasFocusWithin(false);
  };
  useOutsideClick(itemRef, handleClick2);
  return head3 ? import_react184.default.createElement("div", _extends({
    role: "row"
  }, other, {
    className: classes
  }), selection && (_StructuredListCell || (_StructuredListCell = import_react184.default.createElement(StructuredListCell, {
    head: true
  }))), children) : (
    // eslint-disable-next-line jsx-a11y/interactive-supports-focus
    import_react184.default.createElement("div", _extends({}, other, {
      role: "row",
      className: classes,
      ref: itemRef,
      onClick: (event) => {
        setSelectedRow == null ? void 0 : setSelectedRow(id);
        onClick && onClick(event);
        if (selection) {
          setHasFocusWithin(true);
        }
      },
      onFocus: () => {
        setHasFocusWithin(true);
      },
      onBlur: () => {
        setHasFocusWithin(false);
      },
      onKeyDown
    }), import_react184.default.createElement(GridRowContext.Provider, {
      value
    }, selection && import_react184.default.createElement(StructuredListCell, null, selectedRow === id ? import_react184.default.createElement(RadioButtonChecked, {
      className: `${prefix}--structured-list__icon`
    }) : import_react184.default.createElement(RadioButton, {
      className: `${prefix}--structured-list__icon`
    })), children))
  );
}
StructuredListRow.propTypes = {
  /**
   * Provide the contents of your StructuredListRow
   */
  children: import_prop_types139.default.node,
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types139.default.string,
  /**
   * Specify whether your StructuredListRow should be used as a header row
   */
  head: import_prop_types139.default.bool,
  /**
   * Specify whether a `<label>` should be used
   */
  label: deprecate(import_prop_types139.default.bool, `
The \`label\` prop is no longer needed and will be removed in the next major version of Carbon.`),
  /**
   * Provide a handler that is invoked on the click
   */
  onClick: import_prop_types139.default.func,
  /**
   * Provide a handler that is invoked on the key down event for the control,
   */
  onKeyDown: import_prop_types139.default.func,
  /**
   * Mark if this row should be selectable
   */
  selection: import_prop_types139.default.bool
};
function StructuredListInput(props) {
  const defaultId2 = useId("structureListInput");
  const {
    className,
    name = `structured-list-input-${defaultId2}`,
    title,
    id,
    onChange,
    ...other
  } = props;
  const prefix = usePrefix();
  const classes = (0, import_classnames118.default)(`${prefix}--structured-list-input`, `${prefix}--visually-hidden`, className);
  const row = import_react184.default.useContext(GridRowContext);
  const selectedRow = import_react184.default.useContext(GridSelectedRowStateContext);
  const setSelectedRow = import_react184.default.useContext(GridSelectedRowDispatchContext);
  return import_react184.default.createElement("input", _extends({}, other, {
    type: "radio",
    tabIndex: 0,
    checked: !!row && row.id === selectedRow,
    value: (row == null ? void 0 : row.id) ?? "",
    onChange: (event) => {
      setSelectedRow == null ? void 0 : setSelectedRow(event.target.value);
      onChange && onChange(event);
    },
    id: id ?? defaultId2,
    className: classes,
    name,
    title
  }));
}
StructuredListInput.propTypes = {
  /**
   * Specify an optional className to be applied to the input
   */
  className: import_prop_types139.default.string,
  /**
   * Specify whether the underlying input should be checked by default
   */
  defaultChecked: deprecate(import_prop_types139.default.bool, `
The prop \`defaultChecked\` is no longer needed and will be removed in the next major version of Carbon.`),
  /**
   * Specify a custom `id` for the input
   */
  id: import_prop_types139.default.string,
  /**
   * Provide a `name` for the input
   */
  name: import_prop_types139.default.string,
  /**
   * Provide an optional hook that is called each time the input is updated
   */
  onChange: import_prop_types139.default.func,
  /**
   * Provide a `title` for the input
   */
  title: import_prop_types139.default.string,
  /**
   * Specify the value of the input
   */
  value: deprecate(import_prop_types139.default.oneOfType([import_prop_types139.default.string, import_prop_types139.default.number]).isRequired, `
The prop \`value\` will be removed in the next major version of Carbon.`)
};
function StructuredListCell(props) {
  const {
    children,
    className,
    head: head3,
    noWrap,
    ...other
  } = props;
  const prefix = usePrefix();
  const classes = (0, import_classnames118.default)({
    [`${prefix}--structured-list-th`]: head3,
    [`${prefix}--structured-list-td`]: !head3,
    [`${prefix}--structured-list-content--nowrap`]: noWrap
  }, className);
  if (head3) {
    return import_react184.default.createElement(Text, _extends({
      className: classes,
      role: "columnheader"
    }, other), children);
  }
  return import_react184.default.createElement(Text, _extends({
    as: "div",
    className: classes,
    role: "cell"
  }, other), children);
}
StructuredListCell.propTypes = {
  /**
   * Provide the contents of your StructuredListCell
   */
  children: import_prop_types139.default.node,
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types139.default.string,
  /**
   * Specify whether your StructuredListCell should be used as a header cell
   */
  head: import_prop_types139.default.bool,
  /**
   * Specify whether your StructuredListCell should have text wrapping
   */
  noWrap: import_prop_types139.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/StructuredList/StructuredList.Skeleton.js
var import_prop_types140 = __toESM(require_prop_types());
var import_react185 = __toESM(require_react());
var import_classnames119 = __toESM(require_classnames());
var _span6;
var _span23;
var _span32;
function StructuredListSkeleton(_ref) {
  let {
    rowCount = 5,
    className,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const classNames = (0, import_classnames119.default)(`${prefix}--skeleton`, `${prefix}--structured-list`, className);
  const rows = new Array(rowCount).fill(null).map((_, i) => import_react185.default.createElement("div", {
    className: `${prefix}--structured-list-row`,
    key: i
  }, import_react185.default.createElement("div", {
    className: `${prefix}--structured-list-td`
  }), import_react185.default.createElement("div", {
    className: `${prefix}--structured-list-td`
  }), import_react185.default.createElement("div", {
    className: `${prefix}--structured-list-td`
  })));
  return import_react185.default.createElement("div", _extends({
    className: classNames
  }, rest3), import_react185.default.createElement("div", {
    className: `${prefix}--structured-list-thead`
  }, import_react185.default.createElement("div", {
    className: `${prefix}--structured-list-row ${prefix}--structured-list-row--header-row`
  }, import_react185.default.createElement("div", {
    className: `${prefix}--structured-list-th`
  }, _span6 || (_span6 = import_react185.default.createElement("span", null))), import_react185.default.createElement("div", {
    className: `${prefix}--structured-list-th`
  }, _span23 || (_span23 = import_react185.default.createElement("span", null))), import_react185.default.createElement("div", {
    className: `${prefix}--structured-list-th`
  }, _span32 || (_span32 = import_react185.default.createElement("span", null))))), import_react185.default.createElement("div", {
    className: `${prefix}--structured-list-tbody`
  }, rows));
}
StructuredListSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types140.default.string,
  /**
   * number of table rows
   */
  rowCount: import_prop_types140.default.number
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Switch/Switch.js
var import_prop_types141 = __toESM(require_prop_types());
var import_react186 = __toESM(require_react());
var import_classnames120 = __toESM(require_classnames());
var Switch = import_react186.default.forwardRef(function Switch2(props, tabRef) {
  const {
    children,
    className,
    disabled,
    index: index4,
    name,
    onClick = noopFn,
    onKeyDown = noopFn,
    selected = false,
    text,
    ...other
  } = props;
  const prefix = usePrefix();
  const handleClick2 = (e2) => {
    e2.preventDefault();
    onClick == null ? void 0 : onClick({
      index: index4,
      name,
      text
    });
  };
  const handleKeyDown = (event) => {
    const key = event.key || event.which;
    onKeyDown == null ? void 0 : onKeyDown({
      index: index4,
      name,
      text,
      key
    });
  };
  const classes = (0, import_classnames120.default)(className, `${prefix}--content-switcher-btn`, {
    [`${prefix}--content-switcher--selected`]: selected
  });
  const commonProps = {
    onClick: handleClick2,
    onKeyDown: handleKeyDown,
    className: classes,
    disabled
  };
  return import_react186.default.createElement("button", _extends({
    type: "button",
    ref: tabRef,
    role: "tab",
    tabIndex: selected ? 0 : -1,
    "aria-selected": selected
  }, other, commonProps), import_react186.default.createElement("span", {
    className: `${prefix}--content-switcher__label`,
    title: text
  }, text !== void 0 ? text : children));
});
Switch.displayName = "Switch";
Switch.propTypes = {
  /**
   * Provide child elements to be rendered inside of the Switch
   */
  children: import_prop_types141.default.node,
  /**
   * Specify an optional className to be added to your Switch
   */
  className: import_prop_types141.default.string,
  /**
   * Specify whether or not the Switch should be disabled
   */
  disabled: import_prop_types141.default.bool,
  /**
   * The index of your Switch in your ContentSwitcher that is used for event handlers.
   * Reserved for usage in ContentSwitcher
   */
  index: import_prop_types141.default.number,
  /**
   * Provide the name of your Switch that is used for event handlers
   */
  name: import_prop_types141.default.oneOfType([import_prop_types141.default.string, import_prop_types141.default.number]),
  /**
   * A handler that is invoked when a user clicks on the control.
   * Reserved for usage in ContentSwitcher
   */
  onClick: import_prop_types141.default.func,
  /**
   * A handler that is invoked on the key down event for the control.
   * Reserved for usage in ContentSwitcher
   */
  onKeyDown: import_prop_types141.default.func,
  /**
   * Whether your Switch is selected. Reserved for usage in ContentSwitcher
   */
  selected: import_prop_types141.default.bool,
  /**
   * Provide the contents of your Switch
   */
  text: import_prop_types141.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Switch/IconSwitch.js
var import_prop_types142 = __toESM(require_prop_types());
var import_react187 = __toESM(require_react());
var import_classnames121 = __toESM(require_classnames());
var noopFn2 = () => {
};
var IconSwitch = import_react187.default.forwardRef(function Switch3(props, tabRef) {
  const {
    align,
    children,
    className,
    disabled,
    enterDelayMs,
    index: index4,
    leaveDelayMs = 0,
    name,
    onClick = noopFn2,
    onKeyDown = noopFn2,
    selected = false,
    size: size6,
    text,
    ...other
  } = props;
  const prefix = usePrefix();
  const [isHovered, setIsHovered] = (0, import_react187.useState)(false);
  const handleClick2 = (e2) => {
    e2.preventDefault();
    onClick({
      index: index4,
      name,
      text
    });
  };
  const handleKeyDown = (event) => {
    const key = event.key || event.which;
    onKeyDown({
      index: index4,
      name,
      text,
      key
    });
  };
  const handleMouseEnter = () => {
    setIsHovered(true);
  };
  const handleMouseLeave = () => {
    setIsHovered(false);
  };
  const classes = (0, import_classnames121.default)(className, `${prefix}--content-switcher-btn`, {
    [`${prefix}--content-switcher--selected`]: selected
  });
  const iconButtonClasses = (0, import_classnames121.default)(`${prefix}--content-switcher-popover__wrapper`, {
    [`${prefix}--content-switcher-popover--selected`]: selected,
    [`${prefix}--content-switcher-popover--disabled`]: disabled
  });
  const commonProps = {
    onClick: handleClick2,
    onKeyDown: handleKeyDown,
    className: classes,
    disabled,
    align,
    enterDelayMs,
    leaveDelayMs,
    size: size6
  };
  return import_react187.default.createElement(IconButton, _extends({
    label: text,
    type: "button",
    ref: tabRef,
    role: "tab",
    tabIndex: selected || isHovered ? 0 : -1,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    onFocus: handleMouseEnter,
    onBlur: handleMouseLeave,
    "aria-selected": selected,
    "aria-label": text,
    wrapperClasses: iconButtonClasses
  }, other, commonProps), children);
});
IconSwitch.displayName = "IconSwitch";
IconSwitch.propTypes = {
  /**
   * Specify how the trigger should align with the tooltip
   */
  align: import_prop_types142.default.oneOf(["top", "top-left", "top-right", "bottom", "bottom-left", "bottom-right", "left", "right"]),
  /**
   * Provide child elements to be rendered inside of the Switch
   */
  children: import_prop_types142.default.node,
  /**
   * Specify an optional className to be added to your Switch
   */
  className: import_prop_types142.default.string,
  /**
   * Specify whether or not the Switch should be disabled
   */
  disabled: import_prop_types142.default.bool,
  /**
   * Specify the duration in milliseconds to delay before displaying the tooltip
   */
  enterDelayMs: import_prop_types142.default.number,
  /**
   * The index of your Switch in your ContentSwitcher that is used for event handlers.
   * Reserved for usage in ContentSwitcher
   */
  index: import_prop_types142.default.number,
  /**
   * Specify the duration in milliseconds to delay before hiding the tooltip
   */
  leaveDelayMs: import_prop_types142.default.number,
  /**
   * Provide the name of your Switch that is used for event handlers
   */
  name: import_prop_types142.default.oneOfType([import_prop_types142.default.string, import_prop_types142.default.number]),
  /**
   * A handler that is invoked when a user clicks on the control.
   * Reserved for usage in ContentSwitcher
   */
  onClick: import_prop_types142.default.func,
  /**
   * A handler that is invoked on the key down event for the control.
   * Reserved for usage in ContentSwitcher
   */
  onKeyDown: import_prop_types142.default.func,
  /**
   * Whether your Switch is selected. Reserved for usage in ContentSwitcher
   */
  selected: import_prop_types142.default.bool,
  /**
   * Passed in from `ContentSwitcher` to render icon-only variant
   */
  size: import_prop_types142.default.oneOf(["sm", "md", "lg"]),
  /**
   * Provide the visible text displayed by the Tooltip
   */
  text: import_prop_types142.default.string
};
var IconSwitch$1 = IconSwitch;

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Tabs/Tabs.js
var import_classnames122 = __toESM(require_classnames());
var import_prop_types143 = __toESM(require_prop_types());
var import_react190 = __toESM(require_react());
var import_react_is3 = __toESM(require_react_is2());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/internal/useEffectOnce.js
var import_react188 = __toESM(require_react());
function useEffectOnce(callback) {
  const savedCallback = (0, import_react188.useRef)(callback);
  const effectGuard = (0, import_react188.useRef)(false);
  (0, import_react188.useEffect)(() => {
    savedCallback.current = callback;
  });
  (0, import_react188.useEffect)(() => {
    if (effectGuard.current !== true) {
      effectGuard.current = true;
      savedCallback.current();
    }
  }, []);
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Tabs/usePressable.js
var import_react189 = __toESM(require_react());
function usePressable(ref) {
  let {
    onPress,
    onPressIn,
    onPressOut,
    onLongPress,
    delayLongPressMs = 500
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const savedOnPress = (0, import_react189.useRef)(onPress);
  const savedOnPressIn = (0, import_react189.useRef)(onPressIn);
  const savedOnPressOut = (0, import_react189.useRef)(onPressOut);
  const savedOnLongPress = (0, import_react189.useRef)(onLongPress);
  const [pendingLongPress, setPendingLongPress] = (0, import_react189.useState)(false);
  const [longPress, setLongPress] = (0, import_react189.useState)(false);
  const state = (0, import_react189.useRef)({
    longPress: false
  });
  (0, import_react189.useEffect)(() => {
    savedOnPress.current = onPress;
  }, [onPress]);
  (0, import_react189.useEffect)(() => {
    savedOnPressIn.current = onPressIn;
  }, [onPressIn]);
  (0, import_react189.useEffect)(() => {
    savedOnPressOut.current = onPressOut;
  }, [onPressOut]);
  (0, import_react189.useEffect)(() => {
    savedOnLongPress.current = onLongPress;
  }, [onLongPress]);
  (0, import_react189.useEffect)(() => {
    const {
      current: element
    } = ref;
    function onPointerDown(event) {
      var _a;
      setPendingLongPress(true);
      (_a = savedOnPressIn.current) == null ? void 0 : _a.call(savedOnPressIn);
      event.preventDefault();
    }
    function onPointerUp() {
      var _a;
      setPendingLongPress(false);
      setLongPress(false);
      (_a = savedOnPressOut.current) == null ? void 0 : _a.call(savedOnPressOut, state.current);
    }
    function onPointerCancel() {
      var _a;
      setPendingLongPress(false);
      setLongPress(false);
      (_a = savedOnPressOut.current) == null ? void 0 : _a.call(savedOnPressOut);
      state.current.longPress = false;
    }
    function onPointerLeave() {
      var _a;
      setPendingLongPress(false);
      setLongPress(false);
      (_a = savedOnPressOut.current) == null ? void 0 : _a.call(savedOnPressOut);
      state.current.longPress = false;
    }
    function onClick() {
      var _a;
      setLongPress(false);
      setPendingLongPress(false);
      (_a = savedOnPress.current) == null ? void 0 : _a.call(savedOnPress, state.current);
      state.current.longPress = false;
    }
    function onContextMenu(event) {
      event.preventDefault();
    }
    element.addEventListener("pointerdown", onPointerDown);
    element.addEventListener("pointerup", onPointerUp);
    element.addEventListener("pointercancel", onPointerCancel);
    element.addEventListener("pointerleave", onPointerLeave);
    element.addEventListener("click", onClick);
    element.addEventListener("contextmenu", onContextMenu);
    return () => {
      element.removeEventListener("pointerdown", onPointerDown);
      element.removeEventListener("pointerup", onPointerUp);
      element.removeEventListener("pointercancel", onPointerCancel);
      element.removeEventListener("pointerleave", onPointerLeave);
      element.removeEventListener("click", onClick);
      element.removeEventListener("contextmenu", onContextMenu);
    };
  }, [ref]);
  (0, import_react189.useEffect)(() => {
    if (pendingLongPress) {
      const timeoutId2 = setTimeout(() => {
        setPendingLongPress(false);
        setLongPress(true);
      }, delayLongPressMs);
      return () => {
        clearTimeout(timeoutId2);
      };
    }
  }, [pendingLongPress, delayLongPressMs]);
  (0, import_react189.useEffect)(() => {
    var _a;
    if (longPress) {
      state.current.longPress = true;
      return (_a = savedOnLongPress.current) == null ? void 0 : _a.call(savedOnLongPress);
    }
  }, [longPress]);
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Tabs/Tabs.js
var _ChevronLeft;
var _ChevronRight;
var verticalTabHeight = 64;
var TabsContext = import_react190.default.createContext({
  baseId: "",
  activeIndex: 0,
  defaultSelectedIndex: 0,
  dismissable: false,
  onTabCloseRequest() {
  },
  setActiveIndex() {
  },
  selectedIndex: 0,
  setSelectedIndex() {
  }
});
var TabContext = import_react190.default.createContext({
  index: 0,
  hasSecondaryLabel: false
});
var lgMediaQuery = `(min-width: ${breakpoints.lg.width})`;
var smMediaQuery = `(max-width: ${breakpoints.md.width})`;
var TabPanelContext = import_react190.default.createContext(0);
function Tabs(_ref) {
  let {
    children,
    defaultSelectedIndex = 0,
    onChange,
    selectedIndex: controlledSelectedIndex,
    dismissable,
    onTabCloseRequest
  } = _ref;
  const baseId = useId("ccs");
  const [activeIndex, setActiveIndex] = (0, import_react190.useState)(defaultSelectedIndex);
  const [selectedIndex, setSelectedIndex] = useControllableState({
    value: controlledSelectedIndex,
    defaultValue: defaultSelectedIndex,
    onChange: (value2) => onChange == null ? void 0 : onChange({
      selectedIndex: value2
    })
  });
  const value = {
    baseId,
    activeIndex,
    defaultSelectedIndex,
    dismissable,
    onTabCloseRequest,
    setActiveIndex,
    selectedIndex,
    setSelectedIndex
  };
  return import_react190.default.createElement(TabsContext.Provider, {
    value
  }, children);
}
Tabs.propTypes = {
  /**
   * Provide child elements to be rendered inside the `Tabs`.
   * These elements should render either `TabsList` or `TabsPanels`
   */
  children: import_prop_types143.default.node,
  /**
   * Specify which content tab should be initially selected when the component
   * is first rendered
   */
  defaultSelectedIndex: import_prop_types143.default.number,
  /**
   * Whether the render Tab children should be dismissable.
   */
  dismissable: import_prop_types143.default.bool,
  /**
   * Provide an optional function which is called whenever the state of the
   * `Tabs` changes
   */
  onChange: import_prop_types143.default.func,
  /**
   * If specifying the `onTabCloseRequest` prop, provide a callback function
   * responsible for removing the tab when close button is pressed on one of the Tab elements
   */
  onTabCloseRequest: (props) => {
    if (props.dismissable && !props.onTabCloseRequest) {
      return new Error("dismissable property specified without also providing an onTabCloseRequest property.");
    }
    return void 0;
  },
  /**
   * Control which content panel is currently selected. This puts the component
   * in a controlled mode and should be used along with `onChange`
   */
  selectedIndex: import_prop_types143.default.number
};
function TabsVertical(_ref2) {
  let {
    children,
    height,
    defaultSelectedIndex = 0,
    onChange,
    selectedIndex: controlledSelectedIndex,
    ...rest3
  } = _ref2;
  const [selectedIndex, setSelectedIndex] = useControllableState({
    value: controlledSelectedIndex,
    defaultValue: defaultSelectedIndex,
    onChange: (value) => onChange == null ? void 0 : onChange({
      selectedIndex: value
    })
  });
  const props = {
    ...rest3,
    selectedIndex,
    onChange: (_ref3) => {
      let {
        selectedIndex: selectedIndex2
      } = _ref3;
      return setSelectedIndex(selectedIndex2);
    }
  };
  const isSm = useMatchMedia(smMediaQuery);
  if (!isSm) {
    return (
      // eslint-disable-next-line react/forbid-component-props
      import_react190.default.createElement(GridAsGridComponent, {
        style: {
          height
        }
      }, import_react190.default.createElement(Tabs, props, children))
    );
  }
  return import_react190.default.createElement(Tabs, props, children);
}
TabsVertical.propTypes = {
  /**
   * Provide child elements to be rendered inside the `TabsVertical`.
   * These elements should render either `TabsListVertical` or `TabsPanels`
   */
  children: import_prop_types143.default.node,
  /**
   * Specify which content tab should be initially selected when the component
   * is first rendered
   */
  defaultSelectedIndex: import_prop_types143.default.number,
  /**
   * Option to set a height style only if using vertical variation
   */
  height: import_prop_types143.default.string,
  /**
   * Provide an optional function which is called whenever the state of the
   * `Tabs` changes
   */
  onChange: import_prop_types143.default.func,
  /**
   * Control which content panel is currently selected. This puts the component
   * in a controlled mode and should be used along with `onChange`
   */
  selectedIndex: import_prop_types143.default.number
};
function getNextIndex2(event, total, index4) {
  switch (true) {
    case match(event, ArrowRight2):
      return (index4 + 1) % total;
    case match(event, ArrowLeft):
      return (total + index4 - 1) % total;
    case match(event, Home):
      return 0;
    case match(event, End):
      return total - 1;
    default:
      return index4;
  }
}
function getNextIndexVertical(event, total, index4) {
  switch (true) {
    case match(event, ArrowDown):
      return (index4 + 1) % total;
    case match(event, ArrowUp2):
      return (total + index4 - 1) % total;
    case match(event, Home):
      return 0;
    case match(event, End):
      return total - 1;
    default:
      return index4;
  }
}
function TabList(_ref4) {
  let {
    activation = "automatic",
    "aria-label": label,
    children,
    className: customClassName,
    contained = false,
    fullWidth = false,
    iconSize,
    leftOverflowButtonProps,
    light,
    rightOverflowButtonProps,
    scrollDebounceWait = 200,
    scrollIntoView: scrollIntoView2,
    ...rest3
  } = _ref4;
  const {
    activeIndex,
    selectedIndex,
    setSelectedIndex,
    setActiveIndex,
    dismissable
  } = import_react190.default.useContext(TabsContext);
  const prefix = usePrefix();
  const ref = (0, import_react190.useRef)(null);
  const previousButton = (0, import_react190.useRef)(null);
  const nextButton = (0, import_react190.useRef)(null);
  const [isScrollable, setIsScrollable] = (0, import_react190.useState)(false);
  const [scrollLeft, setScrollLeft] = (0, import_react190.useState)(0);
  let hasSecondaryLabelTabs = false;
  if (contained) {
    hasSecondaryLabelTabs = import_react190.default.Children.toArray(children).some((child) => {
      return (0, import_react_is3.isElement)(child) && !!child.props.secondaryLabel;
    });
  }
  const isLg = useMatchMedia(lgMediaQuery);
  const distributeWidth = fullWidth && contained && isLg && import_react190.default.Children.toArray(children).length < 9;
  const className = (0, import_classnames122.default)(`${prefix}--tabs`, {
    [`${prefix}--tabs--contained`]: contained,
    [`${prefix}--tabs--light`]: light,
    [`${prefix}--tabs__icon--default`]: iconSize === "default",
    [`${prefix}--tabs__icon--lg`]: iconSize === "lg",
    // TODO: V12 - Remove this class
    [`${prefix}--layout--size-lg`]: iconSize === "lg",
    [`${prefix}--tabs--tall`]: hasSecondaryLabelTabs,
    [`${prefix}--tabs--full-width`]: distributeWidth,
    [`${prefix}--tabs--dismissable`]: dismissable
  }, customClassName);
  const buttonWidth = 44;
  const [isNextButtonVisible, setIsNextButtonVisible] = (0, import_react190.useState)(ref.current ? scrollLeft + buttonWidth + ref.current.clientWidth < ref.current.scrollWidth : false);
  const isPreviousButtonVisible = ref.current ? isScrollable && scrollLeft > 0 : false;
  const previousButtonClasses = (0, import_classnames122.default)(`${prefix}--tab--overflow-nav-button`, `${prefix}--tab--overflow-nav-button--previous`, {
    [`${prefix}--tab--overflow-nav-button--hidden`]: !isPreviousButtonVisible
  });
  const nextButtonClasses = (0, import_classnames122.default)(`${prefix}--tab--overflow-nav-button`, `${prefix}--tab--overflow-nav-button--next`, {
    [`${prefix}--tab--overflow-nav-button--hidden`]: !isNextButtonVisible
  });
  const tabs = (0, import_react190.useRef)([]);
  const debouncedOnScroll = (0, import_react190.useCallback)(() => {
    return debounce2((event) => {
      setScrollLeft(event.target.scrollLeft);
    }, scrollDebounceWait);
  }, [scrollDebounceWait]);
  function onKeyDown(event) {
    var _a;
    if (matches(event, [ArrowRight2, ArrowLeft, Home, End])) {
      event.preventDefault();
      const filteredTabs = tabs.current.filter((tab) => tab !== null);
      const activeTabs = filteredTabs.filter((tab) => !tab.disabled);
      const currentIndex = activeTabs.indexOf(tabs.current[activation === "automatic" ? selectedIndex : activeIndex]);
      const nextIndex = tabs.current.indexOf(activeTabs[getNextIndex2(event, activeTabs.length, currentIndex)]);
      if (activation === "automatic") {
        setSelectedIndex(nextIndex);
      } else if (activation === "manual") {
        setActiveIndex(nextIndex);
      }
      (_a = tabs.current[nextIndex]) == null ? void 0 : _a.focus();
    }
  }
  function handleBlur(_ref5) {
    var _a;
    let {
      relatedTarget: currentActiveNode
    } = _ref5;
    if ((_a = ref.current) == null ? void 0 : _a.contains(currentActiveNode)) {
      return;
    }
    if (activation === "manual") {
      setActiveIndex(selectedIndex);
    }
  }
  function scrollTabIntoView(tab) {
    if (!isScrollable || !ref.current) {
      return;
    }
    if (tab) {
      const {
        width: tabWidth
      } = tab.getBoundingClientRect();
      const start = tab.offsetLeft;
      const end = tab.offsetLeft + tabWidth;
      const visibleStart = ref.current.scrollLeft + buttonWidth;
      const visibleEnd = ref.current.scrollLeft + ref.current.clientWidth - buttonWidth;
      if (start < visibleStart) {
        setScrollLeft(start - buttonWidth);
      }
      if (end > visibleEnd) {
        setScrollLeft(end + buttonWidth - ref.current.clientWidth);
      }
    }
  }
  useEffectOnce(() => {
    const tab = tabs.current[selectedIndex];
    if (scrollIntoView2 && tab) {
      tab.scrollIntoView({
        block: "nearest",
        inline: "nearest"
      });
    }
  });
  (0, import_react190.useEffect)(() => {
    setIsNextButtonVisible(ref.current ? scrollLeft + buttonWidth + ref.current.clientWidth + 1 < ref.current.scrollWidth : false);
    if (dismissable) {
      if (ref.current) {
        setIsScrollable(ref.current.scrollWidth > ref.current.clientWidth);
      }
    }
  }, [scrollLeft, children, dismissable, isScrollable]);
  useEffectOnce(() => {
    var _a;
    if ((_a = tabs.current[selectedIndex]) == null ? void 0 : _a.disabled) {
      const activeTabs = tabs.current.filter((tab) => {
        return !tab.disabled;
      });
      if (activeTabs.length > 0) {
        const tab = activeTabs[0];
        setSelectedIndex(tabs.current.indexOf(tab));
      }
    }
  });
  useIsomorphicEffect$1(() => {
    if (ref.current) {
      setIsScrollable(ref.current.scrollWidth > ref.current.clientWidth + 1);
    }
    function handler() {
      if (ref.current) {
        setIsScrollable(ref.current.scrollWidth > ref.current.clientWidth + 1);
      }
    }
    const debouncedHandler = debounce2(handler, 200);
    window.addEventListener("resize", debouncedHandler);
    return () => {
      debouncedHandler.cancel();
      window.removeEventListener("resize", debouncedHandler);
    };
  }, []);
  useIsomorphicEffect$1(() => {
    if (scrollLeft !== null && ref.current) {
      ref.current.scrollLeft = scrollLeft;
    }
  }, [scrollLeft]);
  useIsomorphicEffect$1(() => {
    const tab = activation === "manual" ? tabs.current[activeIndex] : tabs.current[selectedIndex];
    scrollTabIntoView(tab);
  }, [activation, activeIndex]);
  useIsomorphicEffect$1(() => {
    const tab = tabs.current[selectedIndex];
    scrollTabIntoView(tab);
  }, [selectedIndex, isScrollable, children]);
  usePressable(previousButton, {
    onPress(_ref6) {
      let {
        longPress
      } = _ref6;
      if (!longPress && ref.current) {
        setScrollLeft(Math.max(scrollLeft - ref.current.scrollWidth / tabs.current.length * 1.5, 0));
      }
    },
    onLongPress() {
      return createLongPressBehavior(ref, "backward", setScrollLeft);
    }
  });
  usePressable(nextButton, {
    onPress(_ref7) {
      let {
        longPress
      } = _ref7;
      if (!longPress && ref.current) {
        setScrollLeft(Math.min(scrollLeft + ref.current.scrollWidth / tabs.current.length * 1.5, ref.current.scrollWidth - ref.current.clientWidth));
      }
    },
    onLongPress() {
      return createLongPressBehavior(ref, "forward", setScrollLeft);
    }
  });
  return import_react190.default.createElement("div", {
    className
  }, import_react190.default.createElement("button", _extends({
    "aria-hidden": "true",
    tabIndex: -1,
    "aria-label": "Scroll left",
    ref: previousButton,
    className: previousButtonClasses,
    type: "button"
  }, leftOverflowButtonProps), _ChevronLeft || (_ChevronLeft = import_react190.default.createElement(ChevronLeft, null))), import_react190.default.createElement("div", _extends({}, rest3, {
    "aria-label": label,
    ref,
    role: "tablist",
    className: `${prefix}--tab--list`,
    onScroll: debouncedOnScroll,
    onKeyDown,
    onBlur: handleBlur
  }), import_react190.default.Children.map(children, (child, index4) => {
    return !(0, import_react_is3.isElement)(child) ? null : import_react190.default.createElement(TabContext.Provider, {
      value: {
        index: index4,
        hasSecondaryLabel: hasSecondaryLabelTabs,
        contained
      }
    }, import_react190.default.cloneElement(child, {
      ref: (node) => {
        tabs.current[index4] = node;
      }
    }));
  })), import_react190.default.createElement("button", _extends({
    "aria-hidden": "true",
    tabIndex: -1,
    "aria-label": "Scroll right",
    ref: nextButton,
    className: nextButtonClasses,
    type: "button"
  }, rightOverflowButtonProps), _ChevronRight || (_ChevronRight = import_react190.default.createElement(ChevronRight, null))));
}
TabList.propTypes = {
  /**
   * Specify whether the content tab should be activated automatically or
   * manually
   */
  activation: import_prop_types143.default.oneOf(["automatic", "manual"]),
  /**
   * Provide an accessible label to be read when a user interacts with this
   * component
   */
  "aria-label": import_prop_types143.default.string,
  /**
   * Provide child elements to be rendered inside `ContentTabs`.
   * These elements should render a `ContentTab`
   */
  children: import_prop_types143.default.node,
  /**
   * Specify an optional className to be added to the container node
   */
  className: import_prop_types143.default.string,
  /**
   * Specify whether component is contained type
   */
  contained: import_prop_types143.default.bool,
  /**
   * Used for tabs within a grid, this makes it so tabs span the full container width and have the same width. Only available on contained tabs with <9 children
   */
  fullWidth: import_prop_types143.default.bool,
  /**
   * If using `IconTab`, specify the size of the icon being used.
   */
  iconSize: import_prop_types143.default.oneOf(["default", "lg"]),
  /**
   * Provide the props that describe the left overflow button
   */
  leftOverflowButtonProps: import_prop_types143.default.object,
  /**
   * Specify whether to use the light component variant
   */
  light: deprecate(import_prop_types143.default.bool, "The `light` prop for `TabList` has been deprecated in favor of the new `Layer` component. It will be removed in the next major release."),
  /**
   * Provide the props that describe the right overflow button
   */
  rightOverflowButtonProps: import_prop_types143.default.object,
  /**
   * Optionally provide a delay (in milliseconds) passed to the lodash
   * debounce of the onScroll handler. This will impact the responsiveness
   * of scroll arrow buttons rendering when scrolling to the first or last tab.
   */
  scrollDebounceWait: import_prop_types143.default.number,
  /**
   * Choose whether to automatically scroll
   * to newly selected tabs on component rerender
   */
  scrollIntoView: import_prop_types143.default.bool
};
function TabListVertical(_ref8) {
  let {
    activation = "automatic",
    "aria-label": label,
    children,
    className: customClassName,
    scrollIntoView: scrollIntoView2,
    ...rest3
  } = _ref8;
  const {
    activeIndex,
    selectedIndex,
    setSelectedIndex,
    setActiveIndex
  } = import_react190.default.useContext(TabsContext);
  const prefix = usePrefix();
  const ref = (0, import_react190.useRef)(null);
  const [isOverflowingBottom, setIsOverflowingBottom] = (0, import_react190.useState)(false);
  const [isOverflowingTop, setIsOverflowingTop] = (0, import_react190.useState)(false);
  const isSm = useMatchMedia(smMediaQuery);
  const className = (0, import_classnames122.default)(`${prefix}--tabs`, `${prefix}--tabs--vertical`, `${prefix}--tabs--contained`, customClassName);
  const tabs = (0, import_react190.useRef)([]);
  function onKeyDown(event) {
    var _a;
    if (matches(event, [ArrowDown, ArrowUp2, Home, End])) {
      event.preventDefault();
      const filteredTabs = tabs.current.filter((tab) => tab !== null);
      const activeTabs = filteredTabs.filter((tab) => !tab.disabled);
      const currentIndex = activeTabs.indexOf(tabs.current[activation === "automatic" ? selectedIndex : activeIndex]);
      const nextIndex = tabs.current.indexOf(activeTabs[getNextIndexVertical(event, activeTabs.length, currentIndex)]);
      if (activation === "automatic") {
        setSelectedIndex(nextIndex);
      } else if (activation === "manual") {
        setActiveIndex(nextIndex);
      }
      (_a = tabs.current[nextIndex]) == null ? void 0 : _a.focus();
    }
  }
  function handleBlur(_ref9) {
    var _a;
    let {
      relatedTarget: currentActiveNode
    } = _ref9;
    if ((_a = ref.current) == null ? void 0 : _a.contains(currentActiveNode)) {
      return;
    }
    if (activation === "manual") {
      setActiveIndex(selectedIndex);
    }
  }
  useEffectOnce(() => {
    var _a;
    if ((_a = tabs.current[selectedIndex]) == null ? void 0 : _a.disabled) {
      const activeTabs = tabs.current.filter((tab) => {
        return !tab.disabled;
      });
      if (activeTabs.length > 0) {
        const tab = activeTabs[0];
        setSelectedIndex(tabs.current.indexOf(tab));
      }
    }
  });
  (0, import_react190.useEffect)(() => {
    function handler() {
      var _a, _b, _c;
      const containerHeight = (_a = ref.current) == null ? void 0 : _a.offsetHeight;
      const containerTop = (_b = ref.current) == null ? void 0 : _b.getBoundingClientRect().top;
      const selectedPositionTop = (_c = tabs.current[selectedIndex]) == null ? void 0 : _c.getBoundingClientRect().top;
      const halfTabHeight = verticalTabHeight / 2;
      if (containerTop && containerHeight) {
        if (selectedPositionTop - halfTabHeight < containerTop || selectedPositionTop - containerTop + verticalTabHeight + halfTabHeight > containerHeight) {
          ref.current.scrollTo({
            top: (selectedIndex - 1) * verticalTabHeight,
            behavior: "smooth"
          });
        }
      }
    }
    window.addEventListener("resize", handler);
    handler();
    return () => {
      window.removeEventListener("resize", handler);
    };
  }, [selectedIndex, scrollIntoView2]);
  (0, import_react190.useEffect)(() => {
    const element = ref.current;
    if (!element) {
      return;
    }
    const handler = () => {
      const halfTabHeight = verticalTabHeight / 2;
      setIsOverflowingBottom(element.scrollTop + element.clientHeight + halfTabHeight <= element.scrollHeight);
      setIsOverflowingTop(element.scrollTop > halfTabHeight);
    };
    const resizeObserver = new ResizeObserver(() => handler());
    resizeObserver.observe(element);
    element.addEventListener("scroll", handler);
    return () => {
      resizeObserver.disconnect();
      element.removeEventListener("scroll", handler);
    };
  });
  if (isSm) {
    return import_react190.default.createElement(TabList, _extends({}, rest3, {
      "aria-label": label,
      contained: true
    }), children);
  }
  return import_react190.default.createElement("div", {
    className
  }, isOverflowingTop && import_react190.default.createElement("div", {
    className: `${prefix}--tab--list-gradient_top`
  }), import_react190.default.createElement("div", _extends({}, rest3, {
    "aria-label": label,
    ref,
    role: "tablist",
    className: `${prefix}--tab--list`,
    onKeyDown,
    onBlur: handleBlur
  }), import_react190.default.Children.map(children, (child, index4) => {
    return !(0, import_react_is3.isElement)(child) ? null : import_react190.default.createElement(TabContext.Provider, {
      value: {
        index: index4,
        hasSecondaryLabel: false
      }
    }, import_react190.default.cloneElement(child, {
      ref: (node) => {
        tabs.current[index4] = node;
      }
    }));
  })), isOverflowingBottom && import_react190.default.createElement("div", {
    className: `${prefix}--tab--list-gradient_bottom`
  }));
}
TabListVertical.propTypes = {
  /**
   * Specify whether the content tab should be activated automatically or
   * manually
   */
  activation: import_prop_types143.default.oneOf(["automatic", "manual"]),
  /**
   * Provide an accessible label to be read when a user interacts with this
   * component
   */
  "aria-label": import_prop_types143.default.string.isRequired,
  /**
   * Provide child elements to be rendered inside `ContentTabs`.
   * These elements should render a `ContentTab`
   */
  children: import_prop_types143.default.node,
  /**
   * Specify an optional className to be added to the container node
   */
  className: import_prop_types143.default.string
};
function createLongPressBehavior(ref, direction, setScrollLeft) {
  const node = ref.current;
  if (!node) {
    return () => {
    };
  }
  const defaultScrollBehavior = node == null ? void 0 : node.style["scroll-behavior"];
  node.style["scroll-behavior"] = "auto";
  const scrollDelta = direction === "forward" ? 5 : -5;
  let frameId = null;
  function tick() {
    if (!node) {
      return;
    }
    node.scrollLeft = node.scrollLeft + scrollDelta;
    frameId = requestAnimationFrame(tick);
  }
  frameId = requestAnimationFrame(tick);
  return () => {
    node.style["scroll-behavior"] = defaultScrollBehavior;
    setScrollLeft(node.scrollLeft);
    if (frameId) {
      cancelAnimationFrame(frameId);
    }
  };
}
var Tab2 = (0, import_react190.forwardRef)(function Tab3(_ref10, forwardRef13) {
  let {
    as = "button",
    children,
    className: customClassName,
    disabled,
    onClick,
    onKeyDown,
    secondaryLabel,
    renderIcon: Icon,
    ...rest3
  } = _ref10;
  const prefix = usePrefix();
  const {
    selectedIndex,
    setSelectedIndex,
    baseId,
    dismissable,
    onTabCloseRequest
  } = import_react190.default.useContext(TabsContext);
  const {
    index: index4,
    hasSecondaryLabel,
    contained
  } = import_react190.default.useContext(TabContext);
  const dismissIconRef = (0, import_react190.useRef)(null);
  const tabRef = (0, import_react190.useRef)(null);
  const ref = useMergedRefs([forwardRef13, tabRef]);
  const [ignoreHover, setIgnoreHover] = (0, import_react190.useState)(false);
  const id = `${baseId}-tab-${index4}`;
  const panelId = `${baseId}-tabpanel-${index4}`;
  const [isEllipsisApplied, setIsEllipsisApplied] = (0, import_react190.useState)(false);
  const isEllipsisActive2 = (element) => {
    setIsEllipsisApplied(element.offsetHeight < element.scrollHeight);
    return element.offsetHeight < element.scrollHeight;
  };
  const className = (0, import_classnames122.default)(`${prefix}--tabs__nav-item`, `${prefix}--tabs__nav-link`, {
    [`${prefix}--tabs__nav-item--selected`]: selectedIndex === index4,
    [`${prefix}--tabs__nav-item--disabled`]: disabled,
    [`${prefix}--tabs__nav-item--hover-off`]: ignoreHover
  }, customClassName);
  const BaseComponent = as;
  const onDismissIconMouseEnter = (evt) => {
    if (contained && tabRef.current) {
      evt.stopPropagation();
      setIgnoreHover(true);
      tabRef.current.classList.add(`${prefix}--tabs__nav-item--hover-off`);
    }
  };
  const onDismissIconMouseLeave = () => {
    if (contained && tabRef.current) {
      tabRef.current.classList.remove(`${prefix}--tabs__nav-item--hover-off`);
      setIgnoreHover(false);
    }
  };
  useEvent(dismissIconRef, "mouseover", onDismissIconMouseEnter);
  useEvent(dismissIconRef, "mouseleave", onDismissIconMouseLeave);
  useIsomorphicEffect$1(() => {
    function handler() {
      const elementTabId = document.getElementById(`${id}`) || tabRef.current;
      if (elementTabId == null ? void 0 : elementTabId.closest(`.${prefix}--tabs--vertical`)) {
        const newElement = elementTabId == null ? void 0 : elementTabId.getElementsByClassName(`${prefix}--tabs__nav-item-label`)[0];
        isEllipsisActive2(newElement);
      }
    }
    handler();
    window.addEventListener("resize", handler);
    return () => {
      window.removeEventListener("resize", handler);
    };
  }, [prefix, id]);
  const handleClose = (evt) => {
    var _a;
    evt.stopPropagation();
    onTabCloseRequest == null ? void 0 : onTabCloseRequest(index4);
    if (tabRef.current && tabRef.current.parentElement) {
      const tabCount = Array.from(tabRef.current.parentElement.childNodes).filter((node) => {
        const element = node;
        return element.classList.contains(`${prefix}--tabs__nav-link`) && !element.classList.contains(`${prefix}--tabs__nav-item--disabled`);
      }).length;
      if (tabRef.current && index4 + 1 !== tabCount) {
        tabRef.current.focus();
      } else {
        const prevTabIndex = (tabCount - 2) * 2;
        (_a = tabRef.current.parentElement.childNodes[prevTabIndex]) == null ? void 0 : _a.focus();
      }
    }
  };
  const handleKeyDown = (event) => {
    if (dismissable && match(event, Delete)) {
      handleClose(event);
    }
    onKeyDown == null ? void 0 : onKeyDown(event);
  };
  const DismissIcon = import_react190.default.createElement("div", {
    className: (0, import_classnames122.default)({
      [`${prefix}--tabs__nav-item--close`]: dismissable,
      [`${prefix}--tabs__nav-item--close--hidden`]: !dismissable
    })
  }, import_react190.default.createElement("button", {
    type: "button",
    tabIndex: selectedIndex === index4 && dismissable ? 0 : -1,
    "aria-disabled": disabled,
    "aria-hidden": selectedIndex === index4 && dismissable ? "false" : "true",
    disabled,
    className: (0, import_classnames122.default)({
      [`${prefix}--tabs__nav-item--close-icon`]: dismissable,
      [`${prefix}--visually-hidden`]: !dismissable,
      [`${prefix}--tabs__nav-item--close-icon--selected`]: selectedIndex === index4,
      [`${prefix}--tabs__nav-item--close-icon--disabled`]: disabled
    }),
    onClick: handleClose,
    title: `Remove ${typeof children === "string" ? children : ""} tab`,
    ref: dismissIconRef
  }, import_react190.default.createElement(Close, {
    "aria-hidden": selectedIndex === index4 && dismissable ? "false" : "true",
    "aria-label": `Press delete to remove ${typeof children === "string" ? children : ""} tab`
  })));
  const hasIcon = Icon ?? dismissable;
  if (isEllipsisApplied) {
    return import_react190.default.createElement(Tooltip, {
      label: children,
      align: "top",
      leaveDelayMs: 0,
      autoAlign: true,
      onMouseEnter: () => false,
      closeOnActivation: true
    }, import_react190.default.createElement(BaseComponent, _extends({}, rest3, {
      "aria-controls": panelId,
      "aria-disabled": disabled,
      "aria-selected": selectedIndex === index4,
      ref,
      id,
      role: "tab",
      className,
      disabled,
      title: children,
      onClick: (evt) => {
        if (disabled) {
          return;
        }
        setSelectedIndex(index4);
        onClick == null ? void 0 : onClick(evt);
      },
      onKeyDown: handleKeyDown,
      tabIndex: selectedIndex === index4 ? "0" : "-1",
      type: "button"
    }), import_react190.default.createElement("div", {
      className: `${prefix}--tabs__nav-item-label-wrapper`
    }, import_react190.default.createElement(Text, {
      className: `${prefix}--tabs__nav-item-label`
    }, children)), hasSecondaryLabel && secondaryLabel && import_react190.default.createElement(Text, {
      as: "div",
      className: `${prefix}--tabs__nav-item-secondary-label`,
      title: secondaryLabel
    }, secondaryLabel)));
  }
  return import_react190.default.createElement(import_react190.default.Fragment, null, import_react190.default.createElement(BaseComponent, _extends({}, rest3, {
    "aria-controls": panelId,
    "aria-disabled": disabled,
    "aria-selected": selectedIndex === index4,
    ref,
    id,
    role: "tab",
    className,
    disabled,
    onClick: (evt) => {
      if (disabled) {
        return;
      }
      setSelectedIndex(index4);
      onClick == null ? void 0 : onClick(evt);
    },
    onKeyDown: handleKeyDown,
    tabIndex: selectedIndex === index4 ? "0" : "-1",
    type: "button"
  }), import_react190.default.createElement("div", {
    className: `${prefix}--tabs__nav-item-label-wrapper`
  }, dismissable && Icon && import_react190.default.createElement("div", {
    className: `${prefix}--tabs__nav-item--icon-left`
  }, import_react190.default.createElement(Icon, {
    size: 16
  })), import_react190.default.createElement(Text, {
    className: `${prefix}--tabs__nav-item-label`
  }, children), !dismissable && Icon && import_react190.default.createElement("div", {
    className: (0, import_classnames122.default)(`${prefix}--tabs__nav-item--icon`, {
      [`${prefix}--visually-hidden`]: !hasIcon
    })
  }, !dismissable && Icon && import_react190.default.createElement(Icon, {
    size: 16
  }))), hasSecondaryLabel && secondaryLabel && import_react190.default.createElement(Text, {
    as: "div",
    className: `${prefix}--tabs__nav-item-secondary-label`,
    title: secondaryLabel
  }, secondaryLabel)), DismissIcon);
});
Tab2.propTypes = {
  /**
   * Provide a custom element to render instead of the default button
   */
  // @ts-expect-error: Invalid prop type derivation
  as: import_prop_types143.default.oneOfType([import_prop_types143.default.string, import_prop_types143.default.elementType]),
  /**
   * Provide child elements to be rendered inside `Tab`.
   */
  children: import_prop_types143.default.node,
  /**
   * Specify an optional className to be added to your Tab
   */
  className: import_prop_types143.default.string,
  /**
   * Whether your Tab is disabled.
   */
  disabled: import_prop_types143.default.bool,
  /**
   * Provide a handler that is invoked when a user clicks on the control
   */
  onClick: import_prop_types143.default.func,
  /**
   * Provide a handler that is invoked on the key down event for the control
   */
  onKeyDown: import_prop_types143.default.func,
  /*
   * An optional parameter to allow overriding the anchor rendering.
   * Useful for using Tab along with react-router or other client
   * side router libraries.
   **/
  renderButton: import_prop_types143.default.func,
  /**
   * Optional prop to render an icon next to the label.
   * Can be a React component class
   */
  // @ts-expect-error: Invalid prop type derivation
  renderIcon: import_prop_types143.default.oneOfType([import_prop_types143.default.func, import_prop_types143.default.object]),
  /*
   * An optional label to render under the primary tab label.
  /* This prop is only useful for conained tabs
   **/
  secondaryLabel: import_prop_types143.default.string
};
var IconTab = import_react190.default.forwardRef(function IconTab2(_ref11, ref) {
  let {
    children,
    className: customClassName,
    defaultOpen = false,
    enterDelayMs,
    leaveDelayMs,
    label,
    ...rest3
  } = _ref11;
  const prefix = usePrefix();
  const classNames = (0, import_classnames122.default)(`${prefix}--tabs__nav-item--icon-only`, customClassName);
  return import_react190.default.createElement(Tooltip, {
    align: "bottom",
    defaultOpen,
    className: `${prefix}--icon-tooltip`,
    enterDelayMs,
    label,
    leaveDelayMs
  }, import_react190.default.createElement(Tab2, _extends({
    className: classNames,
    ref
  }, rest3), children));
});
IconTab.propTypes = {
  /**
   * Provide an icon to be rendered inside `IconTab` as the visual label for Tab.
   */
  children: import_prop_types143.default.node,
  /**
   * Specify an optional className to be added to your Tab
   */
  className: import_prop_types143.default.string,
  /**
   * Specify whether the tooltip for the icon should be open when it first renders
   */
  defaultOpen: import_prop_types143.default.bool,
  /**
   * Specify the duration in milliseconds to delay before displaying the tooltip for the icon.
   */
  enterDelayMs: import_prop_types143.default.number,
  /**
   * Provide the label to be rendered inside the Tooltip. The label will use
   * `aria-labelledby` and will fully describe the child node that is provided.
   * This means that if you have text in the child node it will not be
   * announced to the screen reader.
   */
  label: import_prop_types143.default.node.isRequired,
  /**
   * Specify the duration in milliseconds to delay before hiding the tooltip
   */
  leaveDelayMs: import_prop_types143.default.number
};
var TabPanel = import_react190.default.forwardRef(function TabPanel2(_ref12, forwardRef13) {
  let {
    children,
    className: customClassName,
    ...rest3
  } = _ref12;
  const prefix = usePrefix();
  const panel = (0, import_react190.useRef)(null);
  const ref = useMergedRefs([forwardRef13, panel]);
  const [tabIndex, setTabIndex] = (0, import_react190.useState)(0);
  const [interactiveContent, setInteractiveContent] = (0, import_react190.useState)(false);
  const {
    selectedIndex,
    baseId
  } = import_react190.default.useContext(TabsContext);
  const index4 = import_react190.default.useContext(TabPanelContext);
  const id = `${baseId}-tabpanel-${index4}`;
  const tabId = `${baseId}-tab-${index4}`;
  const className = (0, import_classnames122.default)(`${prefix}--tab-content`, customClassName, {
    [`${prefix}--tab-content--interactive`]: interactiveContent
  });
  useEffectOnce(() => {
    if (!panel.current) {
      return;
    }
    const content = getInteractiveContent(panel.current);
    if (content) {
      setInteractiveContent(true);
      setTabIndex(-1);
    }
  });
  (0, import_react190.useEffect)(() => {
    const node = panel.current;
    if (!node) {
      return;
    }
    function callback() {
      const content = getInteractiveContent(node);
      if (content) {
        setInteractiveContent(true);
        setTabIndex(-1);
      } else {
        setInteractiveContent(false);
        setTabIndex(0);
      }
    }
    const observer = new MutationObserver(callback);
    observer.observe(node, {
      childList: true,
      subtree: true
    });
    return () => observer.disconnect();
  }, []);
  return import_react190.default.createElement("div", _extends({}, rest3, {
    "aria-labelledby": tabId,
    id,
    className,
    ref,
    role: "tabpanel",
    tabIndex,
    hidden: selectedIndex !== index4
  }), children);
});
TabPanel.propTypes = {
  /**
   * Provide child elements to be rendered inside `TabPanel`.
   */
  children: import_prop_types143.default.node,
  /**
   * Specify an optional className to be added to TabPanel.
   */
  className: import_prop_types143.default.string
};
function TabPanels(_ref13) {
  let {
    children
  } = _ref13;
  const prefix = usePrefix();
  const refs = (0, import_react190.useRef)([]);
  const hiddenStates = (0, import_react190.useRef)([]);
  useIsomorphicEffect$1(() => {
    var _a, _b;
    const tabContainer = (_a = refs.current[0]) == null ? void 0 : _a.previousElementSibling;
    const isVertical = tabContainer == null ? void 0 : tabContainer.classList.contains(`${prefix}--tabs--vertical`);
    const parentHasHeight = (_b = tabContainer == null ? void 0 : tabContainer.parentElement) == null ? void 0 : _b.style.height;
    if (isVertical && !parentHasHeight) {
      hiddenStates.current = refs.current.map((ref) => (ref == null ? void 0 : ref.hidden) || false);
      refs.current.forEach((ref) => {
        if (ref) {
          ref.hidden = false;
        }
      });
      const heights = refs.current.map((ref) => (ref == null ? void 0 : ref.offsetHeight) || 0);
      const max4 = Math.max(...heights);
      tabContainer.style.height = max4 + "px";
      refs.current.forEach((ref, index4) => {
        if (ref) {
          ref.hidden = hiddenStates.current[index4];
        }
      });
    }
  });
  return import_react190.default.createElement(import_react190.default.Fragment, null, import_react190.default.Children.map(children, (child, index4) => {
    return !(0, import_react_is3.isElement)(child) ? null : import_react190.default.createElement(TabPanelContext.Provider, {
      value: index4
    }, import_react190.default.cloneElement(child, {
      ref: (element) => {
        refs.current[index4] = element;
      }
    }));
  }));
}
TabPanels.propTypes = {
  /**
   * Provide child elements to be rendered inside `TabPanels`.
   */
  children: import_prop_types143.default.node
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/TabContent/TabContent.js
var import_prop_types144 = __toESM(require_prop_types());
var import_react191 = __toESM(require_react());
var import_classnames123 = __toESM(require_classnames());
function useTabbableContent(ref) {
  const [hasTabbableContent, setHasTabbableContent] = (0, import_react191.useState)(false);
  useIsomorphicEffect$1(() => {
    if (ref.current) {
      setHasTabbableContent(!!ref.current.querySelector(selectorTabbable));
    }
  });
  return hasTabbableContent;
}
function TabContent(props) {
  const {
    className,
    selected,
    children,
    ...other
  } = props;
  const prefix = usePrefix();
  const tabContentClasses = (0, import_classnames123.default)(`${prefix}--tab-content`, className);
  const ref = (0, import_react191.useRef)(null);
  const hasTabbableContent = useTabbableContent(ref);
  return import_react191.default.createElement("div", _extends({
    role: "tabpanel"
  }, other, {
    className: tabContentClasses,
    selected,
    hidden: !selected,
    ref,
    tabIndex: hasTabbableContent ? void 0 : 0
  }), children);
}
TabContent.propTypes = {
  /**
   * Pass in content to render inside the TabContent
   */
  children: import_prop_types144.default.node,
  /**
   * Provide a className for the tab content container
   */
  className: import_prop_types144.default.string,
  /**
   * Specify whether the TabContent is selected
   */
  selected: import_prop_types144.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Tabs/Tabs.Skeleton.js
var import_prop_types145 = __toESM(require_prop_types());
var import_react192 = __toESM(require_react());
var import_classnames124 = __toESM(require_classnames());
var _span7;
var _Tab;
var _Tab2;
var _Tab3;
var _Tab4;
var _Tab5;
function Tab4() {
  const prefix = usePrefix();
  return import_react192.default.createElement("li", {
    className: `${prefix}--tabs__nav-item`
  }, import_react192.default.createElement("div", {
    className: `${prefix}--tabs__nav-link`
  }, _span7 || (_span7 = import_react192.default.createElement("span", null))));
}
function TabsSkeleton(_ref) {
  let {
    className,
    contained,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const tabClasses = (0, import_classnames124.default)(className, `${prefix}--tabs`, `${prefix}--skeleton`, {
    [`${prefix}--tabs--contained`]: contained
  });
  return import_react192.default.createElement("div", _extends({
    className: tabClasses
  }, rest3), import_react192.default.createElement("ul", {
    className: `${prefix}--tabs__nav`
  }, _Tab || (_Tab = import_react192.default.createElement(Tab4, null)), _Tab2 || (_Tab2 = import_react192.default.createElement(Tab4, null)), _Tab3 || (_Tab3 = import_react192.default.createElement(Tab4, null)), _Tab4 || (_Tab4 = import_react192.default.createElement(Tab4, null)), _Tab5 || (_Tab5 = import_react192.default.createElement(Tab4, null))));
}
TabsSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types145.default.string,
  /**
   * Provide the type of Tab
   */
  contained: import_prop_types145.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Tag/Tag.js
var import_prop_types146 = __toESM(require_prop_types());
var import_react193 = __toESM(require_react());
var import_classnames125 = __toESM(require_classnames());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Tag/isEllipsisActive.js
var isEllipsisActive = (element) => {
  if (element) {
    return (element == null ? void 0 : element.offsetWidth) < (element == null ? void 0 : element.scrollWidth);
  }
  return false;
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Tag/Tag.js
var _Close6;
var TYPES = {
  red: "Red",
  magenta: "Magenta",
  purple: "Purple",
  blue: "Blue",
  cyan: "Cyan",
  teal: "Teal",
  green: "Green",
  gray: "Gray",
  "cool-gray": "Cool-Gray",
  "warm-gray": "Warm-Gray",
  "high-contrast": "High-Contrast",
  outline: "Outline"
};
var SIZES = {
  sm: "sm",
  md: "md",
  lg: "lg"
};
var Tag = import_react193.default.forwardRef((_ref, forwardRef13) => {
  var _a;
  let {
    children,
    className,
    decorator,
    id,
    type,
    filter: filter2,
    // remove filter in next major release - V12
    renderIcon: CustomIconElement,
    title = "Clear filter",
    // remove title in next major release - V12
    disabled,
    onClose,
    // remove onClose in next major release - V12
    size: size6,
    as: BaseComponent,
    slug,
    ...other
  } = _ref;
  const prefix = usePrefix();
  const tagRef = (0, import_react193.useRef)();
  const ref = useMergeRefs([forwardRef13, tagRef]);
  const tagId = id || `tag-${useId()}`;
  const [isEllipsisApplied, setIsEllipsisApplied] = (0, import_react193.useState)(false);
  (0, import_react193.useLayoutEffect)(() => {
    var _a2;
    const newElement = (_a2 = tagRef.current) == null ? void 0 : _a2.getElementsByClassName(`${prefix}--tag__label`)[0];
    setIsEllipsisApplied(isEllipsisActive(newElement));
  }, [prefix, tagRef]);
  const conditions = [`${prefix}--tag--selectable`, `${prefix}--tag--filter`, `${prefix}--tag--operational`];
  const isInteractiveTag = conditions.some((el) => className == null ? void 0 : className.includes(el));
  const tagClasses = (0, import_classnames125.default)(`${prefix}--tag`, className, {
    [`${prefix}--tag--disabled`]: disabled,
    [`${prefix}--tag--filter`]: filter2,
    [`${prefix}--tag--${size6}`]: size6,
    // TODO: V12 - Remove this class
    [`${prefix}--layout--size-${size6}`]: size6,
    [`${prefix}--tag--${type}`]: type,
    [`${prefix}--tag--interactive`]: other.onClick && !isInteractiveTag && isEllipsisApplied
  });
  const typeText = type !== void 0 && type in Object.keys(TYPES) ? TYPES[type] : "";
  const handleClose = (event) => {
    if (onClose) {
      event.stopPropagation();
      onClose(event);
    }
  };
  let normalizedDecorator = import_react193.default.isValidElement(slug ?? decorator) ? slug ?? decorator : null;
  if (normalizedDecorator && ((_a = normalizedDecorator["type"]) == null ? void 0 : _a.displayName) === "AILabel" && !isInteractiveTag) {
    normalizedDecorator = import_react193.default.cloneElement(normalizedDecorator, {
      size: "sm",
      kind: "inline"
    });
  }
  if (filter2) {
    const ComponentTag2 = BaseComponent ?? "div";
    return import_react193.default.createElement(ComponentTag2, _extends({
      className: tagClasses,
      id: tagId
    }, other), CustomIconElement && size6 !== "sm" ? import_react193.default.createElement("div", {
      className: `${prefix}--tag__custom-icon`
    }, import_react193.default.createElement(CustomIconElement, null)) : "", import_react193.default.createElement(Text, {
      title: typeof children === "string" ? children : void 0,
      className: `${prefix}--tag__label`
    }, children !== null && children !== void 0 ? children : typeText), normalizedDecorator, import_react193.default.createElement("button", {
      type: "button",
      className: `${prefix}--tag__close-icon`,
      onClick: handleClose,
      disabled,
      "aria-label": title,
      title
    }, _Close6 || (_Close6 = import_react193.default.createElement(Close, null))));
  }
  const ComponentTag = BaseComponent ?? (other.onClick || (className == null ? void 0 : className.includes(`${prefix}--tag--operational`)) ? "button" : "div");
  const labelClasses = (0, import_classnames125.default)({
    [`${prefix}--tag__label`]: !isInteractiveTag
  });
  return import_react193.default.createElement(ComponentTag, _extends({
    ref,
    disabled,
    className: tagClasses,
    id: tagId,
    type: ComponentTag === "button" ? "button" : void 0
  }, other), CustomIconElement && size6 !== "sm" ? import_react193.default.createElement("div", {
    className: `${prefix}--tag__custom-icon`
  }, import_react193.default.createElement(CustomIconElement, null)) : "", isEllipsisApplied && !isInteractiveTag ? import_react193.default.createElement(DefinitionTooltip, {
    openOnHover: false,
    definition: children !== null && children !== void 0 ? children : typeText,
    className: `${prefix}--definition--tooltip--tag`
  }, import_react193.default.createElement(Text, {
    title: children !== null && children !== void 0 && typeof children === "string" ? children : typeText,
    className: labelClasses
  }, children !== null && children !== void 0 ? children : typeText)) : import_react193.default.createElement(Text, {
    title: children !== null && children !== void 0 && typeof children === "string" ? children : typeText,
    className: labelClasses
  }, children !== null && children !== void 0 ? children : typeText), slug ? normalizedDecorator : decorator ? import_react193.default.createElement("div", {
    className: `${prefix}--tag__decorator`
  }, normalizedDecorator) : "");
});
Tag.propTypes = {
  /**
   * Provide an alternative tag or component to use instead of the default
   * wrapping element
   */
  as: import_prop_types146.default.elementType,
  /**
   * Provide content to be rendered inside of a `Tag`
   */
  children: import_prop_types146.default.node,
  /**
   * Provide a custom className that is applied to the containing <span>
   */
  className: import_prop_types146.default.string,
  /**
   * **Experimental:** Provide a `decorator` component to be rendered inside the `Tag` component
   */
  decorator: import_prop_types146.default.node,
  /**
   * Specify if the `Tag` is disabled
   */
  disabled: import_prop_types146.default.bool,
  /**
   * Determine if `Tag` is a filter/chip
   */
  filter: deprecate(import_prop_types146.default.bool, "The `filter` prop has been deprecated and will be removed in the next major version. Use DismissibleTag instead."),
  /**
   * Specify the id for the tag.
   */
  id: import_prop_types146.default.string,
  /**
   * Click handler for filter tag close button.
   */
  onClose: deprecate(import_prop_types146.default.func, "The `onClose` prop has been deprecated and will be removed in the next major version. Use DismissibleTag instead."),
  /**
   * Optional prop to render a custom icon.
   * Can be a React component class
   */
  renderIcon: import_prop_types146.default.oneOfType([import_prop_types146.default.func, import_prop_types146.default.object]),
  /**
   * Specify the size of the Tag. Currently supports either `sm`,
   * `md` (default) or `lg` sizes.
   */
  size: import_prop_types146.default.oneOf(Object.keys(SIZES)),
  /**
   * **Experimental:** Provide a `Slug` component to be rendered inside the `Tag` component
   */
  slug: deprecate(import_prop_types146.default.node, "The `slug` prop has been deprecated and will be removed in the next major version. Use the decorator prop instead."),
  /**
   * Text to show on clear filters
   */
  title: deprecate(import_prop_types146.default.string, "The `title` prop has been deprecated and will be removed in the next major version. Use DismissibleTag instead."),
  /**
   * Specify the type of the `Tag`
   */
  type: import_prop_types146.default.oneOf(Object.keys(TYPES))
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Tag/DismissibleTag.js
var import_prop_types147 = __toESM(require_prop_types());
var import_react195 = __toESM(require_react());
var import_classnames126 = __toESM(require_classnames());
var _Close7;
var DismissibleTag = (_ref) => {
  var _a;
  let {
    className,
    decorator,
    disabled,
    id,
    renderIcon,
    title = "Dismiss",
    onClose,
    slug,
    size: size6,
    text,
    tagTitle,
    type,
    ...other
  } = _ref;
  const prefix = usePrefix();
  const tagLabelRef = (0, import_react195.useRef)(null);
  const tagId = id || `tag-${useId()}`;
  const tagClasses = (0, import_classnames126.default)(`${prefix}--tag--filter`, className);
  const [isEllipsisApplied, setIsEllipsisApplied] = (0, import_react195.useState)(false);
  (0, import_react195.useLayoutEffect)(() => {
    var _a2;
    const newElement = (_a2 = tagLabelRef.current) == null ? void 0 : _a2.getElementsByClassName(`${prefix}--tag__label`)[0];
    setIsEllipsisApplied(isEllipsisActive(newElement));
  }, [prefix, tagLabelRef]);
  const handleClose = (event) => {
    if (onClose) {
      event.stopPropagation();
      onClose(event);
    }
  };
  let normalizedDecorator = import_react195.default.isValidElement(slug ?? decorator) ? slug ?? decorator : null;
  if (normalizedDecorator && ((_a = normalizedDecorator["type"]) == null ? void 0 : _a.displayName) === "AILabel") {
    normalizedDecorator = import_react195.default.cloneElement(normalizedDecorator, {
      size: "sm",
      kind: "inline"
    });
  }
  const tooltipClasses = (0, import_classnames126.default)(`${prefix}--icon-tooltip`, `${prefix}--tag-label-tooltip`);
  const {
    onClick,
    ...otherProps
  } = other;
  const dismissLabel = `Dismiss "${text}"`;
  return import_react195.default.createElement(Tag, _extends({
    ref: tagLabelRef,
    type,
    size: size6,
    renderIcon,
    disabled,
    className: tagClasses,
    id: tagId
  }, otherProps), import_react195.default.createElement("div", {
    className: `${prefix}--interactive--tag-children`
  }, import_react195.default.createElement(Text, {
    title: tagTitle ? tagTitle : text,
    className: `${prefix}--tag__label`
  }, text), slug ? normalizedDecorator : decorator ? import_react195.default.createElement("div", {
    className: `${prefix}--tag__decorator`
  }, normalizedDecorator) : "", import_react195.default.createElement(Tooltip, {
    label: isEllipsisApplied ? dismissLabel : title,
    align: "bottom",
    className: tooltipClasses,
    leaveDelayMs: 0,
    closeOnActivation: true
  }, import_react195.default.createElement("button", {
    type: "button",
    className: `${prefix}--tag__close-icon`,
    onClick: handleClose,
    disabled,
    "aria-label": title
  }, _Close7 || (_Close7 = import_react195.default.createElement(Close, null))))));
};
DismissibleTag.propTypes = {
  /**
   * Provide a custom className that is applied to the containing <span>
   */
  className: import_prop_types147.default.string,
  /**
   * **Experimental:** Provide a `decorator` component to be rendered inside the `DismissibleTag` component
   */
  decorator: import_prop_types147.default.node,
  /**
   * Specify if the `DismissibleTag` is disabled
   */
  disabled: import_prop_types147.default.bool,
  /**
   * Specify the id for the tag.
   */
  id: import_prop_types147.default.string,
  /**
   * Click handler for filter tag close button.
   */
  onClose: import_prop_types147.default.func,
  /**
   * Optional prop to render a custom icon.
   * Can be a React component class
   */
  renderIcon: import_prop_types147.default.oneOfType([import_prop_types147.default.func, import_prop_types147.default.object]),
  /**
   * Specify the size of the Tag. Currently supports either `sm`,
   * `md` (default) or `lg` sizes.
   */
  size: import_prop_types147.default.oneOf(Object.keys(SIZES)),
  /**
   * **Experimental:** Provide a `Slug` component to be rendered inside the `DismissibleTag` component
   */
  slug: deprecate(import_prop_types147.default.node, "The `slug` prop has been deprecated and will be removed in the next major version. Use the decorator prop instead."),
  /**
   * Provide text to be rendered inside of a the tag.
   */
  text: import_prop_types147.default.string,
  /**
   * Provide a custom `title` to be inserted in the tag.
   */
  tagTitle: import_prop_types147.default.string,
  /**
   * Text to show on clear filters
   */
  title: import_prop_types147.default.string,
  /**
   * Specify the type of the `Tag`
   */
  type: import_prop_types147.default.oneOf(Object.keys(TYPES))
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Tag/OperationalTag.js
var import_prop_types148 = __toESM(require_prop_types());
var import_react196 = __toESM(require_react());
var import_classnames127 = __toESM(require_classnames());
var TYPES2 = {
  red: "Red",
  magenta: "Magenta",
  purple: "Purple",
  blue: "Blue",
  cyan: "Cyan",
  teal: "Teal",
  green: "Green",
  gray: "Gray",
  "cool-gray": "Cool-Gray",
  "warm-gray": "Warm-Gray"
};
var OperationalTag = (_ref) => {
  let {
    className,
    disabled,
    id,
    renderIcon,
    size: size6,
    text,
    type = "gray",
    ...other
  } = _ref;
  const prefix = usePrefix();
  const tagRef = (0, import_react196.useRef)(null);
  const tagId = id || `tag-${useId()}`;
  const tagClasses = (0, import_classnames127.default)(`${prefix}--tag--operational`, className);
  const [isEllipsisApplied, setIsEllipsisApplied] = (0, import_react196.useState)(false);
  (0, import_react196.useLayoutEffect)(() => {
    var _a;
    const newElement = (_a = tagRef.current) == null ? void 0 : _a.getElementsByClassName(`${prefix}--tag__label`)[0];
    setIsEllipsisApplied(isEllipsisActive(newElement));
  }, [prefix, tagRef]);
  const tooltipClasses = (0, import_classnames127.default)(`${prefix}--icon-tooltip`, `${prefix}--tag-label-tooltip`);
  if (isEllipsisApplied) {
    return import_react196.default.createElement(Tooltip, {
      label: text,
      align: "bottom",
      className: tooltipClasses,
      leaveDelayMs: 0,
      onMouseEnter: () => false,
      closeOnActivation: true
    }, import_react196.default.createElement(Tag, _extends({
      ref: tagRef,
      type,
      size: size6,
      renderIcon,
      disabled,
      className: tagClasses,
      id: tagId
    }, other), import_react196.default.createElement(Text, {
      title: text,
      className: `${prefix}--tag__label`
    }, text)));
  }
  return import_react196.default.createElement(Tag, _extends({
    ref: tagRef,
    type,
    size: size6,
    renderIcon,
    disabled,
    className: tagClasses,
    id: tagId
  }, other), import_react196.default.createElement(Text, {
    title: text,
    className: `${prefix}--tag__label`
  }, text));
};
OperationalTag.propTypes = {
  /**
   * Provide a custom className that is applied to the containing <span>
   */
  className: import_prop_types148.default.string,
  /**
   * Specify if the `OperationalTag` is disabled
   */
  disabled: import_prop_types148.default.bool,
  /**
   * Specify the id for the tag.
   */
  id: import_prop_types148.default.string,
  /**
   * Optional prop to render a custom icon.
   * Can be a React component class
   */
  renderIcon: import_prop_types148.default.oneOfType([import_prop_types148.default.func, import_prop_types148.default.object]),
  /**
   * Specify the size of the Tag. Currently supports either `sm`,
   * `md` (default) or `lg` sizes.
   */
  size: import_prop_types148.default.oneOf(Object.keys(SIZES)),
  /**
   * Provide text to be rendered inside of a the tag.
   */
  text: import_prop_types148.default.string,
  /**
   * Specify the type of the `Tag`
   */
  type: import_prop_types148.default.oneOf(Object.keys(TYPES2))
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Tag/SelectableTag.js
var import_prop_types149 = __toESM(require_prop_types());
var import_react197 = __toESM(require_react());
var import_classnames128 = __toESM(require_classnames());
var SelectableTag = (_ref) => {
  let {
    className,
    disabled,
    id,
    renderIcon,
    onChange,
    onClick,
    selected = false,
    size: size6,
    text,
    ...other
  } = _ref;
  const prefix = usePrefix();
  const tagRef = (0, import_react197.useRef)(null);
  const tagId = id || `tag-${useId()}`;
  const [selectedTag, setSelectedTag] = (0, import_react197.useState)(selected);
  const tagClasses = (0, import_classnames128.default)(`${prefix}--tag--selectable`, className, {
    [`${prefix}--tag--selectable-selected`]: selectedTag
  });
  const [isEllipsisApplied, setIsEllipsisApplied] = (0, import_react197.useState)(false);
  (0, import_react197.useLayoutEffect)(() => {
    var _a;
    const newElement = (_a = tagRef.current) == null ? void 0 : _a.getElementsByClassName(`${prefix}--tag__label`)[0];
    setIsEllipsisApplied(isEllipsisActive(newElement));
  }, [prefix, tagRef]);
  const tooltipClasses = (0, import_classnames128.default)(`${prefix}--icon-tooltip`, `${prefix}--tag-label-tooltip`);
  const handleClick2 = (e2) => {
    setSelectedTag(!selectedTag);
    onChange == null ? void 0 : onChange(!selectedTag);
    onClick == null ? void 0 : onClick(e2);
  };
  if (isEllipsisApplied) {
    return import_react197.default.createElement(Tooltip, {
      label: text,
      align: "bottom",
      className: tooltipClasses,
      leaveDelayMs: 0,
      onMouseEnter: () => false
    }, import_react197.default.createElement(Tag, _extends({
      "aria-pressed": selectedTag !== false,
      ref: tagRef,
      size: size6,
      renderIcon,
      disabled,
      className: tagClasses,
      id: tagId,
      onClick: handleClick2
    }, other), import_react197.default.createElement(Text, {
      title: text,
      className: `${prefix}--tag__label`
    }, text)));
  }
  return import_react197.default.createElement(Tag, _extends({
    "aria-pressed": selectedTag !== false,
    ref: tagRef,
    size: size6,
    renderIcon,
    disabled,
    className: tagClasses,
    id: tagId,
    onClick: handleClick2
  }, other), import_react197.default.createElement(Text, {
    title: text,
    className: `${prefix}--tag__label`
  }, text));
};
SelectableTag.propTypes = {
  /**
   * Provide a custom className that is applied to the containing <span>
   */
  className: import_prop_types149.default.string,
  /**
   * Specify if the `SelectableTag` is disabled
   */
  disabled: import_prop_types149.default.bool,
  /**
   * Specify the id for the tag.
   */
  id: import_prop_types149.default.string,
  /**
   * Optional prop to render a custom icon.
   * Can be a React component class
   */
  renderIcon: import_prop_types149.default.oneOfType([import_prop_types149.default.func, import_prop_types149.default.object]),
  /**
   * Provide an optional hook that is called when selected is changed
   */
  onChange: import_prop_types149.default.func,
  /**
   * Provide an optional function to be called when the tag is clicked.
   */
  onClick: import_prop_types149.default.func,
  /**
   * Specify the state of the selectable tag.
   */
  selected: import_prop_types149.default.bool,
  /**
   * Specify the size of the Tag. Currently supports either `sm`,
   * `md` (default) or `lg` sizes.
   */
  size: import_prop_types149.default.oneOf(Object.keys(SIZES)),
  /**
   * Provide text to be rendered inside of a the tag.
   */
  text: import_prop_types149.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Tag/Tag.Skeleton.js
var import_prop_types150 = __toESM(require_prop_types());
var import_react198 = __toESM(require_react());
var import_classnames129 = __toESM(require_classnames());
function TagSkeleton(_ref) {
  let {
    className,
    size: size6,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const tagClasses = (0, import_classnames129.default)(`${prefix}--tag`, `${prefix}--skeleton`, className, {
    [`${prefix}--tag--${size6}`]: size6,
    // TODO: V12 - Remove this class
    [`${prefix}--layout--size-${size6}`]: size6
  });
  return import_react198.default.createElement("span", _extends({
    className: tagClasses
  }, rest3));
}
TagSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types150.default.string,
  /**
   * Specify the size of the Tag. Currently supports either `sm` or
   * default sizes.
   */
  size: import_prop_types150.default.oneOf(["sm"])
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/TextArea/TextArea.js
var import_prop_types151 = __toESM(require_prop_types());
var import_react199 = __toESM(require_react());
var import_classnames130 = __toESM(require_classnames());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/internal/useAnnouncer.js
function useAnnouncer(textCount, maxCount) {
  let entityName = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "characters";
  const remaining = maxCount - textCount;
  if (remaining <= 10 && remaining > 0) {
    const entity = remaining === 1 ? entityName.slice(0, -1) : entityName;
    return `${remaining} ${entity} left.`;
  }
  if (remaining <= 0) {
    return `Maximum ${entityName} reached.`;
  }
  return null;
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/TextArea/TextArea.js
var TextArea = import_react199.default.forwardRef((props, forwardRef13) => {
  var _a;
  const {
    className,
    decorator,
    disabled = false,
    id,
    labelText,
    hideLabel,
    onChange = noopFn,
    onClick = noopFn,
    onKeyDown = noopFn,
    invalid = false,
    invalidText = "",
    helperText = "",
    light,
    placeholder = "",
    enableCounter = false,
    maxCount = void 0,
    counterMode = "character",
    warn: warn2 = false,
    warnText = "",
    rows = 4,
    slug,
    ...other
  } = props;
  const prefix = usePrefix();
  const {
    isFluid
  } = (0, import_react199.useContext)(FormContext);
  const {
    defaultValue,
    value
  } = other;
  const textAreaInstanceId = useId();
  const textareaRef = (0, import_react199.useRef)(null);
  const ref = useMergedRefs([forwardRef13, textareaRef]);
  function getInitialTextCount() {
    var _a2, _b;
    const targetValue = defaultValue || value || ((_a2 = textareaRef.current) == null ? void 0 : _a2.value) || "";
    const strValue = targetValue.toString();
    if (counterMode === "character") {
      return strValue.length;
    } else {
      return ((_b = strValue.match(/\w+/g)) == null ? void 0 : _b.length) || 0;
    }
  }
  const [textCount, setTextCount] = (0, import_react199.useState)(getInitialTextCount());
  (0, import_react199.useEffect)(() => {
    setTextCount(getInitialTextCount());
  }, [value, defaultValue, counterMode]);
  useIsomorphicEffect$1(() => {
    if (other.cols && textareaRef.current) {
      textareaRef.current.style.width = "";
      textareaRef.current.style.resize = "none";
    } else if (textareaRef.current) {
      textareaRef.current.style.width = `100%`;
    }
  }, [other.cols]);
  const textareaProps = {
    id,
    onKeyDown: (evt) => {
      if (!disabled && enableCounter && counterMode === "word") {
        const key = evt.which;
        if (maxCount && textCount >= maxCount && key === 32 || maxCount && textCount >= maxCount && key === 13) {
          evt.preventDefault();
        }
      }
      if (!disabled && onKeyDown) {
        onKeyDown(evt);
      }
    },
    onPaste: (evt) => {
      if (!disabled) {
        if (counterMode === "word" && enableCounter && typeof maxCount !== "undefined" && textareaRef.current !== null) {
          const existingWords = textareaRef.current.value.match(/\w+/g) || [];
          const pastedWords = evt.clipboardData.getData("Text").match(/\w+/g) || [];
          const totalWords = existingWords.length + pastedWords.length;
          if (totalWords > maxCount) {
            evt.preventDefault();
            const allowedWords = existingWords.concat(pastedWords).slice(0, maxCount);
            setTimeout(() => {
              setTextCount(maxCount);
            }, 0);
            textareaRef.current.value = allowedWords.join(" ");
          }
        }
      }
    },
    onChange: (evt) => {
      var _a2, _b, _c;
      if (!disabled) {
        if (counterMode == "character") {
          (_a2 = evt == null ? void 0 : evt.persist) == null ? void 0 : _a2.call(evt);
          setTimeout(() => {
            var _a3, _b2;
            setTextCount((_b2 = (_a3 = evt.target) == null ? void 0 : _a3.value) == null ? void 0 : _b2.length);
          }, 0);
        } else if (counterMode == "word") {
          if (!evt.target.value) {
            setTimeout(() => {
              setTextCount(0);
            }, 0);
            return;
          }
          if (enableCounter && typeof maxCount !== "undefined" && textareaRef.current !== null) {
            const matchedWords = (_c = (_b = evt.target) == null ? void 0 : _b.value) == null ? void 0 : _c.match(/\w+/g);
            if (matchedWords && matchedWords.length <= maxCount) {
              textareaRef.current.removeAttribute("maxLength");
              setTimeout(() => {
                setTextCount(matchedWords.length);
              }, 0);
            } else if (matchedWords && matchedWords.length > maxCount) {
              setTimeout(() => {
                setTextCount(matchedWords.length);
              }, 0);
            }
          }
        }
        if (onChange) {
          onChange(evt);
        }
      }
    },
    onClick: (evt) => {
      if (!disabled && onClick) {
        onClick(evt);
      }
    }
  };
  const formItemClasses = (0, import_classnames130.default)(`${prefix}--form-item`, className);
  const textAreaWrapperClasses = (0, import_classnames130.default)(`${prefix}--text-area__wrapper`, {
    [`${prefix}--text-area__wrapper--cols`]: other.cols,
    [`${prefix}--text-area__wrapper--readonly`]: other.readOnly,
    [`${prefix}--text-area__wrapper--warn`]: warn2,
    [`${prefix}--text-area__wrapper--slug`]: slug,
    [`${prefix}--text-area__wrapper--decorator`]: decorator
  });
  const labelClasses = (0, import_classnames130.default)(`${prefix}--label`, {
    [`${prefix}--visually-hidden`]: hideLabel && !isFluid,
    [`${prefix}--label--disabled`]: disabled
  });
  const textareaClasses = (0, import_classnames130.default)(`${prefix}--text-area`, {
    [`${prefix}--text-area--light`]: light,
    [`${prefix}--text-area--invalid`]: invalid,
    [`${prefix}--text-area--warn`]: warn2
  });
  const counterClasses = (0, import_classnames130.default)(`${prefix}--label`, {
    [`${prefix}--label--disabled`]: disabled
  });
  const helperTextClasses = (0, import_classnames130.default)(`${prefix}--form__helper-text`, {
    [`${prefix}--form__helper-text--disabled`]: disabled
  });
  const label = labelText ? import_react199.default.createElement(Text, {
    as: "label",
    htmlFor: id,
    className: labelClasses
  }, labelText) : null;
  const counter = enableCounter && maxCount && (counterMode === "character" || counterMode === "word") ? import_react199.default.createElement(Text, {
    as: "div",
    className: counterClasses
  }, `${textCount}/${maxCount}`) : null;
  const helperId = !helperText ? void 0 : `text-area-helper-text-${textAreaInstanceId}`;
  const helper = helperText ? import_react199.default.createElement(Text, {
    as: "div",
    id: helperId,
    className: helperTextClasses
  }, helperText) : null;
  const errorId = id + "-error-msg";
  const error2 = invalid ? import_react199.default.createElement(Text, {
    as: "div",
    role: "alert",
    className: `${prefix}--form-requirement`,
    id: errorId
  }, invalidText, isFluid && import_react199.default.createElement(WarningFilled, {
    className: `${prefix}--text-area__invalid-icon`
  })) : null;
  const warning3 = warn2 ? import_react199.default.createElement(Text, {
    as: "div",
    role: "alert",
    className: `${prefix}--form-requirement`
  }, warnText, isFluid && import_react199.default.createElement(WarningAltFilled, {
    className: `${prefix}--text-area__invalid-icon ${prefix}--text-area__invalid-icon--warning`
  })) : null;
  let ariaDescribedBy;
  if (invalid) {
    ariaDescribedBy = errorId;
  } else if (!invalid && !warn2 && !isFluid && helperText) {
    ariaDescribedBy = helperId;
  }
  if (enableCounter) {
    if (counterMode == "character") {
      textareaProps.maxLength = maxCount;
    }
  }
  const announcerRef = (0, import_react199.useRef)(null);
  const [prevAnnouncement, setPrevAnnouncement] = (0, import_react199.useState)("");
  const ariaAnnouncement = useAnnouncer(textCount, maxCount, counterMode === "word" ? "words" : void 0);
  (0, import_react199.useEffect)(() => {
    if (ariaAnnouncement && ariaAnnouncement !== prevAnnouncement) {
      const announcer = announcerRef.current;
      if (announcer) {
        announcer.textContent = "";
        const timeoutId2 = setTimeout(() => {
          if (announcer) {
            announcer.textContent = ariaAnnouncement;
            setPrevAnnouncement(ariaAnnouncement);
          }
        }, counterMode === "word" ? 2e3 : 1e3);
        return () => {
          if (timeoutId2) {
            clearTimeout(timeoutId2);
          }
        };
      }
    }
  }, [ariaAnnouncement, prevAnnouncement, counterMode]);
  const input = import_react199.default.createElement("textarea", _extends({}, other, textareaProps, {
    placeholder,
    "aria-readonly": other.readOnly ? true : false,
    className: textareaClasses,
    "aria-invalid": invalid,
    "aria-describedby": ariaDescribedBy,
    disabled,
    rows,
    readOnly: other.readOnly,
    ref
  }));
  let normalizedDecorator = import_react199.default.isValidElement(slug ?? decorator) ? slug ?? decorator : null;
  if (normalizedDecorator && ((_a = normalizedDecorator["type"]) == null ? void 0 : _a.displayName) === "AILabel") {
    normalizedDecorator = import_react199.default.cloneElement(normalizedDecorator, {
      size: "mini"
    });
  }
  return import_react199.default.createElement("div", {
    className: formItemClasses
  }, import_react199.default.createElement("div", {
    className: `${prefix}--text-area__label-wrapper`
  }, label, counter), import_react199.default.createElement("div", {
    className: textAreaWrapperClasses,
    "data-invalid": invalid || null
  }, invalid && !isFluid && import_react199.default.createElement(WarningFilled, {
    className: `${prefix}--text-area__invalid-icon`
  }), warn2 && !invalid && !isFluid && import_react199.default.createElement(WarningAltFilled, {
    className: `${prefix}--text-area__invalid-icon ${prefix}--text-area__invalid-icon--warning`
  }), input, slug ? normalizedDecorator : decorator ? import_react199.default.createElement("div", {
    className: `${prefix}--text-area__inner-wrapper--decorator`
  }, normalizedDecorator) : "", import_react199.default.createElement("span", {
    className: `${prefix}--text-area__counter-alert`,
    role: "alert",
    "aria-live": "assertive",
    "aria-atomic": "true",
    ref: announcerRef
  }, ariaAnnouncement), isFluid && import_react199.default.createElement("hr", {
    className: `${prefix}--text-area__divider`
  }), isFluid && invalid ? error2 : null, isFluid && warn2 && !invalid ? warning3 : null), !invalid && !warn2 && !isFluid ? helper : null, invalid && !isFluid ? error2 : null, warn2 && !invalid && !isFluid ? warning3 : null);
});
TextArea.displayName = "TextArea";
TextArea.propTypes = {
  /**
   * Provide a custom className that is applied directly to the underlying
   * `<textarea>` node
   */
  className: import_prop_types151.default.string,
  /**
   * Specify the `cols` attribute for the underlying `<textarea>` node
   */
  cols: import_prop_types151.default.number,
  /**
   * Specify the method used for calculating the counter number
   */
  counterMode: import_prop_types151.default.oneOf(["character", "word"]),
  /**
   * **Experimental**: Provide a `decorator` component to be rendered inside the `TextArea` component
   */
  decorator: import_prop_types151.default.node,
  /**
   * Optionally provide the default value of the `<textarea>`
   */
  defaultValue: import_prop_types151.default.oneOfType([import_prop_types151.default.string, import_prop_types151.default.number]),
  /**
   * Specify whether the control is disabled
   */
  disabled: import_prop_types151.default.bool,
  /**
   * Specify whether to display the counter
   */
  enableCounter: import_prop_types151.default.bool,
  /**
   * Provide text that is used alongside the control label for additional help
   */
  helperText: import_prop_types151.default.node,
  /**
   * Specify whether you want the underlying label to be visually hidden
   */
  hideLabel: import_prop_types151.default.bool,
  /**
   * Provide a unique identifier for the control
   */
  id: import_prop_types151.default.string,
  /**
   * Specify whether the control is currently invalid
   */
  invalid: import_prop_types151.default.bool,
  /**
   * Provide the text that is displayed when the control is in an invalid state
   */
  invalidText: import_prop_types151.default.node,
  /**
   * Provide the text that will be read by a screen reader when visiting this
   * control
   */
  labelText: import_prop_types151.default.node.isRequired,
  /**
   * `true` to use the light version. For use on $ui-01 backgrounds only.
   * Don't use this to make tile background color same as container background color.
   */
  light: deprecate(import_prop_types151.default.bool, "The `light` prop for `TextArea` has been deprecated in favor of the new `Layer` component. It will be removed in the next major release."),
  /**
   * Max entity count allowed for the textarea. This is needed in order for enableCounter to display
   */
  maxCount: import_prop_types151.default.number,
  /**
   * Optionally provide an `onChange` handler that is called whenever `<textarea>`
   * is updated
   */
  onChange: import_prop_types151.default.func,
  /**
   * Optionally provide an `onClick` handler that is called whenever the
   * `<textarea>` is clicked
   */
  onClick: import_prop_types151.default.func,
  /**
   * Optionally provide an `onKeyDown` handler that is called whenever `<textarea>`
   * is keyed
   */
  onKeyDown: import_prop_types151.default.func,
  /**
   * Specify the placeholder attribute for the `<textarea>`
   */
  placeholder: import_prop_types151.default.string,
  /**
   * Whether the textarea should be read-only
   */
  readOnly: import_prop_types151.default.bool,
  /**
   * Specify the rows attribute for the `<textarea>`
   */
  rows: import_prop_types151.default.number,
  /**
   * **Experimental**: Provide a `Slug` component to be rendered inside the `TextArea` component
   */
  slug: deprecate(import_prop_types151.default.node, "The `slug` prop for `TextArea` has been deprecated in favor of the new `decorator` prop. It will be removed in the next major release."),
  /**
   * Provide the current value of the `<textarea>`
   */
  value: import_prop_types151.default.oneOfType([import_prop_types151.default.string, import_prop_types151.default.number]),
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types151.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types151.default.node
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/TextArea/TextArea.Skeleton.js
var import_prop_types152 = __toESM(require_prop_types());
var import_react200 = __toESM(require_react());
var import_classnames131 = __toESM(require_classnames());
var TextAreaSkeleton = (props) => {
  const {
    className,
    hideLabel,
    ...rest3
  } = props;
  const prefix = usePrefix();
  return import_react200.default.createElement("div", _extends({
    className: (0, import_classnames131.default)(`${prefix}--form-item`, className)
  }, rest3), !hideLabel && import_react200.default.createElement("span", {
    className: `${prefix}--label ${prefix}--skeleton`
  }), import_react200.default.createElement("div", {
    className: `${prefix}--skeleton ${prefix}--text-area`
  }));
};
TextAreaSkeleton.propTypes = {
  /**
   * Specify an optional className to add to the form item wrapper.
   */
  className: import_prop_types152.default.string,
  /**
   * Specify whether the label should be hidden, or not
   */
  hideLabel: import_prop_types152.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/TextInput/TextInput.js
var import_prop_types153 = __toESM(require_prop_types());
var import_react201 = __toESM(require_react());
var import_classnames132 = __toESM(require_classnames());
var TextInput = import_react201.default.forwardRef(function TextInput2(_ref, ref) {
  var _a;
  let {
    className,
    decorator,
    disabled = false,
    helperText,
    hideLabel,
    id,
    inline: inline5 = false,
    invalid = false,
    invalidText,
    labelText,
    light,
    onChange = () => {
    },
    onClick = () => {
    },
    placeholder,
    readOnly,
    size: size6,
    type = "text",
    warn: warn2 = false,
    warnText,
    enableCounter = false,
    maxCount,
    slug,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const {
    defaultValue,
    value
  } = rest3;
  const [textCount, setTextCount] = (0, import_react201.useState)((defaultValue == null ? void 0 : defaultValue.toString().length) || (value == null ? void 0 : value.toString().length) || 0);
  const normalizedProps = useNormalizedInputProps({
    id,
    readOnly,
    disabled,
    invalid,
    invalidText,
    warn: warn2,
    warnText
  });
  const textInputClasses = (0, import_classnames132.default)(`${prefix}--text-input`, {
    [`${prefix}--text-input--light`]: light,
    [`${prefix}--text-input--invalid`]: normalizedProps.invalid,
    [`${prefix}--text-input--warning`]: normalizedProps.warn,
    [`${prefix}--text-input--${size6}`]: size6,
    // TODO: V12 - Remove this class
    [`${prefix}--layout--size-${size6}`]: size6
  });
  const sharedTextInputProps = {
    id,
    onChange: (evt) => {
      var _a2;
      if (!normalizedProps.disabled) {
        setTextCount((_a2 = evt.target.value) == null ? void 0 : _a2.length);
        onChange(evt);
      }
    },
    onClick: (evt) => {
      if (!normalizedProps.disabled) {
        onClick(evt);
      }
    },
    placeholder,
    type,
    ref,
    className: textInputClasses,
    title: placeholder,
    disabled: normalizedProps.disabled,
    readOnly,
    ["aria-describedby"]: helperText && normalizedProps.helperId,
    ...rest3
  };
  if (enableCounter) {
    sharedTextInputProps.maxLength = maxCount;
  }
  const inputWrapperClasses = (0, import_classnames132.default)([(0, import_classnames132.default)(`${prefix}--form-item`, className)], `${prefix}--text-input-wrapper`, {
    [`${prefix}--text-input-wrapper--readonly`]: readOnly,
    [`${prefix}--text-input-wrapper--light`]: light,
    [`${prefix}--text-input-wrapper--inline`]: inline5,
    [`${prefix}--text-input-wrapper--inline--invalid`]: inline5 && normalizedProps.invalid
  });
  const labelClasses = (0, import_classnames132.default)(`${prefix}--label`, {
    [`${prefix}--visually-hidden`]: hideLabel,
    [`${prefix}--label--disabled`]: normalizedProps.disabled,
    [`${prefix}--label--inline`]: inline5,
    [`${prefix}--label--inline--${size6}`]: inline5 && !!size6
  });
  const helperTextClasses = (0, import_classnames132.default)(`${prefix}--form__helper-text`, {
    [`${prefix}--form__helper-text--disabled`]: normalizedProps.disabled,
    [`${prefix}--form__helper-text--inline`]: inline5
  });
  const fieldOuterWrapperClasses = (0, import_classnames132.default)(`${prefix}--text-input__field-outer-wrapper`, {
    [`${prefix}--text-input__field-outer-wrapper--inline`]: inline5
  });
  const fieldWrapperClasses = (0, import_classnames132.default)(`${prefix}--text-input__field-wrapper`, {
    [`${prefix}--text-input__field-wrapper--warning`]: normalizedProps.warn,
    [`${prefix}--text-input__field-wrapper--slug`]: slug,
    [`${prefix}--text-input__field-wrapper--decorator`]: decorator
  });
  const iconClasses = (0, import_classnames132.default)({
    [`${prefix}--text-input__invalid-icon`]: normalizedProps.invalid || normalizedProps.warn,
    [`${prefix}--text-input__invalid-icon--warning`]: normalizedProps.warn
  });
  const counterClasses = (0, import_classnames132.default)(`${prefix}--label`, {
    [`${prefix}--label--disabled`]: disabled,
    [`${prefix}--text-input__label-counter`]: true
  });
  const counter = enableCounter && maxCount ? import_react201.default.createElement(Text, {
    as: "div",
    className: counterClasses
  }, `${textCount}/${maxCount}`) : null;
  const label = labelText ? import_react201.default.createElement(Text, {
    as: "label",
    htmlFor: id,
    className: labelClasses
  }, labelText) : null;
  const labelWrapper = import_react201.default.createElement("div", {
    className: `${prefix}--text-input__label-wrapper`
  }, label, counter);
  const helper = helperText ? import_react201.default.createElement(Text, {
    as: "div",
    id: normalizedProps.helperId,
    className: helperTextClasses
  }, helperText) : null;
  const input = import_react201.default.createElement("input", textInputProps({
    sharedTextInputProps,
    invalid: normalizedProps.invalid,
    invalidId: normalizedProps.invalidId,
    warn: normalizedProps.warn,
    warnId: normalizedProps.warnId
  }));
  const {
    isFluid
  } = (0, import_react201.useContext)(FormContext);
  const announcerRef = (0, import_react201.useRef)(null);
  const [prevAnnouncement, setPrevAnnouncement] = (0, import_react201.useState)("");
  const ariaAnnouncement = useAnnouncer(textCount, maxCount);
  (0, import_react201.useEffect)(() => {
    if (ariaAnnouncement && ariaAnnouncement !== prevAnnouncement) {
      const announcer = announcerRef.current;
      if (announcer) {
        announcer.textContent = "";
        const timeoutId2 = setTimeout(() => {
          if (announcer) {
            announcer.textContent = ariaAnnouncement;
            setPrevAnnouncement(ariaAnnouncement);
          }
        }, 1e3);
        return () => {
          if (timeoutId2) {
            clearTimeout(timeoutId2);
          }
        };
      }
    }
  }, [ariaAnnouncement, prevAnnouncement]);
  const Icon = normalizedProps.icon;
  let normalizedDecorator = import_react201.default.isValidElement(slug ?? decorator) ? slug ?? decorator : null;
  if (normalizedDecorator && ((_a = normalizedDecorator["type"]) == null ? void 0 : _a.displayName) === "AILabel") {
    normalizedDecorator = import_react201.default.cloneElement(normalizedDecorator, {
      size: "mini"
    });
  }
  return import_react201.default.createElement("div", {
    className: inputWrapperClasses
  }, !inline5 ? labelWrapper : import_react201.default.createElement("div", {
    className: `${prefix}--text-input__label-helper-wrapper`
  }, labelWrapper, !isFluid && (normalizedProps.validation || helper)), import_react201.default.createElement("div", {
    className: fieldOuterWrapperClasses
  }, import_react201.default.createElement("div", {
    className: fieldWrapperClasses,
    "data-invalid": normalizedProps.invalid || null
  }, Icon && import_react201.default.createElement(Icon, {
    className: iconClasses
  }), input, slug ? normalizedDecorator : decorator ? import_react201.default.createElement("div", {
    className: `${prefix}--text-input__field-inner-wrapper--decorator`
  }, normalizedDecorator) : "", import_react201.default.createElement("span", {
    className: `${prefix}--text-input__counter-alert`,
    role: "alert",
    "aria-live": "assertive",
    "aria-atomic": "true",
    ref: announcerRef
  }, ariaAnnouncement), isFluid && import_react201.default.createElement("hr", {
    className: `${prefix}--text-input__divider`
  }), isFluid && !inline5 && normalizedProps.validation), !isFluid && !inline5 && (normalizedProps.validation || helper)));
});
TextInput.displayName = "TextInput";
TextInput.PasswordInput = PasswordInput;
TextInput.ControlledPasswordInput = ControlledPasswordInput;
TextInput.propTypes = {
  /**
   * Specify an optional className to be applied to the `<input>` node
   */
  className: import_prop_types153.default.string,
  /**
   * **Experimental**: Provide a `decorator` component to be rendered inside the `TextInput` component
   */
  decorator: import_prop_types153.default.node,
  /**
   * Optionally provide the default value of the `<input>`
   */
  defaultValue: import_prop_types153.default.oneOfType([import_prop_types153.default.string, import_prop_types153.default.number]),
  /**
   * Specify whether the `<input>` should be disabled
   */
  disabled: import_prop_types153.default.bool,
  /**
   * Specify whether to display the character counter
   */
  enableCounter: import_prop_types153.default.bool,
  /**
   * Provide text that is used alongside the control label for additional help
   */
  helperText: import_prop_types153.default.node,
  /**
   * Specify whether you want the underlying label to be visually hidden
   */
  hideLabel: import_prop_types153.default.bool,
  /**
   * Specify a custom `id` for the `<input>`
   */
  id: import_prop_types153.default.string.isRequired,
  /**
   * `true` to use the inline version.
   */
  inline: import_prop_types153.default.bool,
  /**
   * Specify whether the control is currently invalid
   */
  invalid: import_prop_types153.default.bool,
  /**
   * Provide the text that is displayed when the control is in an invalid state
   */
  invalidText: import_prop_types153.default.node,
  /**
   * Provide the text that will be read by a screen reader when visiting this
   * control
   */
  labelText: import_prop_types153.default.node.isRequired,
  /**
   * `true` to use the light version. For use on $ui-01 backgrounds only.
   * Don't use this to make tile background color same as container background color.
   */
  light: deprecate(import_prop_types153.default.bool, "The `light` prop for `TextInput` has been deprecated in favor of the new `Layer` component. It will be removed in the next major release."),
  /**
   * Max character count allowed for the input. This is needed in order for enableCounter to display
   */
  maxCount: import_prop_types153.default.number,
  /**
   * Optionally provide an `onChange` handler that is called whenever `<input>`
   * is updated
   */
  onChange: import_prop_types153.default.func,
  /**
   * Optionally provide an `onClick` handler that is called whenever the
   * `<input>` is clicked
   */
  onClick: import_prop_types153.default.func,
  /**
   * Specify the placeholder attribute for the `<input>`
   */
  placeholder: import_prop_types153.default.string,
  /**
   * Whether the input should be read-only
   */
  readOnly: import_prop_types153.default.bool,
  /**
   * Specify the size of the Text Input. Currently supports the following:
   */
  size: import_prop_types153.default.oneOf(["sm", "md", "lg"]),
  /**
   * **Experimental**: Provide a `Slug` component to be rendered inside the `TextInput` component
   */
  slug: deprecate(import_prop_types153.default.node, "The `slug` prop for `TextInput` has been deprecated in favor of the new `decorator` prop. It will be removed in the next major release."),
  /**
   * Specify the type of the `<input>`
   */
  type: import_prop_types153.default.string,
  /**
   * Specify the value of the `<input>`
   */
  value: import_prop_types153.default.oneOfType([import_prop_types153.default.string, import_prop_types153.default.number]),
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types153.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types153.default.node
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/TextInput/TextInput.Skeleton.js
var import_prop_types154 = __toESM(require_prop_types());
var import_react202 = __toESM(require_react());
var import_classnames133 = __toESM(require_classnames());
var TextInputSkeleton = (_ref) => {
  let {
    hideLabel,
    className,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  return import_react202.default.createElement("div", _extends({
    className: (0, import_classnames133.default)(`${prefix}--form-item`, className)
  }, rest3), !hideLabel && import_react202.default.createElement("span", {
    className: `${prefix}--label ${prefix}--skeleton`
  }), import_react202.default.createElement("div", {
    className: `${prefix}--skeleton ${prefix}--text-input`
  }));
};
TextInputSkeleton.propTypes = {
  /**
   * Specify an optional className to add to the form item wrapper.
   */
  className: import_prop_types154.default.string,
  /**
   * Specify whether the label should be hidden, or not
   */
  hideLabel: import_prop_types154.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/TextInput/index.js
if (true) {
  deprecateFieldOnObject(TextInput, "ControlledPasswordInput", ControlledPasswordInput);
  deprecateFieldOnObject(TextInput, "PasswordInput", PasswordInput);
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Tile/Tile.js
var import_react203 = __toESM(require_react());
var import_prop_types155 = __toESM(require_prop_types());
var import_classnames134 = __toESM(require_classnames());
var _CheckboxCheckedFille;
var _Checkbox;
var _ChevronDown3;
var _ChevronDown22;
var Tile = import_react203.default.forwardRef(function Tile2(_ref, ref) {
  let {
    children,
    className,
    decorator,
    light = false,
    slug,
    hasRoundedCorners = false,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const tileClasses = (0, import_classnames134.default)(`${prefix}--tile`, {
    [`${prefix}--tile--light`]: light,
    [`${prefix}--tile--slug`]: slug,
    [`${prefix}--tile--slug-rounded`]: slug && hasRoundedCorners,
    [`${prefix}--tile--decorator`]: decorator,
    [`${prefix}--tile--decorator-rounded`]: decorator && hasRoundedCorners
  }, className);
  return import_react203.default.createElement("div", _extends({
    className: tileClasses,
    ref
  }, rest3), children, slug, decorator && import_react203.default.createElement("div", {
    className: `${prefix}--tile--inner-decorator`
  }, decorator));
});
Tile.displayName = "Tile";
Tile.propTypes = {
  /**
   * The child nodes.
   */
  children: import_prop_types155.default.node,
  /**
   * The CSS class names.
   */
  className: import_prop_types155.default.string,
  /**
   * **Experimental**: Provide a `decorator` component to be rendered inside the `Tile` component
   */
  decorator: import_prop_types155.default.node,
  /**
   * **Experimental**: Specify if the `Tile` component should be rendered with rounded corners. Only valid
   * when `slug` prop is present
   */
  hasRoundedCorners: import_prop_types155.default.bool,
  /**
   * `true` to use the light version. For use on $ui-01 backgrounds only.
   * Don't use this to make tile background color same as container background color.
   *
   * @deprecated
   */
  light: deprecate(import_prop_types155.default.bool, "The `light` prop for `Tile` is no longer needed and has been deprecated. It will be removed in the next major release. Use the Layer component instead."),
  /**
   * **Experimental**: Provide a `Slug` component to be rendered inside the `Tile` component
   */
  slug: deprecate(import_prop_types155.default.node, "The `slug` prop for `Tile` has been deprecated in favor of the new `decorator` prop. It will be removed in the next major release.")
};
var ClickableTile = import_react203.default.forwardRef(function ClickableTile2(_ref2, ref) {
  let {
    children,
    className,
    clicked = false,
    decorator,
    disabled,
    href,
    light,
    onClick = () => {
    },
    onKeyDown = () => {
    },
    renderIcon: Icon,
    hasRoundedCorners,
    slug,
    ...rest3
  } = _ref2;
  const prefix = usePrefix();
  const classes = (0, import_classnames134.default)(`${prefix}--tile`, `${prefix}--tile--clickable`, {
    [`${prefix}--tile--is-clicked`]: clicked,
    [`${prefix}--tile--light`]: light,
    [`${prefix}--tile--slug`]: slug,
    [`${prefix}--tile--slug-rounded`]: slug && hasRoundedCorners,
    [`${prefix}--tile--decorator`]: decorator,
    [`${prefix}--tile--decorator-rounded`]: decorator && hasRoundedCorners
  }, className);
  const [isSelected, setIsSelected] = (0, import_react203.useState)(clicked);
  function handleOnClick(evt) {
    var _a;
    (_a = evt == null ? void 0 : evt.persist) == null ? void 0 : _a.call(evt);
    setIsSelected(!isSelected);
    onClick(evt);
  }
  function handleOnKeyDown2(evt) {
    var _a;
    (_a = evt == null ? void 0 : evt.persist) == null ? void 0 : _a.call(evt);
    if (matches(evt, [Enter, Space])) {
      setIsSelected(!isSelected);
    }
    onKeyDown(evt);
  }
  const v12DefaultIcons = useFeatureFlag("enable-v12-tile-default-icons");
  if (v12DefaultIcons) {
    if (!Icon) {
      Icon = ArrowRight;
    }
    if (disabled) {
      Icon = Error2;
    }
  }
  const iconClasses = (0, import_classnames134.default)({
    [`${prefix}--tile--icon`]: !v12DefaultIcons || v12DefaultIcons && !disabled,
    [`${prefix}--tile--disabled-icon`]: v12DefaultIcons && disabled
  });
  return import_react203.default.createElement(Link, _extends({
    className: classes,
    href,
    tabIndex: !href && !disabled ? 0 : void 0,
    onClick: !disabled ? handleOnClick : void 0,
    onKeyDown: handleOnKeyDown2,
    ref,
    disabled
  }, rest3), slug || decorator ? import_react203.default.createElement("div", {
    className: `${prefix}--tile-content`
  }, children) : children, (slug === true || decorator === true) && import_react203.default.createElement(AiLabel, {
    size: "24",
    className: `${prefix}--tile--ai-label-icon`
  }), import_react203.default.isValidElement(decorator) && import_react203.default.createElement("div", {
    className: `${prefix}--tile--inner-decorator`
  }, decorator), Icon && import_react203.default.createElement(Icon, {
    className: iconClasses,
    "aria-hidden": "true"
  }));
});
ClickableTile.displayName = "ClickableTile";
ClickableTile.propTypes = {
  /**
   * The child nodes.
   */
  children: import_prop_types155.default.node,
  /**
   * The CSS class names.
   */
  className: import_prop_types155.default.string,
  /**
   * Boolean for whether a tile has been clicked.
   */
  clicked: import_prop_types155.default.bool,
  /**
   * **Experimental**: Provide a `decorator` component or set the boolean to True for an AILabel icon to be rendered inside the `ClickableTile` component
   */
  decorator: import_prop_types155.default.oneOfType([import_prop_types155.default.bool, import_prop_types155.default.node]),
  /**
   * Specify whether the ClickableTile should be disabled
   */
  disabled: import_prop_types155.default.bool,
  /**
   * **Experimental**: Specify if the `ClickableTile` component should be rendered with rounded corners.
   * Only valid when `slug` prop is present
   */
  hasRoundedCorners: import_prop_types155.default.bool,
  /**
   * The href for the link.
   */
  href: import_prop_types155.default.string,
  /**
   * `true` to use the light version. For use on $ui-01 backgrounds only.
   * Don't use this to make tile background color same as container background color.
   */
  light: deprecate(import_prop_types155.default.bool, "The `light` prop for `ClickableTile` is no longer needed and has been deprecated. It will be removed in the next major release. Use the Layer component instead."),
  /**
   * Specify the function to run when the ClickableTile is clicked
   */
  onClick: import_prop_types155.default.func,
  /**
   * Specify the function to run when the ClickableTile is interacted with via a keyboard
   */
  onKeyDown: import_prop_types155.default.func,
  /**
   * The rel property for the link.
   */
  rel: import_prop_types155.default.string,
  /**
   * Optional prop to allow overriding the icon rendering.
   * Can be a React component class
   */
  // @ts-expect-error: Invalid derived prop type, seemingly no real solution.
  renderIcon: import_prop_types155.default.oneOfType([import_prop_types155.default.func, import_prop_types155.default.object])
};
var SelectableTile = import_react203.default.forwardRef(function SelectableTile2(_ref3, ref) {
  var _a;
  let {
    children,
    className,
    decorator,
    disabled,
    id,
    light,
    onClick = () => {
    },
    onChange = () => {
    },
    onKeyDown = () => {
    },
    selected = false,
    tabIndex = 0,
    title = "title",
    slug,
    hasRoundedCorners,
    ...rest3
  } = _ref3;
  const prefix = usePrefix();
  const clickHandler = onClick;
  const keyDownHandler = onKeyDown;
  const [isSelected, setIsSelected] = (0, import_react203.useState)(selected);
  const [prevSelected, setPrevSelected] = (0, import_react203.useState)(selected);
  const classes = (0, import_classnames134.default)(`${prefix}--tile`, `${prefix}--tile--selectable`, {
    [`${prefix}--tile--is-selected`]: isSelected,
    [`${prefix}--tile--light`]: light,
    [`${prefix}--tile--disabled`]: disabled,
    [`${prefix}--tile--slug`]: slug,
    [`${prefix}--tile--slug-rounded`]: slug && hasRoundedCorners,
    [`${prefix}--tile--decorator`]: decorator,
    [`${prefix}--tile--decorator-rounded`]: decorator && hasRoundedCorners
  }, className);
  function handleOnClick(evt) {
    var _a2;
    evt.preventDefault();
    (_a2 = evt == null ? void 0 : evt.persist) == null ? void 0 : _a2.call(evt);
    if (normalizedDecorator && decoratorRef.current && decoratorRef.current.contains(evt.target)) {
      return;
    }
    setIsSelected(!isSelected);
    clickHandler(evt);
    onChange(evt, isSelected, id);
  }
  function handleOnKeyDown2(evt) {
    var _a2;
    (_a2 = evt == null ? void 0 : evt.persist) == null ? void 0 : _a2.call(evt);
    if (matches(evt, [Enter, Space])) {
      evt.preventDefault();
      setIsSelected(!isSelected);
      onChange(evt, isSelected, id);
    }
    keyDownHandler(evt);
  }
  function handleChange(event) {
    setIsSelected(event.target.checked);
    onChange(event, isSelected, id);
  }
  if (selected !== prevSelected) {
    setIsSelected(selected);
    setPrevSelected(selected);
  }
  const decoratorRef = (0, import_react203.useRef)(null);
  let normalizedDecorator = import_react203.default.isValidElement(slug ?? decorator) ? slug ?? decorator : null;
  if (normalizedDecorator && ((_a = normalizedDecorator["type"]) == null ? void 0 : _a.displayName) === "AILabel") {
    normalizedDecorator = import_react203.default.cloneElement(normalizedDecorator, {
      size: "xs",
      ref: decoratorRef
    });
  }
  return (
    // eslint-disable-next-line jsx-a11y/interactive-supports-focus
    import_react203.default.createElement("div", _extends({
      className: classes,
      onClick: !disabled ? handleOnClick : void 0,
      role: "checkbox",
      "aria-checked": isSelected,
      onKeyDown: !disabled ? handleOnKeyDown2 : void 0,
      tabIndex: !disabled ? tabIndex : void 0,
      ref,
      id,
      onChange: !disabled ? handleChange : void 0,
      title
    }, rest3), import_react203.default.createElement("span", {
      className: `${prefix}--tile__checkmark ${prefix}--tile__checkmark--persistent`
    }, isSelected ? _CheckboxCheckedFille || (_CheckboxCheckedFille = import_react203.default.createElement(CheckboxCheckedFilled, null)) : _Checkbox || (_Checkbox = import_react203.default.createElement(Checkbox, null))), import_react203.default.createElement(Text, {
      as: "label",
      htmlFor: id,
      className: `${prefix}--tile-content`
    }, children), slug ? normalizedDecorator : decorator ? import_react203.default.createElement("div", {
      className: `${prefix}--tile--inner-decorator`
    }, normalizedDecorator) : "")
  );
});
SelectableTile.propTypes = {
  children: import_prop_types155.default.node,
  className: import_prop_types155.default.string,
  /**
   * **Experimental**: Provide a `decorator` component to be rendered inside the `SelectableTile` component
   */
  decorator: import_prop_types155.default.node,
  /**
   * Specify whether the SelectableTile should be disabled
   */
  disabled: import_prop_types155.default.bool,
  /**
   * **Experimental**: Specify if the `SelectableTile` component should be rendered with rounded corners.
   * Only valid when `slug` prop is present
   */
  hasRoundedCorners: import_prop_types155.default.bool,
  /**
   * The ID of the `<input>`.
   */
  id: import_prop_types155.default.string,
  /**
   * `true` to use the light version. For use on $ui-01 backgrounds only.
   * Don't use this to make tile background color same as container background color.
   */
  light: deprecate(import_prop_types155.default.bool, "The `light` prop for `SelectableTile` is no longer needed and has been deprecated. It will be removed in the next major release. Use the Layer component instead."),
  /**
   * The `name` of the `<input>`.
   * @deprecated
   */
  name: deprecate(import_prop_types155.default.string, "The `name` property is no longer used.  It will be removed in the next major release."),
  /**
   * The empty handler of the `<input>`.
   */
  onChange: import_prop_types155.default.func,
  /**
   * Specify the function to run when the SelectableTile is clicked
   */
  onClick: import_prop_types155.default.func,
  /**
   * Specify the function to run when the SelectableTile is interacted with via a keyboard
   */
  onKeyDown: import_prop_types155.default.func,
  /**
   * `true` to select this tile.
   */
  selected: import_prop_types155.default.bool,
  /**
   * **Experimental**: Provide a `Slug` component to be rendered inside the `SelectableTile` component
   */
  slug: deprecate(import_prop_types155.default.node, "The `slug` prop for `SelectableTile` has been deprecated in favor of the new `decorator` prop. It will be removed in the next major release."),
  /**
   * Specify the tab index of the wrapper element
   */
  tabIndex: import_prop_types155.default.number,
  /**
   * The `title` of the `<input>`.
   */
  title: import_prop_types155.default.string,
  /**
   * The value of the `<input>`.
   * @deprecated
   */
  value: deprecate(import_prop_types155.default.oneOfType([import_prop_types155.default.string, import_prop_types155.default.number]), "The `value` property is no longer used.  It will be removed in the next major release.`")
};
var ExpandableTile = import_react203.default.forwardRef(function ExpandableTile2(_ref4, forwardRef13) {
  var _a;
  let {
    tabIndex = 0,
    className,
    children,
    decorator,
    expanded = false,
    tileMaxHeight = 0,
    // eslint-disable-line
    tilePadding = 0,
    // eslint-disable-line
    onClick,
    onKeyUp,
    tileCollapsedIconText = "Interact to expand Tile",
    tileExpandedIconText = "Interact to collapse Tile",
    tileCollapsedLabel,
    tileExpandedLabel,
    light,
    slug,
    hasRoundedCorners,
    ...rest3
  } = _ref4;
  const [isTileMaxHeight, setIsTileMaxHeight] = (0, import_react203.useState)(tileMaxHeight);
  const [isTilePadding, setIsTilePadding] = (0, import_react203.useState)(tilePadding);
  const [prevExpanded, setPrevExpanded] = (0, import_react203.useState)(expanded);
  const [prevTileMaxHeight, setPrevTileMaxHeight] = (0, import_react203.useState)(tileMaxHeight);
  const [prevTilePadding, setPrevTilePadding] = (0, import_react203.useState)(tilePadding);
  const [isExpanded, setIsExpanded] = (0, import_react203.useState)(expanded);
  const [interactive, setInteractive] = (0, import_react203.useState)(true);
  const aboveTheFold = (0, import_react203.useRef)(null);
  const belowTheFold = (0, import_react203.useRef)(null);
  const chevronInteractiveRef = (0, import_react203.useRef)(null);
  const tileContent = (0, import_react203.useRef)(null);
  const tile = (0, import_react203.useRef)(null);
  const ref = useMergedRefs([forwardRef13, tile]);
  const prefix = usePrefix();
  if (expanded !== prevExpanded) {
    setIsExpanded(expanded);
    setPrevExpanded(expanded);
    setMaxHeight();
  }
  if (tileMaxHeight !== prevTileMaxHeight) {
    setIsTileMaxHeight(tileMaxHeight);
    setPrevTileMaxHeight(tileMaxHeight);
  }
  if (tilePadding !== prevTilePadding) {
    setIsTilePadding(tilePadding);
    setPrevTilePadding(tilePadding);
  }
  function setMaxHeight() {
    var _a2;
    if (isExpanded && tileContent.current) {
      setIsTileMaxHeight((_a2 = tileContent.current.getBoundingClientRect()) == null ? void 0 : _a2.height);
    }
    if (aboveTheFold.current) {
      setIsTileMaxHeight(aboveTheFold.current.getBoundingClientRect().height);
    }
  }
  function handleClick2(evt) {
    var _a2;
    (_a2 = evt == null ? void 0 : evt.persist) == null ? void 0 : _a2.call(evt);
    setIsExpanded(!isExpanded);
    setMaxHeight();
  }
  function handleKeyUp(evt) {
    if (evt.target !== tile.current && evt.target !== chevronInteractiveRef.current) {
      if (matches(evt, [Enter, Space])) {
        evt.preventDefault();
      }
    }
  }
  function getChildren2() {
    return import_react203.default.Children.toArray(children);
  }
  const classNames = (0, import_classnames134.default)(`${prefix}--tile`, `${prefix}--tile--expandable`, {
    [`${prefix}--tile--is-expanded`]: isExpanded,
    [`${prefix}--tile--light`]: light
  }, className);
  const interactiveClassNames = (0, import_classnames134.default)(`${prefix}--tile`, `${prefix}--tile--expandable`, `${prefix}--tile--expandable--interactive`, {
    [`${prefix}--tile--is-expanded`]: isExpanded,
    [`${prefix}--tile--light`]: light,
    [`${prefix}--tile--slug`]: slug,
    [`${prefix}--tile--slug-rounded`]: slug && hasRoundedCorners,
    [`${prefix}--tile--decorator`]: decorator,
    [`${prefix}--tile--decorator-rounded`]: decorator && hasRoundedCorners
  }, className);
  const chevronInteractiveClassNames = (0, import_classnames134.default)(`${prefix}--tile__chevron`, `${prefix}--tile__chevron--interactive`);
  const childrenAsArray = getChildren2();
  useIsomorphicEffect$1(() => {
    if (!tile.current || !aboveTheFold.current) {
      return;
    }
    const getStyle = window.getComputedStyle(tile.current, null);
    const {
      current: node
    } = aboveTheFold;
    const {
      height
    } = node.getBoundingClientRect();
    const paddingTop = parseInt(getStyle.getPropertyValue("padding-top"), 10);
    const paddingBottom = parseInt(getStyle.getPropertyValue("padding-bottom"), 10);
    setIsTileMaxHeight(height);
    setIsTilePadding(paddingTop + paddingBottom);
  }, [isTileMaxHeight]);
  useIsomorphicEffect$1(() => {
    if (!aboveTheFold.current || !belowTheFold.current) {
      return;
    }
    if (!getInteractiveContent(belowTheFold.current) && !getRoleContent(belowTheFold.current) && !getInteractiveContent(aboveTheFold.current) && !getRoleContent(aboveTheFold.current) && !(slug || decorator)) {
      setInteractive(false);
    }
  }, [slug, decorator]);
  useIsomorphicEffect$1(() => {
    if (!tile.current) {
      return;
    }
    if (isExpanded) {
      tile.current.style.maxHeight = "";
    } else {
      tile.current.style.maxHeight = isTileMaxHeight + isTilePadding + "px";
    }
  }, [isExpanded, isTileMaxHeight, isTilePadding]);
  (0, import_react203.useEffect)(() => {
    if (!aboveTheFold.current) {
      return;
    }
    const resizeObserver = new ResizeObserver((entries) => {
      const [aboveTheFold2] = entries;
      setIsTileMaxHeight(aboveTheFold2.contentRect.height);
    });
    resizeObserver.observe(aboveTheFold.current);
    return () => resizeObserver.disconnect();
  }, []);
  const belowTheFoldId = useId("expandable-tile-interactive");
  let normalizedDecorator = import_react203.default.isValidElement(slug ?? decorator) ? slug ?? decorator : null;
  if (normalizedDecorator && ((_a = normalizedDecorator["type"]) == null ? void 0 : _a.displayName) === "AILabel") {
    normalizedDecorator = import_react203.default.cloneElement(normalizedDecorator, {
      size: "xs"
    });
  }
  return interactive ? import_react203.default.createElement("div", _extends({
    // @ts-expect-error: Needlesly strict & deep typing for the element type
    ref,
    className: interactiveClassNames
  }, rest3), import_react203.default.createElement("div", {
    ref: tileContent
  }, slug ? normalizedDecorator : decorator ? import_react203.default.createElement("div", {
    className: `${prefix}--tile--inner-decorator`
  }, normalizedDecorator) : "", import_react203.default.createElement("div", {
    ref: aboveTheFold,
    className: `${prefix}--tile-content`
  }, childrenAsArray[0]), import_react203.default.createElement("button", {
    type: "button",
    "aria-expanded": isExpanded,
    "aria-controls": belowTheFoldId,
    onKeyUp: composeEventHandlers([onKeyUp, handleKeyUp]),
    onClick: composeEventHandlers([onClick, handleClick2]),
    "aria-label": isExpanded ? tileExpandedIconText : tileCollapsedIconText,
    ref: chevronInteractiveRef,
    className: chevronInteractiveClassNames
  }, _ChevronDown3 || (_ChevronDown3 = import_react203.default.createElement(ChevronDown, null))), import_react203.default.createElement("div", {
    ref: belowTheFold,
    className: `${prefix}--tile-content`,
    id: belowTheFoldId
  }, childrenAsArray[1]))) : import_react203.default.createElement("button", _extends({
    type: "button",
    ref,
    className: classNames,
    "aria-expanded": isExpanded,
    title: isExpanded ? tileExpandedIconText : tileCollapsedIconText
  }, rest3, {
    onKeyUp: composeEventHandlers([onKeyUp, handleKeyUp]),
    onClick: composeEventHandlers([onClick, handleClick2]),
    tabIndex
  }), import_react203.default.createElement("div", {
    ref: tileContent
  }, import_react203.default.createElement("div", {
    ref: aboveTheFold,
    className: `${prefix}--tile-content`
  }, childrenAsArray[0]), import_react203.default.createElement("div", {
    className: `${prefix}--tile__chevron`
  }, import_react203.default.createElement("span", null, isExpanded ? tileExpandedLabel : tileCollapsedLabel), _ChevronDown22 || (_ChevronDown22 = import_react203.default.createElement(ChevronDown, null))), import_react203.default.createElement("div", {
    ref: belowTheFold,
    className: `${prefix}--tile-content`
  }, childrenAsArray[1])));
});
ExpandableTile.propTypes = {
  children: import_prop_types155.default.node,
  className: import_prop_types155.default.string,
  /**
   * **Experimental**: Provide a `decorator` component to be rendered inside the `ExpandableTile` component
   */
  decorator: import_prop_types155.default.node,
  /**
   * `true` if the tile is expanded.
   */
  expanded: import_prop_types155.default.bool,
  /**
   * Specify if the `ExpandableTile` component should be rendered with rounded corners.
   * Only valid when `slug` prop is present
   */
  hasRoundedCorners: import_prop_types155.default.bool,
  /**
   * An ID that can be provided to aria-labelledby
   */
  id: import_prop_types155.default.string,
  /**
   * `true` to use the light version. For use on $ui-01 backgrounds only.
   * Don't use this to make tile background color same as container background color.
   */
  light: deprecate(import_prop_types155.default.bool, "The `light` prop for `ExpandableTile` is no longer needed and has been deprecated. It will be removed in the next major release. Use the Layer component instead."),
  /**
   * Specify the function to run when the ExpandableTile is clicked
   */
  onClick: import_prop_types155.default.func,
  /**
   * optional handler to trigger a function when a key is pressed
   */
  onKeyUp: import_prop_types155.default.func,
  /**
   * **Experimental**: Provide a `Slug` component to be rendered inside the `ExpandableTile` component
   */
  slug: deprecate(import_prop_types155.default.node, "The `slug` prop for `ExpandableTile` has been deprecated in favor of the new `decorator` prop. It will be removed in the next major release."),
  /**
   * The `tabindex` attribute.
   */
  tabIndex: import_prop_types155.default.number,
  /**
   * The description of the "collapsed" icon that can be read by screen readers.
   */
  tileCollapsedIconText: import_prop_types155.default.string,
  /**
   * When "collapsed", a label to appear next to the chevron (e.g., "View more").
   */
  tileCollapsedLabel: import_prop_types155.default.string,
  /**
   * The description of the "expanded" icon that can be read by screen readers.
   */
  tileExpandedIconText: import_prop_types155.default.string,
  /**
   * When "expanded", a label to appear next to the chevron (e.g., "View less").
   */
  tileExpandedLabel: import_prop_types155.default.string
};
ExpandableTile.displayName = "ExpandableTile";
var TileAboveTheFoldContent = import_react203.default.forwardRef(function TilAboveTheFoldContent(_ref5, ref) {
  let {
    children
  } = _ref5;
  const prefix = usePrefix();
  return import_react203.default.createElement("div", {
    ref,
    className: `${prefix}--tile-content__above-the-fold`
  }, children);
});
TileAboveTheFoldContent.propTypes = {
  /**
   * The child nodes.
   */
  children: import_prop_types155.default.node
};
TileAboveTheFoldContent.displayName = "TileAboveTheFoldContent";
var TileBelowTheFoldContent = import_react203.default.forwardRef(function TileBelowTheFoldContent2(_ref6, ref) {
  let {
    children
  } = _ref6;
  const prefix = usePrefix();
  return import_react203.default.createElement("div", {
    ref,
    className: `${prefix}--tile-content__below-the-fold`
  }, children);
});
TileBelowTheFoldContent.propTypes = {
  /**
   * The child nodes.
   */
  children: import_prop_types155.default.node
};
TileBelowTheFoldContent.displayName = "TileBelowTheFoldContent";

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/TileGroup/TileGroup.js
var import_prop_types156 = __toESM(require_prop_types());
var import_react204 = __toESM(require_react());
var TileGroup = (props) => {
  const {
    children,
    className,
    defaultSelected,
    disabled,
    legend,
    name,
    onChange = noopFn,
    valueSelected,
    required
  } = props;
  const prefix = usePrefix();
  const [selected, setSelected] = (0, import_react204.useState)(valueSelected ?? defaultSelected);
  const [prevValueSelected, setPrevValueSelected] = (0, import_react204.useState)(valueSelected);
  if (valueSelected !== prevValueSelected) {
    setSelected(valueSelected);
    setPrevValueSelected(valueSelected);
  }
  const getRadioTilesWithWrappers = (children2) => {
    const traverseAndModifyChildren = (children3) => {
      return import_react204.default.Children.map(children3, (child) => {
        var _a;
        if ((child == null ? void 0 : child.type) === RadioTile) {
          const {
            value,
            ...otherProps
          } = child.props;
          return import_react204.default.createElement(RadioTile, _extends({}, otherProps, {
            required,
            name,
            key: value,
            value,
            onChange: handleChange,
            checked: value === selected
          }));
        } else if ((_a = child == null ? void 0 : child.props) == null ? void 0 : _a.children) {
          return import_react204.default.cloneElement(child, {
            ...child.props,
            children: traverseAndModifyChildren(child.props.children)
          });
        } else {
          return child;
        }
      });
    };
    return import_react204.default.createElement(import_react204.default.Fragment, null, traverseAndModifyChildren(children2));
  };
  const handleChange = (newSelection, value, evt) => {
    if (newSelection !== selected) {
      setSelected(newSelection);
      onChange(newSelection, name, evt);
    }
  };
  const renderLegend = (legend2) => {
    if (legend2) {
      return import_react204.default.createElement("legend", {
        className: `${prefix}--label`
      }, legend2);
    }
  };
  return import_react204.default.createElement("fieldset", {
    className: className ?? `${prefix}--tile-group`,
    disabled
  }, renderLegend(legend), import_react204.default.createElement("div", null, getRadioTilesWithWrappers(children)));
};
TileGroup.propTypes = {
  /**
   * Provide a collection of <RadioTile> components to render in the group
   */
  children: import_prop_types156.default.node,
  /**
   * Provide an optional className to be applied to the container node
   */
  className: import_prop_types156.default.string,
  /**
   * Specify the the value of <RadioTile> to be selected by default
   */
  defaultSelected: import_prop_types156.default.oneOfType([import_prop_types156.default.string, import_prop_types156.default.number]),
  /**
   * Specify whether the group is disabled
   */
  disabled: import_prop_types156.default.bool,
  /**
   * Provide an optional legend for this group
   */
  legend: import_prop_types156.default.string,
  /**
   * Specify the name of the underlying `<input>` nodes
   */
  name: import_prop_types156.default.string.isRequired,
  /**
   * Provide an optional `onChange` hook that is called whenever the value of
   * the group changes
   */
  onChange: import_prop_types156.default.func,
  /**
   * `true` to specify if input selection in group is required.
   */
  required: import_prop_types156.default.bool,
  /**
   * Specify the value that is currently selected in the group
   */
  valueSelected: import_prop_types156.default.oneOfType([import_prop_types156.default.string, import_prop_types156.default.number])
};
TileGroup.displayName = "TileGroup";

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/TimePicker/TimePicker.js
var import_classnames135 = __toESM(require_classnames());
var import_prop_types157 = __toESM(require_prop_types());
var import_react205 = __toESM(require_react());
var TimePicker = import_react205.default.forwardRef(function TimePicker2(_ref, ref) {
  let {
    children,
    className,
    disabled = false,
    hideLabel,
    id,
    invalidText = "Invalid time format.",
    invalid = false,
    warningText = "Warning message.",
    warning: warning3 = false,
    labelText,
    light = false,
    maxLength = 5,
    onChange = () => {
    },
    onClick = () => {
    },
    onBlur = () => {
    },
    pattern = "(1[012]|[1-9]):[0-5][0-9](\\s)?",
    placeholder = "hh:mm",
    readOnly,
    size: size6 = "md",
    type = "text",
    value,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const [isValue, setValue] = import_react205.default.useState(value);
  const [prevValue, setPrevValue] = import_react205.default.useState(value);
  if (value !== prevValue) {
    setValue(value);
    setPrevValue(value);
  }
  function handleOnClick(evt) {
    if (!disabled) {
      if (!readOnly) {
        setValue(isValue);
      }
      onClick(evt);
    }
  }
  function handleOnChange(evt) {
    if (!disabled && !readOnly) {
      setValue(isValue);
      onChange(evt);
    }
  }
  function handleOnBlur(evt) {
    if (!disabled) {
      if (!readOnly) {
        setValue(isValue);
      }
      onBlur(evt);
    }
  }
  const timePickerInputClasses = (0, import_classnames135.default)(`${prefix}--time-picker__input-field`, `${prefix}--text-input`, [className], {
    [`${prefix}--text-input--light`]: light,
    [`${prefix}--time-picker__input-field-error`]: invalid || warning3
  });
  const timePickerClasses = (0, import_classnames135.default)({
    [`${prefix}--time-picker`]: true,
    [`${prefix}--time-picker--light`]: light,
    [`${prefix}--time-picker--invalid`]: invalid,
    [`${prefix}--time-picker--warning`]: warning3,
    [`${prefix}--time-picker--readonly`]: readOnly,
    [`${prefix}--time-picker--${size6}`]: size6,
    ...className && {
      [className]: true
    }
  });
  const labelClasses = (0, import_classnames135.default)(`${prefix}--label`, {
    [`${prefix}--visually-hidden`]: hideLabel,
    [`${prefix}--label--disabled`]: disabled
  });
  const label = labelText ? import_react205.default.createElement("label", {
    htmlFor: id,
    className: labelClasses
  }, labelText) : null;
  function getInternalPickerSelects() {
    const readOnlyEventHandlers = {
      onMouseDown: (evt) => {
        if (readOnly) {
          evt.preventDefault();
          evt.target.focus();
        }
      },
      onKeyDown: (evt) => {
        const selectAccessKeys = ["ArrowDown", "ArrowUp", " "];
        if (readOnly && selectAccessKeys.includes(evt.key)) {
          evt.preventDefault();
        }
      }
    };
    const mappedChildren = import_react205.default.Children.map(children, (pickerSelect) => {
      const item = pickerSelect;
      if (item) {
        return import_react205.default.cloneElement(item, {
          ...item.props,
          disabled: item.props.disabled ?? disabled,
          readOnly,
          ...readOnlyEventHandlers
        });
      }
    });
    return mappedChildren;
  }
  const readOnlyProps = {
    readOnly
  };
  return import_react205.default.createElement("div", {
    className: (0, import_classnames135.default)(`${prefix}--form-item`, className)
  }, label, import_react205.default.createElement("div", {
    className: timePickerClasses
  }, import_react205.default.createElement("div", {
    className: `${prefix}--time-picker__input`
  }, import_react205.default.createElement("input", _extends({
    className: timePickerInputClasses,
    "data-invalid": invalid ? invalid : void 0,
    disabled,
    id,
    maxLength,
    onClick: handleOnClick,
    onChange: handleOnChange,
    onBlur: handleOnBlur,
    placeholder,
    pattern,
    ref,
    type,
    value
  }, rest3, readOnlyProps)), (invalid || warning3) && import_react205.default.createElement("div", {
    className: `${prefix}--time-picker__error__icon`
  }, invalid ? import_react205.default.createElement(WarningFilled, {
    className: `${prefix}--checkbox__invalid-icon`,
    size: 16
  }) : import_react205.default.createElement(WarningAltFilled, {
    className: `${prefix}--text-input__invalid-icon--warning`,
    size: 16
  }))), getInternalPickerSelects()), (invalid || warning3) && import_react205.default.createElement("div", {
    className: `${prefix}--form-requirement`
  }, invalid ? invalidText : warningText));
});
TimePicker.propTypes = {
  /**
   * Pass in the children that will be rendered next to the form control
   */
  children: import_prop_types157.default.node,
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types157.default.string,
  /**
   * Specify whether the `<input>` should be disabled
   */
  disabled: import_prop_types157.default.bool,
  /**
   * Specify whether you want the underlying label to be visually hidden
   */
  hideLabel: import_prop_types157.default.bool,
  /**
   * Specify a custom `id` for the `<input>`
   */
  id: import_prop_types157.default.string.isRequired,
  /**
   * Specify whether the control is currently invalid
   */
  invalid: import_prop_types157.default.bool,
  /**
   * Provide the text that is displayed when the control is in an invalid state
   */
  invalidText: import_prop_types157.default.node,
  /**
   * Provide the text that will be read by a screen reader when visiting this
   * control
   */
  labelText: import_prop_types157.default.node,
  /**
   * The `light` prop for `TimePicker` has been deprecated. It will be removed in v12. Use the `Layer` component instead.
   */
  light: deprecate(import_prop_types157.default.bool, "The `light` prop for `TimePicker` is no longer needed and has been deprecated. It will be removed in the next major release. Use the `Layer` component instead."),
  /**
   * Specify the maximum length of the time string in `<input>`
   */
  maxLength: import_prop_types157.default.number,
  /**
   * Optionally provide an `onBlur` handler that is called whenever the
   * `<input>` loses focus
   */
  onBlur: import_prop_types157.default.func,
  /**
   * Optionally provide an `onChange` handler that is called whenever `<input>`
   * is updated
   */
  onChange: import_prop_types157.default.func,
  /**
   * Optionally provide an `onClick` handler that is called whenever the
   * `<input>` is clicked
   */
  onClick: import_prop_types157.default.func,
  /**
   * Specify the regular expression working as the pattern of the time string in `<input>`
   */
  pattern: import_prop_types157.default.string,
  /**
   * Specify the placeholder attribute for the `<input>`
   */
  placeholder: import_prop_types157.default.string,
  /**
   * Specify whether the TimePicker should be read-only
   */
  readOnly: import_prop_types157.default.bool,
  /**
   * Specify the size of the Time Picker.
   */
  size: import_prop_types157.default.oneOf(["sm", "md", "lg"]),
  /**
   * Specify the type of the `<input>`
   */
  type: import_prop_types157.default.string,
  /**
   * Specify the value of the `<input>`
   */
  value: import_prop_types157.default.string,
  /**
   * Specify a warning message
   */
  warning: import_prop_types157.default.bool,
  /**
   * Provide the text that is displayed when the control is in an warning state
   */
  warningText: import_prop_types157.default.node
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/TimePickerSelect/TimePickerSelect.js
var import_classnames136 = __toESM(require_classnames());
var import_prop_types158 = __toESM(require_prop_types());
var import_react206 = __toESM(require_react());
var TimePickerSelect = import_react206.default.forwardRef(function TimePickerSelect2(_ref, ref) {
  let {
    ["aria-label"]: ariaLabel = "open list of options",
    children,
    id,
    disabled = false,
    className,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const selectClasses = (0, import_classnames136.default)({
    [`${prefix}--select`]: true,
    [`${prefix}--time-picker__select`]: true,
    ...className && {
      [className]: true
    }
  });
  return import_react206.default.createElement("div", {
    className: selectClasses
  }, import_react206.default.createElement("select", _extends({
    "aria-label": ariaLabel,
    className: `${prefix}--select-input`,
    disabled,
    id,
    ref
  }, rest3), children), import_react206.default.createElement(ChevronDown, {
    className: `${prefix}--select__arrow`,
    "aria-hidden": "true"
  }));
});
TimePickerSelect.propTypes = {
  /**
   * Provide the contents of your TimePickerSelect
   */
  children: import_prop_types158.default.node,
  /**
   * Specify an optional className to be applied to the node containing the label and the select box
   */
  className: import_prop_types158.default.string,
  /**
   * Optionally provide the default value of the `<select>`
   */
  defaultValue: import_prop_types158.default.any,
  /**
   * Specify whether the control is disabled
   */
  disabled: import_prop_types158.default.bool,
  /**
   * Specify a custom `id` for the `<select>`
   */
  id: import_prop_types158.default.string.isRequired
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Toggle/Toggle.js
var import_react207 = __toESM(require_react());
var import_prop_types159 = __toESM(require_prop_types());
var import_classnames137 = __toESM(require_classnames());
var _path15;
function Toggle(_ref) {
  let {
    "aria-labelledby": ariaLabelledby,
    className,
    defaultToggled = false,
    disabled = false,
    hideLabel = false,
    id,
    labelA = "Off",
    labelB = "On",
    labelText,
    onClick,
    onToggle,
    readOnly,
    size: size6 = "md",
    toggled,
    ...other
  } = _ref;
  const prefix = usePrefix();
  const buttonElement = (0, import_react207.useRef)(null);
  const [checked, setChecked] = useControllableState({
    value: toggled,
    onChange: onToggle,
    defaultValue: defaultToggled
  });
  function handleClick2(e2) {
    if (!readOnly) {
      setChecked(!checked);
    }
    if (onClick) {
      onClick(e2);
    }
  }
  const isSm = size6 === "sm";
  const sideLabel = hideLabel ? labelText : checked ? labelB : labelA;
  const renderSideLabel = !(hideLabel && !labelText);
  const LabelComponent = labelText ? "label" : "div";
  const wrapperClasses = (0, import_classnames137.default)(`${prefix}--toggle`, {
    [`${prefix}--toggle--disabled`]: disabled,
    [`${prefix}--toggle--readonly`]: readOnly
  }, className);
  const labelTextClasses = (0, import_classnames137.default)(`${prefix}--toggle__label-text`, {
    [`${prefix}--visually-hidden`]: hideLabel
  });
  const appearanceClasses = (0, import_classnames137.default)(`${prefix}--toggle__appearance`, {
    [`${prefix}--toggle__appearance--sm`]: isSm
  });
  const switchClasses = (0, import_classnames137.default)(`${prefix}--toggle__switch`, {
    [`${prefix}--toggle__switch--checked`]: checked
  });
  const labelId = `${id}_label`;
  return (
    // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions
    import_react207.default.createElement("div", {
      className: wrapperClasses,
      onClick: !labelText ? (e2) => {
        if (buttonElement.current && e2.target !== buttonElement.current && !disabled) {
          handleClick2(e2);
          buttonElement.current.focus();
        }
      } : void 0
    }, import_react207.default.createElement("button", _extends({}, other, {
      ref: buttonElement,
      id,
      className: `${prefix}--toggle__button`,
      role: "switch",
      type: "button",
      "aria-checked": checked,
      "aria-labelledby": ariaLabelledby ?? (labelText ? labelId : void 0),
      disabled,
      onClick: handleClick2
    })), import_react207.default.createElement(LabelComponent, {
      id: labelId,
      htmlFor: ariaLabelledby ? void 0 : id,
      className: `${prefix}--toggle__label`
    }, labelText && import_react207.default.createElement(Text, {
      className: labelTextClasses
    }, labelText), import_react207.default.createElement("div", {
      className: appearanceClasses
    }, import_react207.default.createElement("div", {
      className: switchClasses
    }, isSm && import_react207.default.createElement("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: `${prefix}--toggle__check`,
      width: "6px",
      height: "5px",
      viewBox: "0 0 6 5"
    }, _path15 || (_path15 = import_react207.default.createElement("path", {
      d: "M2.2 2.7L5 0 6 1 2.2 5 0 2.7 1 1.5z"
    })))), renderSideLabel && import_react207.default.createElement(Text, {
      className: `${prefix}--toggle__text`,
      "aria-hidden": "true"
    }, sideLabel))))
  );
}
Toggle.propTypes = {
  /**
   * Specify another element's id to be used as the label for this toggle
   */
  "aria-labelledby": import_prop_types159.default.string,
  /**
   * Specify a custom className to apply to the form-item node
   */
  className: import_prop_types159.default.string,
  /**
   * Specify whether the toggle should be on by default
   */
  defaultToggled: import_prop_types159.default.bool,
  /**
   * Whether this control should be disabled
   */
  disabled: import_prop_types159.default.bool,
  /**
   * If true, the side labels (props.labelA and props.labelB) will be replaced by
   * props.labelText (if passed), so that the toggle doesn't render a top label.
   */
  hideLabel: import_prop_types159.default.bool,
  /**
   * Provide an id that unique represents the underlying `<button>`
   */
  id: import_prop_types159.default.string.isRequired,
  /**
   * Specify the label for the "off" position
   */
  labelA: import_prop_types159.default.node,
  /**
   * Specify the label for the "on" position
   */
  labelB: import_prop_types159.default.node,
  /**
   * Provide the text that will be read by a screen reader when visiting this
   * control. This should be provided unless 'aria-labelledby' is set instead
   * or you use an external <label> element with its "for" attribute set to the
   * toggle's id.
   */
  labelText: import_prop_types159.default.string,
  /**
   * Provide an event listener that is called when the control is clicked
   */
  onClick: import_prop_types159.default.func,
  /**
   * Provide an event listener that is called when the control is toggled
   */
  onToggle: import_prop_types159.default.func,
  /**
   * Whether the toggle should be read-only
   */
  readOnly: import_prop_types159.default.bool,
  /**
   * Specify the size of the Toggle. Currently only supports 'sm' or 'md' (default)
   */
  size: import_prop_types159.default.oneOf(["sm", "md"]),
  /**
   * Specify whether the control is toggled
   */
  toggled: import_prop_types159.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Toggle/Toggle.Skeleton.js
var import_prop_types160 = __toESM(require_prop_types());
var import_react208 = __toESM(require_react());
var import_classnames138 = __toESM(require_classnames());
var ToggleSkeleton = (_ref) => {
  let {
    className,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const skeletonClassNames = (0, import_classnames138.default)(`${prefix}--toggle ${prefix}--toggle--skeleton`, className);
  return import_react208.default.createElement("div", _extends({
    className: skeletonClassNames
  }, rest3), import_react208.default.createElement("div", {
    className: `${prefix}--toggle__skeleton-circle`
  }), import_react208.default.createElement("div", {
    className: `${prefix}--toggle__skeleton-rectangle`
  }));
};
ToggleSkeleton.propTypes = {
  "aria-label": import_prop_types160.default.string,
  className: import_prop_types160.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ToggleSmall/ToggleSmall.Skeleton.js
var import_prop_types161 = __toESM(require_prop_types());
var import_react209 = __toESM(require_react());
var import_classnames139 = __toESM(require_classnames());
var _path16;
var ToggleSmallSkeleton = class extends import_react209.default.Component {
  render() {
    const {
      id,
      labelText,
      className,
      ...rest3
    } = this.props;
    return import_react209.default.createElement(PrefixContext.Consumer, null, (prefix) => {
      return import_react209.default.createElement("div", _extends({
        className: (0, import_classnames139.default)(`${prefix}--form-item`, className)
      }, rest3), import_react209.default.createElement("input", {
        type: "checkbox",
        id,
        className: `${prefix}--toggle ${prefix}--toggle--small ${prefix}--skeleton`
      }), import_react209.default.createElement("label", {
        className: `${prefix}--toggle__label ${prefix}--skeleton`,
        htmlFor: id
      }, labelText && import_react209.default.createElement("span", {
        className: `${prefix}--toggle__label-text`
      }, labelText), import_react209.default.createElement("span", {
        className: `${prefix}--toggle__appearance`
      }, import_react209.default.createElement("svg", {
        className: `${prefix}--toggle__check`,
        width: "6px",
        height: "5px",
        viewBox: "0 0 6 5"
      }, _path16 || (_path16 = import_react209.default.createElement("path", {
        d: "M2.2403 2.7299L4.9245 0 6 1.1117 2.2384 5 0 2.6863 1.0612 1.511z"
      }))))));
    });
  }
};
_defineProperty(ToggleSmallSkeleton, "propTypes", {
  ["aria-label"]: import_prop_types161.default.string.isRequired,
  /**
   * Specify an optional className to add to the form item wrapper.
   */
  className: import_prop_types161.default.string,
  /**
   * Provide an id that unique represents the underlying `<input>`
   */
  id: import_prop_types161.default.string,
  /**
   * Provide the text that will be read by a screen reader when visiting this
   * control
   * `aria-label` is always required but will be null if `labelText` is also
   * provided
   */
  labelText: import_prop_types161.default.string
});

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Toggletip/index.js
var import_classnames140 = __toESM(require_classnames());
var import_prop_types162 = __toESM(require_prop_types());
var import_react210 = __toESM(require_react());
function ToggletipLabel(_ref) {
  let {
    as: BaseComponent = "span",
    children,
    className: customClassName
  } = _ref;
  const prefix = usePrefix();
  const className = (0, import_classnames140.default)(`${prefix}--toggletip-label`, customClassName);
  const BaseComponentAsAny = BaseComponent;
  return import_react210.default.createElement(BaseComponentAsAny, {
    className
  }, children);
}
ToggletipLabel.propTypes = {
  /**
   * Provide a custom element or component to render the top-level node for the
   * component.
   */
  as: import_prop_types162.default.elementType,
  /**
   * Custom children to be rendered as the content of the label
   */
  children: import_prop_types162.default.node,
  /**
   * Provide a custom class name to be added to the outermost node in the
   * component
   */
  className: import_prop_types162.default.string
};
var ToggletipContext = import_react210.default.createContext(void 0);
function useToggletip() {
  return (0, import_react210.useContext)(ToggletipContext);
}
function Toggletip(_ref2) {
  let {
    align,
    as,
    autoAlign,
    className: customClassName,
    children,
    defaultOpen = false,
    ...rest3
  } = _ref2;
  const ref = (0, import_react210.useRef)(null);
  const [open, setOpen] = (0, import_react210.useState)(defaultOpen);
  const prefix = usePrefix();
  const id = useId();
  const className = (0, import_classnames140.default)(`${prefix}--toggletip`, customClassName, {
    [`${prefix}--toggletip--open`]: open,
    [`${prefix}--autoalign`]: autoAlign
  });
  const actions = {
    toggle: () => {
      setOpen(!open);
    },
    close: () => {
      setOpen(false);
    }
  };
  const value = {
    buttonProps: {
      "aria-expanded": open,
      "aria-controls": id,
      onClick: actions.toggle
    },
    contentProps: {
      id
    },
    onClick: {
      onClick: actions.toggle
    }
  };
  const onKeyDown = (event) => {
    var _a;
    if (open && match(event, Escape)) {
      actions.close();
      const button = (_a = ref.current) == null ? void 0 : _a.children[0];
      if (button instanceof HTMLButtonElement) {
        button.focus();
      }
    }
  };
  const handleBlur = (event) => {
    if (open && event.relatedTarget === null) {
      return;
    }
    if (!event.currentTarget.contains(event.relatedTarget)) {
      actions.close();
    }
  };
  useWindowEvent("blur", () => {
    if (open) {
      actions.close();
    }
  });
  useWindowEvent("click", (event) => {
    if (open && ref.current && !ref.current.contains(event.target)) {
      actions.close();
    }
  });
  return import_react210.default.createElement(ToggletipContext.Provider, {
    value
  }, import_react210.default.createElement(Popover, _extends({
    align,
    as,
    caret: true,
    className,
    dropShadow: false,
    highContrast: true,
    open,
    onKeyDown,
    onBlur: handleBlur,
    ref,
    autoAlign
  }, rest3), children));
}
Toggletip.propTypes = {
  /**
   * Specify how the toggletip should align with the button
   */
  align: import_prop_types162.default.oneOf([
    "top",
    "top-left",
    // deprecated use top-start instead
    "top-right",
    // deprecated use top-end instead
    "bottom",
    "bottom-left",
    // deprecated use bottom-start instead
    "bottom-right",
    // deprecated use bottom-end instead
    "left",
    "left-bottom",
    // deprecated use left-end instead
    "left-top",
    // deprecated use left-start instead
    "right",
    "right-bottom",
    // deprecated use right-end instead
    "right-top",
    // deprecated use right-start instead
    // new values to match floating-ui
    "top-start",
    "top-end",
    "bottom-start",
    "bottom-end",
    "left-end",
    "left-start",
    "right-end",
    "right-start"
  ]),
  /**
   * Provide an offset value for alignment axis.
   */
  alignmentAxisOffset: import_prop_types162.default.number,
  /**
   * Provide a custom element or component to render the top-level node for the
   * component.
   */
  as: import_prop_types162.default.elementType,
  /**
   * Will auto-align the popover on first render if it is not visible. This prop is currently experimental and is subject to future changes.
   */
  autoAlign: import_prop_types162.default.bool,
  /**
   * Custom children to be rendered as the content of the label
   */
  children: import_prop_types162.default.node,
  /**
   * Provide a custom class name to be added to the outermost node in the
   * component
   */
  className: import_prop_types162.default.string,
  /**
   * Specify if the toggletip should be open by default
   */
  defaultOpen: import_prop_types162.default.bool
};
var ToggletipButton = import_react210.default.forwardRef(function ToggletipButton2(_ref3, ref) {
  let {
    children,
    className: customClassName,
    label = "Show information",
    as: BaseComponent,
    ...rest3
  } = _ref3;
  const toggletip = useToggletip();
  const prefix = usePrefix();
  const className = (0, import_classnames140.default)(`${prefix}--toggletip-button`, customClassName);
  const ComponentToggle = BaseComponent ?? "button";
  if (ComponentToggle !== "button") {
    return import_react210.default.createElement(ComponentToggle, _extends({}, toggletip == null ? void 0 : toggletip.onClick, {
      className
    }, rest3), children);
  }
  return import_react210.default.createElement("button", _extends({}, toggletip == null ? void 0 : toggletip.buttonProps, {
    "aria-label": label,
    type: "button",
    className,
    ref
  }, rest3), children);
});
ToggletipButton.propTypes = {
  /**
   * Custom children to be rendered as the content of the label
   */
  children: import_prop_types162.default.node,
  /**
   * Provide a custom class name to be added to the outermost node in the
   * component
   */
  className: import_prop_types162.default.string,
  /**
   * Provide an accessible label for this button
   */
  label: import_prop_types162.default.string
};
ToggletipButton.displayName = "ToggletipButton";
var ToggletipContent = import_react210.default.forwardRef(function ToggletipContent2(_ref4, ref) {
  let {
    children,
    className: customClassName
  } = _ref4;
  const toggletip = useToggletip();
  const prefix = usePrefix();
  return import_react210.default.createElement(PopoverContent, _extends({
    className: customClassName
  }, toggletip == null ? void 0 : toggletip.contentProps, {
    ref
  }), import_react210.default.createElement("div", {
    className: `${prefix}--toggletip-content`
  }, children));
});
ToggletipContent.propTypes = {
  /**
   * Custom children to be rendered as the content of the label
   */
  children: import_prop_types162.default.node,
  /**
   * Provide a custom class name to be added to the outermost node in the
   * component
   */
  className: import_prop_types162.default.string
};
ToggletipContent.displayName = "ToggletipContent";
function ToggletipActions(_ref5) {
  let {
    children,
    className: customClassName
  } = _ref5;
  const prefix = usePrefix();
  const className = (0, import_classnames140.default)(`${prefix}--toggletip-actions`, customClassName);
  return import_react210.default.createElement("div", {
    className
  }, children);
}
ToggletipActions.propTypes = {
  /**
   * Custom children to be rendered as the content of the label
   */
  children: import_prop_types162.default.node,
  /**
   * Provide a custom class name to be added to the outermost node in the
   * component
   */
  className: import_prop_types162.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/TreeView/TreeNode.js
var import_classnames141 = __toESM(require_classnames());
var import_prop_types163 = __toESM(require_prop_types());
var import_react211 = __toESM(require_react());
var TreeNode = import_react211.default.forwardRef((_ref, forwardedRef) => {
  let {
    active,
    children,
    className,
    depth: propDepth,
    disabled,
    id: nodeId,
    isExpanded,
    defaultIsExpanded,
    label,
    onNodeFocusEvent,
    onSelect: onNodeSelect,
    onToggle,
    onTreeSelect,
    renderIcon: Icon,
    selected: propSelected,
    value,
    ...rest3
  } = _ref;
  const depth = propDepth;
  const selected = propSelected;
  const enableTreeviewControllable = useFeatureFlag("enable-treeview-controllable");
  const {
    current: id
  } = (0, import_react211.useRef)(nodeId || uniqueId2());
  const controllableExpandedState = useControllableState({
    value: isExpanded,
    onChange: onToggle,
    defaultValue: defaultIsExpanded
  });
  const uncontrollableExpandedState = (0, import_react211.useState)(isExpanded);
  const [expanded, setExpanded] = enableTreeviewControllable ? controllableExpandedState : uncontrollableExpandedState;
  const currentNode = (0, import_react211.useRef)(null);
  const currentNodeLabel = (0, import_react211.useRef)(null);
  const prefix = usePrefix();
  const setRefs = (element) => {
    currentNode.current = element;
    if (typeof forwardedRef === "function") {
      forwardedRef(element);
    } else if (forwardedRef) {
      forwardedRef.current = element;
    }
  };
  const nodesWithProps = import_react211.default.Children.map(children, (node) => {
    if (import_react211.default.isValidElement(node)) {
      return import_react211.default.cloneElement(node, {
        active,
        depth: depth + 1,
        disabled: disabled || node.props.disabled,
        onTreeSelect,
        selected,
        tabIndex: !node.props.disabled && -1 || null
      });
    }
  });
  const isActive = active === id;
  const isSelected = selected.includes(id);
  const treeNodeClasses = (0, import_classnames141.default)(className, `${prefix}--tree-node`, {
    [`${prefix}--tree-node--active`]: isActive,
    [`${prefix}--tree-node--disabled`]: disabled,
    [`${prefix}--tree-node--selected`]: isSelected,
    [`${prefix}--tree-node--with-icon`]: Icon,
    [`${prefix}--tree-leaf-node`]: !children,
    [`${prefix}--tree-parent-node`]: children
  });
  const toggleClasses = (0, import_classnames141.default)(`${prefix}--tree-parent-node__toggle-icon`, {
    [`${prefix}--tree-parent-node__toggle-icon--expanded`]: expanded
  });
  function handleToggleClick(event) {
    if (disabled) {
      return;
    }
    event.stopPropagation();
    if (!enableTreeviewControllable) {
      onToggle == null ? void 0 : onToggle(event, {
        id,
        isExpanded: !expanded,
        label,
        value
      });
    }
    setExpanded(!expanded);
  }
  function handleClick2(event) {
    var _a;
    event.stopPropagation();
    if (!disabled) {
      onTreeSelect == null ? void 0 : onTreeSelect(event, {
        id,
        label,
        value
      });
      onNodeSelect == null ? void 0 : onNodeSelect(event, {
        id,
        label,
        value
      });
      (_a = rest3 == null ? void 0 : rest3.onClick) == null ? void 0 : _a.call(rest3, event);
    }
  }
  function handleKeyDown(event) {
    var _a, _b, _c, _d;
    if (disabled) {
      return;
    }
    if (matches(event, [ArrowLeft, ArrowRight2, Enter])) {
      event.stopPropagation();
    }
    if (match(event, ArrowLeft)) {
      const findParentTreeNode = (node) => {
        if (!node) return null;
        if (node.classList.contains(`${prefix}--tree-parent-node`)) {
          return node;
        }
        if (node.classList.contains(`${prefix}--tree`)) {
          return null;
        }
        return findParentTreeNode(node.parentElement);
      };
      if (children && expanded) {
        if (!enableTreeviewControllable) {
          onToggle == null ? void 0 : onToggle(event, {
            id,
            isExpanded: false,
            label,
            value
          });
        }
        setExpanded(false);
      } else {
        const parentNode = findParentTreeNode(((_a = currentNode.current) == null ? void 0 : _a.parentElement) || null);
        if (parentNode instanceof HTMLElement) {
          parentNode.focus();
        }
      }
    }
    if (children && match(event, ArrowRight2)) {
      if (expanded) {
        ((_c = (_b = currentNode.current) == null ? void 0 : _b.lastChild) == null ? void 0 : _c.firstChild).focus();
      } else {
        if (!enableTreeviewControllable) {
          onToggle == null ? void 0 : onToggle(event, {
            id,
            isExpanded: true,
            label,
            value
          });
        }
        setExpanded(true);
      }
    }
    if (matches(event, [Enter, Space])) {
      event.preventDefault();
      handleClick2(event);
    }
    (_d = rest3 == null ? void 0 : rest3.onKeyDown) == null ? void 0 : _d.call(rest3, event);
  }
  function handleFocusEvent(event) {
    var _a, _b;
    if (event.type === "blur") {
      (_a = rest3 == null ? void 0 : rest3.onBlur) == null ? void 0 : _a.call(rest3, event);
    }
    if (event.type === "focus") {
      (_b = rest3 == null ? void 0 : rest3.onFocus) == null ? void 0 : _b.call(rest3, event);
    }
    onNodeFocusEvent == null ? void 0 : onNodeFocusEvent(event);
  }
  (0, import_react211.useEffect)(() => {
    const calcOffset = () => {
      if (children && Icon) {
        return depth + 1 + depth * 0.5;
      }
      if (children) {
        return depth + 1;
      }
      if (Icon) {
        return depth + 2 + depth * 0.5;
      }
      return depth + 2.5;
    };
    if (currentNodeLabel.current) {
      currentNodeLabel.current.style.marginInlineStart = `-${calcOffset()}rem`;
      currentNodeLabel.current.style.paddingInlineStart = `${calcOffset()}rem`;
    }
    if (!enableTreeviewControllable) {
      setExpanded(isExpanded);
    }
  }, [children, depth, Icon, isExpanded, enableTreeviewControllable, setExpanded]);
  const treeNodeProps = {
    ...rest3,
    ["aria-current"]: isActive || void 0,
    ["aria-selected"]: disabled ? void 0 : isSelected,
    ["aria-disabled"]: disabled,
    className: treeNodeClasses,
    id,
    onBlur: handleFocusEvent,
    onClick: handleClick2,
    onFocus: handleFocusEvent,
    onKeyDown: handleKeyDown,
    role: "treeitem"
  };
  if (!children) {
    return import_react211.default.createElement("li", _extends({}, treeNodeProps, {
      ref: setRefs
    }), import_react211.default.createElement("div", {
      className: `${prefix}--tree-node__label`,
      ref: currentNodeLabel
    }, Icon && import_react211.default.createElement(Icon, {
      className: `${prefix}--tree-node__icon`
    }), label));
  }
  return import_react211.default.createElement("li", _extends({}, treeNodeProps, {
    "aria-expanded": !!expanded,
    ref: setRefs
  }), import_react211.default.createElement("div", {
    className: `${prefix}--tree-node__label`,
    ref: currentNodeLabel
  }, import_react211.default.createElement("span", {
    className: `${prefix}--tree-parent-node__toggle`,
    disabled,
    onClick: handleToggleClick
  }, import_react211.default.createElement(CaretDown, {
    className: toggleClasses
  })), import_react211.default.createElement("span", {
    className: `${prefix}--tree-node__label__details`
  }, Icon && import_react211.default.createElement(Icon, {
    className: `${prefix}--tree-node__icon`
  }), label)), import_react211.default.createElement("ul", {
    role: "group",
    className: (0, import_classnames141.default)(`${prefix}--tree-node__children`, {
      [`${prefix}--tree-node--hidden`]: !expanded
    })
  }, nodesWithProps));
});
TreeNode.propTypes = {
  /**
   * **Note:** this is controlled by the parent TreeView component, do not set manually.
   * The ID of the active node in the tree
   */
  active: import_prop_types163.default.oneOfType([import_prop_types163.default.string, import_prop_types163.default.number]),
  /**
   * Specify the children of the TreeNode
   */
  children: import_prop_types163.default.node,
  /**
   * Specify an optional className to be applied to the TreeNode
   */
  className: import_prop_types163.default.string,
  /**
   * **[Experimental]** The default expansion state of the node.
   * *This is only supported with the `enable-treeview-controllable` feature flag!*
   */
  defaultIsExpanded: import_prop_types163.default.bool,
  /**
   * **Note:** this is controlled by the parent TreeView component, do not set manually.
   * TreeNode depth to determine spacing
   */
  depth: import_prop_types163.default.number,
  /**
   * Specify if the TreeNode is disabled
   */
  disabled: import_prop_types163.default.bool,
  /**
   * Specify the TreeNode's ID. Must be unique in the DOM and is used for props.active and props.selected
   */
  id: import_prop_types163.default.string,
  /**
   * Specify if the TreeNode is expanded (only applicable to parent nodes)
   */
  isExpanded: import_prop_types163.default.bool,
  /**
   * Rendered label for the TreeNode
   */
  label: import_prop_types163.default.node,
  /**
   * Callback function for when the node receives or loses focus
   */
  onNodeFocusEvent: import_prop_types163.default.func,
  /**
   * Callback function for when the node is selected
   */
  onSelect: import_prop_types163.default.func,
  /**
   * Callback function for when a parent node is expanded or collapsed
   */
  onToggle: import_prop_types163.default.func,
  /**
   * Callback function for when any node in the tree is selected
   */
  onTreeSelect: import_prop_types163.default.func,
  /**
   * Optional prop to allow each node to have an associated icon.
   * Can be a React component class
   */
  // @ts-ignore
  renderIcon: import_prop_types163.default.oneOfType([import_prop_types163.default.func, import_prop_types163.default.object]),
  /**
   * **Note:** this is controlled by the parent TreeView component, do not set manually.
   * Array containing all selected node IDs in the tree
   */
  // @ts-ignore
  selected: import_prop_types163.default.arrayOf(import_prop_types163.default.oneOfType([import_prop_types163.default.string, import_prop_types163.default.number])),
  /**
   * Specify the value of the TreeNode
   */
  value: import_prop_types163.default.string
};
TreeNode.displayName = "TreeNode";

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/TreeView/TreeView.js
var import_classnames142 = __toESM(require_classnames());
var import_prop_types164 = __toESM(require_prop_types());
var import_react212 = __toESM(require_react());
var TreeView = (_ref) => {
  let {
    active: prespecifiedActive,
    children,
    className,
    hideLabel = false,
    label,
    multiselect = false,
    onActivate,
    onSelect,
    selected: preselected,
    size: size6 = "sm",
    ...rest3
  } = _ref;
  const enableTreeviewControllable = useFeatureFlag("enable-treeview-controllable");
  const {
    current: treeId
  } = (0, import_react212.useRef)(rest3.id || uniqueId2());
  const prefix = usePrefix();
  const treeClasses = (0, import_classnames142.default)(className, `${prefix}--tree`, {
    // @ts-ignore - will always be false according to prop types
    [`${prefix}--tree--${size6}`]: size6 !== "default"
  });
  const treeRootRef = (0, import_react212.useRef)(null);
  const treeWalker = (0, import_react212.useRef)(treeRootRef == null ? void 0 : treeRootRef.current);
  const controllableSelectionState = useControllableState({
    value: preselected,
    onChange: onSelect,
    defaultValue: []
  });
  const uncontrollableSelectionState = (0, import_react212.useState)(preselected ?? []);
  const [selected, setSelected] = enableTreeviewControllable ? controllableSelectionState : uncontrollableSelectionState;
  const controllableActiveState = useControllableState({
    value: prespecifiedActive,
    onChange: onActivate,
    defaultValue: void 0
  });
  const uncontrollableActiveState = (0, import_react212.useState)(prespecifiedActive);
  const [active, setActive] = enableTreeviewControllable ? controllableActiveState : uncontrollableActiveState;
  function resetNodeTabIndices() {
    var _a;
    Array.prototype.forEach.call(((_a = treeRootRef == null ? void 0 : treeRootRef.current) == null ? void 0 : _a.querySelectorAll('[tabIndex="0"]')) ?? [], (item) => {
      item.tabIndex = -1;
    });
  }
  function handleTreeSelect(event) {
    let node = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const nodeId = node.id;
    if (multiselect && (event.metaKey || event.ctrlKey)) {
      if (!selected.includes(nodeId)) {
        setSelected(selected.concat(nodeId));
      } else {
        setSelected(selected.filter((selectedId) => selectedId !== nodeId));
      }
      if (!enableTreeviewControllable) {
        onSelect == null ? void 0 : onSelect(event, node);
      }
    } else {
      setSelected([nodeId]);
      setActive(nodeId);
      if (!enableTreeviewControllable) {
        onSelect == null ? void 0 : onSelect(event, {
          activeNodeId: nodeId,
          ...node
        });
      }
    }
  }
  function handleFocusEvent(event) {
    var _a, _b;
    if (event.type === "blur") {
      const {
        relatedTarget: currentFocusedNode,
        target: prevFocusedNode
      } = event;
      if ((_a = treeRootRef == null ? void 0 : treeRootRef.current) == null ? void 0 : _a.contains(currentFocusedNode)) {
        prevFocusedNode.tabIndex = -1;
      }
    }
    if (event.type === "focus") {
      resetNodeTabIndices();
      const {
        relatedTarget: prevFocusedNode,
        target: currentFocusedNode
      } = event;
      if ((_b = treeRootRef == null ? void 0 : treeRootRef.current) == null ? void 0 : _b.contains(prevFocusedNode)) {
        prevFocusedNode.tabIndex = -1;
      }
      currentFocusedNode.tabIndex = 0;
    }
  }
  let focusTarget = false;
  const nodesWithProps = import_react212.default.Children.map(children, (_node) => {
    const node = _node;
    const sharedNodeProps = {
      active,
      depth: 0,
      onNodeFocusEvent: handleFocusEvent,
      onTreeSelect: handleTreeSelect,
      selected,
      tabIndex: !node.props.disabled && -1 || void 0
    };
    if (!focusTarget && !node.props.disabled) {
      sharedNodeProps.tabIndex = 0;
      focusTarget = true;
    }
    if (import_react212.default.isValidElement(node)) {
      return import_react212.default.cloneElement(node, sharedNodeProps);
    }
  });
  function handleKeyDown(event) {
    var _a, _b, _c;
    event.stopPropagation();
    if (matches(event, [
      ArrowUp2,
      ArrowDown,
      Home,
      End,
      // @ts-ignore - `matches` doesn't like the object syntax without missing properties
      {
        code: "KeyA"
      }
    ])) {
      event.preventDefault();
    }
    if (!treeWalker.current) {
      return;
    }
    treeWalker.current.currentNode = event.target;
    let nextFocusNode = null;
    if (match(event, ArrowUp2)) {
      nextFocusNode = treeWalker.current.previousNode();
    }
    if (match(event, ArrowDown)) {
      nextFocusNode = treeWalker.current.nextNode();
    }
    if (matches(event, [Home, End, {
      code: "KeyA"
    }])) {
      const nodeIds = [];
      if (matches(event, [Home, End])) {
        if (multiselect && event.shiftKey && event.ctrlKey && treeWalker.current.currentNode instanceof Element && !treeWalker.current.currentNode.getAttribute("aria-disabled") && !treeWalker.current.currentNode.classList.contains(`${prefix}--tree-node--hidden`)) {
          nodeIds.push((_a = treeWalker.current.currentNode) == null ? void 0 : _a.id);
        }
        while (match(event, Home) ? treeWalker.current.previousNode() : treeWalker.current.nextNode()) {
          nextFocusNode = treeWalker.current.currentNode;
          if (multiselect && event.shiftKey && event.ctrlKey && nextFocusNode instanceof Element && !nextFocusNode.getAttribute("aria-disabled") && !nextFocusNode.classList.contains(`${prefix}--tree-node--hidden`)) {
            nodeIds.push(nextFocusNode == null ? void 0 : nextFocusNode.id);
          }
        }
      }
      if (match(event, {
        code: "KeyA"
      }) && event.ctrlKey) {
        treeWalker.current.currentNode = treeWalker.current.root;
        while (treeWalker.current.nextNode()) {
          if (treeWalker.current.currentNode instanceof Element && !treeWalker.current.currentNode.getAttribute("aria-disabled") && !treeWalker.current.currentNode.classList.contains(`${prefix}--tree-node--hidden`)) {
            nodeIds.push((_b = treeWalker.current.currentNode) == null ? void 0 : _b.id);
          }
        }
      }
      setSelected(selected.concat(nodeIds));
    }
    if (nextFocusNode && nextFocusNode !== event.target) {
      resetNodeTabIndices();
      if (nextFocusNode instanceof HTMLElement) {
        nextFocusNode.tabIndex = 0;
        nextFocusNode.focus();
      }
    }
    (_c = rest3 == null ? void 0 : rest3.onKeyDown) == null ? void 0 : _c.call(rest3, event);
  }
  (0, import_react212.useEffect)(() => {
    treeWalker.current = treeWalker.current ?? document.createTreeWalker(treeRootRef == null ? void 0 : treeRootRef.current, NodeFilter.SHOW_ELEMENT, {
      acceptNode: function(node) {
        if (!(node instanceof Element)) {
          return NodeFilter.FILTER_SKIP;
        }
        if (node.classList.contains(`${prefix}--tree-node--disabled`) || node.classList.contains(`${prefix}--tree-node--hidden`)) {
          return NodeFilter.FILTER_REJECT;
        }
        if (node.matches(`li.${prefix}--tree-node`)) {
          return NodeFilter.FILTER_ACCEPT;
        }
        return NodeFilter.FILTER_SKIP;
      }
    });
  }, [prefix]);
  const useActiveAndSelectedOnMount = () => (0, import_react212.useEffect)(() => {
    if (!enableTreeviewControllable) {
      if (preselected == null ? void 0 : preselected.length) {
        setSelected(preselected);
      }
      if (prespecifiedActive) {
        setActive(prespecifiedActive);
      }
    }
  }, []);
  useActiveAndSelectedOnMount();
  const labelId = `${treeId}__label`;
  const TreeLabel = () => !hideLabel ? import_react212.default.createElement("label", {
    id: labelId,
    className: `${prefix}--label`
  }, label) : null;
  return import_react212.default.createElement(import_react212.default.Fragment, null, import_react212.default.createElement(TreeLabel, null), import_react212.default.createElement("ul", _extends({}, rest3, {
    "aria-label": hideLabel ? label : void 0,
    "aria-labelledby": !hideLabel ? labelId : void 0,
    "aria-multiselectable": multiselect || void 0,
    className: treeClasses,
    onKeyDown: handleKeyDown,
    ref: treeRootRef,
    role: "tree"
  }), nodesWithProps));
};
TreeView.propTypes = {
  /**
   * Mark the active node in the tree, represented by its ID
   */
  active: import_prop_types164.default.oneOfType([import_prop_types164.default.string, import_prop_types164.default.number]),
  /**
   * Specify the children of the TreeView
   */
  children: import_prop_types164.default.node,
  /**
   * Specify an optional className to be applied to the TreeView
   */
  className: import_prop_types164.default.string,
  /**
   * Specify whether or not the label should be hidden
   */
  hideLabel: import_prop_types164.default.bool,
  /**
   * Provide the label text that will be read by a screen reader
   */
  label: import_prop_types164.default.string.isRequired,
  /**
   * **[Experimental]** Specify the selection mode of the tree.
   * If `multiselect` is `false` then only one node can be selected at a time
   */
  multiselect: import_prop_types164.default.bool,
  /**
   * **[Experimental]** Callback function that is called when any node is activated.
   * *This is only supported with the `enable-treeview-controllable` feature flag!*
   */
  onActivate: import_prop_types164.default.func,
  /**
   * Callback function that is called when any node is selected
   */
  onSelect: import_prop_types164.default.func,
  /**
   * Array representing all selected node IDs in the tree
   */
  selected: import_prop_types164.default.arrayOf(import_prop_types164.default.oneOfType([import_prop_types164.default.string, import_prop_types164.default.number])),
  /**
   * Specify the size of the tree from a list of available sizes.
   */
  size: import_prop_types164.default.oneOf(["xs", "sm"])
};
TreeView.TreeNode = TreeNode;

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/Content.js
var import_classnames143 = __toESM(require_classnames());
var import_prop_types165 = __toESM(require_prop_types());
var import_react213 = __toESM(require_react());
var Content = (_ref) => {
  let {
    className: customClassName,
    children,
    tagName = "main",
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const className = (0, import_classnames143.default)(`${prefix}--content`, customClassName);
  return import_react213.default.createElement(tagName, {
    ...rest3,
    className
  }, children);
};
Content.propTypes = {
  /**
   * Provide children nodes to be rendered in the content container
   */
  children: import_prop_types165.default.node,
  /**
   * Optionally provide a custom class name that is applied to the container
   */
  className: import_prop_types165.default.string,
  /**
   * Optionally specify the tag of the content node. Defaults to `main`
   */
  tagName: import_prop_types165.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/Header.js
var import_classnames144 = __toESM(require_classnames());
var import_prop_types167 = __toESM(require_prop_types());
var import_react214 = __toESM(require_react());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/prop-types/AriaPropTypes.js
var import_prop_types166 = __toESM(require_prop_types());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/prop-types/isRequiredOneOf.js
function isRequiredOneOf(propTypes2) {
  const names = Object.keys(propTypes2);
  const checker = (propType) => function(props, propName, componentName) {
    if (names.every((name) => typeof props[name] === "undefined")) {
      return new Error(`${componentName} requires one of the following props: ${names.join(", ")}`);
    }
    for (var _len = arguments.length, rest3 = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      rest3[_key - 3] = arguments[_key];
    }
    return propType(props, propName, componentName, ...rest3);
  };
  return names.reduce((o2, name) => ({
    ...o2,
    [name]: checker(propTypes2[name])
  }), {});
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/prop-types/AriaPropTypes.js
var AriaLabelPropType = isRequiredOneOf({
  "aria-label": import_prop_types166.default.string,
  "aria-labelledby": import_prop_types166.default.string
});

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/Header.js
var Header = (_ref) => {
  let {
    className: customClassName,
    children,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const className = (0, import_classnames144.default)(`${prefix}--header`, customClassName);
  return import_react214.default.createElement("header", _extends({}, rest3, {
    className
  }), children);
};
Header.propTypes = {
  /**
   * Required props for the accessibility label of the header
   */
  ...AriaLabelPropType,
  /**
   * Optionally provide a custom class name that is applied to the underlying <header>
   */
  className: import_prop_types167.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/HeaderContainer.js
var import_prop_types168 = __toESM(require_prop_types());
var import_react215 = __toESM(require_react());
function HeaderContainer(_ref) {
  let {
    render: Children,
    isSideNavExpanded = false,
    ...rest3
  } = _ref;
  const [isSideNavExpandedState, setIsSideNavExpandedState] = (0, import_react215.useState)(isSideNavExpanded);
  useWindowEvent("keydown", (event) => {
    if (match(event, Escape)) {
      setIsSideNavExpandedState(false);
    }
  });
  const handleHeaderMenuButtonClick = (0, import_react215.useCallback)(() => {
    setIsSideNavExpandedState((prevIsSideNavExpanded) => !prevIsSideNavExpanded);
  }, [setIsSideNavExpandedState]);
  return import_react215.default.createElement(Children, _extends({}, rest3, {
    isSideNavExpanded: isSideNavExpandedState,
    onClickSideNavExpand: handleHeaderMenuButtonClick
  }));
}
HeaderContainer.propTypes = {
  /**
   * Optionally provide a custom class name that is applied to the underlying <header>
   */
  isSideNavExpanded: import_prop_types168.default.bool,
  /**
   * A function or a component that is invoked with `isSideNavExpanded` and `onClickSideNavExpand`.
   * The function or component can then use those properties to within the components it
   * returns, such as with the HeaderMenuButton and SideNav components. Additional props will also be passed
   * into this component for convenience.
   */
  render: import_prop_types168.default.elementType.isRequired
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/HeaderGlobalAction.js
var import_classnames145 = __toESM(require_classnames());
var import_react216 = __toESM(require_react());
var import_prop_types169 = __toESM(require_prop_types());
var HeaderGlobalAction = import_react216.default.forwardRef(function HeaderGlobalAction2(_ref, ref) {
  let {
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    children,
    className: customClassName,
    onClick,
    isActive,
    tooltipAlignment,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const className = (0, import_classnames145.default)({
    [customClassName]: !!customClassName,
    [`${prefix}--header__action`]: true,
    [`${prefix}--header__action--active`]: isActive
  });
  const accessibilityLabel = {
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy
  };
  return import_react216.default.createElement(Button, _extends({}, rest3, accessibilityLabel, {
    className,
    onClick,
    type: "button",
    hasIconOnly: true,
    iconDescription: ariaLabel,
    tooltipPosition: "bottom",
    tooltipAlignment,
    ref
  }), children);
});
HeaderGlobalAction.propTypes = {
  /**
   * Required props for the accessibility label of the button
   */
  ...AriaLabelPropType,
  /**
   * Provide a custom icon for this global action
   */
  children: import_prop_types169.default.node.isRequired,
  /**
   * Optionally provide a custom class name that is applied to the underlying
   * button
   */
  className: import_prop_types169.default.string,
  /**
   * Specify whether the action is currently active
   */
  isActive: import_prop_types169.default.bool,
  /**
   * Optionally provide an onClick handler that is called when the underlying
   * button fires it's onclick event
   */
  onClick: import_prop_types169.default.func,
  /**
   * Specify the alignment of the tooltip to the icon-only button.
   * Can be one of: start, center, or end.
   */
  tooltipAlignment: import_prop_types169.default.oneOf(["start", "center", "end"])
};
HeaderGlobalAction.displayName = "HeaderGlobalAction";

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/HeaderGlobalBar.js
var HeaderGlobalBar = wrapComponent({
  name: "HeaderGlobalBar",
  className: (prefix) => `${prefix}--header__global`,
  type: "div"
});

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/HeaderMenu.js
var import_classnames146 = __toESM(require_classnames());
var import_react217 = __toESM(require_react());
var import_prop_types170 = __toESM(require_prop_types());
var HeaderMenu = class extends import_react217.default.Component {
  constructor(props) {
    super(props);
    _defineProperty(this, "_subMenus", import_react217.default.createRef());
    _defineProperty(this, "items", []);
    _defineProperty(this, "menuButtonRef", null);
    _defineProperty(this, "handleOnClick", (e2) => {
      const {
        current: subMenusNode
      } = this._subMenus;
      if (!subMenusNode || !subMenusNode.contains(e2.target)) {
        e2.preventDefault();
      }
      this.setState((prevState) => ({
        expanded: !prevState.expanded
      }));
    });
    _defineProperty(this, "handleOnKeyDown", (event) => {
      if (matches(event, [Enter, Space])) {
        event.stopPropagation();
        event.preventDefault();
        this.setState((prevState) => ({
          expanded: !prevState.expanded
        }));
        return;
      }
    });
    _defineProperty(this, "handleOnBlur", (event) => {
      var _a;
      const siblingItemBlurredTo = this.items.find((element) => element === event.relatedTarget);
      const childItemBlurredTo = (_a = this._subMenus.current) == null ? void 0 : _a.contains(event.relatedTarget);
      if (!siblingItemBlurredTo && !childItemBlurredTo) {
        this.setState({
          expanded: false,
          selectedIndex: null
        });
      }
    });
    _defineProperty(this, "handleMenuButtonRef", (node) => {
      const {
        focusRef
      } = this.props;
      if (typeof focusRef === "function") {
        focusRef(node);
      }
      this.menuButtonRef = node;
    });
    _defineProperty(this, "handleItemRef", (index4) => (node) => {
      this.items[index4] = node;
    });
    _defineProperty(this, "handleMenuClose", (event) => {
      if (matches(event, [Escape]) && this.state.expanded) {
        event.stopPropagation();
        event.preventDefault();
        this.setState(() => ({
          expanded: false,
          selectedIndex: null
        }));
        if (this.menuButtonRef !== null) {
          this.menuButtonRef.focus();
        }
        return;
      }
    });
    _defineProperty(this, "_renderMenuItem", (item, index4) => {
      if (import_react217.default.isValidElement(item)) {
        return import_react217.default.cloneElement(item, {
          ref: this.handleItemRef(index4)
        });
      }
    });
    this.state = {
      // Used to manage the expansion state of the menu
      expanded: false,
      // Refers to the menuitem that is currently focused
      // Note: children should have `role="menuitem"` on node consuming ref
      selectedIndex: null
    };
    this.items = [];
  }
  render() {
    const prefix = this.context;
    const {
      isActive,
      isCurrentPage,
      "aria-label": ariaLabel,
      "aria-labelledby": ariaLabelledBy,
      className: customClassName,
      children,
      renderMenuContent: MenuContent,
      menuLinkName,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      focusRef,
      onBlur,
      onClick,
      onKeyDown,
      ...rest3
    } = this.props;
    const hasActiveDescendant2 = (childrenArg) => import_react217.default.Children.toArray(childrenArg).some((child) => import_react217.default.isValidElement(child) && // This is the type guard
    (child.props.isActive || child.props.isCurrentPage || Array.isArray(child.props.children) && hasActiveDescendant2(child.props.children)));
    const accessibilityLabel = {
      "aria-label": ariaLabel,
      "aria-labelledby": ariaLabelledBy
    };
    const itemClassName = (0, import_classnames146.default)({
      [`${prefix}--header__submenu`]: true,
      [`${customClassName}`]: !!customClassName
    });
    const isActivePage = isActive ? isActive : isCurrentPage;
    const linkClassName = (0, import_classnames146.default)({
      [`${prefix}--header__menu-item`]: true,
      [`${prefix}--header__menu-title`]: true,
      // We set the current class only if `isActive` is passed in and we do
      // not have an `aria-current="page"` set for the breadcrumb item
      [`${prefix}--header__menu-item--current`]: isActivePage || hasActiveDescendant2(children) && !this.state.expanded
    });
    return import_react217.default.createElement("li", _extends({}, rest3, {
      className: itemClassName,
      onKeyDown: composeEventHandlers([onKeyDown, this.handleMenuClose]),
      onClick: composeEventHandlers([onClick, this.handleOnClick]),
      onBlur: composeEventHandlers([onBlur, this.handleOnBlur])
    }), import_react217.default.createElement("a", _extends({
      // eslint-disable-line jsx-a11y/role-supports-aria-props,jsx-a11y/anchor-is-valid
      "aria-haspopup": "menu",
      "aria-expanded": this.state.expanded,
      className: linkClassName,
      href: "#",
      onKeyDown: this.handleOnKeyDown,
      ref: this.handleMenuButtonRef,
      tabIndex: 0
    }, accessibilityLabel), menuLinkName, MenuContent ? import_react217.default.createElement(MenuContent, null) : import_react217.default.createElement(ChevronDown, {
      className: `${this.context}--header__menu-arrow`
    })), import_react217.default.createElement("ul", _extends({}, accessibilityLabel, {
      ref: this._subMenus,
      className: `${prefix}--header__menu`
    }), import_react217.default.Children.map(children, this._renderMenuItem)));
  }
};
_defineProperty(HeaderMenu, "propTypes", {
  /**
   * Required props for the accessibility label of the menu
   */
  ...AriaLabelPropType,
  /**
   * Optionally provide a custom class to apply to the underlying `<li>` node
   */
  className: import_prop_types170.default.string,
  /**
   * Provide a custom ref handler for the menu button
   */
  focusRef: import_prop_types170.default.func,
  /**
   * Applies selected styles to the item if a user sets this to true and `aria-current !== 'page'`.
   */
  isActive: import_prop_types170.default.bool,
  /**
   * Applies selected styles to the item if a user sets this to true and `aria-current !== 'page'`.
   * @deprecated Please use `isActive` instead. This will be removed in the next major release.
   */
  isCurrentPage: deprecate(import_prop_types170.default.bool, "The `isCurrentPage` prop for `HeaderMenu` has been deprecated. Please use `isActive` instead. This will be removed in the next major release."),
  /**
   * Provide a label for the link text
   */
  menuLinkName: import_prop_types170.default.string.isRequired,
  /**
   * Optionally provide an onBlur handler that is called when the underlying
   * button fires it's onblur event
   */
  onBlur: import_prop_types170.default.func,
  /**
   * Optionally provide an onClick handler that is called when the underlying
   * button fires it's onclick event
   */
  onClick: import_prop_types170.default.func,
  /**
   * Optionally provide an onKeyDown handler that is called when the underlying
   * button fires it's onkeydown event
   */
  onKeyDown: import_prop_types170.default.func,
  /**
   * Optional component to render instead of string
   */
  renderMenuContent: import_prop_types170.default.func,
  /**
   * Optionally provide a tabIndex for the underlying menu button
   */
  tabIndex: import_prop_types170.default.number
});
_defineProperty(HeaderMenu, "contextType", PrefixContext);
var HeaderMenuForwardRef = import_react217.default.forwardRef((props, ref) => {
  return import_react217.default.createElement(HeaderMenu, _extends({}, props, {
    focusRef: ref
  }));
});
HeaderMenuForwardRef.displayName = "HeaderMenu";

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/HeaderMenuButton.js
var import_classnames147 = __toESM(require_classnames());
var import_react218 = __toESM(require_react());
var import_prop_types171 = __toESM(require_prop_types());
var _Menu;
var _Close8;
function HeaderMenuButton(_ref) {
  let {
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    className: customClassName,
    renderMenuIcon,
    renderCloseIcon,
    isActive,
    isCollapsible,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const className = (0, import_classnames147.default)({
    ...typeof customClassName === "string" && {
      [customClassName]: !!customClassName
    },
    [`${prefix}--header__action`]: true,
    [`${prefix}--header__menu-trigger`]: true,
    [`${prefix}--header__action--active`]: isActive,
    [`${prefix}--header__menu-toggle`]: true,
    [`${prefix}--header__menu-toggle__hidden`]: !isCollapsible
  });
  const menuIcon = renderMenuIcon ? renderMenuIcon : _Menu || (_Menu = import_react218.default.createElement(Menu, {
    size: 20
  }));
  const closeIcon = renderCloseIcon ? renderCloseIcon : _Close8 || (_Close8 = import_react218.default.createElement(Close, {
    size: 20
  }));
  return import_react218.default.createElement("button", _extends({}, rest3, {
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    className,
    title: ariaLabel,
    type: "button"
  }), isActive ? closeIcon : menuIcon);
}
HeaderMenuButton.propTypes = {
  /**
   * Required props for accessibility label on the underlying menu button
   */
  ...AriaLabelPropType,
  /**
   * Optionally provide a custom class name that is applied to the underlying
   * button
   */
  className: import_prop_types171.default.string,
  /**
   * Specify whether the menu button is "active".
   */
  isActive: import_prop_types171.default.bool,
  /**
   * Specify whether the menu button is collapsible.
   */
  isCollapsible: import_prop_types171.default.bool,
  /**
   * Optionally provide an onClick handler that is called when the underlying
   * button fires it's onclick event
   */
  onClick: import_prop_types171.default.func
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/HeaderMenuItem.js
var import_prop_types173 = __toESM(require_prop_types());
var import_react220 = __toESM(require_react());
var import_classnames148 = __toESM(require_classnames());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/Link.js
var import_prop_types172 = __toESM(require_prop_types());
var import_react219 = __toESM(require_react());
function LinkRenderFunction(_ref, ref) {
  let {
    element,
    as: BaseComponent,
    // Captured here to prevent it from being passed into the created element.
    // See https://github.com/carbon-design-system/carbon/issues/3970
    isSideNavExpanded: _isSideNavExpanded,
    ...rest3
  } = _ref;
  const BaseComponentAsAny = BaseComponent ?? element ?? "a";
  return import_react219.default.createElement(BaseComponentAsAny, _extends({
    ref
  }, rest3));
}
var Link2 = (0, import_react219.forwardRef)(LinkRenderFunction);
var LinkPropTypes = {
  /**
   * Provide a custom element or component to render the top-level node for the
   * component.
   */
  as: import_prop_types172.default.elementType,
  /**
   * The base element to use to build the link. Defaults to `a`, can also accept
   * alternative tag names or custom components like `Link` from `react-router`.
   * @deprecated Use `as` instead
   *
   */
  element: deprecate(import_prop_types172.default.elementType, "The `element` prop for `Link` has been deprecated. Please use `as` instead. This will be removed in the next major release."),
  /**
   * Property to indicate if the side nav container is open (or not). Use to
   * keep local state and styling in step with the SideNav expansion state.
   */
  isSideNavExpanded: import_prop_types172.default.bool
};
Link2.displayName = "Link";
Link2.propTypes = LinkPropTypes;

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/HeaderMenuItem.js
var HeaderMenuItem = (0, import_react220.forwardRef)(function HeaderMenuItemRenderFunction(_ref, ref) {
  let {
    className,
    isActive,
    isCurrentPage,
    "aria-current": ariaCurrent,
    children,
    role,
    tabIndex = 0,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  if (isCurrentPage) {
    isActive = isCurrentPage;
  }
  const linkClassName = (0, import_classnames148.default)({
    [`${prefix}--header__menu-item`]: true,
    // We set the current class only if `isActive` is passed in and we do
    // not have an `aria-current="page"` set for the breadcrumb item
    [`${prefix}--header__menu-item--current`]: isActive && ariaCurrent !== "page"
  });
  return import_react220.default.createElement("li", {
    className,
    role
  }, import_react220.default.createElement(Link2, _extends({}, rest3, {
    "aria-current": ariaCurrent,
    className: linkClassName,
    ref,
    tabIndex
  }), import_react220.default.createElement("span", {
    className: `${prefix}--text-truncate--end`
  }, children)));
});
HeaderMenuItem.displayName = "HeaderMenuItem";
HeaderMenuItem.propTypes = {
  /**
   * Pass in a valid `element` to replace the underlying `<a>` tag with a
   * custom `Link` element
   */
  ...LinkPropTypes,
  /**
   * Pass in children that are either a string or can be read as a string by
   * screen readers
   */
  children: import_prop_types173.default.node.isRequired,
  /**
   * Optionally provide a custom class to apply to the underlying `<li>` node
   */
  className: import_prop_types173.default.string,
  /**
   * Applies selected styles to the item if a user sets this to true and `aria-current !== 'page'`.
   */
  isActive: import_prop_types173.default.bool,
  /**
   * Applies selected styles to the item if a user sets this to true and `aria-current !== 'page'`.
   * @deprecated Please use `isActive` instead. This will be removed in the next major release.
   */
  isCurrentPage: deprecate(import_prop_types173.default.bool, "The `isCurrentPage` prop for `HeaderMenuItem` has been deprecated. Please use `isActive` instead. This will be removed in the next major release."),
  /**
   * Optionally supply a role for the underlying `<li>` node. Useful for resetting
   * `<ul>` semantics for menus.
   */
  role: import_prop_types173.default.string,
  /**
   * Specify the tab index of the Link
   */
  tabIndex: import_prop_types173.default.number
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/HeaderName.js
var import_classnames149 = __toESM(require_classnames());
var import_react221 = __toESM(require_react());
var import_prop_types174 = __toESM(require_prop_types());
function HeaderName(_ref) {
  let {
    children,
    className: customClassName,
    prefix = "IBM",
    ...rest3
  } = _ref;
  const selectorPrefix = usePrefix();
  const className = (0, import_classnames149.default)(`${selectorPrefix}--header__name`, customClassName);
  return import_react221.default.createElement(Link2, _extends({}, rest3, {
    className
  }), prefix && import_react221.default.createElement(import_react221.default.Fragment, null, import_react221.default.createElement("span", {
    className: `${selectorPrefix}--header__name--prefix`
  }, prefix), " "), children);
}
HeaderName.propTypes = {
  /**
   * Pass in a valid `element` to replace the underlying `<a>` tag with a
   * custom `Link` element
   */
  ...LinkPropTypes,
  /**
   * Pass in children that are either a string or can be read as a string by
   * screen readers
   */
  children: import_prop_types174.default.node.isRequired,
  /**
   * Optionally provide a custom class to apply to the underlying `<li>` node
   */
  className: import_prop_types174.default.string,
  /**
   * Provide an href for the name to link to
   */
  href: import_prop_types174.default.string,
  /**
   * Optionally specify a prefix to your header name. Useful for companies, for
   * example: IBM [Product Name] versus solely [Product Name]
   */
  prefix: import_prop_types174.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/HeaderNavigation.js
var import_classnames150 = __toESM(require_classnames());
var import_react222 = __toESM(require_react());
var import_prop_types175 = __toESM(require_prop_types());
function HeaderNavigation(_ref) {
  let {
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    children,
    className: customClassName,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const className = (0, import_classnames150.default)(`${prefix}--header__nav`, customClassName);
  return import_react222.default.createElement("nav", _extends({}, rest3, {
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    className
  }), import_react222.default.createElement("ul", {
    className: `${prefix}--header__menu-bar`
  }, children));
}
HeaderNavigation.propTypes = {
  /**
   * Required props for accessibility label on the underlying menu
   */
  ...AriaLabelPropType,
  /**
   * Provide valid children of HeaderNavigation, for example `HeaderMenuItem`
   * or `HeaderMenu`
   */
  children: import_prop_types175.default.node,
  /**
   * Optionally provide a custom class to apply to the underlying <nav> node
   */
  className: import_prop_types175.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/HeaderPanel.js
var import_classnames151 = __toESM(require_classnames());
var import_prop_types176 = __toESM(require_prop_types());
var import_react223 = __toESM(require_react());
var noopFn3 = () => {
};
var HeaderPanel = import_react223.default.forwardRef(function HeaderPanel2(_ref, ref) {
  let {
    children,
    className: customClassName,
    expanded,
    addFocusListeners = true,
    onHeaderPanelFocus = noopFn3,
    href,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const headerPanelReference = (0, import_react223.useRef)(null);
  const headerPanelRef = useMergedRefs([headerPanelReference, ref]);
  const controlled = (0, import_react223.useRef)(expanded !== void 0).current;
  const [expandedState, setExpandedState] = (0, import_react223.useState)(expanded);
  const expandedProp = controlled ? expanded : expandedState;
  const [lastClickedElement, setLastClickedElement] = (0, import_react223.useState)(null);
  const className = (0, import_classnames151.default)(`${prefix}--header-panel`, {
    [`${prefix}--header-panel--expanded`]: expandedProp,
    [customClassName]: !!customClassName
  });
  const eventHandlers = {};
  if (addFocusListeners) {
    eventHandlers.onBlur = (event) => {
      var _a;
      if (!event.currentTarget.contains(event.relatedTarget) && !((_a = lastClickedElement == null ? void 0 : lastClickedElement.classList) == null ? void 0 : _a.contains(`${prefix}--switcher__item-link`))) {
        setExpandedState(false);
        setLastClickedElement(null);
        if (expanded) {
          onHeaderPanelFocus();
        }
      }
    };
    eventHandlers.onKeyDown = (event) => {
      if (match(event, Escape)) {
        setExpandedState(false);
        onHeaderPanelFocus();
        if (href) {
          window.location.href = href;
        }
      }
    };
  }
  useWindowEvent("click", () => {
    var _a, _b;
    const focusedElement = document.activeElement;
    setLastClickedElement(focusedElement);
    const childJsxElement = children;
    if (((_a = childJsxElement == null ? void 0 : childJsxElement.type) == null ? void 0 : _a.displayName) === "Switcher" && !(focusedElement == null ? void 0 : focusedElement.closest(`.${prefix}--header-panel--expanded`)) && !(focusedElement == null ? void 0 : focusedElement.closest(`.${prefix}--header__action`)) && !((_b = headerPanelReference == null ? void 0 : headerPanelReference.current) == null ? void 0 : _b.classList.contains(`${prefix}--switcher`)) && expanded) {
      setExpandedState(false);
      onHeaderPanelFocus();
    }
  });
  return import_react223.default.createElement("div", _extends({}, rest3, {
    className,
    ref: headerPanelRef
  }, eventHandlers), children);
});
HeaderPanel.propTypes = {
  /**
   * Specify whether focus and blur listeners are added. They are by default.
   */
  addFocusListeners: import_prop_types176.default.bool,
  /**
   * The content that will render inside of the `HeaderPanel`
   */
  children: import_prop_types176.default.node,
  /**
   * Optionally provide a custom class to apply to the underlying `<li>` node
   */
  className: import_prop_types176.default.string,
  /**
   * Specify whether the panel is expanded
   */
  expanded: import_prop_types176.default.bool,
  /**
   * Provide the `href` to the id of the element on your package that could
   * be target.
   */
  href: import_prop_types176.default.string,
  /**
   * An optional listener that is called a callback to collapse the HeaderPanel
   */
  onHeaderPanelFocus: import_prop_types176.default.func
};
HeaderPanel.displayName = "HeaderPanel";

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/HeaderSideNavItems.js
var import_classnames152 = __toESM(require_classnames());
var import_react224 = __toESM(require_react());
var import_prop_types177 = __toESM(require_prop_types());
function HeaderSideNavItems(_ref) {
  let {
    className: customClassName,
    children,
    hasDivider = false
  } = _ref;
  const prefix = usePrefix();
  const className = (0, import_classnames152.default)({
    [`${prefix}--side-nav__header-navigation`]: true,
    [`${prefix}--side-nav__header-divider`]: hasDivider
  }, customClassName);
  return import_react224.default.createElement("ul", {
    className
  }, children);
}
HeaderSideNavItems.propTypes = {
  /**
   * The child nodes to be rendered
   */
  children: import_prop_types177.default.node,
  /**
   * Optionally provide a custom class name that is applied to the underlying
   * button
   */
  className: import_prop_types177.default.string,
  /**
   * Optionally specify if container will have a bottom divider to differentiate
   * between original sidenav items and header menu items. False by default.
   */
  hasDivider: import_prop_types177.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/Switcher.js
var import_react225 = __toESM(require_react());
var import_classnames153 = __toESM(require_classnames());
var import_prop_types178 = __toESM(require_prop_types());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/prop-types/tools/getDisplayName.js
var cachedDisplayNames = /* @__PURE__ */ new WeakMap();
var getDisplayName = (type) => {
  if (typeof type === "string") {
    return type;
  }
  if (cachedDisplayNames.has(type)) {
    return cachedDisplayNames.get(type);
  }
  let displayName;
  if (typeof type.displayName === "string") {
    displayName = type.displayName;
  }
  if (!displayName) {
    displayName = type.name || "Unknown";
  }
  cachedDisplayNames.set(type, displayName);
  return displayName;
};
var getDisplayName$1 = getDisplayName;

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/Switcher.js
var Switcher = (0, import_react225.forwardRef)(function Switcher2(props, forwardRef13) {
  const switcherRef = (0, import_react225.useRef)(null);
  const ref = useMergedRefs([switcherRef, forwardRef13]);
  const prefix = usePrefix();
  const {
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    className: customClassName,
    children,
    expanded
  } = props;
  const accessibilityLabel = {
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy
  };
  const className = (0, import_classnames153.default)(`${prefix}--switcher`, {
    [customClassName || ""]: !!customClassName
  });
  const handleSwitcherItemFocus = (_ref) => {
    var _a, _b;
    let {
      currentIndex,
      direction
    } = _ref;
    const enabledIndices = import_react225.default.Children.toArray(children).reduce((acc, curr, i) => {
      if (import_react225.default.isValidElement(curr) && Object.keys(curr.props).length !== 0 && getDisplayName$1(curr.type) === "SwitcherItem") {
        acc.push(i);
      }
      return acc;
    }, []);
    const nextValidIndex = (() => {
      const nextIndex = enabledIndices.indexOf(currentIndex) + direction;
      switch (enabledIndices[nextIndex]) {
        case void 0:
          if (direction === -1) {
            return enabledIndices[enabledIndices.length - 1];
          }
          return enabledIndices[0];
        case 0:
          if (direction === 1) {
            return enabledIndices[1];
          }
        default:
          return enabledIndices[nextIndex];
      }
    })();
    const switcherItem = (_b = (_a = switcherRef.current) == null ? void 0 : _a.children[nextValidIndex]) == null ? void 0 : _b.children[0];
    if (switcherItem) {
      switcherItem.focus();
    }
  };
  const childrenWithProps = import_react225.default.Children.toArray(children).map((child, index4) => {
    if (import_react225.default.isValidElement(child) && child.type && getDisplayName$1(child.type) === "SwitcherItem") {
      return import_react225.default.cloneElement(child, {
        handleSwitcherItemFocus,
        index: index4,
        key: index4,
        expanded
      });
    }
    return import_react225.default.cloneElement(child, {
      index: index4,
      key: index4,
      expanded
    });
  });
  return import_react225.default.createElement("ul", _extends({
    ref,
    className
  }, accessibilityLabel), childrenWithProps);
});
Switcher.displayName = "Switcher";
Switcher.propTypes = {
  /**
   * Required props for accessibility label on the underlying menu
   */
  ...AriaLabelPropType,
  /**
   * expects to receive <SwitcherItem />
   */
  children: import_prop_types178.default.node.isRequired,
  /**
   * Optionally provide a custom class to apply to the underlying `<ul>` node
   */
  className: import_prop_types178.default.string,
  /**
   * Specify whether the panel is expanded
   */
  expanded: import_prop_types178.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/SwitcherItem.js
var import_react226 = __toESM(require_react());
var import_classnames154 = __toESM(require_classnames());
var import_prop_types179 = __toESM(require_prop_types());
var SwitcherItem = (0, import_react226.forwardRef)(function SwitcherItem2(props, forwardRef13) {
  const {
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    className: customClassName,
    children,
    isSelected,
    expanded,
    tabIndex = expanded ? 0 : -1,
    index: index4,
    handleSwitcherItemFocus,
    onKeyDown = () => {
    },
    href,
    target,
    rel,
    ...rest3
  } = props;
  const prefix = usePrefix();
  const classNames = (0, import_classnames154.default)(`${prefix}--switcher__item`, {
    [customClassName || ""]: !!customClassName
  });
  const accessibilityLabel = {
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy
  };
  const linkClassName = (0, import_classnames154.default)(`${prefix}--switcher__item-link`, {
    [`${prefix}--switcher__item-link--selected`]: isSelected
  });
  function setTabFocus(evt) {
    if (match(evt, ArrowDown)) {
      evt.preventDefault();
      handleSwitcherItemFocus == null ? void 0 : handleSwitcherItemFocus({
        currentIndex: index4 || -1,
        direction: 1
      });
    }
    if (match(evt, ArrowUp2)) {
      evt.preventDefault();
      handleSwitcherItemFocus == null ? void 0 : handleSwitcherItemFocus({
        currentIndex: index4 || -1,
        direction: -1
      });
    }
  }
  return import_react226.default.createElement("li", {
    className: classNames
  }, import_react226.default.createElement(Link2, _extends({
    onKeyDown: (evt) => {
      setTabFocus(evt);
      onKeyDown(evt);
    },
    href,
    target,
    rel,
    ref: forwardRef13
  }, rest3, {
    className: linkClassName,
    tabIndex
  }, accessibilityLabel), children));
});
SwitcherItem.displayName = "SwitcherItem";
SwitcherItem.propTypes = {
  ...AriaLabelPropType,
  /**
   * Specify the text content for the link
   */
  children: import_prop_types179.default.node.isRequired,
  /**
   * Optionally provide a custom class to apply to the underlying `<li>` node
   */
  className: import_prop_types179.default.string,
  /**
   * event handlers
   */
  handleSwitcherItemFocus: import_prop_types179.default.func,
  /**
   * Optionally provide an href for the underlying li`
   */
  href: import_prop_types179.default.string,
  /**
   * Specify the index of the SwitcherItem
   */
  index: import_prop_types179.default.number,
  /**
   * event handlers
   */
  onClick: import_prop_types179.default.func,
  /**
   * event handlers
   */
  onKeyDown: import_prop_types179.default.func,
  /**
   * Specify the tab index of the Link
   */
  tabIndex: import_prop_types179.default.number,
  /**
   * Specify where to open the link.
   */
  target: import_prop_types179.default.string,
  /**
   * The rel property for the link.
   */
  rel: import_prop_types179.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/SwitcherDivider.js
var import_react227 = __toESM(require_react());
var import_classnames155 = __toESM(require_classnames());
var import_prop_types180 = __toESM(require_prop_types());
var SwitcherDivider = (_ref) => {
  let {
    className: customClassName,
    ...other
  } = _ref;
  const prefix = usePrefix();
  const classNames = (0, import_classnames155.default)(`${prefix}--switcher__item--divider`, {
    [customClassName || ""]: !!customClassName
  });
  return import_react227.default.createElement("hr", _extends({}, other, {
    className: classNames
  }));
};
SwitcherDivider.propTypes = {
  /**
   * Optionally provide a custom class to apply to the underlying `<li>` node
   */
  className: import_prop_types180.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/SkipToContent.js
var import_classnames156 = __toESM(require_classnames());
var import_react228 = __toESM(require_react());
var import_prop_types181 = __toESM(require_prop_types());
function SkipToContent(_ref) {
  let {
    children = "Skip to main content",
    className: customClassName,
    href = "#main-content",
    tabIndex = 0,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const className = (0, import_classnames156.default)(`${prefix}--skip-to-content`, customClassName);
  return import_react228.default.createElement("a", _extends({}, rest3, {
    className,
    href,
    tabIndex
  }), children);
}
SkipToContent.propTypes = {
  /**
   * A ReactNode to display in the SkipToContent `a` tag.
   * `'Skip to main content'` by default.
   */
  children: import_prop_types181.default.string,
  className: import_prop_types181.default.string,
  /**
   * Provide the `href` to the id of the element on your package that is the
   * main content. `#main-content` by default.
   */
  href: import_prop_types181.default.string,
  /**
   * Optionally override the default tabindex of 0
   */
  tabIndex: import_prop_types181.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/SideNav.js
var import_react229 = __toESM(require_react());
var import_classnames157 = __toESM(require_classnames());
var import_prop_types182 = __toESM(require_prop_types());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/_utils.js
var CARBON_SIDENAV_ITEMS = ["SideNavFooter", "SideNavHeader", "SideNavItems", "SideNavMenu", "SideNavLink"];

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/SideNav.js
var SideNavContext = (0, import_react229.createContext)({});
function SideNavRenderFunction(_ref, ref) {
  let {
    expanded: expandedProp,
    defaultExpanded = false,
    isChildOfHeader = true,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    children,
    onToggle,
    className: customClassName,
    // TO-DO: comment back in when footer is added for rails
    // translateById: t = (id) => translations[id],
    href,
    isFixedNav = false,
    isRail,
    isPersistent = true,
    addFocusListeners = true,
    addMouseListeners = true,
    onOverlayClick,
    onSideNavBlur,
    enterDelayMs = 100,
    ...other
  } = _ref;
  const prefix = usePrefix();
  const {
    current: controlled
  } = (0, import_react229.useRef)(expandedProp !== void 0);
  const [expandedState, setExpandedState] = useDelayedState(defaultExpanded);
  const [expandedViaHoverState, setExpandedViaHoverState] = useDelayedState(defaultExpanded);
  const expanded = controlled ? expandedProp : expandedState;
  const sideNavRef = (0, import_react229.useRef)(null);
  const navRef = useMergedRefs([sideNavRef, ref]);
  const handleToggle = function(event) {
    let value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !expanded;
    if (!controlled) {
      setExpandedState(value, enterDelayMs);
    }
    if (onToggle) {
      onToggle(event, value);
    }
    if (controlled || isRail) {
      setExpandedViaHoverState(value, enterDelayMs);
    }
  };
  const accessibilityLabel = {
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy
  };
  const className = (0, import_classnames157.default)(customClassName, {
    [`${prefix}--side-nav`]: true,
    [`${prefix}--side-nav--expanded`]: expanded || expandedViaHoverState,
    [`${prefix}--side-nav--collapsed`]: !expanded && isFixedNav,
    [`${prefix}--side-nav--rail`]: isRail,
    [`${prefix}--side-nav--ux`]: isChildOfHeader,
    [`${prefix}--side-nav--hidden`]: !isPersistent
  });
  const overlayClassName = (0, import_classnames157.default)({
    [`${prefix}--side-nav__overlay`]: true,
    [`${prefix}--side-nav__overlay-active`]: expanded || expandedViaHoverState
  });
  let childrenToRender = children;
  childrenToRender = import_react229.default.Children.map(children, (child) => {
    var _a, _b;
    const currentExpansionState = controlled ? expandedViaHoverState || expanded : expanded;
    if ((0, import_react229.isValidElement)(child)) {
      const childJsxElement = child;
      return import_react229.default.cloneElement(childJsxElement, {
        ...CARBON_SIDENAV_ITEMS.includes(((_a = childJsxElement.type) == null ? void 0 : _a.displayName) ?? ((_b = childJsxElement.type) == null ? void 0 : _b.name)) ? {
          isSideNavExpanded: currentExpansionState
        } : {}
      });
    }
    return child;
  });
  const eventHandlers = {};
  if (addFocusListeners) {
    eventHandlers.onFocus = (event) => {
      if (!event.currentTarget.contains(event.relatedTarget) && isRail) {
        handleToggle(event, true);
      }
    };
    eventHandlers.onBlur = (event) => {
      if (!event.currentTarget.contains(event.relatedTarget)) {
        handleToggle(event, false);
      }
      if (!event.currentTarget.contains(event.relatedTarget) && expanded && !isFixedNav) {
        if (onSideNavBlur) {
          onSideNavBlur();
        }
      }
    };
    eventHandlers.onKeyDown = (event) => {
      if (match(event, Escape)) {
        handleToggle(event, false);
        if (href) {
          window.location.href = href;
        }
      }
    };
  }
  if (addMouseListeners && isRail) {
    eventHandlers.onMouseEnter = () => {
      handleToggle(true, true);
    };
    eventHandlers.onMouseLeave = () => {
      setExpandedState(false);
      setExpandedViaHoverState(false);
      handleToggle(false, false);
    };
    eventHandlers.onClick = () => {
      setExpandedState(true);
      setExpandedViaHoverState(true);
      handleToggle(true, true);
    };
  }
  useWindowEvent("keydown", (event) => {
    const focusedElement = document.activeElement;
    if (match(event, Tab) && expanded && !isFixedNav && sideNavRef.current && (focusedElement == null ? void 0 : focusedElement.classList.contains(`${prefix}--header__menu-toggle`)) && !focusedElement.closest("nav")) {
      sideNavRef.current.focus();
    }
  });
  const lgMediaQuery2 = `(min-width: ${breakpoints.lg.width})`;
  const isLg = useMatchMedia(lgMediaQuery2);
  return import_react229.default.createElement(SideNavContext.Provider, {
    value: {
      isRail
    }
  }, isFixedNav ? null : (
    // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions
    import_react229.default.createElement("div", {
      className: overlayClassName,
      onClick: onOverlayClick
    })
  ), import_react229.default.createElement("nav", _extends({
    tabIndex: -1,
    ref: navRef,
    className: `${prefix}--side-nav__navigation ${className}`,
    inert: !isRail ? expanded || isLg ? void 0 : -1 : void 0
  }, accessibilityLabel, eventHandlers, other), childrenToRender));
}
var SideNav = import_react229.default.forwardRef(SideNavRenderFunction);
SideNav.displayName = "SideNav";
SideNav.propTypes = {
  /**
   * Required props for accessibility label on the underlying menu
   */
  ...AriaLabelPropType,
  /**
   * Specify whether focus and blur listeners are added. They are by default.
   */
  addFocusListeners: import_prop_types182.default.bool,
  /**
   * Specify whether mouse entry/exit listeners are added. They are by default.
   */
  addMouseListeners: import_prop_types182.default.bool,
  /**
   * Optionally provide a custom class to apply to the underlying `<li>` node
   */
  className: import_prop_types182.default.string,
  /**
   * If `true`, the SideNav will be open on initial render.
   */
  defaultExpanded: import_prop_types182.default.bool,
  /**
   * Specify the duration in milliseconds to delay before displaying the sidenavigation
   */
  enterDelayMs: import_prop_types182.default.number,
  /**
   * If `true`, the SideNav will be expanded, otherwise it will be collapsed.
   * Using this prop causes SideNav to become a controled component.
   */
  expanded: import_prop_types182.default.bool,
  /**
   * Provide the `href` to the id of the element on your package that is the
   * main content.
   */
  href: import_prop_types182.default.string,
  /**
   * Optionally provide a custom class to apply to the underlying `<li>` node
   */
  isChildOfHeader: import_prop_types182.default.bool,
  /**
   * Specify if sideNav is standalone
   */
  isFixedNav: import_prop_types182.default.bool,
  /**
   * Specify if the sideNav will be persistent above the lg breakpoint
   */
  isPersistent: import_prop_types182.default.bool,
  /**
   * Optional prop to display the side nav rail.
   */
  isRail: import_prop_types182.default.bool,
  /**
   * An optional listener that is called when the SideNav overlay is clicked
   *
   * @param {object} event
   */
  onOverlayClick: import_prop_types182.default.func,
  /**
   * An optional listener that is called a callback to collapse the SideNav
   */
  onSideNavBlur: import_prop_types182.default.func,
  /**
   * An optional listener that is called when an event that would cause
   * toggling the SideNav occurs.
   *
   * @param {object} event
   * @param {boolean} value
   */
  onToggle: import_prop_types182.default.func
  /**
   * Provide a custom function for translating all message ids within this
   * component. This function will take in two arguments: the mesasge Id and the
   * state of the component. From this, you should return a string representing
   * the label you want displayed or read by screen readers.
   */
  // translateById: PropTypes.func,
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/SideNavDetails.js
var import_classnames158 = __toESM(require_classnames());
var import_prop_types183 = __toESM(require_prop_types());
var import_react230 = __toESM(require_react());
var SideNavDetails = (_ref) => {
  let {
    children,
    className: customClassName,
    title,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const className = (0, import_classnames158.default)(`${prefix}--side-nav__details`, customClassName);
  return import_react230.default.createElement("div", _extends({
    className
  }, rest3), import_react230.default.createElement("h2", {
    className: `${prefix}--side-nav__title`,
    title
  }, title), children);
};
SideNavDetails.propTypes = {
  /**
   * Provide optional children to render in `SideNavDetails`. Useful for
   * rendering the `SideNavSwitcher` component.
   */
  children: import_prop_types183.default.node,
  /**
   * Optionally provide a custom class to apply to the underlying `<li>` node
   */
  className: import_prop_types183.default.string,
  /**
   * Provide the text that will be rendered as the title in the component
   */
  title: import_prop_types183.default.string.isRequired
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/SideNavDivider.js
var import_classnames159 = __toESM(require_classnames());
var import_prop_types184 = __toESM(require_prop_types());
var import_react231 = __toESM(require_react());
var _hr;
var SideNavDivider = (_ref) => {
  let {
    className
  } = _ref;
  const prefix = usePrefix();
  const classNames = (0, import_classnames159.default)(`${prefix}--side-nav__divider`, className);
  return import_react231.default.createElement("li", {
    className: classNames
  }, _hr || (_hr = import_react231.default.createElement("hr", null)));
};
SideNavDivider.propTypes = {
  /**
   * Provide an optional class to be applied to the containing node
   */
  className: import_prop_types184.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/SideNavFooter.js
var import_classnames160 = __toESM(require_classnames());
var import_react232 = __toESM(require_react());
var import_prop_types185 = __toESM(require_prop_types());
var _Close9;
var _ChevronRight2;
function SideNavFooter(_ref) {
  let {
    assistiveText = "Toggle opening or closing the side navigation",
    className: customClassName,
    expanded,
    onToggle
  } = _ref;
  const prefix = usePrefix();
  const className = (0, import_classnames160.default)(`${prefix}--side-nav__footer`, customClassName);
  return import_react232.default.createElement("footer", {
    className
  }, import_react232.default.createElement("button", {
    className: `${prefix}--side-nav__toggle`,
    type: "button",
    onClick: (evt) => onToggle(evt),
    title: assistiveText
  }, import_react232.default.createElement("div", {
    className: `${prefix}--side-nav__icon`
  }, expanded ? _Close9 || (_Close9 = import_react232.default.createElement(Close, {
    size: 20
  })) : _ChevronRight2 || (_ChevronRight2 = import_react232.default.createElement(ChevronRight, {
    size: 20
  }))), import_react232.default.createElement("span", {
    className: `${prefix}--assistive-text`
  }, assistiveText)));
}
SideNavFooter.displayName = "SideNavFooter";
SideNavFooter.propTypes = {
  /**
   * Provide text to be read to screen readers and shown as a tooltip when
   * interacting with the toggle button in the footer
   */
  assistiveText: import_prop_types185.default.string,
  className: import_prop_types185.default.string,
  /**
   * Specify whether the side navigation is expanded or collapsed
   */
  expanded: import_prop_types185.default.bool.isRequired,
  /**
   * Provide a function that is called when the toggle button is interacted
   * with. Useful for controlling the expansion state of the side navigation.
   */
  onToggle: import_prop_types185.default.func.isRequired
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/SideNavHeader.js
var import_classnames162 = __toESM(require_classnames());
var import_prop_types187 = __toESM(require_prop_types());
var import_react234 = __toESM(require_react());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/SideNavIcon.js
var import_classnames161 = __toESM(require_classnames());
var import_prop_types186 = __toESM(require_prop_types());
var import_react233 = __toESM(require_react());
var SideNavIcon = (_ref) => {
  let {
    children,
    className: customClassName,
    small = false
  } = _ref;
  const prefix = usePrefix();
  const className = (0, import_classnames161.default)({
    [`${prefix}--side-nav__icon`]: true,
    [`${prefix}--side-nav__icon--small`]: small,
    [customClassName]: !!customClassName
  });
  return import_react233.default.createElement("div", {
    className
  }, children);
};
SideNavIcon.propTypes = {
  /**
   * Provide a single icon as the child to `SideNavIcon` to render in the
   * container
   */
  children: import_prop_types186.default.node.isRequired,
  /**
   * Provide an optional class to be applied to the containing node
   */
  className: import_prop_types186.default.string,
  /**
   * Specify whether the icon should be placed in a smaller bounding box
   */
  small: import_prop_types186.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/SideNavHeader.js
var SideNavHeader = (_ref) => {
  let {
    children,
    className: customClassName,
    renderIcon: IconElement
  } = _ref;
  const prefix = usePrefix();
  const className = (0, import_classnames162.default)(`${prefix}--side-nav__header`, customClassName);
  return import_react234.default.createElement("header", {
    className
  }, import_react234.default.createElement(SideNavIcon, null, import_react234.default.createElement(IconElement, null)), children);
};
SideNavHeader.displayName = "SideNavHeader";
SideNavHeader.propTypes = {
  /**
   * The child nodes to be rendered
   */
  children: import_prop_types187.default.node,
  /**
   * Provide an optional class to be applied to the containing node
   */
  className: import_prop_types187.default.string,
  /**
   * Property to indicate if the side nav container is open (or not). Use to
   * keep local state and styling in step with the SideNav expansion state.
   */
  isSideNavExpanded: import_prop_types187.default.bool,
  /**
   * Provide an icon to render in the header of the side navigation. Should be
   * a React class.
   */
  // @ts-expect-error - PropTypes are unable to cover this case.
  renderIcon: import_prop_types187.default.oneOfType([import_prop_types187.default.func, import_prop_types187.default.object]).isRequired
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/SideNavItem.js
var import_classnames163 = __toESM(require_classnames());
var import_prop_types188 = __toESM(require_prop_types());
var import_react235 = __toESM(require_react());
var SideNavItem = (_ref) => {
  let {
    className: customClassName,
    children,
    large = false
  } = _ref;
  const prefix = usePrefix();
  const className = (0, import_classnames163.default)({
    [`${prefix}--side-nav__item`]: true,
    [`${prefix}--side-nav__item--large`]: large,
    [customClassName]: !!customClassName
  });
  return import_react235.default.createElement("li", {
    className
  }, children);
};
SideNavItem.propTypes = {
  /**
   * Provide a single icon as the child to `SideNavItem` to render in the
   * container
   */
  children: import_prop_types188.default.node.isRequired,
  /**
   * Provide an optional class to be applied to the containing node
   */
  className: import_prop_types188.default.string,
  /**
   * Specify if this is a large variation of the SideNavItem
   */
  large: import_prop_types188.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/SideNavItems.js
var import_classnames164 = __toESM(require_classnames());
var import_prop_types189 = __toESM(require_prop_types());
var import_react236 = __toESM(require_react());
var SideNavItems = (_ref) => {
  let {
    className: customClassName,
    children,
    isSideNavExpanded
  } = _ref;
  const prefix = usePrefix();
  const className = (0, import_classnames164.default)([`${prefix}--side-nav__items`], customClassName);
  const childrenWithExpandedState = import_react236.default.Children.map(children, (child) => {
    var _a;
    if (import_react236.default.isValidElement(child)) {
      const childDisplayName = (_a = child.type) == null ? void 0 : _a.displayName;
      return import_react236.default.cloneElement(child, {
        ...CARBON_SIDENAV_ITEMS.includes(childDisplayName) ? {
          isSideNavExpanded
        } : {}
      });
    }
  });
  return import_react236.default.createElement("ul", {
    className
  }, childrenWithExpandedState);
};
SideNavItems.displayName = "SideNavItems";
SideNavItems.propTypes = {
  /**
   * Provide a single icon as the child to `SideNavIcon` to render in the
   * container
   */
  children: import_prop_types189.default.node.isRequired,
  /**
   * Provide an optional class to be applied to the containing node
   */
  className: import_prop_types189.default.string,
  /**
   * Property to indicate if the side nav container is open (or not). Use to
   * keep local state and styling in step with the SideNav expansion state.
   */
  isSideNavExpanded: import_prop_types189.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/SideNavLink.js
var import_classnames166 = __toESM(require_classnames());
var import_prop_types191 = __toESM(require_prop_types());
var import_react238 = __toESM(require_react());

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/SideNavLinkText.js
var import_classnames165 = __toESM(require_classnames());
var import_react237 = __toESM(require_react());
var import_prop_types190 = __toESM(require_prop_types());
function SideNavLinkText(_ref) {
  let {
    className: customClassName,
    children,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const className = (0, import_classnames165.default)(`${prefix}--side-nav__link-text`, customClassName);
  return import_react237.default.createElement("span", _extends({}, rest3, {
    className
  }), children);
}
SideNavLinkText.propTypes = {
  /**
   * Provide the content for the link text
   */
  children: import_prop_types190.default.node.isRequired,
  /**
   * Provide an optional class to be applied to the containing node
   */
  className: import_prop_types190.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/SideNavLink.js
var SideNavLink = (0, import_react238.forwardRef)(function SideNavLink2(_ref, ref) {
  let {
    children,
    className: customClassName,
    renderIcon: IconElement,
    isActive,
    isSideNavExpanded,
    large = false,
    tabIndex,
    ...rest3
  } = _ref;
  const isRail = (0, import_react238.useContext)(SideNavContext);
  const prefix = usePrefix();
  const className = (0, import_classnames166.default)({
    [`${prefix}--side-nav__link`]: true,
    [`${prefix}--side-nav__link--current`]: isActive,
    [customClassName]: !!customClassName
  });
  return import_react238.default.createElement(SideNavItem, {
    large
  }, import_react238.default.createElement(Link2, _extends({}, rest3, {
    className,
    ref,
    tabIndex: tabIndex === void 0 ? !isSideNavExpanded && !isRail ? -1 : 0 : tabIndex
  }), IconElement && import_react238.default.createElement(SideNavIcon, {
    small: true
  }, import_react238.default.createElement(IconElement, null)), import_react238.default.createElement(SideNavLinkText, null, children)));
});
SideNavLink.displayName = "SideNavLink";
SideNavLink.propTypes = {
  ...LinkPropTypes,
  /**
   * Specify the text content for the link
   */
  children: import_prop_types191.default.node.isRequired,
  /**
   * Provide an optional class to be applied to the containing node
   */
  className: import_prop_types191.default.string,
  /**
   * Specify whether the link is the current page
   */
  isActive: import_prop_types191.default.bool,
  /**
   * Property to indicate if the side nav container is open (or not). Use to
   * keep local state and styling in step with the SideNav expansion state.
   */
  isSideNavExpanded: import_prop_types191.default.bool,
  /**
   * Specify if this is a large variation of the SideNavLink
   */
  large: import_prop_types191.default.bool,
  /**
   * Provide an icon to render in the side navigation link. Should be a React class.
   */
  // @ts-expect-error - PropTypes are unable to cover this case.
  renderIcon: import_prop_types191.default.oneOfType([import_prop_types191.default.func, import_prop_types191.default.object]),
  /**
   * Optional prop to specify the tabIndex of the button. If undefined, it will be applied default validation
   */
  tabIndex: import_prop_types191.default.number
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/SideNavMenu.js
var import_classnames167 = __toESM(require_classnames());
var import_prop_types192 = __toESM(require_prop_types());
var import_react239 = __toESM(require_react());
var _ChevronDown4;
var SideNavMenu = import_react239.default.forwardRef(function SideNavMenu2(_ref, ref) {
  let {
    className: customClassName,
    children,
    defaultExpanded = false,
    isActive = false,
    large = false,
    renderIcon: IconElement,
    isSideNavExpanded,
    tabIndex,
    title
  } = _ref;
  const {
    isRail
  } = (0, import_react239.useContext)(SideNavContext);
  const prefix = usePrefix();
  const [isExpanded, setIsExpanded] = (0, import_react239.useState)(defaultExpanded);
  const [prevExpanded, setPrevExpanded] = (0, import_react239.useState)(defaultExpanded);
  const className = (0, import_classnames167.default)({
    [`${prefix}--side-nav__item`]: true,
    [`${prefix}--side-nav__item--active`]: isActive || hasActiveDescendant(children) && !isExpanded,
    [`${prefix}--side-nav__item--icon`]: IconElement,
    [`${prefix}--side-nav__item--large`]: large,
    [customClassName]: !!customClassName
  });
  if (!isSideNavExpanded && isExpanded && isRail) {
    setIsExpanded(false);
    setPrevExpanded(true);
  } else if (isSideNavExpanded && prevExpanded && isRail) {
    setIsExpanded(true);
    setPrevExpanded(false);
  }
  return (
    // eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions
    import_react239.default.createElement("li", {
      className,
      onKeyDown: (event) => {
        if (match(event, Escape)) {
          setIsExpanded(false);
        }
      }
    }, import_react239.default.createElement("button", {
      "aria-expanded": isExpanded,
      className: `${prefix}--side-nav__submenu`,
      onClick: () => {
        setIsExpanded(!isExpanded);
      },
      ref,
      type: "button",
      tabIndex: tabIndex === void 0 ? !isSideNavExpanded && !isRail ? -1 : 0 : tabIndex
    }, IconElement && import_react239.default.createElement(SideNavIcon, null, import_react239.default.createElement(IconElement, null)), import_react239.default.createElement("span", {
      className: `${prefix}--side-nav__submenu-title`
    }, title), import_react239.default.createElement(SideNavIcon, {
      className: `${prefix}--side-nav__submenu-chevron`,
      small: true
    }, _ChevronDown4 || (_ChevronDown4 = import_react239.default.createElement(ChevronDown, {
      size: 20
    })))), import_react239.default.createElement("ul", {
      className: `${prefix}--side-nav__menu`
    }, children))
  );
});
SideNavMenu.displayName = "SideNavMenu";
SideNavMenu.propTypes = {
  /**
   * Provide <SideNavMenuItem>'s inside of the `SideNavMenu`
   */
  children: import_prop_types192.default.node,
  /**
   * Provide an optional class to be applied to the containing node
   */
  className: import_prop_types192.default.string,
  /**
   * Specify whether the menu should default to expanded. By default, it will
   * be closed.
   */
  defaultExpanded: import_prop_types192.default.bool,
  /**
   * Specify whether the `SideNavMenu` is "active". `SideNavMenu` should be
   * considered active if one of its menu items are a link for the current
   * page.
   */
  isActive: import_prop_types192.default.bool,
  /**
   * Property to indicate if the side nav container is open (or not). Use to
   * keep local state and styling in step with the SideNav expansion state.
   */
  isSideNavExpanded: import_prop_types192.default.bool,
  /**
   * Specify if this is a large variation of the SideNavMenu
   */
  large: import_prop_types192.default.bool,
  /**
   * Pass in a custom icon to render next to the `SideNavMenu` title
   */
  // @ts-expect-error - PropTypes are unable to cover this case.
  renderIcon: import_prop_types192.default.oneOfType([import_prop_types192.default.func, import_prop_types192.default.object]),
  /**
   * Optional prop to specify the tabIndex of the button. If undefined, it will be applied default validation
   */
  tabIndex: import_prop_types192.default.number,
  /**
   * Provide the text for the overall menu name
   */
  title: import_prop_types192.default.string.isRequired
};
function hasActiveDescendant(children) {
  if (Array.isArray(children)) {
    return children.some((child) => {
      if (!import_react239.default.isValidElement(child)) {
        return false;
      }
      const props = child.props;
      if (props.isActive === true || props["aria-current"] || props.children instanceof Array && hasActiveDescendant(props.children)) {
        return true;
      }
      return false;
    });
  }
  if (import_react239.default.isValidElement(children)) {
    const props = children.props;
    if (props.isActive === true || props["aria-current"]) {
      return true;
    }
  }
  return false;
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/SideNavMenuItem.js
var import_classnames168 = __toESM(require_classnames());
var import_prop_types193 = __toESM(require_prop_types());
var import_react240 = __toESM(require_react());
var SideNavMenuItem = import_react240.default.forwardRef(function SideNavMenuItem2(props, ref) {
  const prefix = usePrefix();
  const {
    children,
    className: customClassName,
    as: Component2 = Link2,
    isActive,
    ...rest3
  } = props;
  const className = (0, import_classnames168.default)(`${prefix}--side-nav__menu-item`, customClassName);
  const linkClassName = (0, import_classnames168.default)({
    [`${prefix}--side-nav__link`]: true,
    [`${prefix}--side-nav__link--current`]: isActive
  });
  return import_react240.default.createElement("li", {
    className
  }, import_react240.default.createElement(Component2, _extends({}, rest3, {
    className: linkClassName,
    ref
  }), import_react240.default.createElement(SideNavLinkText, null, children)));
});
SideNavMenuItem.displayName = "SideNavMenuItem";
SideNavMenuItem.propTypes = {
  /**
   * Specify the children to be rendered inside of the `SideNavMenuItem`
   */
  children: import_prop_types193.default.node,
  /**
   * Provide an optional class to be applied to the containing node
   */
  className: import_prop_types193.default.string,
  /**
   * Optionally provide an href for the underlying li`
   */
  href: import_prop_types193.default.string,
  /**
   * Optionally specify whether the link is "active". An active link is one that
   * has an href that is the same as the current page. Can also pass in
   * `aria-current="page"`, as well.
   */
  isActive: import_prop_types193.default.bool,
  /**
   * Optional component to render instead of default Link
   */
  as: import_prop_types193.default.elementType
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UIShell/SideNavSwitcher.js
var import_classnames169 = __toESM(require_classnames());
var import_prop_types194 = __toESM(require_prop_types());
var import_react241 = __toESM(require_react());
var _ChevronDown5;
var SideNavSwitcher = (0, import_react241.forwardRef)(function SideNavSwitcher2(props, ref) {
  const id = useId("side-nav-switcher");
  const prefix = usePrefix();
  const {
    className: customClassName,
    labelText,
    onChange,
    options
  } = props;
  const className = (0, import_classnames169.default)(`${prefix}--side-nav__switcher`, customClassName);
  return import_react241.default.createElement("div", {
    className
  }, import_react241.default.createElement("label", {
    htmlFor: id,
    className: `${prefix}--assistive-text`
  }, labelText), import_react241.default.createElement("select", {
    id,
    className: `${prefix}--side-nav__select`,
    defaultValue: "",
    onBlur: onChange,
    onChange,
    ref
  }, import_react241.default.createElement("option", {
    className: `${prefix}--side-nav__option`,
    disabled: true,
    hidden: true,
    value: ""
  }, labelText), options.map((option) => import_react241.default.createElement("option", {
    key: option,
    className: `${prefix}--side-nav__option`,
    value: option
  }, option))), import_react241.default.createElement("div", {
    className: `${prefix}--side-nav__switcher-chevron`
  }, _ChevronDown5 || (_ChevronDown5 = import_react241.default.createElement(ChevronDown, {
    size: 20
  }))));
});
SideNavSwitcher.displayName = "SideNavSwitcher";
SideNavSwitcher.propTypes = {
  /**
   * Provide an optional class to be applied to the containing node
   */
  className: import_prop_types194.default.string,
  /**
   * Provide the label for the switcher. This will be the first visible option
   * when someone views this control
   */
  labelText: import_prop_types194.default.string.isRequired,
  /**
   * Provide a callback function that is called whenever the switcher value is
   * updated
   */
  onChange: import_prop_types194.default.func,
  /**
   * Provide an array of options to be rendered in the switcher as an
   * `<option>`. The text value will be what is displayed to the user and is set
   * as the `value` prop for each `<option>`.
   */
  // @ts-expect-error
  options: import_prop_types194.default.arrayOf(import_prop_types194.default.string).isRequired
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/UnorderedList/UnorderedList.js
var import_prop_types195 = __toESM(require_prop_types());
var import_react242 = __toESM(require_react());
var import_classnames170 = __toESM(require_classnames());
function UnorderedList(_ref) {
  let {
    className,
    nested = false,
    isExpressive = false,
    ...other
  } = _ref;
  const prefix = usePrefix();
  const classNames = (0, import_classnames170.default)(`${prefix}--list--unordered`, className, {
    [`${prefix}--list--nested`]: nested,
    [`${prefix}--list--expressive`]: isExpressive
  });
  return import_react242.default.createElement("ul", _extends({
    className: classNames
  }, other));
}
UnorderedList.propTypes = {
  /**
   * Specify a collection of ListItem's to be rendered in the UnorderedList
   */
  children: import_prop_types195.default.node,
  /**
   * Specify an optional className to be applied to the underlying `<ul>` node
   */
  className: import_prop_types195.default.string,
  /**
   * Specify whether this ordered list expressive or not
   */
  isExpressive: import_prop_types195.default.bool,
  /**
   * Specify whether the list is nested, or not
   */
  nested: import_prop_types195.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FluidComboBox/FluidComboBox.js
var import_prop_types196 = __toESM(require_prop_types());
var import_react243 = __toESM(require_react());
var import_classnames171 = __toESM(require_classnames());
var FluidComboBox = import_react243.default.forwardRef(function FluidComboBox2(_ref, ref) {
  let {
    className,
    isCondensed,
    ...other
  } = _ref;
  const prefix = usePrefix();
  const classNames = (0, import_classnames171.default)(`${prefix}--list-box__wrapper--fluid`, className, {
    [`${prefix}--list-box__wrapper--fluid--condensed`]: isCondensed
  });
  return import_react243.default.createElement(FormContext.Provider, {
    value: {
      isFluid: true
    }
  }, import_react243.default.createElement(ComboBox, _extends({
    ref,
    className: classNames
  }, other)));
});
FluidComboBox.propTypes = {
  /**
   * Specify an optional className to be applied to the outer FluidForm wrapper
   */
  className: import_prop_types196.default.string,
  /**
   * Specify the direction of the dropdown. Can be either top or bottom.
   */
  direction: import_prop_types196.default.oneOf(["top", "bottom"]),
  /**
   * Specify whether the `<input>` should be disabled
   */
  disabled: import_prop_types196.default.bool,
  /**
   * Specify a custom `id` for the `<input>`
   */
  id: import_prop_types196.default.string.isRequired,
  /**
   * Allow users to pass in an arbitrary item or a string (in case their items are an array of strings)
   * from their collection that are pre-selected
   */
  initialSelectedItem: import_prop_types196.default.oneOfType([import_prop_types196.default.object, import_prop_types196.default.string, import_prop_types196.default.number]),
  /**
   * Specify if the currently selected value is invalid.
   */
  invalid: import_prop_types196.default.bool,
  /**
   * Provide the text that is displayed when the control is in an invalid state
   */
  invalidText: import_prop_types196.default.node,
  /**
   * Specify if the `FluidComboBox` should render its menu items in condensed mode
   */
  isCondensed: import_prop_types196.default.bool,
  /**
   * Function to render items as custom components instead of strings.
   * Defaults to null and is overridden by a getter
   */
  itemToElement: import_prop_types196.default.func,
  /**
   * Helper function passed to downshift that allows the library to render a
   * given item to a string label. By default, it extracts the `label` field
   * from a given item to serve as the item label in the list.
   */
  itemToString: import_prop_types196.default.func,
  /**
   * We try to stay as generic as possible here to allow individuals to pass
   * in a collection of whatever kind of data structure they prefer
   */
  items: import_prop_types196.default.array.isRequired,
  /**
   * Generic `label` that will be used as the textual representation of what
   * this field is for
   */
  label: import_prop_types196.default.node.isRequired,
  /**
   * `onChange` is a utility for this controlled component to communicate to a
   * consuming component what kind of internal state changes are occurring.
   */
  onChange: import_prop_types196.default.func.isRequired,
  /**
   * An optional callback to render the currently selected item as a react element instead of only
   * as a string.
   */
  renderSelectedItem: import_prop_types196.default.func,
  /**
   * In the case you want to control the dropdown selection entirely.
   */
  selectedItem: import_prop_types196.default.oneOfType([import_prop_types196.default.object, import_prop_types196.default.string, import_prop_types196.default.number]),
  /**
   * Provide the title text that will be read by a screen reader when
   * visiting this control
   */
  titleText: import_prop_types196.default.node,
  /**
   * Callback function for translating ListBoxMenuIcon SVG title
   */
  translateWithId: import_prop_types196.default.func,
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types196.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types196.default.node
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FluidComboBox/FluidComboBox.Skeleton.js
var import_prop_types197 = __toESM(require_prop_types());
var import_react244 = __toESM(require_react());
var import_classnames172 = __toESM(require_classnames());
var FluidComboBoxSkeleton = (_ref) => {
  let {
    className,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const wrapperClasses = (0, import_classnames172.default)(className, `${prefix}--list-box__wrapper--fluid`);
  return import_react244.default.createElement("div", _extends({
    className: wrapperClasses
  }, rest3), import_react244.default.createElement("div", {
    className: `${prefix}--skeleton ${prefix}--list-box`
  }, import_react244.default.createElement("span", {
    className: `${prefix}--list-box__label`
  }), import_react244.default.createElement("div", {
    className: `${prefix}--list-box__field`
  })));
};
FluidComboBoxSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types197.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FluidDatePicker/FluidDatePicker.js
var import_prop_types198 = __toESM(require_prop_types());
var import_classnames173 = __toESM(require_classnames());
var import_react245 = __toESM(require_react());
var FluidDatePicker = import_react245.default.forwardRef(function FluidDatePicker2(_ref, ref) {
  let {
    className,
    children,
    invalid,
    invalidText,
    readOnly,
    warn: warn2,
    warnText,
    ...other
  } = _ref;
  const prefix = usePrefix();
  const classNames = (0, import_classnames173.default)(className, {
    [`${prefix}--date-picker--fluid`]: true,
    [`${prefix}--date-picker--fluid--invalid`]: invalid,
    [`${prefix}--date-picker--fluid--readonly`]: readOnly,
    [`${prefix}--date-picker--fluid--warn`]: warn2
  });
  return import_react245.default.createElement(FormContext.Provider, {
    value: {
      isFluid: true
    }
  }, import_react245.default.createElement(DatePicker, _extends({
    invalid,
    invalidText,
    readOnly,
    warn: warn2,
    warnText,
    className: classNames,
    ref
  }, other), children));
});
FluidDatePicker.propTypes = {
  /**
   * The child node(s)
   */
  children: import_prop_types198.default.node,
  /**
   * Specify an optional className to be applied to the outer FluidForm wrapper
   */
  className: import_prop_types198.default.string,
  /**
   * Specify whether or not the control is invalid
   */
  invalid: import_prop_types198.default.bool,
  /**
   * Provide the text that is displayed when the control is in error state
   */
  invalidText: import_prop_types198.default.node,
  /**
   * Whether the input should be read-only
   */
  readOnly: import_prop_types198.default.bool,
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types198.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types198.default.node
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FluidDatePicker/FluidDatePicker.Skeleton.js
var import_prop_types199 = __toESM(require_prop_types());
var import_react246 = __toESM(require_react());
var import_classnames174 = __toESM(require_classnames());
var FluidDatePickerSkeleton = (_ref) => {
  let {
    className,
    datePickerType = "single",
    ...other
  } = _ref;
  const prefix = usePrefix();
  const classNames = (0, import_classnames174.default)(className, `${prefix}--form-item ${prefix}--date-picker--fluid__skeleton`, {
    [`${prefix}--date-picker--fluid__skeleton--range`]: datePickerType === "range"
  });
  return import_react246.default.createElement(FormContext.Provider, {
    value: {
      isFluid: true
    }
  }, import_react246.default.createElement("div", _extends({
    className: classNames
  }, other), import_react246.default.createElement("div", {
    className: `${prefix}--date-picker--fluid__skeleton--container`
  }, import_react246.default.createElement("span", {
    className: `${prefix}--label ${prefix}--skeleton`
  }), import_react246.default.createElement("div", {
    className: `${prefix}--skeleton ${prefix}--text-input`
  }), datePickerType !== "simple" && import_react246.default.createElement(Calendar, {
    className: `${prefix}--date-picker__icon`,
    role: "img",
    "aria-hidden": "true"
  })), datePickerType === "range" && import_react246.default.createElement("div", {
    className: `${prefix}--date-picker--fluid__skeleton--container`
  }, import_react246.default.createElement("span", {
    className: `${prefix}--label ${prefix}--skeleton`
  }), import_react246.default.createElement("div", {
    className: `${prefix}--skeleton ${prefix}--text-input`
  }), import_react246.default.createElement(Calendar, {
    className: `${prefix}--date-picker__icon`,
    role: "img",
    "aria-hidden": "true"
  }))));
};
FluidDatePickerSkeleton.propTypes = {
  /**
   * Specify an optional className to be applied to the outer FluidForm wrapper
   */
  className: import_prop_types199.default.string,
  /**
   * Specify which variant of the DatePicker the skeleton should mimic
   */
  datePickerType: import_prop_types199.default.oneOf(["simple", "single", "range"])
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FluidDatePickerInput/FluidDatePickerInput.js
var import_react247 = __toESM(require_react());
var FluidDatePickerInput = import_react247.default.forwardRef(function FluidDatePickerInput2(_ref, ref) {
  let {
    ...other
  } = _ref;
  return import_react247.default.createElement(FormContext.Provider, {
    value: {
      isFluid: true
    }
  }, import_react247.default.createElement(DatePickerInput, _extends({
    ref
  }, other)));
});

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FluidDropdown/FluidDropdown.js
var import_prop_types200 = __toESM(require_prop_types());
var import_react248 = __toESM(require_react());
var import_classnames175 = __toESM(require_classnames());
var FluidDropdown = import_react248.default.forwardRef(function FluidDropdown2(_ref, ref) {
  let {
    className,
    isCondensed,
    ...other
  } = _ref;
  const prefix = usePrefix();
  const classNames = (0, import_classnames175.default)(`${prefix}--list-box__wrapper--fluid`, className, {
    [`${prefix}--list-box__wrapper--fluid--condensed`]: isCondensed
  });
  return import_react248.default.createElement(FormContext.Provider, {
    value: {
      isFluid: true
    }
  }, import_react248.default.createElement(Dropdown, _extends({
    ref,
    className: classNames
  }, other)));
});
FluidDropdown.propTypes = {
  /**
   * Specify an optional className to be applied to the outer FluidForm wrapper
   */
  className: import_prop_types200.default.string,
  /**
   * Specify the direction of the dropdown. Can be either top or bottom.
   */
  direction: import_prop_types200.default.oneOf(["top", "bottom"]),
  /**
   * Specify whether the `<input>` should be disabled
   */
  disabled: import_prop_types200.default.bool,
  /**
   * Specify a custom `id` for the `<input>`
   */
  id: import_prop_types200.default.string.isRequired,
  /**
   * Allow users to pass in an arbitrary item or a string (in case their items are an array of strings)
   * from their collection that are pre-selected
   */
  initialSelectedItem: import_prop_types200.default.oneOfType([import_prop_types200.default.object, import_prop_types200.default.string, import_prop_types200.default.number]),
  /**
   * Specify if the currently selected value is invalid.
   */
  invalid: import_prop_types200.default.bool,
  /**
   * Provide the text that is displayed when the control is in an invalid state
   */
  invalidText: import_prop_types200.default.node,
  /**
   * Specify if the `FluidDropdown` should render its menu items in condensed mode
   */
  isCondensed: import_prop_types200.default.bool,
  /**
   * Function to render items as custom components instead of strings.
   * Defaults to null and is overridden by a getter
   */
  itemToElement: import_prop_types200.default.func,
  /**
   * Helper function passed to downshift that allows the library to render a
   * given item to a string label. By default, it extracts the `label` field
   * from a given item to serve as the item label in the list.
   */
  itemToString: import_prop_types200.default.func,
  /**
   * We try to stay as generic as possible here to allow individuals to pass
   * in a collection of whatever kind of data structure they prefer
   */
  items: import_prop_types200.default.array.isRequired,
  /**
   * Generic `label` that will be used as the textual representation of what
   * this field is for
   */
  label: import_prop_types200.default.node.isRequired,
  /**
   * `onChange` is a utility for this controlled component to communicate to a
   * consuming component what kind of internal state changes are occurring.
   */
  onChange: import_prop_types200.default.func,
  /**
   * An optional callback to render the currently selected item as a react element instead of only
   * as a string.
   */
  renderSelectedItem: import_prop_types200.default.func,
  /**
   * In the case you want to control the dropdown selection entirely.
   */
  selectedItem: import_prop_types200.default.oneOfType([import_prop_types200.default.object, import_prop_types200.default.string, import_prop_types200.default.number]),
  /**
   * Provide the title text that will be read by a screen reader when
   * visiting this control
   */
  titleText: import_prop_types200.default.node,
  /**
   * Callback function for translating ListBoxMenuIcon SVG title
   */
  translateWithId: import_prop_types200.default.func,
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types200.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types200.default.node
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FluidDropdown/FluidDropdown.Skeleton.js
var import_prop_types201 = __toESM(require_prop_types());
var import_react249 = __toESM(require_react());
var import_classnames176 = __toESM(require_classnames());
var FluidDropdownSkeleton = (_ref) => {
  let {
    className,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const wrapperClasses = (0, import_classnames176.default)(className, `${prefix}--list-box__wrapper--fluid`);
  return import_react249.default.createElement("div", _extends({
    className: wrapperClasses
  }, rest3), import_react249.default.createElement("div", {
    className: `${prefix}--skeleton ${prefix}--list-box`
  }, import_react249.default.createElement("span", {
    className: `${prefix}--list-box__label`
  }), import_react249.default.createElement("div", {
    className: `${prefix}--list-box__field`
  })));
};
FluidDropdownSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types201.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FluidMultiSelect/FluidMultiSelect.js
var import_prop_types202 = __toESM(require_prop_types());
var import_react250 = __toESM(require_react());
var import_classnames177 = __toESM(require_classnames());
var FluidMultiSelect = import_react250.default.forwardRef(function FluidMultiSelect2(_ref, ref) {
  let {
    className,
    isCondensed,
    isFilterable,
    ...other
  } = _ref;
  const prefix = usePrefix();
  const classNames = (0, import_classnames177.default)(`${prefix}--list-box__wrapper--fluid`, className, {
    [`${prefix}--list-box__wrapper--fluid--condensed`]: isCondensed
  });
  return import_react250.default.createElement(FormContext.Provider, {
    value: {
      isFluid: true
    }
  }, isFilterable ? (
    // @ts-ignore
    import_react250.default.createElement(FilterableMultiSelect, _extends({
      ref,
      className: classNames
    }, other))
  ) : import_react250.default.createElement(MultiSelect, _extends({
    ref,
    className: classNames
  }, other)));
});
FluidMultiSelect.propTypes = {
  /**
   * Specify an optional className to be applied to the outer FluidForm wrapper
   */
  className: import_prop_types202.default.string,
  /**
   * Specify the text that should be read for screen readers that describes total items selected
   */
  clearSelectionDescription: import_prop_types202.default.string,
  /**
   * Specify the text that should be read for screen readers to clear selection.
   */
  clearSelectionText: import_prop_types202.default.string,
  /**
   * Provide a compare function that is used to determine the ordering of
   * options. See 'sortItems' for more control. Consider declaring function
   * with `useCallback` to prevent unnecessary re-renders.
   */
  compareItems: import_prop_types202.default.func,
  /**
   * Specify the direction of the multiselect dropdown. Can be either top or bottom.
   */
  direction: import_prop_types202.default.oneOf(["top", "bottom"]),
  /**
   * Specify whether the `<input>` should be disabled
   */
  disabled: import_prop_types202.default.bool,
  /**
   * Additional props passed to Downshift.
   *
   * **Use with caution:** anything you define here overrides the components'
   * internal handling of that prop. Downshift APIs and internals are subject to
   * change, and in some cases they can not be shimmed by Carbon to shield you
   * from potentially breaking changes.
   */
  downshiftProps: import_prop_types202.default.object,
  /**
   * Specify a custom `id` for the `<input>`
   */
  id: import_prop_types202.default.string.isRequired,
  /**
   * Allow users to pass in arbitrary items from their collection that are
   * pre-selected
   */
  initialSelectedItems: import_prop_types202.default.array,
  /**
   * Specify if the currently selected value is invalid.
   */
  invalid: import_prop_types202.default.bool,
  /**
   * Provide the text that is displayed when the control is in an invalid state
   */
  invalidText: import_prop_types202.default.node,
  /**
   * Specify if the `FluidMultiSelect` should render its menu items in condensed mode
   */
  isCondensed: import_prop_types202.default.bool,
  /**
   * Specify if the `FluidMultiSelect` should render the `filterable` variant of `FluidMultiSelect`
   */
  isFilterable: import_prop_types202.default.bool,
  /**
   * Function to render items as custom components instead of strings.
   * Defaults to null and is overridden by a getter
   */
  itemToElement: import_prop_types202.default.func,
  /**
   * Helper function passed to downshift that allows the library to render a
   * given item to a string label. By default, it extracts the `label` field
   * from a given item to serve as the item label in the list. Consider
   * declaring function with `useCallback` to prevent unnecessary re-renders.
   */
  itemToString: import_prop_types202.default.func,
  /**
   * We try to stay as generic as possible here to allow individuals to pass
   * in a collection of whatever kind of data structure they prefer
   */
  items: import_prop_types202.default.array.isRequired,
  /**
   * Generic `label` that will be used as the textual representation of what
   * this field is for
   */
  label: import_prop_types202.default.node.isRequired,
  /**
   * Specify the locale of the control. Used for the default `compareItems`
   * used for sorting the list of items in the control.
   */
  locale: import_prop_types202.default.string,
  /**
   * `onChange` is a utility for this controlled component to communicate to a
   * consuming component what kind of internal state changes are occurring.
   */
  onChange: import_prop_types202.default.func,
  /**
   * **Filterable variant only** - `onInputValueChange` is a utility for this controlled component to communicate to
   * the currently typed input.
   */
  onInputValueChange: import_prop_types202.default.func,
  /**
   * `onMenuChange` is a utility for this controlled component to communicate to a
   * consuming component that the menu was open(`true`)/closed(`false`).
   */
  onMenuChange: import_prop_types202.default.func,
  /**
   * Whether or not the Multiselect is readonly
   */
  readOnly: import_prop_types202.default.bool,
  /**
   * For full control of the selected items
   */
  selectedItems: import_prop_types202.default.array,
  /**
   * Specify feedback (mode) of the selection.
   * `top`: selected item jumps to top
   * `fixed`: selected item stays at it's position
   * `top-after-reopen`: selected item jump to top after reopen dropdown
   */
  selectionFeedback: import_prop_types202.default.oneOf(["top", "fixed", "top-after-reopen"]),
  /**
   * Provide a method that sorts all options in the control. Overriding this
   * prop means that you also have to handle the sort logic for selected versus
   * un-selected items. If you just want to control ordering, consider the
   * `compareItems` prop instead.
   *
   * The return value should be a number whose sign indicates the relative order
   * of the two elements: negative if a is less than b, positive if a is greater
   * than b, and zero if they are equal.
   *
   * sortItems :
   *   (items: Array<Item>, {
   *     selectedItems: Array<Item>,
   *     itemToString: Item => string,
   *     compareItems: (itemA: string, itemB: string, {
   *       locale: string
   *     }) => number,
   *     locale: string,
   *   }) => Array<Item>
   */
  sortItems: import_prop_types202.default.func,
  /**
   * Provide the title text that will be read by a screen reader when
   * visiting this control
   */
  titleText: import_prop_types202.default.node,
  /**
   * Callback function for translating ListBoxMenuIcon SVG title
   */
  translateWithId: import_prop_types202.default.func,
  /**
   * Specify title to show title on hover
   */
  useTitleInItem: import_prop_types202.default.bool,
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types202.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types202.default.node
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FluidMultiSelect/FluidMultiSelect.Skeleton.js
var import_prop_types203 = __toESM(require_prop_types());
var import_react251 = __toESM(require_react());
var import_classnames178 = __toESM(require_classnames());
var FluidMultiSelectSkeleton = (_ref) => {
  let {
    className,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const wrapperClasses = (0, import_classnames178.default)(className, `${prefix}--list-box__wrapper--fluid`);
  return import_react251.default.createElement("div", _extends({
    className: wrapperClasses
  }, rest3), import_react251.default.createElement("div", {
    className: `${prefix}--skeleton ${prefix}--list-box`
  }, import_react251.default.createElement("span", {
    className: `${prefix}--list-box__label`
  }), import_react251.default.createElement("div", {
    className: `${prefix}--list-box__field`
  })));
};
FluidMultiSelectSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types203.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FluidSelect/FluidSelect.js
var import_prop_types204 = __toESM(require_prop_types());
var import_react252 = __toESM(require_react());
var import_classnames179 = __toESM(require_classnames());
var FluidSelect = import_react252.default.forwardRef(function FluidSelect2(_ref, ref) {
  let {
    className,
    children,
    ...other
  } = _ref;
  const prefix = usePrefix();
  const classNames = (0, import_classnames179.default)(`${prefix}--select--fluid`, className);
  return import_react252.default.createElement(FormContext.Provider, {
    value: {
      isFluid: true
    }
  }, import_react252.default.createElement(Select, _extends({
    ref,
    className: classNames
  }, other), children));
});
FluidSelect.propTypes = {
  /**
   * Provide the contents of your Select
   */
  children: import_prop_types204.default.node,
  /**
   * Specify an optional className to be applied to the node containing the label and the select box
   */
  className: import_prop_types204.default.string,
  /**
   * Optionally provide the default value of the `<select>`
   */
  defaultValue: import_prop_types204.default.any,
  /**
   * Specify whether the control is disabled
   */
  disabled: import_prop_types204.default.bool,
  /**
   * Specify a custom `id` for the `<select>`
   */
  id: import_prop_types204.default.string.isRequired,
  /**
   * Specify if the currently value is invalid.
   */
  invalid: import_prop_types204.default.bool,
  /**
   * Message which is displayed if the value is invalid.
   */
  invalidText: import_prop_types204.default.node,
  /**
   * Provide label text to be read by screen readers when interacting with the
   * control
   */
  labelText: import_prop_types204.default.node,
  /**
   * Provide an optional `onChange` hook that is called each time the value of
   * the underlying `<input>` changes
   */
  onChange: import_prop_types204.default.func,
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types204.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types204.default.node,
  /**
   * Whether or not the component is readonly
   */
  readOnly: import_prop_types204.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FluidSelect/FluidSelect.Skeleton.js
var import_prop_types205 = __toESM(require_prop_types());
var import_react253 = __toESM(require_react());
var import_classnames180 = __toESM(require_classnames());
var FluidSelectSkeleton = (_ref) => {
  let {
    className,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const wrapperClasses = (0, import_classnames180.default)(className, `${prefix}--list-box__wrapper--fluid`);
  return import_react253.default.createElement("div", _extends({
    className: wrapperClasses
  }, rest3), import_react253.default.createElement("div", {
    className: `${prefix}--skeleton ${prefix}--list-box`
  }, import_react253.default.createElement("span", {
    className: `${prefix}--list-box__label`
  }), import_react253.default.createElement("div", {
    className: `${prefix}--list-box__field`
  })));
};
FluidSelectSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types205.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FluidSearch/FluidSearch.js
var import_prop_types206 = __toESM(require_prop_types());
var import_react254 = __toESM(require_react());
var import_classnames181 = __toESM(require_classnames());
var FluidSearch = import_react254.default.forwardRef(function FluidSearch2(_ref, ref) {
  let {
    className,
    ...other
  } = _ref;
  const prefix = usePrefix();
  const classNames = (0, import_classnames181.default)(`${prefix}--search--fluid`, className);
  return import_react254.default.createElement(FormContext.Provider, {
    value: {
      isFluid: true
    }
  }, import_react254.default.createElement(Search2, _extends({
    ref,
    className: classNames
  }, other)));
});
FluidSearch.propTypes = {
  /**
   * Specify an optional value for the `autocomplete` property on the underlying
   * `<input>`, defaults to "off"
   */
  autoComplete: import_prop_types206.default.string,
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types206.default.string,
  /**
   * Specify a label to be read by screen readers on the "close" button
   */
  closeButtonLabelText: import_prop_types206.default.string,
  /**
   * Optionally provide the default value of the `<input>`
   */
  defaultValue: import_prop_types206.default.oneOfType([import_prop_types206.default.string, import_prop_types206.default.number]),
  /**
   * Specify whether the `<input>` should be disabled
   */
  disabled: import_prop_types206.default.bool,
  /**
   * Specify a custom `id` for the input
   */
  id: import_prop_types206.default.string,
  /**
   * Provide the label text for the Search icon
   */
  labelText: import_prop_types206.default.node.isRequired,
  /**
   * Optional callback called when the search value changes.
   */
  onChange: import_prop_types206.default.func,
  /**
   * Optional callback called when the search value is cleared.
   */
  onClear: import_prop_types206.default.func,
  /**
   * Provide a handler that is invoked on the key down event for the input
   */
  onKeyDown: import_prop_types206.default.func,
  /**
   * Provide an optional placeholder text for the Search.
   * Note: if the label and placeholder differ,
   * VoiceOver on Mac will read both
   */
  placeholder: import_prop_types206.default.string,
  /**
   * Specify the role for the underlying `<input>`, defaults to `searchbox`
   */
  role: import_prop_types206.default.string,
  /**
   * Optional prop to specify the type of the `<input>`
   */
  type: import_prop_types206.default.string,
  /**
   * Specify the value of the `<input>`
   */
  value: import_prop_types206.default.oneOfType([import_prop_types206.default.string, import_prop_types206.default.number])
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FluidSearch/FluidSearch.Skeleton.js
var import_prop_types207 = __toESM(require_prop_types());
var import_react255 = __toESM(require_react());
var import_classnames182 = __toESM(require_classnames());
var FluidSearchSkeleton = (_ref) => {
  let {
    className,
    ...other
  } = _ref;
  const prefix = usePrefix();
  return import_react255.default.createElement(FormContext.Provider, {
    value: {
      isFluid: true
    }
  }, import_react255.default.createElement("div", _extends({
    className: (0, import_classnames182.default)(`${prefix}--form-item ${prefix}--text-input--fluid__skeleton`, className)
  }, other), import_react255.default.createElement("span", {
    className: `${prefix}--label ${prefix}--skeleton`
  }), import_react255.default.createElement("div", {
    className: `${prefix}--skeleton ${prefix}--text-input`
  })));
};
FluidSearchSkeleton.propTypes = {
  /**
   * Specify an optional className to be applied to the outer FluidForm wrapper
   */
  className: import_prop_types207.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FluidTextArea/FluidTextArea.js
var import_prop_types208 = __toESM(require_prop_types());
var import_react256 = __toESM(require_react());
var import_classnames183 = __toESM(require_classnames());
var FluidTextArea = (_ref) => {
  let {
    className,
    ...other
  } = _ref;
  const prefix = usePrefix();
  const classNames = (0, import_classnames183.default)(`${prefix}--text-area--fluid`, className);
  return import_react256.default.createElement(FormContext.Provider, {
    value: {
      isFluid: true
    }
  }, import_react256.default.createElement(TextArea, _extends({
    className: classNames
  }, other)));
};
FluidTextArea.propTypes = {
  /**
   * Provide a custom className that is applied directly to the underlying
   * `<textarea>` node
   */
  className: import_prop_types208.default.string,
  /**
   * Specify the `cols` attribute for the underlying `<textarea>` node
   */
  cols: import_prop_types208.default.number,
  /**
   * Optionally provide the default value of the `<textarea>`
   */
  defaultValue: import_prop_types208.default.oneOfType([import_prop_types208.default.string, import_prop_types208.default.number]),
  /**
   * Specify whether the control is disabled
   */
  disabled: import_prop_types208.default.bool,
  /**
   * Specify whether to display the character counter
   */
  enableCounter: import_prop_types208.default.bool,
  /**
   * Provide text that is used alongside the control label for additional help
   */
  helperText: import_prop_types208.default.node,
  /**
   * Specify whether you want the underlying label to be visually hidden
   */
  hideLabel: import_prop_types208.default.bool,
  /**
   * Provide a unique identifier for the control
   */
  id: import_prop_types208.default.string,
  /**
   * Specify whether the control is currently invalid
   */
  invalid: import_prop_types208.default.bool,
  /**
   * Provide the text that is displayed when the control is in an invalid state
   */
  invalidText: import_prop_types208.default.node,
  /**
   * Provide the text that will be read by a screen reader when visiting this
   * control
   */
  labelText: import_prop_types208.default.node.isRequired,
  /**
   * `true` to use the light version. For use on $ui-01 backgrounds only.
   * Don't use this to make tile background color same as container background color.
   */
  light: deprecate(import_prop_types208.default.bool, "The `light` prop for `FluidTextArea` has been deprecated in favor of the new `Layer` component. It will be removed in the next major release."),
  /**
   * Max character count allowed for the textarea. This is needed in order for enableCounter to display
   */
  maxCount: import_prop_types208.default.number,
  /**
   * Optionally provide an `onChange` handler that is called whenever `<textarea>`
   * is updated
   */
  onChange: import_prop_types208.default.func,
  /**
   * Optionally provide an `onClick` handler that is called whenever the
   * `<textarea>` is clicked
   */
  onClick: import_prop_types208.default.func,
  /**
   * Specify the placeholder attribute for the `<textarea>`
   */
  placeholder: import_prop_types208.default.string,
  /**
   * Specify the rows attribute for the `<textarea>`
   */
  rows: import_prop_types208.default.number,
  /**
   * Provide the current value of the `<textarea>`
   */
  value: import_prop_types208.default.oneOfType([import_prop_types208.default.string, import_prop_types208.default.number]),
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types208.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types208.default.node,
  /**
   * Whether or not the component is readonly
   */
  readOnly: import_prop_types208.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FluidTextArea/FluidTextArea.Skeleton.js
var import_prop_types209 = __toESM(require_prop_types());
var import_react257 = __toESM(require_react());
var import_classnames184 = __toESM(require_classnames());
var FluidTextAreaSkeleton = (_ref) => {
  let {
    className,
    ...other
  } = _ref;
  const prefix = usePrefix();
  return import_react257.default.createElement(FormContext.Provider, {
    value: {
      isFluid: true
    }
  }, import_react257.default.createElement("div", _extends({
    className: (0, import_classnames184.default)(`${prefix}--form-item ${prefix}--text-area--fluid__skeleton`, className)
  }, other), import_react257.default.createElement("span", {
    className: `${prefix}--label ${prefix}--skeleton`
  }), import_react257.default.createElement("div", {
    className: `${prefix}--skeleton ${prefix}--text-area`
  })));
};
FluidTextAreaSkeleton.propTypes = {
  /**
   * Specify an optional className to be applied to the outer FluidForm wrapper
   */
  className: import_prop_types209.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FluidTextInput/FluidTextInput.js
var import_prop_types210 = __toESM(require_prop_types());
var import_react258 = __toESM(require_react());
var import_classnames185 = __toESM(require_classnames());
var FluidTextInput = import_react258.default.forwardRef(function FluidTextInput2(_ref, ref) {
  let {
    className,
    isPassword,
    ...other
  } = _ref;
  const prefix = usePrefix();
  const classNames = (0, import_classnames185.default)(className, {
    [`${prefix}--text-input--fluid`]: !isPassword
  });
  return import_react258.default.createElement(FormContext.Provider, {
    value: {
      isFluid: true
    }
  }, isPassword ? import_react258.default.createElement(PasswordInput, _extends({
    className: classNames,
    ref
  }, other)) : import_react258.default.createElement(TextInput, _extends({
    className: classNames,
    ref
  }, other)));
});
FluidTextInput.propTypes = {
  /**
   * Specify an optional className to be applied to the outer FluidForm wrapper
   */
  className: import_prop_types210.default.string,
  /**
   * Optionally provide the default value of the `<input>`
   */
  defaultValue: import_prop_types210.default.oneOfType([import_prop_types210.default.string, import_prop_types210.default.number]),
  /**
   * Specify whether the `<input>` should be disabled
   */
  disabled: import_prop_types210.default.bool,
  /**
   * Specify a custom `id` for the `<input>`
   */
  id: import_prop_types210.default.string.isRequired,
  /**
   * Specify whether the control is currently invalid
   */
  invalid: import_prop_types210.default.bool,
  /**
   * Provide the text that is displayed when the control is in an invalid state
   */
  invalidText: import_prop_types210.default.node,
  /**
   * Specify whether the control is a password input
   */
  isPassword: import_prop_types210.default.bool,
  /**
   * Provide the text that will be read by a screen reader when visiting this
   * control
   */
  labelText: import_prop_types210.default.node.isRequired,
  /**
   * Optionally provide an `onChange` handler that is called whenever `<input>`
   * is updated
   */
  onChange: import_prop_types210.default.func,
  /**
   * Optionally provide an `onClick` handler that is called whenever the
   * `<input>` is clicked
   */
  onClick: import_prop_types210.default.func,
  /**
   * Specify the placeholder attribute for the `<input>`
   */
  placeholder: import_prop_types210.default.string,
  /**
   * Specify the value of the `<input>`
   */
  value: import_prop_types210.default.oneOfType([import_prop_types210.default.string, import_prop_types210.default.number]),
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types210.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types210.default.node,
  /**
   * Whether or not the component is readonly
   */
  readOnly: import_prop_types210.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FluidTextInput/FluidPasswordInput.js
var import_prop_types211 = __toESM(require_prop_types());
var import_react259 = __toESM(require_react());
var import_classnames186 = __toESM(require_classnames());
({
  /**
   * Specify an optional className to be applied to the outer FluidForm wrapper
   */
  className: import_prop_types211.default.string,
  /**
   * Optionally provide the default value of the `<input>`
   */
  defaultValue: import_prop_types211.default.oneOfType([import_prop_types211.default.string, import_prop_types211.default.number]),
  /**
   * Specify whether the `<input>` should be disabled
   */
  disabled: import_prop_types211.default.bool,
  /**
   * "Hide password" tooltip text on password visibility toggle
   */
  hidePasswordLabel: import_prop_types211.default.string,
  /**
   * Specify a custom `id` for the `<input>`
   */
  id: import_prop_types211.default.string.isRequired,
  /**
   * Specify whether the control is currently invalid
   */
  invalid: import_prop_types211.default.bool,
  /**
   * Provide the text that is displayed when the control is in an invalid state
   */
  invalidText: import_prop_types211.default.node,
  /**
   * Specify whether the control is a password input
   */
  isPassword: import_prop_types211.default.bool,
  /**
   * Provide the text that will be read by a screen reader when visiting this
   * control
   */
  labelText: import_prop_types211.default.node.isRequired,
  /**
   * Optionally provide an `onChange` handler that is called whenever `<input>`
   * is updated
   */
  onChange: import_prop_types211.default.func,
  /**
   * Optionally provide an `onClick` handler that is called whenever the
   * `<input>` is clicked
   */
  onClick: import_prop_types211.default.func,
  /**
   * Callback function that is called whenever the toggle password visibility
   * button is clicked
   */
  onTogglePasswordVisibility: import_prop_types211.default.func,
  /**
   * Specify the placeholder attribute for the `<input>`
   */
  placeholder: import_prop_types211.default.string,
  /**
   * "Show password" tooltip text on password visibility toggle
   */
  showPasswordLabel: import_prop_types211.default.string,
  /**
   * Specify the value of the `<input>`
   */
  value: import_prop_types211.default.oneOfType([import_prop_types211.default.string, import_prop_types211.default.number]),
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types211.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types211.default.node,
  /**
   * Whether or not the component is readonly
   */
  readOnly: import_prop_types211.default.bool
});

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FluidTextInput/FluidTextInput.Skeleton.js
var import_prop_types212 = __toESM(require_prop_types());
var import_react260 = __toESM(require_react());
var import_classnames187 = __toESM(require_classnames());
var FluidTextInputSkeleton = (_ref) => {
  let {
    className,
    ...other
  } = _ref;
  const prefix = usePrefix();
  return import_react260.default.createElement(FormContext.Provider, {
    value: {
      isFluid: true
    }
  }, import_react260.default.createElement("div", _extends({
    className: (0, import_classnames187.default)(`${prefix}--form-item ${prefix}--text-input--fluid__skeleton`, className)
  }, other), import_react260.default.createElement("span", {
    className: `${prefix}--label ${prefix}--skeleton`
  }), import_react260.default.createElement("div", {
    className: `${prefix}--skeleton ${prefix}--text-input`
  })));
};
FluidTextInputSkeleton.propTypes = {
  /**
   * Specify an optional className to be applied to the outer FluidForm wrapper
   */
  className: import_prop_types212.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FluidTimePicker/FluidTimePicker.js
var import_react261 = __toESM(require_react());
var import_prop_types213 = __toESM(require_prop_types());
var import_classnames188 = __toESM(require_classnames());
var FluidTimePicker = import_react261.default.forwardRef(function FluidTimePicker2(_ref, ref) {
  let {
    className,
    children,
    disabled,
    invalid,
    invalidText,
    warn: warn2,
    warnText,
    readOnly,
    ...other
  } = _ref;
  const prefix = usePrefix();
  const classNames = (0, import_classnames188.default)(className, {
    [`${prefix}--time-picker--fluid`]: true,
    [`${prefix}--time-picker--equal-width`]: import_react261.default.Children.toArray(children).length !== 2,
    [`${prefix}--time-picker--fluid--disabled`]: disabled,
    [`${prefix}--time-picker--fluid--invalid`]: invalid,
    [`${prefix}--time-picker--fluid--warning`]: warn2
  });
  const errorText = () => {
    if (invalid) {
      return invalidText;
    }
    if (warn2) {
      return warnText;
    }
  };
  const error2 = invalid || warn2;
  const childrenWithProps = () => {
    if (disabled) {
      return import_react261.default.Children.toArray(children).map((child) => import_react261.default.cloneElement(child, {
        disabled: true
      }));
    }
    if (readOnly) {
      return import_react261.default.Children.toArray(children).map((child) => import_react261.default.cloneElement(child, {
        readOnly: true
      }));
    }
    return children;
  };
  return import_react261.default.createElement("div", {
    className: classNames
  }, import_react261.default.createElement("div", {
    className: `${prefix}--time-picker--fluid__wrapper`
  }, import_react261.default.createElement("div", {
    className: `${prefix}--time-picker__input`
  }, import_react261.default.createElement(FluidTextInput, _extends({
    ref,
    readOnly,
    disabled
  }, other))), childrenWithProps()), error2 && import_react261.default.createElement("hr", {
    className: `${prefix}--time-picker__divider`
  }), error2 && import_react261.default.createElement("div", {
    className: `${prefix}--form-requirement`
  }, errorText()), error2 && invalid ? import_react261.default.createElement(WarningFilled, {
    className: `${prefix}--time-picker__icon ${prefix}--time-picker__icon--invalid`
  }) : import_react261.default.createElement(WarningAltFilled, {
    className: `${prefix}--time-picker__icon ${prefix}--time-picker__icon--warn`
  }));
});
FluidTimePicker.propTypes = {
  /**
   * The child node(s)
   */
  children: import_prop_types213.default.node,
  /**
   * Specify an optional className to be applied to the outer FluidTimePicker wrapper
   */
  className: import_prop_types213.default.string,
  /**
   * Specify whether the `<input>` should be disabled
   */
  disabled: import_prop_types213.default.bool,
  /**
   * Specify whether or not the control is invalid
   */
  invalid: import_prop_types213.default.bool,
  /**
   * Provide the text that is displayed when the control is in error state
   */
  invalidText: import_prop_types213.default.node,
  /**
   * Provide the text that will be read by a screen reader when visiting this
   * control
   */
  labelText: import_prop_types213.default.node.isRequired,
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types213.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types213.default.node,
  /**
   * Whether or not the component is readonly
   */
  readOnly: import_prop_types213.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FluidTimePicker/FluidTimePicker.Skeleton.js
var import_prop_types214 = __toESM(require_prop_types());
var import_react262 = __toESM(require_react());
var import_classnames189 = __toESM(require_classnames());
var _FluidTextInputSkelet;
var _FluidSelectSkeleton;
var _FluidSelectSkeleton2;
var FluidTimePickerSkeleton = (_ref) => {
  let {
    className,
    isOnlyTwo,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const wrapperClasses = (0, import_classnames189.default)(className, `${prefix}--time-picker--fluid--skeleton`, {
    [`${prefix}--time-picker--equal-width`]: isOnlyTwo
  });
  return import_react262.default.createElement("div", _extends({
    className: wrapperClasses
  }, rest3), _FluidTextInputSkelet || (_FluidTextInputSkelet = import_react262.default.createElement(FluidTextInputSkeleton, null)), _FluidSelectSkeleton || (_FluidSelectSkeleton = import_react262.default.createElement(FluidSelectSkeleton, null)), !isOnlyTwo ? _FluidSelectSkeleton2 || (_FluidSelectSkeleton2 = import_react262.default.createElement(FluidSelectSkeleton, null)) : null);
};
FluidTimePickerSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types214.default.string,
  /**
   * Specify if there are only two TimePicker elements
   */
  isOnlyTwo: import_prop_types214.default.bool
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/FluidTimePickerSelect/FluidTimePickerSelect.js
var import_react263 = __toESM(require_react());
var import_prop_types215 = __toESM(require_prop_types());
var FluidTimePickerSelect = import_react263.default.forwardRef(function FluidTimePickerSelect2(_ref, ref) {
  let {
    children,
    className,
    ...other
  } = _ref;
  return import_react263.default.createElement(FluidSelect, _extends({
    className,
    ref
  }, other), children);
});
FluidTimePickerSelect.propTypes = {
  /**
   * Provide the contents of your Select
   */
  children: import_prop_types215.default.node,
  /**
   * Specify an optional className to be applied to the node containing the label and the select box
   */
  className: import_prop_types215.default.string,
  /**
   * Optionally provide the default value of the `<select>`
   */
  defaultValue: import_prop_types215.default.any,
  /**
   * Specify whether the control is disabled
   */
  disabled: import_prop_types215.default.bool,
  /**
   * Specify a custom `id` for the `<select>`
   */
  id: import_prop_types215.default.string.isRequired,
  /**
   * Provide label text to be read by screen readers when interacting with the
   * control
   */
  labelText: import_prop_types215.default.node,
  /**
   * Provide an optional `onChange` hook that is called each time the value of
   * the underlying `<input>` changes
   */
  onChange: import_prop_types215.default.func
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Heading/index.js
var import_prop_types216 = __toESM(require_prop_types());
var import_react264 = __toESM(require_react());
var HeadingContext = import_react264.default.createContext(1);
var Section = import_react264.default.forwardRef(function Section2(_ref, ref) {
  let {
    as: BaseComponent = "section",
    level: levelOverride,
    ...rest3
  } = _ref;
  const parentLevel = import_react264.default.useContext(HeadingContext);
  const level = levelOverride ?? parentLevel + 1;
  const BaseComponentAsAny = BaseComponent;
  return import_react264.default.createElement(HeadingContext.Provider, {
    value: Math.min(level, 6)
  }, import_react264.default.createElement(BaseComponentAsAny, _extends({
    ref
  }, rest3)));
});
Section.propTypes = {
  /**
   * Provide an alternative tag or component to use instead of the default
   * <section> element
   */
  as: import_prop_types216.default.elementType,
  /**
   * Specify the content that will be placed in the component
   */
  children: import_prop_types216.default.node,
  /**
   * Specify a class name for the outermost node of the component
   */
  className: import_prop_types216.default.string,
  /**
   * Overrides the level of the section
   */
  level: import_prop_types216.default.number
};
var Heading = import_react264.default.forwardRef(function Heading2(props, ref) {
  const HeadingIntrinsic = `h${import_react264.default.useContext(HeadingContext)}`;
  return import_react264.default.createElement(HeadingIntrinsic, _extends({
    ref
  }, props));
});
Heading.propTypes = {
  /**
   * Specify the content that will be placed in the component
   */
  children: import_prop_types216.default.node,
  /**
   * Specify a class name for the outermost node of the component
   */
  className: import_prop_types216.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/OverflowMenuV2/index.js
var import_react265 = __toESM(require_react());
var didWarnAboutDeprecation8 = false;
function OverflowMenuV2(props) {
  if (true) {
    true ? warning(didWarnAboutDeprecation8, "`<OverflowMenuV2>` is deprecated and will be removed in the next major version. Use `<OverflowMenu>` with the `enable-v12-overflowmenu` feature flag instead.") : void 0;
    didWarnAboutDeprecation8 = true;
  }
  return import_react265.default.createElement(FeatureFlags2, {
    enableV12Overflowmenu: true
  }, import_react265.default.createElement(OverflowMenu4, props));
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ProgressBar/ProgressBar.js
var import_react266 = __toESM(require_react());
var import_prop_types217 = __toESM(require_prop_types());
var import_classnames190 = __toESM(require_classnames());
function ProgressBar(_ref) {
  let {
    className,
    helperText,
    hideLabel,
    label,
    max: max4 = 100,
    size: size6 = "big",
    status = "active",
    type = "default",
    value
  } = _ref;
  const labelId = useId("progress-bar");
  const helperId = useId("progress-bar-helper");
  const helperTextId = useId("progress-bar-helper-text");
  const prefix = usePrefix();
  const isFinished = status === "finished";
  const isError2 = status === "error";
  const indeterminate = !isFinished && !isError2 && (value === null || value === void 0);
  let cappedValue = value;
  if (cappedValue && cappedValue > max4) {
    cappedValue = max4;
  }
  if (cappedValue && cappedValue < 0) {
    cappedValue = 0;
  }
  if (isError2) {
    cappedValue = 0;
  } else if (isFinished) {
    cappedValue = max4;
  }
  const percentage = (cappedValue ?? NaN) / max4;
  const wrapperClasses = (0, import_classnames190.default)(`${prefix}--progress-bar`, `${prefix}--progress-bar--${size6}`, `${prefix}--progress-bar--${type}`, {
    [`${prefix}--progress-bar--indeterminate`]: indeterminate,
    [`${prefix}--progress-bar--finished`]: isFinished,
    [`${prefix}--progress-bar--error`]: isError2
  }, className);
  const labelClasses = (0, import_classnames190.default)(`${prefix}--progress-bar__label`, {
    [`${prefix}--visually-hidden`]: hideLabel
  });
  let StatusIcon = null;
  if (isError2) {
    StatusIcon = import_react266.default.forwardRef(function ErrorFilled16(props, ref2) {
      return import_react266.default.createElement(ErrorFilled, _extends({
        ref: ref2,
        size: 16
      }, props));
    });
  } else if (isFinished) {
    StatusIcon = import_react266.default.forwardRef(function CheckmarkFilled16(props, ref2) {
      return import_react266.default.createElement(CheckmarkFilled, _extends({
        ref: ref2,
        size: 16
      }, props));
    });
  }
  const ref = (0, import_react266.useRef)(null);
  useIsomorphicEffect$1(() => {
    if (ref.current) {
      if (!isFinished && !isError2) {
        ref.current.style.transform = `scaleX(${percentage})`;
      } else {
        ref.current.style.transform = "";
      }
    }
  }, [percentage, isFinished, isError2]);
  return import_react266.default.createElement("div", {
    className: wrapperClasses
  }, import_react266.default.createElement("div", {
    className: labelClasses,
    id: labelId
  }, import_react266.default.createElement("span", {
    className: `${prefix}--progress-bar__label-text`
  }, label), StatusIcon && import_react266.default.createElement(StatusIcon, {
    className: `${prefix}--progress-bar__status-icon`
  })), import_react266.default.createElement("div", {
    className: `${prefix}--progress-bar__track`,
    role: "progressbar",
    "aria-busy": !isFinished,
    "aria-invalid": isError2,
    "aria-labelledby": labelId,
    "aria-describedby": helperText ? helperTextId : void 0,
    "aria-valuemin": !indeterminate ? 0 : void 0,
    "aria-valuemax": !indeterminate ? max4 : void 0,
    "aria-valuenow": !indeterminate ? cappedValue : void 0
  }, import_react266.default.createElement("div", {
    className: `${prefix}--progress-bar__bar`,
    ref
  })), helperText && import_react266.default.createElement("div", {
    id: helperTextId,
    className: `${prefix}--progress-bar__helper-text`
  }, helperText, import_react266.default.createElement("div", {
    className: `${prefix}--visually-hidden`,
    "aria-live": "polite",
    id: helperId
  }, isFinished ? "Done" : "Loading")));
}
ProgressBar.propTypes = {
  /**
   * Additional CSS class names.
   */
  className: import_prop_types217.default.string,
  /**
   * The current progress as a textual representation.
   */
  helperText: import_prop_types217.default.string,
  /**
   * Whether the label should be visually hidden.
   */
  hideLabel: import_prop_types217.default.bool,
  /**
   * A label describing the progress bar.
   */
  label: import_prop_types217.default.string.isRequired,
  /**
   * The maximum value.
   */
  max: import_prop_types217.default.number,
  /**
   * Specify the size of the ProgressBar.
   */
  size: import_prop_types217.default.oneOf(["small", "big"]),
  /**
   * Specify the status.
   */
  status: import_prop_types217.default.oneOf(["active", "finished", "error"]),
  /**
   * Defines the alignment variant of the progress bar.
   */
  type: import_prop_types217.default.oneOf(["default", "inline", "indented"]),
  /**
   * The current value.
   */
  value: import_prop_types217.default.number
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/AILabel/index.js
var import_classnames191 = __toESM(require_classnames());
var import_prop_types218 = __toESM(require_prop_types());
var import_react267 = __toESM(require_react());
var _Undo;
var AILabelContent = import_react267.default.forwardRef(function AILabelContent2(_ref, ref) {
  let {
    className,
    children,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const hasAILabelActions = import_react267.default.Children.toArray(children).some((child) => {
    var _a;
    const item = child;
    ((_a = item.type) == null ? void 0 : _a.displayName) === "AILabelActions";
  });
  const aiLabelContentClasses = (0, import_classnames191.default)(className, {
    [`${prefix}--ai-label-content`]: true,
    [`${prefix}--ai-label-content--with-actions`]: hasAILabelActions
  });
  return import_react267.default.createElement(ToggletipContent, {
    className: aiLabelContentClasses
  }, children);
});
AILabelContent.displayName = "AILabelContent";
AILabelContent.propTypes = {
  /**
   * Specify the content you want rendered inside the AILabel ToggleTip
   */
  children: import_prop_types218.default.node,
  /**
   * Specify an optional className to be added to the AILabel callout
   */
  className: import_prop_types218.default.string
};
var AILabelActions = import_react267.default.forwardRef(function AILabelActions2(_ref2, ref) {
  let {
    className,
    children,
    ...rest3
  } = _ref2;
  const prefix = usePrefix();
  const aiLabelActionsClasses = (0, import_classnames191.default)(className, {
    [`${prefix}--ai-label-actions`]: true
  });
  return import_react267.default.createElement(ToggletipActions, {
    className: aiLabelActionsClasses
  }, children);
});
AILabelActions.displayName = "AILabelActions";
AILabelActions.propTypes = {
  /**
   * Specify the content you want rendered inside the AILabel callout toolbar
   */
  children: import_prop_types218.default.node,
  /**
   * Specify an optional className to be added to the AILabel toolbar
   */
  className: import_prop_types218.default.string
};
var propMappingFunction9 = (deprecatedValue) => {
  return mapPopoverAlignProp(deprecatedValue);
};
var AILabel = import_react267.default.forwardRef(function AILabel2(_ref3, ref) {
  let {
    aiText = "AI",
    aiTextLabel,
    textLabel,
    align,
    autoAlign = true,
    children,
    className,
    kind = "default",
    onRevertClick,
    revertActive,
    revertLabel = "Revert to AI input",
    slugLabel = "Show information",
    ["aria-label"]: ariaLabel = "Show information",
    size: size6 = "xs",
    ...rest3
  } = _ref3;
  const prefix = usePrefix();
  const id = useId("AILabel");
  const aiLabelClasses = (0, import_classnames191.default)(className, {
    [`${prefix}--ai-label`]: true,
    [`${prefix}--ai-label--revert`]: revertActive
  });
  const aiLabelButtonClasses = (0, import_classnames191.default)({
    [`${prefix}--ai-label__button`]: true,
    [`${prefix}--ai-label__button--${size6}`]: size6,
    [`${prefix}--ai-label__button--${kind}`]: kind,
    [`${prefix}--ai-label__button--inline-with-content`]: kind === "inline" && (aiTextLabel || textLabel)
  });
  const handleOnRevertClick = (evt) => {
    if (onRevertClick) {
      onRevertClick(evt);
    }
  };
  const ariaLabelText = !aiTextLabel && !textLabel ? `${aiText} ${slugLabel || ariaLabel}` : `${aiText} ${aiTextLabel || textLabel}`;
  const isSmallIcon = ["xs", "2xs", "mini"].includes(size6);
  return import_react267.default.createElement("div", {
    className: aiLabelClasses,
    ref,
    id
  }, revertActive ? import_react267.default.createElement(IconButton, _extends({
    onClick: handleOnRevertClick,
    kind: "ghost",
    size: "sm",
    label: revertLabel
  }, rest3), _Undo || (_Undo = import_react267.default.createElement(Undo, null))) : import_react267.default.createElement(Toggletip, _extends({
    align,
    autoAlign,
    alignmentAxisOffset: isSmallIcon ? -24 : 0
  }, rest3), import_react267.default.createElement(ToggletipButton, {
    className: aiLabelButtonClasses,
    label: kind === "inline" ? "" : ariaLabelText
  }, import_react267.default.createElement("span", {
    className: `${prefix}--ai-label__text`
  }, aiText), kind === "inline" && (aiTextLabel || textLabel) && import_react267.default.createElement("span", {
    className: `${prefix}--ai-label__additional-text`
  }, aiTextLabel || textLabel)), children));
});
AILabel.displayName = "AILabel";
AILabel.propTypes = {
  /**
   * Specify the content you want rendered inside the `AILabel` ToggleTip
   */
  AILabelContent: import_prop_types218.default.node,
  /**
   * Specify the correct translation of the AI text
   */
  aiText: import_prop_types218.default.string,
  /**
   * @deprecated
   * Specify additional text to be rendered next to the AI label in the inline variant
   */
  aiTextLabel: deprecate(import_prop_types218.default.string, "`aiTextLabel` on `AILabel` has been deprecated - Please use the `textLabel` prop instead"),
  /**
   * Specify how the popover should align with the button
   */
  align: deprecateValuesWithin(
    import_prop_types218.default.oneOf([
      "top",
      "top-left",
      // deprecated use top-start instead
      "top-right",
      // deprecated use top-end instead
      "bottom",
      "bottom-left",
      // deprecated use bottom-start instead
      "bottom-right",
      // deprecated use bottom-end instead
      "left",
      "left-bottom",
      // deprecated use left-end instead
      "left-top",
      // deprecated use left-start instead
      "right",
      "right-bottom",
      // deprecated use right-end instead
      "right-top",
      // deprecated use right-start instead
      // new values to match floating-ui
      "top-start",
      "top-end",
      "bottom-start",
      "bottom-end",
      "left-end",
      "left-start",
      "right-end",
      "right-start"
    ]),
    //allowed prop values
    ["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "left", "left-start", "left-end", "right", "right-start", "right-end"],
    //optional mapper function
    propMappingFunction9
  ),
  /**
   * Specify the text that will be provided to the aria-label of the `AILabel` button
   */
  "aria-label": import_prop_types218.default.string,
  /**
   * Will auto-align the popover. This prop is currently experimental and is subject to future changes.
   */
  autoAlign: import_prop_types218.default.bool,
  /**
   * Specify the content you want rendered inside the `AILabel` ToggleTip
   */
  children: import_prop_types218.default.node,
  /**
   * Specify an optional className to be added to the `AILabel`
   */
  className: import_prop_types218.default.string,
  /**
   * Specify the type of `AILabel`, from the following list of types:
   */
  kind: import_prop_types218.default.oneOf(["default", "inline"]),
  /**
   * Callback function that fires when the revert button is clicked
   */
  onRevertClick: import_prop_types218.default.func,
  /**
   * Specify whether the revert button should be visible
   */
  revertActive: import_prop_types218.default.bool,
  /**
   * Specify the text that should be shown when the revert button is hovered
   */
  revertLabel: import_prop_types218.default.string,
  /**
   * Specify the size of the button, from the following list of sizes:
   */
  size: import_prop_types218.default.oneOf(["mini", "2xs", "xs", "sm", "md", "lg", "xl"]),
  /**
   * @deprecated
   * Specify the text that will be provided to the aria-label of the `AILabel` button
   */
  slugLabel: deprecate(import_prop_types218.default.string, "`slugLabel` on `AILabel` has been deprecated - Please use the `ariaLabel` prop instead"),
  /**
   * Specify additional text to be rendered next to the AI label in the inline variant
   */
  textLabel: import_prop_types218.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ChatButton/ChatButton.js
var import_react268 = __toESM(require_react());
var import_prop_types219 = __toESM(require_prop_types());
var import_classnames192 = __toESM(require_classnames());
var ChatButton = import_react268.default.forwardRef(function ChatButton2(_ref, ref) {
  let {
    className,
    children,
    disabled,
    isQuickAction,
    isSelected,
    kind,
    renderIcon,
    size: size6,
    ...other
  } = _ref;
  const prefix = usePrefix();
  const classNames = (0, import_classnames192.default)(className, {
    [`${prefix}--chat-btn`]: true,
    [`${prefix}--chat-btn--with-icon`]: renderIcon,
    [`${prefix}--chat-btn--quick-action`]: isQuickAction,
    [`${prefix}--chat-btn--quick-action--selected`]: isSelected
  });
  const allowedSizes = ["sm", "md", "lg"];
  if (isQuickAction) {
    kind = "ghost";
    size6 = "sm";
  } else {
    size6 = allowedSizes.includes(size6) ? size6 : "lg";
  }
  return import_react268.default.createElement(Button, _extends({
    disabled,
    className: classNames,
    kind,
    ref,
    size: size6,
    renderIcon
  }, other), children);
});
ChatButton.propTypes = {
  /**
   * Provide the contents of your Select
   */
  children: import_prop_types219.default.node,
  /**
   * Specify an optional className to be applied to the node containing the label and the select box
   */
  className: import_prop_types219.default.string,
  /**
   * Specify whether the `ChatButton` should be disabled
   */
  disabled: import_prop_types219.default.bool,
  /**
   * Specify whether the `ChatButton` should be rendered as a quick action button
   */
  isQuickAction: import_prop_types219.default.bool,
  /**
   * Specify whether the quick action `ChatButton` should be rendered as selected. This disables the input
   */
  isSelected: import_prop_types219.default.bool,
  /**
   * Specify the kind of `ChatButton` you want to create
   */
  kind: import_prop_types219.default.oneOf(["primary", "secondary", "danger", "ghost", "tertiary"]),
  /**
   * Optional prop to specify an icon to be rendered.
   * Can be a React component class
   */
  // @ts-expect-error: PropTypes are not expressive enough to cover this case
  renderIcon: import_prop_types219.default.oneOfType([import_prop_types219.default.func, import_prop_types219.default.object]),
  /**
   * Specify the size of the `ChatButton`, from the following list of sizes:
   */
  size: import_prop_types219.default.oneOf(["sm", "md", "lg"])
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/ChatButton/ChatButton.Skeleton.js
var import_prop_types220 = __toESM(require_prop_types());
var import_react269 = __toESM(require_react());
var import_classnames193 = __toESM(require_classnames());
var ChatButtonSkeleton = (_ref) => {
  let {
    className,
    size: size6,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const skeletonClasses = (0, import_classnames193.default)(className, `${prefix}--skeleton`, `${prefix}--btn`, `${prefix}--chat-btn`, {
    [`${prefix}--layout--size-${size6}`]: size6
  });
  return import_react269.default.createElement("div", _extends({
    className: skeletonClasses
  }, rest3));
};
ChatButtonSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types220.default.string,
  /**
   * Specify the size of the `ChatButtonSkeleton`, from the following list of sizes:
   */
  size: import_prop_types220.default.oneOf(["sm", "md", "lg"])
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/AISkeleton/AISkeletonPlaceholder.js
var import_react270 = __toESM(require_react());
var import_prop_types221 = __toESM(require_prop_types());
var import_classnames194 = __toESM(require_classnames());
var AISkeletonPlaceholder = (_ref) => {
  let {
    className,
    ...other
  } = _ref;
  const prefix = usePrefix();
  const AISkeletonPlaceholderClasses = (0, import_classnames194.default)({
    className,
    [`${prefix}--skeleton__placeholder--ai`]: true
  }, className);
  return import_react270.default.createElement(SkeletonPlaceholder, _extends({
    className: AISkeletonPlaceholderClasses
  }, other));
};
AISkeletonPlaceholder.propTypes = {
  /**
   * Add a custom class to the component
   * to set the height and width
   */
  className: import_prop_types221.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/AISkeleton/AISkeletonIcon.js
var import_prop_types222 = __toESM(require_prop_types());
var import_react271 = __toESM(require_react());
var import_classnames195 = __toESM(require_classnames());
var AISkeletonIcon = (_ref) => {
  let {
    className,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const AISkeletonIconClasses = (0, import_classnames195.default)(className, {
    [`${prefix}--skeleton__icon--ai`]: true
  });
  return import_react271.default.createElement(SkeletonIcon, _extends({
    className: AISkeletonIconClasses
  }, rest3));
};
AISkeletonIcon.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types222.default.string,
  /**
   * The CSS styles.
   */
  style: import_prop_types222.default.object
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/AISkeleton/AISkeletonText.js
var import_prop_types223 = __toESM(require_prop_types());
var import_react272 = __toESM(require_react());
var import_classnames196 = __toESM(require_classnames());
var AISkeletonText = (_ref) => {
  let {
    className,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const aiSkeletonTextClasses = (0, import_classnames196.default)(className, {
    [`${prefix}--skeleton__text--ai`]: true
  });
  return import_react272.default.createElement(SkeletonText, _extends({
    className: aiSkeletonTextClasses
  }, rest3));
};
AISkeletonText.propTypes = {
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types223.default.string,
  /**
   * generates skeleton text at a larger size
   */
  heading: import_prop_types223.default.bool,
  /**
   * the number of lines shown if paragraph is true
   */
  lineCount: import_prop_types223.default.number,
  /**
   * will generate multiple lines of text
   */
  paragraph: import_prop_types223.default.bool,
  /**
   * width (in px or %) of single line of text or max-width of paragraph lines
   */
  width: import_prop_types223.default.string
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Theme/index.js
var import_classnames197 = __toESM(require_classnames());
var import_prop_types224 = __toESM(require_prop_types());
var import_react273 = __toESM(require_react());
var ThemeContext = import_react273.default.createContext({
  theme: "white"
});
var GlobalTheme = import_react273.default.forwardRef(function GlobalTheme2(_ref, ref) {
  let {
    children,
    theme
  } = _ref;
  const value = (0, import_react273.useMemo)(() => {
    return {
      theme
    };
  }, [theme]);
  const childrenWithProps = import_react273.default.cloneElement(children, {
    ref
  });
  return import_react273.default.createElement(ThemeContext.Provider, {
    value
  }, childrenWithProps);
});
GlobalTheme.propTypes = {
  /**
   * Provide child elements to be rendered inside of `GlobalTheme`, this is
   * typically the root of your app
   */
  children: import_prop_types224.default.node,
  /**
   * Specify the global theme for your app
   */
  theme: import_prop_types224.default.oneOf(["white", "g10", "g90", "g100"])
};
function Theme(_ref2) {
  let {
    as: BaseComponent = "div",
    className: customClassName,
    theme,
    ...rest3
  } = _ref2;
  const prefix = usePrefix();
  const className = (0, import_classnames197.default)(customClassName, {
    [`${prefix}--white`]: theme === "white",
    [`${prefix}--g10`]: theme === "g10",
    [`${prefix}--g90`]: theme === "g90",
    [`${prefix}--g100`]: theme === "g100",
    [`${prefix}--layer-one`]: true
  });
  const value = import_react273.default.useMemo(() => {
    const isDark = theme && ["g90", "g100"].includes(theme);
    return {
      theme,
      isDark
    };
  }, [theme]);
  const BaseComponentAsAny = BaseComponent;
  return import_react273.default.createElement(ThemeContext.Provider, {
    value
  }, import_react273.default.createElement(LayerContext.Provider, {
    value: 1
  }, import_react273.default.createElement(BaseComponentAsAny, _extends({}, rest3, {
    className
  }))));
}
Theme.propTypes = {
  /**
   * Specify a custom component or element to be rendered as the top-level
   * element in the component
   */
  as: import_prop_types224.default.oneOfType([import_prop_types224.default.func, import_prop_types224.default.string, import_prop_types224.default.elementType]),
  /**
   * Provide child elements to be rendered inside of `Theme`
   */
  children: import_prop_types224.default.node,
  /**
   * Provide a custom class name to be used on the outermost element rendered by
   * the component
   */
  className: import_prop_types224.default.string,
  /**
   * Specify the theme
   */
  theme: import_prop_types224.default.oneOf(["white", "g10", "g90", "g100"])
};
function useTheme() {
  return import_react273.default.useContext(ThemeContext);
}
function usePrefersDarkScheme() {
  return useMatchMedia("(prefers-color-scheme: dark)");
}

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/IconIndicator/index.js
var import_prop_types225 = __toESM(require_prop_types());
var import_react274 = __toESM(require_react());
var import_classnames198 = __toESM(require_classnames());
var IconIndicatorKinds = ["failed", "caution-major", "caution-minor", "undefined", "succeeded", "normal", "in-progress", "incomplete", "not-started", "pending", "unknown", "informative"];
var iconTypes2 = {
  failed: ErrorFilled,
  ["caution-major"]: WarningAltInvertedFilled,
  ["caution-minor"]: WarningAltFilled,
  undefined: UndefinedFilled,
  succeeded: CheckmarkFilled,
  normal: CheckmarkOutline,
  ["in-progress"]: InProgress,
  incomplete: Incomplete,
  ["not-started"]: CircleDash,
  pending: PendingFilled,
  unknown: UnknownFilled,
  informative: WarningSquareFilled
};
var IconIndicator = import_react274.default.forwardRef(function IconIndicatorContent(_ref, ref) {
  let {
    className: customClassName,
    kind,
    label,
    size: size6 = 16,
    ...rest3
  } = _ref;
  const prefix = usePrefix();
  const classNames = (0, import_classnames198.default)(`${prefix}--icon-indicator`, customClassName, {
    [`${prefix}--icon-indicator--20`]: size6 == 20
  });
  const IconForKind = iconTypes2[kind];
  if (!IconForKind) {
    return null;
  }
  return import_react274.default.createElement("div", {
    className: classNames,
    ref
  }, import_react274.default.createElement(IconForKind, {
    size: size6,
    className: `${prefix}--icon-indicator--${kind}`
  }), label);
});
IconIndicator.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types225.default.string,
  /**
   * Specify the kind of the Icon Indicator
   */
  kind: import_prop_types225.default.oneOf(IconIndicatorKinds).isRequired,
  /**
   * Label next to the icon.
   */
  label: import_prop_types225.default.string.isRequired,
  /**
   * Specify the size of the Icon Indicator. Defaults to 16.
   */
  size: import_prop_types225.default.oneOf([16, 20])
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Pagination/experimental/PageSelector.js
var import_react275 = __toESM(require_react());
var import_prop_types226 = __toESM(require_prop_types());
var import_classnames199 = __toESM(require_classnames());
function PageSelector(_ref) {
  let {
    className = null,
    currentPage,
    id = 1,
    labelText = "Current page number",
    totalPages,
    ...other
  } = _ref;
  const prefix = usePrefix();
  const namespace = `${prefix}--unstable-pagination__page-selector`;
  const instanceId2 = `${namespace}__select-${useId()}`;
  const renderPages = (total) => {
    const pages = [];
    for (let counter = 1; counter <= total; counter += 1) {
      pages.push(import_react275.default.createElement(SelectItem, {
        key: counter,
        value: counter,
        text: String(counter)
      }));
    }
    return pages;
  };
  return import_react275.default.createElement(Select, _extends({
    className: (0, import_classnames199.default)(namespace, className),
    hideLabel: true,
    id: instanceId2 || id,
    inline: true,
    labelText,
    value: currentPage
  }, other), renderPages(totalPages));
}
PageSelector.propTypes = {
  /** Extra class names to add. */
  className: import_prop_types226.default.string,
  /** The current page. */
  currentPage: import_prop_types226.default.number.isRequired,
  /** The unique ID of this component instance. */
  id: import_prop_types226.default.oneOfType([import_prop_types226.default.string, import_prop_types226.default.number]),
  /** Translatable string to label the page selector element. */
  labelText: import_prop_types226.default.string,
  /**
   * Total number of pages.
   * This value is calculated using a valid `totalItems` prop passed to the parent `Unstable_Pagination`.
   */
  totalPages: import_prop_types226.default.number.isRequired
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/Pagination/experimental/Pagination.js
var import_react276 = __toESM(require_react());
var import_prop_types227 = __toESM(require_prop_types());
var import_classnames200 = __toESM(require_classnames());
var _CaretLeft4;
var _CaretRight4;
function Pagination3(_ref) {
  let {
    backwardText = "Previous page",
    children = void 0,
    className = null,
    disabled = false,
    forwardText = "Next page",
    id = 1,
    initialPage = 1,
    itemsPerPageText = "Items per page:",
    itemRangeText = (min4, max4, total) => `${min4}–${max4} of ${total} items`,
    itemText = (min4, max4) => `${min4}–${max4} items`,
    onChange,
    pageRangeText = (current, total) => `${current} of ${total} pages`,
    pageSize = 10,
    pageSizes = void 0,
    pageText = (page) => `page ${page}`,
    pagesUnknown = false,
    totalItems = void 0,
    ...other
  } = _ref;
  const [currentPage, setCurrentPage] = (0, import_react276.useState)(initialPage);
  const [currentPageSize, setCurrentPageSize] = (0, import_react276.useState)(pageSize);
  const prefix = usePrefix();
  const totalPages = totalItems ? Math.max(Math.ceil(totalItems / currentPageSize), 1) : void 0;
  const backButtonDisabled = disabled || currentPage === 1;
  const forwardButtonDisabled = disabled || currentPage === totalPages;
  function onSetPage(newPage) {
    setCurrentPage(Number(newPage));
  }
  function incrementPage() {
    const page = currentPage + 1;
    setCurrentPage(page);
    onChange({
      page,
      pageSize: currentPageSize
    });
  }
  function decrementPage() {
    const page = currentPage - 1;
    setCurrentPage(page);
    onChange({
      page,
      pageSize: currentPageSize
    });
  }
  const namespace = `${prefix}--unstable-pagination`;
  return import_react276.default.createElement("section", _extends({
    className: (0, import_classnames200.default)(namespace, className)
  }, other), import_react276.default.createElement("div", {
    className: `${namespace}__left`
  }, pageSizes && import_react276.default.createElement(import_react276.default.Fragment, null, import_react276.default.createElement("label", {
    id: `${namespace}__page-sizer__counter-${id}`,
    className: `${namespace}__text`,
    htmlFor: `${namespace}__page-sizer__input-${id}`
  }, itemsPerPageText), import_react276.default.createElement(Select, {
    id: `${namespace}__page-sizer__input-${id}`,
    className: `${namespace}__page-sizer`,
    labelText: "",
    hideLabel: true,
    noLabel: true,
    inline: true,
    onChange: (event) => setCurrentPageSize(Number(event.target.value)),
    value: currentPageSize
  }, pageSizes.map((size6) => import_react276.default.createElement(SelectItem, {
    key: size6,
    value: size6,
    text: String(size6)
  })))), import_react276.default.createElement("span", {
    className: `${namespace}__text`
  }, totalItems && !pagesUnknown && itemRangeText(Math.min(currentPageSize * (currentPage - 1) + 1, totalItems), Math.min(currentPage * currentPageSize, totalItems), totalItems), totalItems && pagesUnknown && itemText(currentPageSize * (currentPage - 1) + 1, currentPage * currentPageSize), !totalItems && itemText(currentPageSize * (currentPage - 1) + 1, currentPage * currentPageSize))), import_react276.default.createElement("div", {
    className: `${namespace}__right`
  }, children && totalItems && children({
    currentPage,
    currentPageSize,
    onSetPage,
    totalPages
  }), children && totalItems && !pagesUnknown && import_react276.default.createElement("span", {
    className: `${namespace}__text`
  }, pageRangeText("", totalPages)), children && !totalItems && import_react276.default.createElement("span", {
    className: `${namespace}__text`
  }, pageText(currentPage)), !children && import_react276.default.createElement("span", {
    className: `${namespace}__text`
  }, !totalItems ? pageText(currentPage) : pageRangeText(currentPage, totalPages)), import_react276.default.createElement(import_react276.default.Fragment, null, import_react276.default.createElement(IconButton, {
    align: "top",
    disabled: backButtonDisabled,
    kind: "ghost",
    className: (0, import_classnames200.default)(`${namespace}__button`, `${namespace}__button--backward`, {
      [`${namespace}__button--no-index`]: backButtonDisabled
    }),
    label: backwardText,
    onClick: () => decrementPage()
  }, _CaretLeft4 || (_CaretLeft4 = import_react276.default.createElement(CaretLeft, null))), import_react276.default.createElement(IconButton, {
    align: "top-right",
    disabled: forwardButtonDisabled,
    kind: "ghost",
    className: (0, import_classnames200.default)(`${namespace}__button`, `${namespace}__button--forward`, {
      [`${namespace}__button--no-index`]: forwardButtonDisabled
    }),
    label: forwardText,
    onClick: () => incrementPage()
  }, _CaretRight4 || (_CaretRight4 = import_react276.default.createElement(CaretRight, null))))));
}
Pagination3.propTypes = {
  /**
   * The description for the backward icon.
   */
  backwardText: import_prop_types227.default.string,
  /**
   * The children of the pagination component.
   */
  children: import_prop_types227.default.oneOfType([import_prop_types227.default.node, import_prop_types227.default.func]),
  /**
   * Extra classes to add.
   */
  className: import_prop_types227.default.string,
  /**
   * `true` if the backward/forward buttons should be disabled.
   */
  disabled: import_prop_types227.default.bool,
  /**
   * The description for the forward icon.
   */
  forwardText: import_prop_types227.default.string,
  /** The unique ID of this component instance. */
  id: import_prop_types227.default.oneOfType([import_prop_types227.default.string, import_prop_types227.default.number]),
  /**
   * The initial active page when the component is first mounted.
   */
  initialPage: import_prop_types227.default.number,
  /**
   * The function returning a translatable text showing where the current page is,
   * in a manner of the range of items.
   */
  itemRangeText: import_prop_types227.default.func,
  /**
   * A variant of `itemRangeText`, used if the total number of items is unknown.
   */
  itemText: import_prop_types227.default.func,
  /**
   * The translatable text indicating the number of items per page.
   */
  itemsPerPageText: import_prop_types227.default.string,
  /**
   * The callback function called when the current page changes.
   */
  onChange: import_prop_types227.default.func,
  /**
   * The function returning a translatable text showing where the current page is,
   * in a manner of the total number of pages.
   */
  pageRangeText: import_prop_types227.default.func,
  /**
   * The number dictating how many items a page contains.
   */
  pageSize: import_prop_types227.default.number,
  /**
   * The choices for `pageSize`.
   */
  pageSizes: import_prop_types227.default.arrayOf(import_prop_types227.default.number),
  /**
   * The translatable text showing the current page.
   */
  pageText: import_prop_types227.default.func,
  /**
   * `true` if total number of pages is unknown.
   */
  pagesUnknown: import_prop_types227.default.bool,
  /**
   * The total number of items.
   * You need to provide total items to calculate total page,
   * which is required by a child like the `PageSelector`
   * to know how many pages to display.
   */
  totalItems: import_prop_types227.default.number
};

// ../node_modules/.pnpm/@carbon+react@1.75.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.83.4/node_modules/@carbon/react/es/components/LayoutDirection/LayoutDirection.js
var import_prop_types228 = __toESM(require_prop_types());
var import_react277 = __toESM(require_react());
function LayoutDirection(_ref) {
  let {
    as: BaseComponent = "div",
    children,
    dir,
    ...rest3
  } = _ref;
  const value = import_react277.default.useMemo(() => {
    return {
      direction: dir
    };
  }, [dir]);
  return import_react277.default.createElement(LayoutDirectionContext.Provider, {
    value
  }, import_react277.default.createElement(BaseComponent, _extends({
    dir
  }, rest3), children));
}
LayoutDirection.propTypes = {
  /**
   * Customize the element type used to render the outermost node
   */
  as: import_prop_types228.default.oneOfType([import_prop_types228.default.func, import_prop_types228.default.string, import_prop_types228.default.elementType]),
  /**
   * Provide child elements or components to be rendered inside of this
   * component
   */
  children: import_prop_types228.default.node,
  /**
   * Specify the layout direction of this part of the page
   */
  dir: import_prop_types228.default.oneOf(["ltr", "rtl"]).isRequired
};
export {
  AILabel,
  AILabelActions,
  AILabelContent,
  AISkeletonIcon,
  AISkeletonPlaceholder,
  AISkeletonText,
  Accordion,
  AccordionItem,
  AccordionSkeleton,
  ActionableNotification,
  AspectRatio,
  Breadcrumb,
  BreadcrumbItem,
  BreadcrumbSkeleton,
  Button,
  ButtonKinds,
  ButtonSet,
  ButtonSizes,
  ButtonSkeleton,
  ButtonTooltipAlignments,
  ButtonTooltipPositions,
  Callout,
  Checkbox2 as Checkbox,
  CheckboxGroup,
  CheckboxSkeleton,
  ClassPrefix,
  ClickableTile,
  CodeSnippet,
  CodeSnippetSkeleton,
  Column,
  ColumnHangComponent as ColumnHang,
  ComboBox,
  ComboButton,
  ComposedModal,
  ContainedList,
  ContainedListItem,
  Content,
  ContentSwitcher2 as ContentSwitcher,
  ControlledPasswordInput,
  Copy2 as Copy,
  CopyButton,
  DangerButton,
  DataTable,
  DataTableSkeleton,
  DatePicker,
  DatePickerInput,
  DatePickerSkeleton,
  DefinitionTooltip,
  DismissibleTag,
  Dropdown,
  DropdownSkeleton,
  ErrorBoundary,
  ErrorBoundaryContext,
  ExpandableSearch,
  ExpandableTile,
  FileUploader,
  FileUploaderButton,
  FileUploaderDropContainer,
  FileUploaderItem,
  FileUploaderSkeleton,
  Filename,
  FilterableMultiSelect,
  FlexGridComponent as FlexGrid,
  FluidForm,
  Form,
  FormContext,
  FormGroup,
  FormItem,
  FormLabel,
  GlobalTheme,
  GridAsGridComponent as Grid,
  GridSettings,
  HStack,
  Header,
  HeaderContainer,
  HeaderGlobalAction,
  HeaderGlobalBar,
  HeaderMenuForwardRef as HeaderMenu,
  HeaderMenuButton,
  HeaderMenuItem,
  HeaderName,
  HeaderNavigation,
  HeaderPanel,
  HeaderSideNavItems,
  Heading,
  IconButton,
  IconButtonKinds,
  IconSkeleton,
  IconSwitch$1 as IconSwitch,
  IconTab,
  IdPrefix,
  InlineLoading,
  InlineNotification,
  Layer2 as Layer,
  Link,
  ListItem,
  Loading,
  Menu2 as Menu,
  MenuButton,
  MenuItem,
  MenuItemDivider,
  MenuItemGroup,
  MenuItemRadioGroup,
  MenuItemSelectable,
  Modal,
  ModalBody,
  ModalFooter,
  ModalHeader,
  ModalWrapper,
  MultiSelect,
  NotificationActionButton,
  NotificationButton,
  NumberInput,
  NumberInputSkeleton,
  OperationalTag,
  OrderedList,
  OverflowMenu4 as OverflowMenu,
  OverflowMenuItem,
  Pagination,
  PaginationNav,
  PaginationSkeleton,
  PasswordInput,
  Popover,
  PopoverContent,
  PrefixContext,
  PrimaryButton,
  ProgressBar,
  ProgressIndicator,
  ProgressIndicatorSkeleton,
  ProgressStep,
  RadioButton2 as RadioButton,
  RadioButtonGroup,
  RadioButtonSkeleton,
  RadioTile,
  Row,
  Search2 as Search,
  SearchSkeleton,
  SecondaryButton,
  Section,
  Select,
  SelectItem,
  SelectItemGroup,
  SelectSkeleton,
  SelectableTag,
  SelectableTile,
  SideNav,
  SideNavDetails,
  SideNavDivider,
  SideNavFooter,
  SideNavHeader,
  SideNavIcon,
  SideNavItem,
  SideNavItems,
  SideNavLink,
  SideNavLinkText,
  SideNavMenu,
  SideNavMenuItem,
  SideNavSwitcher,
  SkeletonIcon,
  SkeletonPlaceholder,
  SkeletonText,
  SkipToContent,
  Slider2 as Slider,
  SliderSkeleton,
  Stack,
  StaticNotification,
  StructuredListBody,
  StructuredListCell,
  StructuredListHead,
  StructuredListInput,
  StructuredListRow,
  StructuredListSkeleton,
  StructuredListWrapper,
  Switch,
  Switcher,
  SwitcherDivider,
  SwitcherItem,
  Tab2 as Tab,
  TabContent,
  TabList,
  TabListVertical,
  TabPanel,
  TabPanels,
  Table,
  TableActionList,
  TableBatchAction,
  TableBatchActions,
  TableBody,
  TableCell,
  TableContainer,
  TableDecoratorRow,
  TableExpandHeader,
  TableExpandRow,
  TableExpandedRow,
  TableHead,
  TableHeader,
  TableRow,
  TableSelectAll,
  TableSelectRow,
  TableSlugRow,
  TableToolbar,
  TableToolbarAction,
  TableToolbarContent,
  TableToolbarMenu,
  TableToolbarSearch,
  Tabs,
  TabsSkeleton,
  TabsVertical,
  Tag,
  TagSkeleton,
  TextArea,
  TextAreaSkeleton,
  TextInput,
  TextInputSkeleton,
  Theme,
  ThemeContext,
  Tile,
  TileAboveTheFoldContent,
  TileBelowTheFoldContent,
  TileGroup,
  TimePicker,
  TimePickerSelect,
  ToastNotification,
  Toggle,
  ToggleSkeleton,
  ToggleSmallSkeleton,
  Toggletip,
  ToggletipActions,
  ToggletipButton,
  ToggletipContent,
  ToggletipLabel,
  Tooltip,
  TreeNode,
  TreeView,
  UnorderedList,
  VStack,
  FeatureFlags2 as unstable_FeatureFlags,
  Layout as unstable_Layout,
  LayoutDirection as unstable_LayoutDirection,
  OverflowMenuV2 as unstable_OverflowMenuV2,
  PageSelector as unstable_PageSelector,
  Pagination3 as unstable_Pagination,
  Text as unstable_Text,
  TextDirection as unstable_TextDirection,
  AISkeletonIcon as unstable__AiSkeletonIcon,
  AISkeletonPlaceholder as unstable__AiSkeletonPlaceholder,
  AISkeletonText as unstable__AiSkeletonText,
  ChatButton as unstable__ChatButton,
  ChatButtonSkeleton as unstable__ChatButtonSkeleton,
  FluidComboBox as unstable__FluidComboBox,
  FluidComboBoxSkeleton as unstable__FluidComboBoxSkeleton,
  FluidDatePicker as unstable__FluidDatePicker,
  FluidDatePickerInput as unstable__FluidDatePickerInput,
  FluidDatePickerSkeleton as unstable__FluidDatePickerSkeleton,
  FluidDropdown as unstable__FluidDropdown,
  FluidDropdownSkeleton as unstable__FluidDropdownSkeleton,
  FluidMultiSelect as unstable__FluidMultiSelect,
  FluidMultiSelectSkeleton as unstable__FluidMultiSelectSkeleton,
  FluidSearch as unstable__FluidSearch,
  FluidSearchSkeleton as unstable__FluidSearchSkeleton,
  FluidSelect as unstable__FluidSelect,
  FluidSelectSkeleton as unstable__FluidSelectSkeleton,
  FluidTextArea as unstable__FluidTextArea,
  FluidTextAreaSkeleton as unstable__FluidTextAreaSkeleton,
  FluidTextInput as unstable__FluidTextInput,
  FluidTextInputSkeleton as unstable__FluidTextInputSkeleton,
  FluidTimePicker as unstable__FluidTimePicker,
  FluidTimePickerSelect as unstable__FluidTimePickerSelect,
  FluidTimePickerSkeleton as unstable__FluidTimePickerSkeleton,
  IconIndicator as unstable__IconIndicator,
  AILabel as unstable__Slug,
  AILabelActions as unstable__SlugActions,
  AILabelContent as unstable__SlugContent,
  useFeatureFlag as unstable_useFeatureFlag,
  useFeatureFlags as unstable_useFeatureFlags,
  useLayoutDirection as unstable_useLayoutDirection,
  useContextMenu,
  useIdPrefix,
  useLayer,
  usePrefersDarkScheme,
  usePrefix,
  useTheme
};
/*! Bundled license information:

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

react-dom/cjs/react-dom.development.js:
  (**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-is/cjs/react-is.development.js:
  (**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-is/cjs/react-is.development.js:
  (**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

flatpickr/dist/l10n/index.js:
  (*! *****************************************************************************
      Copyright (c) Microsoft Corporation.
  
      Permission to use, copy, modify, and/or distribute this software for any
      purpose with or without fee is hereby granted.
  
      THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
      REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
      AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
      INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
      LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
      OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
      PERFORMANCE OF THIS SOFTWARE.
      ***************************************************************************** *)

flatpickr/dist/plugins/rangePlugin.js:
  (*! *****************************************************************************
      Copyright (c) Microsoft Corporation.
  
      Permission to use, copy, modify, and/or distribute this software for any
      purpose with or without fee is hereby granted.
  
      THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
      REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
      AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
      INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
      LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
      OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
      PERFORMANCE OF THIS SOFTWARE.
      ***************************************************************************** *)

tabbable/dist/index.esm.js:
  (*!
  * tabbable 6.2.0
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)
*/
//# sourceMappingURL=@carbon_react.js.map
